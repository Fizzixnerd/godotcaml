open! Base
open Ctypes
module M = Gdforeign
open Godotcaml_base.Godotcaml
open Living
open M

let funptr = Foreign.funptr
module ApiTypes = struct
  module Void = struct include M.Void end

  module type NIL = sig
    include Api_types.API_TYPE

    val to_variant : 
    t structure ptr -> C.variant_ptr structure ptr

    val of_variant : 
    C.variant_ptr structure ptr-> t structure ptr
    end
  
module Nil = struct
  include Nil
  include Conv.Nil

  let godot_to_variant (x:godot_t) : C.variant_ptr structure ptr Living_core.Default.t = 
    let open Living_core.Default.Let_syntax in
    let* new_variant_ptr = Living_core.Default.map (coerce_ptr C.variant_ptr.uninit) (gc_alloc Variant.s ~count:1) in
    let () = get_variant_from_type_constructor type_enum new_variant_ptr (coerce_ptr C.type_ptr.plain x) in
    let inited_variant_ptr = coerce_ptr C.variant_ptr.plain new_variant_ptr in
    Living_core.Default.return inited_variant_ptr

  let ocaml_to_variant : ocaml_t -> C.variant_ptr structure ptr Living_core.Default.t = fun x ->
    of_ocaml x |> Living_core.Default.bind godot_to_variant

  let godot_of_variant : C.variant_ptr structure ptr -> godot_t Living_core.Default.t = fun x ->
    let open Living_core.Default.Let_syntax in
    let* new_type_ptr = gc_alloc s ~count:1 in
    let () = get_variant_to_type_constructor type_enum (coerce_ptr C.type_ptr.uninit new_type_ptr) x in
    Living_core.Default.return (coerce_ptr (ptr s) new_type_ptr)

  let ocaml_of_variant (x: C.variant_ptr structure ptr) : ocaml_t Living_core.Default.t = godot_of_variant x |> Living_core.Default.bind to_ocaml

  let godot_typ : godot_t typ = ptr s
end
    

  module type BOOL = sig
    include Api_types.API_TYPE

    val to_variant : 
    t structure ptr -> C.variant_ptr structure ptr

    val of_variant : 
    C.variant_ptr structure ptr-> t structure ptr
    end
  
module Bool = struct
  include Bool
  include Conv.Bool

  let godot_to_variant (x:godot_t) : C.variant_ptr structure ptr Living_core.Default.t = 
    let open Living_core.Default.Let_syntax in
    let* new_variant_ptr = Living_core.Default.map (coerce_ptr C.variant_ptr.uninit) (gc_alloc Variant.s ~count:1) in
    let () = get_variant_from_type_constructor type_enum new_variant_ptr (coerce_ptr C.type_ptr.plain x) in
    let inited_variant_ptr = coerce_ptr C.variant_ptr.plain new_variant_ptr in
    Living_core.Default.return inited_variant_ptr

  let ocaml_to_variant : ocaml_t -> C.variant_ptr structure ptr Living_core.Default.t = fun x ->
    of_ocaml x |> Living_core.Default.bind godot_to_variant

  let godot_of_variant : C.variant_ptr structure ptr -> godot_t Living_core.Default.t = fun x ->
    let open Living_core.Default.Let_syntax in
    let* new_type_ptr = gc_alloc s ~count:1 in
    let () = get_variant_to_type_constructor type_enum (coerce_ptr C.type_ptr.uninit new_type_ptr) x in
    Living_core.Default.return (coerce_ptr (ptr s) new_type_ptr)

  let ocaml_of_variant (x: C.variant_ptr structure ptr) : ocaml_t Living_core.Default.t = godot_of_variant x |> Living_core.Default.bind to_ocaml

  let godot_typ : godot_t typ = ptr s
end
    

  module type INT = sig
    include Api_types.API_TYPE

    val to_variant : 
    t structure ptr -> C.variant_ptr structure ptr

    val of_variant : 
    C.variant_ptr structure ptr-> t structure ptr
    end
  
module Int = struct
  include Int
  include Conv.Int

  let godot_to_variant (x:godot_t) : C.variant_ptr structure ptr Living_core.Default.t = 
    let open Living_core.Default.Let_syntax in
    let* new_variant_ptr = Living_core.Default.map (coerce_ptr C.variant_ptr.uninit) (gc_alloc Variant.s ~count:1) in
    let () = get_variant_from_type_constructor type_enum new_variant_ptr (coerce_ptr C.type_ptr.plain x) in
    let inited_variant_ptr = coerce_ptr C.variant_ptr.plain new_variant_ptr in
    Living_core.Default.return inited_variant_ptr

  let ocaml_to_variant : ocaml_t -> C.variant_ptr structure ptr Living_core.Default.t = fun x ->
    of_ocaml x |> Living_core.Default.bind godot_to_variant

  let godot_of_variant : C.variant_ptr structure ptr -> godot_t Living_core.Default.t = fun x ->
    let open Living_core.Default.Let_syntax in
    let* new_type_ptr = gc_alloc s ~count:1 in
    let () = get_variant_to_type_constructor type_enum (coerce_ptr C.type_ptr.uninit new_type_ptr) x in
    Living_core.Default.return (coerce_ptr (ptr s) new_type_ptr)

  let ocaml_of_variant (x: C.variant_ptr structure ptr) : ocaml_t Living_core.Default.t = godot_of_variant x |> Living_core.Default.bind to_ocaml

  let godot_typ : godot_t typ = ptr s
end
    

  module type FLOAT = sig
    include Api_types.API_TYPE

    val to_variant : 
    t structure ptr -> C.variant_ptr structure ptr

    val of_variant : 
    C.variant_ptr structure ptr-> t structure ptr
    end
  
module Float = struct
  include Float
  include Conv.Float

  let godot_to_variant (x:godot_t) : C.variant_ptr structure ptr Living_core.Default.t = 
    let open Living_core.Default.Let_syntax in
    let* new_variant_ptr = Living_core.Default.map (coerce_ptr C.variant_ptr.uninit) (gc_alloc Variant.s ~count:1) in
    let () = get_variant_from_type_constructor type_enum new_variant_ptr (coerce_ptr C.type_ptr.plain x) in
    let inited_variant_ptr = coerce_ptr C.variant_ptr.plain new_variant_ptr in
    Living_core.Default.return inited_variant_ptr

  let ocaml_to_variant : ocaml_t -> C.variant_ptr structure ptr Living_core.Default.t = fun x ->
    of_ocaml x |> Living_core.Default.bind godot_to_variant

  let godot_of_variant : C.variant_ptr structure ptr -> godot_t Living_core.Default.t = fun x ->
    let open Living_core.Default.Let_syntax in
    let* new_type_ptr = gc_alloc s ~count:1 in
    let () = get_variant_to_type_constructor type_enum (coerce_ptr C.type_ptr.uninit new_type_ptr) x in
    Living_core.Default.return (coerce_ptr (ptr s) new_type_ptr)

  let ocaml_of_variant (x: C.variant_ptr structure ptr) : ocaml_t Living_core.Default.t = godot_of_variant x |> Living_core.Default.bind to_ocaml

  let godot_typ : godot_t typ = ptr s
end
    

  module type STRING = sig
    include Api_types.API_TYPE

    val to_variant : 
    t structure ptr -> C.variant_ptr structure ptr

    val of_variant : 
    C.variant_ptr structure ptr-> t structure ptr
    end
  
module String = struct
  include String
  include Conv.String

  let godot_to_variant (x:godot_t) : C.variant_ptr structure ptr Living_core.Default.t = 
    let open Living_core.Default.Let_syntax in
    let* new_variant_ptr = Living_core.Default.map (coerce_ptr C.variant_ptr.uninit) (gc_alloc Variant.s ~count:1) in
    let () = get_variant_from_type_constructor type_enum new_variant_ptr (coerce_ptr C.type_ptr.plain x) in
    let inited_variant_ptr = coerce_ptr C.variant_ptr.plain new_variant_ptr in
    Living_core.Default.return inited_variant_ptr

  let ocaml_to_variant : ocaml_t -> C.variant_ptr structure ptr Living_core.Default.t = fun x ->
    of_ocaml x |> Living_core.Default.bind godot_to_variant

  let godot_of_variant : C.variant_ptr structure ptr -> godot_t Living_core.Default.t = fun x ->
    let open Living_core.Default.Let_syntax in
    let* new_type_ptr = gc_alloc s ~count:1 in
    let () = get_variant_to_type_constructor type_enum (coerce_ptr C.type_ptr.uninit new_type_ptr) x in
    Living_core.Default.return (coerce_ptr (ptr s) new_type_ptr)

  let ocaml_of_variant (x: C.variant_ptr structure ptr) : ocaml_t Living_core.Default.t = godot_of_variant x |> Living_core.Default.bind to_ocaml

  let godot_typ : godot_t typ = ptr s
end
    

  module type VECTOR2 = sig
    include Api_types.API_TYPE

    val to_variant : 
    t structure ptr -> C.variant_ptr structure ptr

    val of_variant : 
    C.variant_ptr structure ptr-> t structure ptr
    end
  
module Vector2 = struct
  include Vector2
  include Conv.Vector2

  let godot_to_variant (x:godot_t) : C.variant_ptr structure ptr Living_core.Default.t = 
    let open Living_core.Default.Let_syntax in
    let* new_variant_ptr = Living_core.Default.map (coerce_ptr C.variant_ptr.uninit) (gc_alloc Variant.s ~count:1) in
    let () = get_variant_from_type_constructor type_enum new_variant_ptr (coerce_ptr C.type_ptr.plain x) in
    let inited_variant_ptr = coerce_ptr C.variant_ptr.plain new_variant_ptr in
    Living_core.Default.return inited_variant_ptr

  let ocaml_to_variant : ocaml_t -> C.variant_ptr structure ptr Living_core.Default.t = fun x ->
    of_ocaml x |> Living_core.Default.bind godot_to_variant

  let godot_of_variant : C.variant_ptr structure ptr -> godot_t Living_core.Default.t = fun x ->
    let open Living_core.Default.Let_syntax in
    let* new_type_ptr = gc_alloc s ~count:1 in
    let () = get_variant_to_type_constructor type_enum (coerce_ptr C.type_ptr.uninit new_type_ptr) x in
    Living_core.Default.return (coerce_ptr (ptr s) new_type_ptr)

  let ocaml_of_variant (x: C.variant_ptr structure ptr) : ocaml_t Living_core.Default.t = godot_of_variant x |> Living_core.Default.bind to_ocaml

  let godot_typ : godot_t typ = ptr s
end
    

  module type VECTOR2I = sig
    include Api_types.API_TYPE

    val to_variant : 
    t structure ptr -> C.variant_ptr structure ptr

    val of_variant : 
    C.variant_ptr structure ptr-> t structure ptr
    end
  
module Vector2i = struct
  include Vector2i
  include Conv.Vector2i

  let godot_to_variant (x:godot_t) : C.variant_ptr structure ptr Living_core.Default.t = 
    let open Living_core.Default.Let_syntax in
    let* new_variant_ptr = Living_core.Default.map (coerce_ptr C.variant_ptr.uninit) (gc_alloc Variant.s ~count:1) in
    let () = get_variant_from_type_constructor type_enum new_variant_ptr (coerce_ptr C.type_ptr.plain x) in
    let inited_variant_ptr = coerce_ptr C.variant_ptr.plain new_variant_ptr in
    Living_core.Default.return inited_variant_ptr

  let ocaml_to_variant : ocaml_t -> C.variant_ptr structure ptr Living_core.Default.t = fun x ->
    of_ocaml x |> Living_core.Default.bind godot_to_variant

  let godot_of_variant : C.variant_ptr structure ptr -> godot_t Living_core.Default.t = fun x ->
    let open Living_core.Default.Let_syntax in
    let* new_type_ptr = gc_alloc s ~count:1 in
    let () = get_variant_to_type_constructor type_enum (coerce_ptr C.type_ptr.uninit new_type_ptr) x in
    Living_core.Default.return (coerce_ptr (ptr s) new_type_ptr)

  let ocaml_of_variant (x: C.variant_ptr structure ptr) : ocaml_t Living_core.Default.t = godot_of_variant x |> Living_core.Default.bind to_ocaml

  let godot_typ : godot_t typ = ptr s
end
    

  module type RECT2 = sig
    include Api_types.API_TYPE

    val to_variant : 
    t structure ptr -> C.variant_ptr structure ptr

    val of_variant : 
    C.variant_ptr structure ptr-> t structure ptr
    end
  
module Rect2 = struct
  include Rect2
  include Conv.Rect2

  let godot_to_variant (x:godot_t) : C.variant_ptr structure ptr Living_core.Default.t = 
    let open Living_core.Default.Let_syntax in
    let* new_variant_ptr = Living_core.Default.map (coerce_ptr C.variant_ptr.uninit) (gc_alloc Variant.s ~count:1) in
    let () = get_variant_from_type_constructor type_enum new_variant_ptr (coerce_ptr C.type_ptr.plain x) in
    let inited_variant_ptr = coerce_ptr C.variant_ptr.plain new_variant_ptr in
    Living_core.Default.return inited_variant_ptr

  let ocaml_to_variant : ocaml_t -> C.variant_ptr structure ptr Living_core.Default.t = fun x ->
    of_ocaml x |> Living_core.Default.bind godot_to_variant

  let godot_of_variant : C.variant_ptr structure ptr -> godot_t Living_core.Default.t = fun x ->
    let open Living_core.Default.Let_syntax in
    let* new_type_ptr = gc_alloc s ~count:1 in
    let () = get_variant_to_type_constructor type_enum (coerce_ptr C.type_ptr.uninit new_type_ptr) x in
    Living_core.Default.return (coerce_ptr (ptr s) new_type_ptr)

  let ocaml_of_variant (x: C.variant_ptr structure ptr) : ocaml_t Living_core.Default.t = godot_of_variant x |> Living_core.Default.bind to_ocaml

  let godot_typ : godot_t typ = ptr s
end
    

  module type RECT2I = sig
    include Api_types.API_TYPE

    val to_variant : 
    t structure ptr -> C.variant_ptr structure ptr

    val of_variant : 
    C.variant_ptr structure ptr-> t structure ptr
    end
  
module Rect2i = struct
  include Rect2i
  include Conv.Rect2i

  let godot_to_variant (x:godot_t) : C.variant_ptr structure ptr Living_core.Default.t = 
    let open Living_core.Default.Let_syntax in
    let* new_variant_ptr = Living_core.Default.map (coerce_ptr C.variant_ptr.uninit) (gc_alloc Variant.s ~count:1) in
    let () = get_variant_from_type_constructor type_enum new_variant_ptr (coerce_ptr C.type_ptr.plain x) in
    let inited_variant_ptr = coerce_ptr C.variant_ptr.plain new_variant_ptr in
    Living_core.Default.return inited_variant_ptr

  let ocaml_to_variant : ocaml_t -> C.variant_ptr structure ptr Living_core.Default.t = fun x ->
    of_ocaml x |> Living_core.Default.bind godot_to_variant

  let godot_of_variant : C.variant_ptr structure ptr -> godot_t Living_core.Default.t = fun x ->
    let open Living_core.Default.Let_syntax in
    let* new_type_ptr = gc_alloc s ~count:1 in
    let () = get_variant_to_type_constructor type_enum (coerce_ptr C.type_ptr.uninit new_type_ptr) x in
    Living_core.Default.return (coerce_ptr (ptr s) new_type_ptr)

  let ocaml_of_variant (x: C.variant_ptr structure ptr) : ocaml_t Living_core.Default.t = godot_of_variant x |> Living_core.Default.bind to_ocaml

  let godot_typ : godot_t typ = ptr s
end
    

  module type VECTOR3 = sig
    include Api_types.API_TYPE

    val to_variant : 
    t structure ptr -> C.variant_ptr structure ptr

    val of_variant : 
    C.variant_ptr structure ptr-> t structure ptr
    end
  
module Vector3 = struct
  include Vector3
  include Conv.Vector3

  let godot_to_variant (x:godot_t) : C.variant_ptr structure ptr Living_core.Default.t = 
    let open Living_core.Default.Let_syntax in
    let* new_variant_ptr = Living_core.Default.map (coerce_ptr C.variant_ptr.uninit) (gc_alloc Variant.s ~count:1) in
    let () = get_variant_from_type_constructor type_enum new_variant_ptr (coerce_ptr C.type_ptr.plain x) in
    let inited_variant_ptr = coerce_ptr C.variant_ptr.plain new_variant_ptr in
    Living_core.Default.return inited_variant_ptr

  let ocaml_to_variant : ocaml_t -> C.variant_ptr structure ptr Living_core.Default.t = fun x ->
    of_ocaml x |> Living_core.Default.bind godot_to_variant

  let godot_of_variant : C.variant_ptr structure ptr -> godot_t Living_core.Default.t = fun x ->
    let open Living_core.Default.Let_syntax in
    let* new_type_ptr = gc_alloc s ~count:1 in
    let () = get_variant_to_type_constructor type_enum (coerce_ptr C.type_ptr.uninit new_type_ptr) x in
    Living_core.Default.return (coerce_ptr (ptr s) new_type_ptr)

  let ocaml_of_variant (x: C.variant_ptr structure ptr) : ocaml_t Living_core.Default.t = godot_of_variant x |> Living_core.Default.bind to_ocaml

  let godot_typ : godot_t typ = ptr s
end
    

  module type VECTOR3I = sig
    include Api_types.API_TYPE

    val to_variant : 
    t structure ptr -> C.variant_ptr structure ptr

    val of_variant : 
    C.variant_ptr structure ptr-> t structure ptr
    end
  
module Vector3i = struct
  include Vector3i
  include Conv.Vector3i

  let godot_to_variant (x:godot_t) : C.variant_ptr structure ptr Living_core.Default.t = 
    let open Living_core.Default.Let_syntax in
    let* new_variant_ptr = Living_core.Default.map (coerce_ptr C.variant_ptr.uninit) (gc_alloc Variant.s ~count:1) in
    let () = get_variant_from_type_constructor type_enum new_variant_ptr (coerce_ptr C.type_ptr.plain x) in
    let inited_variant_ptr = coerce_ptr C.variant_ptr.plain new_variant_ptr in
    Living_core.Default.return inited_variant_ptr

  let ocaml_to_variant : ocaml_t -> C.variant_ptr structure ptr Living_core.Default.t = fun x ->
    of_ocaml x |> Living_core.Default.bind godot_to_variant

  let godot_of_variant : C.variant_ptr structure ptr -> godot_t Living_core.Default.t = fun x ->
    let open Living_core.Default.Let_syntax in
    let* new_type_ptr = gc_alloc s ~count:1 in
    let () = get_variant_to_type_constructor type_enum (coerce_ptr C.type_ptr.uninit new_type_ptr) x in
    Living_core.Default.return (coerce_ptr (ptr s) new_type_ptr)

  let ocaml_of_variant (x: C.variant_ptr structure ptr) : ocaml_t Living_core.Default.t = godot_of_variant x |> Living_core.Default.bind to_ocaml

  let godot_typ : godot_t typ = ptr s
end
    

  module type TRANSFORM2D = sig
    include Api_types.API_TYPE

    val to_variant : 
    t structure ptr -> C.variant_ptr structure ptr

    val of_variant : 
    C.variant_ptr structure ptr-> t structure ptr
    end
  
module Transform2D = struct
  include Transform2D
  include Conv.Transform2D

  let godot_to_variant (x:godot_t) : C.variant_ptr structure ptr Living_core.Default.t = 
    let open Living_core.Default.Let_syntax in
    let* new_variant_ptr = Living_core.Default.map (coerce_ptr C.variant_ptr.uninit) (gc_alloc Variant.s ~count:1) in
    let () = get_variant_from_type_constructor type_enum new_variant_ptr (coerce_ptr C.type_ptr.plain x) in
    let inited_variant_ptr = coerce_ptr C.variant_ptr.plain new_variant_ptr in
    Living_core.Default.return inited_variant_ptr

  let ocaml_to_variant : ocaml_t -> C.variant_ptr structure ptr Living_core.Default.t = fun x ->
    of_ocaml x |> Living_core.Default.bind godot_to_variant

  let godot_of_variant : C.variant_ptr structure ptr -> godot_t Living_core.Default.t = fun x ->
    let open Living_core.Default.Let_syntax in
    let* new_type_ptr = gc_alloc s ~count:1 in
    let () = get_variant_to_type_constructor type_enum (coerce_ptr C.type_ptr.uninit new_type_ptr) x in
    Living_core.Default.return (coerce_ptr (ptr s) new_type_ptr)

  let ocaml_of_variant (x: C.variant_ptr structure ptr) : ocaml_t Living_core.Default.t = godot_of_variant x |> Living_core.Default.bind to_ocaml

  let godot_typ : godot_t typ = ptr s
end
    

  module type VECTOR4 = sig
    include Api_types.API_TYPE

    val to_variant : 
    t structure ptr -> C.variant_ptr structure ptr

    val of_variant : 
    C.variant_ptr structure ptr-> t structure ptr
    end
  
module Vector4 = struct
  include Vector4
  include Conv.Vector4

  let godot_to_variant (x:godot_t) : C.variant_ptr structure ptr Living_core.Default.t = 
    let open Living_core.Default.Let_syntax in
    let* new_variant_ptr = Living_core.Default.map (coerce_ptr C.variant_ptr.uninit) (gc_alloc Variant.s ~count:1) in
    let () = get_variant_from_type_constructor type_enum new_variant_ptr (coerce_ptr C.type_ptr.plain x) in
    let inited_variant_ptr = coerce_ptr C.variant_ptr.plain new_variant_ptr in
    Living_core.Default.return inited_variant_ptr

  let ocaml_to_variant : ocaml_t -> C.variant_ptr structure ptr Living_core.Default.t = fun x ->
    of_ocaml x |> Living_core.Default.bind godot_to_variant

  let godot_of_variant : C.variant_ptr structure ptr -> godot_t Living_core.Default.t = fun x ->
    let open Living_core.Default.Let_syntax in
    let* new_type_ptr = gc_alloc s ~count:1 in
    let () = get_variant_to_type_constructor type_enum (coerce_ptr C.type_ptr.uninit new_type_ptr) x in
    Living_core.Default.return (coerce_ptr (ptr s) new_type_ptr)

  let ocaml_of_variant (x: C.variant_ptr structure ptr) : ocaml_t Living_core.Default.t = godot_of_variant x |> Living_core.Default.bind to_ocaml

  let godot_typ : godot_t typ = ptr s
end
    

  module type VECTOR4I = sig
    include Api_types.API_TYPE

    val to_variant : 
    t structure ptr -> C.variant_ptr structure ptr

    val of_variant : 
    C.variant_ptr structure ptr-> t structure ptr
    end
  
module Vector4i = struct
  include Vector4i
  include Conv.Vector4i

  let godot_to_variant (x:godot_t) : C.variant_ptr structure ptr Living_core.Default.t = 
    let open Living_core.Default.Let_syntax in
    let* new_variant_ptr = Living_core.Default.map (coerce_ptr C.variant_ptr.uninit) (gc_alloc Variant.s ~count:1) in
    let () = get_variant_from_type_constructor type_enum new_variant_ptr (coerce_ptr C.type_ptr.plain x) in
    let inited_variant_ptr = coerce_ptr C.variant_ptr.plain new_variant_ptr in
    Living_core.Default.return inited_variant_ptr

  let ocaml_to_variant : ocaml_t -> C.variant_ptr structure ptr Living_core.Default.t = fun x ->
    of_ocaml x |> Living_core.Default.bind godot_to_variant

  let godot_of_variant : C.variant_ptr structure ptr -> godot_t Living_core.Default.t = fun x ->
    let open Living_core.Default.Let_syntax in
    let* new_type_ptr = gc_alloc s ~count:1 in
    let () = get_variant_to_type_constructor type_enum (coerce_ptr C.type_ptr.uninit new_type_ptr) x in
    Living_core.Default.return (coerce_ptr (ptr s) new_type_ptr)

  let ocaml_of_variant (x: C.variant_ptr structure ptr) : ocaml_t Living_core.Default.t = godot_of_variant x |> Living_core.Default.bind to_ocaml

  let godot_typ : godot_t typ = ptr s
end
    

  module type PLANE = sig
    include Api_types.API_TYPE

    val to_variant : 
    t structure ptr -> C.variant_ptr structure ptr

    val of_variant : 
    C.variant_ptr structure ptr-> t structure ptr
    end
  
module Plane = struct
  include Plane
  include Conv.Plane

  let godot_to_variant (x:godot_t) : C.variant_ptr structure ptr Living_core.Default.t = 
    let open Living_core.Default.Let_syntax in
    let* new_variant_ptr = Living_core.Default.map (coerce_ptr C.variant_ptr.uninit) (gc_alloc Variant.s ~count:1) in
    let () = get_variant_from_type_constructor type_enum new_variant_ptr (coerce_ptr C.type_ptr.plain x) in
    let inited_variant_ptr = coerce_ptr C.variant_ptr.plain new_variant_ptr in
    Living_core.Default.return inited_variant_ptr

  let ocaml_to_variant : ocaml_t -> C.variant_ptr structure ptr Living_core.Default.t = fun x ->
    of_ocaml x |> Living_core.Default.bind godot_to_variant

  let godot_of_variant : C.variant_ptr structure ptr -> godot_t Living_core.Default.t = fun x ->
    let open Living_core.Default.Let_syntax in
    let* new_type_ptr = gc_alloc s ~count:1 in
    let () = get_variant_to_type_constructor type_enum (coerce_ptr C.type_ptr.uninit new_type_ptr) x in
    Living_core.Default.return (coerce_ptr (ptr s) new_type_ptr)

  let ocaml_of_variant (x: C.variant_ptr structure ptr) : ocaml_t Living_core.Default.t = godot_of_variant x |> Living_core.Default.bind to_ocaml

  let godot_typ : godot_t typ = ptr s
end
    

  module type QUATERNION = sig
    include Api_types.API_TYPE

    val to_variant : 
    t structure ptr -> C.variant_ptr structure ptr

    val of_variant : 
    C.variant_ptr structure ptr-> t structure ptr
    end
  
module Quaternion = struct
  include Quaternion
  include Conv.Quaternion

  let godot_to_variant (x:godot_t) : C.variant_ptr structure ptr Living_core.Default.t = 
    let open Living_core.Default.Let_syntax in
    let* new_variant_ptr = Living_core.Default.map (coerce_ptr C.variant_ptr.uninit) (gc_alloc Variant.s ~count:1) in
    let () = get_variant_from_type_constructor type_enum new_variant_ptr (coerce_ptr C.type_ptr.plain x) in
    let inited_variant_ptr = coerce_ptr C.variant_ptr.plain new_variant_ptr in
    Living_core.Default.return inited_variant_ptr

  let ocaml_to_variant : ocaml_t -> C.variant_ptr structure ptr Living_core.Default.t = fun x ->
    of_ocaml x |> Living_core.Default.bind godot_to_variant

  let godot_of_variant : C.variant_ptr structure ptr -> godot_t Living_core.Default.t = fun x ->
    let open Living_core.Default.Let_syntax in
    let* new_type_ptr = gc_alloc s ~count:1 in
    let () = get_variant_to_type_constructor type_enum (coerce_ptr C.type_ptr.uninit new_type_ptr) x in
    Living_core.Default.return (coerce_ptr (ptr s) new_type_ptr)

  let ocaml_of_variant (x: C.variant_ptr structure ptr) : ocaml_t Living_core.Default.t = godot_of_variant x |> Living_core.Default.bind to_ocaml

  let godot_typ : godot_t typ = ptr s
end
    

  module type AABB = sig
    include Api_types.API_TYPE

    val to_variant : 
    t structure ptr -> C.variant_ptr structure ptr

    val of_variant : 
    C.variant_ptr structure ptr-> t structure ptr
    end
  
module AABB = struct
  include AABB
  include Conv.AABB

  let godot_to_variant (x:godot_t) : C.variant_ptr structure ptr Living_core.Default.t = 
    let open Living_core.Default.Let_syntax in
    let* new_variant_ptr = Living_core.Default.map (coerce_ptr C.variant_ptr.uninit) (gc_alloc Variant.s ~count:1) in
    let () = get_variant_from_type_constructor type_enum new_variant_ptr (coerce_ptr C.type_ptr.plain x) in
    let inited_variant_ptr = coerce_ptr C.variant_ptr.plain new_variant_ptr in
    Living_core.Default.return inited_variant_ptr

  let ocaml_to_variant : ocaml_t -> C.variant_ptr structure ptr Living_core.Default.t = fun x ->
    of_ocaml x |> Living_core.Default.bind godot_to_variant

  let godot_of_variant : C.variant_ptr structure ptr -> godot_t Living_core.Default.t = fun x ->
    let open Living_core.Default.Let_syntax in
    let* new_type_ptr = gc_alloc s ~count:1 in
    let () = get_variant_to_type_constructor type_enum (coerce_ptr C.type_ptr.uninit new_type_ptr) x in
    Living_core.Default.return (coerce_ptr (ptr s) new_type_ptr)

  let ocaml_of_variant (x: C.variant_ptr structure ptr) : ocaml_t Living_core.Default.t = godot_of_variant x |> Living_core.Default.bind to_ocaml

  let godot_typ : godot_t typ = ptr s
end
    

  module type BASIS = sig
    include Api_types.API_TYPE

    val to_variant : 
    t structure ptr -> C.variant_ptr structure ptr

    val of_variant : 
    C.variant_ptr structure ptr-> t structure ptr
    end
  
module Basis = struct
  include Basis
  include Conv.Basis

  let godot_to_variant (x:godot_t) : C.variant_ptr structure ptr Living_core.Default.t = 
    let open Living_core.Default.Let_syntax in
    let* new_variant_ptr = Living_core.Default.map (coerce_ptr C.variant_ptr.uninit) (gc_alloc Variant.s ~count:1) in
    let () = get_variant_from_type_constructor type_enum new_variant_ptr (coerce_ptr C.type_ptr.plain x) in
    let inited_variant_ptr = coerce_ptr C.variant_ptr.plain new_variant_ptr in
    Living_core.Default.return inited_variant_ptr

  let ocaml_to_variant : ocaml_t -> C.variant_ptr structure ptr Living_core.Default.t = fun x ->
    of_ocaml x |> Living_core.Default.bind godot_to_variant

  let godot_of_variant : C.variant_ptr structure ptr -> godot_t Living_core.Default.t = fun x ->
    let open Living_core.Default.Let_syntax in
    let* new_type_ptr = gc_alloc s ~count:1 in
    let () = get_variant_to_type_constructor type_enum (coerce_ptr C.type_ptr.uninit new_type_ptr) x in
    Living_core.Default.return (coerce_ptr (ptr s) new_type_ptr)

  let ocaml_of_variant (x: C.variant_ptr structure ptr) : ocaml_t Living_core.Default.t = godot_of_variant x |> Living_core.Default.bind to_ocaml

  let godot_typ : godot_t typ = ptr s
end
    

  module type TRANSFORM3D = sig
    include Api_types.API_TYPE

    val to_variant : 
    t structure ptr -> C.variant_ptr structure ptr

    val of_variant : 
    C.variant_ptr structure ptr-> t structure ptr
    end
  
module Transform3D = struct
  include Transform3D
  include Conv.Transform3D

  let godot_to_variant (x:godot_t) : C.variant_ptr structure ptr Living_core.Default.t = 
    let open Living_core.Default.Let_syntax in
    let* new_variant_ptr = Living_core.Default.map (coerce_ptr C.variant_ptr.uninit) (gc_alloc Variant.s ~count:1) in
    let () = get_variant_from_type_constructor type_enum new_variant_ptr (coerce_ptr C.type_ptr.plain x) in
    let inited_variant_ptr = coerce_ptr C.variant_ptr.plain new_variant_ptr in
    Living_core.Default.return inited_variant_ptr

  let ocaml_to_variant : ocaml_t -> C.variant_ptr structure ptr Living_core.Default.t = fun x ->
    of_ocaml x |> Living_core.Default.bind godot_to_variant

  let godot_of_variant : C.variant_ptr structure ptr -> godot_t Living_core.Default.t = fun x ->
    let open Living_core.Default.Let_syntax in
    let* new_type_ptr = gc_alloc s ~count:1 in
    let () = get_variant_to_type_constructor type_enum (coerce_ptr C.type_ptr.uninit new_type_ptr) x in
    Living_core.Default.return (coerce_ptr (ptr s) new_type_ptr)

  let ocaml_of_variant (x: C.variant_ptr structure ptr) : ocaml_t Living_core.Default.t = godot_of_variant x |> Living_core.Default.bind to_ocaml

  let godot_typ : godot_t typ = ptr s
end
    

  module type PROJECTION = sig
    include Api_types.API_TYPE

    val to_variant : 
    t structure ptr -> C.variant_ptr structure ptr

    val of_variant : 
    C.variant_ptr structure ptr-> t structure ptr
    end
  
module Projection = struct
  include Projection
  include Conv.Projection

  let godot_to_variant (x:godot_t) : C.variant_ptr structure ptr Living_core.Default.t = 
    let open Living_core.Default.Let_syntax in
    let* new_variant_ptr = Living_core.Default.map (coerce_ptr C.variant_ptr.uninit) (gc_alloc Variant.s ~count:1) in
    let () = get_variant_from_type_constructor type_enum new_variant_ptr (coerce_ptr C.type_ptr.plain x) in
    let inited_variant_ptr = coerce_ptr C.variant_ptr.plain new_variant_ptr in
    Living_core.Default.return inited_variant_ptr

  let ocaml_to_variant : ocaml_t -> C.variant_ptr structure ptr Living_core.Default.t = fun x ->
    of_ocaml x |> Living_core.Default.bind godot_to_variant

  let godot_of_variant : C.variant_ptr structure ptr -> godot_t Living_core.Default.t = fun x ->
    let open Living_core.Default.Let_syntax in
    let* new_type_ptr = gc_alloc s ~count:1 in
    let () = get_variant_to_type_constructor type_enum (coerce_ptr C.type_ptr.uninit new_type_ptr) x in
    Living_core.Default.return (coerce_ptr (ptr s) new_type_ptr)

  let ocaml_of_variant (x: C.variant_ptr structure ptr) : ocaml_t Living_core.Default.t = godot_of_variant x |> Living_core.Default.bind to_ocaml

  let godot_typ : godot_t typ = ptr s
end
    

  module type COLOR = sig
    include Api_types.API_TYPE

    val to_variant : 
    t structure ptr -> C.variant_ptr structure ptr

    val of_variant : 
    C.variant_ptr structure ptr-> t structure ptr
    end
  
module Color = struct
  include Color
  include Conv.Color

  let godot_to_variant (x:godot_t) : C.variant_ptr structure ptr Living_core.Default.t = 
    let open Living_core.Default.Let_syntax in
    let* new_variant_ptr = Living_core.Default.map (coerce_ptr C.variant_ptr.uninit) (gc_alloc Variant.s ~count:1) in
    let () = get_variant_from_type_constructor type_enum new_variant_ptr (coerce_ptr C.type_ptr.plain x) in
    let inited_variant_ptr = coerce_ptr C.variant_ptr.plain new_variant_ptr in
    Living_core.Default.return inited_variant_ptr

  let ocaml_to_variant : ocaml_t -> C.variant_ptr structure ptr Living_core.Default.t = fun x ->
    of_ocaml x |> Living_core.Default.bind godot_to_variant

  let godot_of_variant : C.variant_ptr structure ptr -> godot_t Living_core.Default.t = fun x ->
    let open Living_core.Default.Let_syntax in
    let* new_type_ptr = gc_alloc s ~count:1 in
    let () = get_variant_to_type_constructor type_enum (coerce_ptr C.type_ptr.uninit new_type_ptr) x in
    Living_core.Default.return (coerce_ptr (ptr s) new_type_ptr)

  let ocaml_of_variant (x: C.variant_ptr structure ptr) : ocaml_t Living_core.Default.t = godot_of_variant x |> Living_core.Default.bind to_ocaml

  let godot_typ : godot_t typ = ptr s
end
    

  module type STRINGNAME = sig
    include Api_types.API_TYPE

    val to_variant : 
    t structure ptr -> C.variant_ptr structure ptr

    val of_variant : 
    C.variant_ptr structure ptr-> t structure ptr
    end
  
module StringName = struct
  include StringName
  include Conv.StringName

  let godot_to_variant (x:godot_t) : C.variant_ptr structure ptr Living_core.Default.t = 
    let open Living_core.Default.Let_syntax in
    let* new_variant_ptr = Living_core.Default.map (coerce_ptr C.variant_ptr.uninit) (gc_alloc Variant.s ~count:1) in
    let () = get_variant_from_type_constructor type_enum new_variant_ptr (coerce_ptr C.type_ptr.plain x) in
    let inited_variant_ptr = coerce_ptr C.variant_ptr.plain new_variant_ptr in
    Living_core.Default.return inited_variant_ptr

  let ocaml_to_variant : ocaml_t -> C.variant_ptr structure ptr Living_core.Default.t = fun x ->
    of_ocaml x |> Living_core.Default.bind godot_to_variant

  let godot_of_variant : C.variant_ptr structure ptr -> godot_t Living_core.Default.t = fun x ->
    let open Living_core.Default.Let_syntax in
    let* new_type_ptr = gc_alloc s ~count:1 in
    let () = get_variant_to_type_constructor type_enum (coerce_ptr C.type_ptr.uninit new_type_ptr) x in
    Living_core.Default.return (coerce_ptr (ptr s) new_type_ptr)

  let ocaml_of_variant (x: C.variant_ptr structure ptr) : ocaml_t Living_core.Default.t = godot_of_variant x |> Living_core.Default.bind to_ocaml

  let godot_typ : godot_t typ = ptr s
end
    

  module type NODEPATH = sig
    include Api_types.API_TYPE

    val to_variant : 
    t structure ptr -> C.variant_ptr structure ptr

    val of_variant : 
    C.variant_ptr structure ptr-> t structure ptr
    end
  
module NodePath = struct
  include NodePath
  include Conv.NodePath

  let godot_to_variant (x:godot_t) : C.variant_ptr structure ptr Living_core.Default.t = 
    let open Living_core.Default.Let_syntax in
    let* new_variant_ptr = Living_core.Default.map (coerce_ptr C.variant_ptr.uninit) (gc_alloc Variant.s ~count:1) in
    let () = get_variant_from_type_constructor type_enum new_variant_ptr (coerce_ptr C.type_ptr.plain x) in
    let inited_variant_ptr = coerce_ptr C.variant_ptr.plain new_variant_ptr in
    Living_core.Default.return inited_variant_ptr

  let ocaml_to_variant : ocaml_t -> C.variant_ptr structure ptr Living_core.Default.t = fun x ->
    of_ocaml x |> Living_core.Default.bind godot_to_variant

  let godot_of_variant : C.variant_ptr structure ptr -> godot_t Living_core.Default.t = fun x ->
    let open Living_core.Default.Let_syntax in
    let* new_type_ptr = gc_alloc s ~count:1 in
    let () = get_variant_to_type_constructor type_enum (coerce_ptr C.type_ptr.uninit new_type_ptr) x in
    Living_core.Default.return (coerce_ptr (ptr s) new_type_ptr)

  let ocaml_of_variant (x: C.variant_ptr structure ptr) : ocaml_t Living_core.Default.t = godot_of_variant x |> Living_core.Default.bind to_ocaml

  let godot_typ : godot_t typ = ptr s
end
    

  module type RID = sig
    include Api_types.API_TYPE

    val to_variant : 
    t structure ptr -> C.variant_ptr structure ptr

    val of_variant : 
    C.variant_ptr structure ptr-> t structure ptr
    end
  
module RID = struct
  include RID
  include Conv.RID

  let godot_to_variant (x:godot_t) : C.variant_ptr structure ptr Living_core.Default.t = 
    let open Living_core.Default.Let_syntax in
    let* new_variant_ptr = Living_core.Default.map (coerce_ptr C.variant_ptr.uninit) (gc_alloc Variant.s ~count:1) in
    let () = get_variant_from_type_constructor type_enum new_variant_ptr (coerce_ptr C.type_ptr.plain x) in
    let inited_variant_ptr = coerce_ptr C.variant_ptr.plain new_variant_ptr in
    Living_core.Default.return inited_variant_ptr

  let ocaml_to_variant : ocaml_t -> C.variant_ptr structure ptr Living_core.Default.t = fun x ->
    of_ocaml x |> Living_core.Default.bind godot_to_variant

  let godot_of_variant : C.variant_ptr structure ptr -> godot_t Living_core.Default.t = fun x ->
    let open Living_core.Default.Let_syntax in
    let* new_type_ptr = gc_alloc s ~count:1 in
    let () = get_variant_to_type_constructor type_enum (coerce_ptr C.type_ptr.uninit new_type_ptr) x in
    Living_core.Default.return (coerce_ptr (ptr s) new_type_ptr)

  let ocaml_of_variant (x: C.variant_ptr structure ptr) : ocaml_t Living_core.Default.t = godot_of_variant x |> Living_core.Default.bind to_ocaml

  let godot_typ : godot_t typ = ptr s
end
    

  module type OBJECT = sig
    include Api_types.API_TYPE

    val to_variant : 
    t structure ptr -> C.variant_ptr structure ptr

    val of_variant : 
    C.variant_ptr structure ptr-> t structure ptr
    end
  
module Object = struct
  include Object
  include Conv.Object

  let godot_to_variant (x:godot_t) : C.variant_ptr structure ptr Living_core.Default.t = 
    let open Living_core.Default.Let_syntax in
    let* new_variant_ptr = Living_core.Default.map (coerce_ptr C.variant_ptr.uninit) (gc_alloc Variant.s ~count:1) in
    let () = get_variant_from_type_constructor type_enum new_variant_ptr (coerce_ptr C.type_ptr.plain x) in
    let inited_variant_ptr = coerce_ptr C.variant_ptr.plain new_variant_ptr in
    Living_core.Default.return inited_variant_ptr

  let ocaml_to_variant : ocaml_t -> C.variant_ptr structure ptr Living_core.Default.t = fun x ->
    of_ocaml x |> Living_core.Default.bind godot_to_variant

  let godot_of_variant : C.variant_ptr structure ptr -> godot_t Living_core.Default.t = fun x ->
    let open Living_core.Default.Let_syntax in
    let* new_type_ptr = gc_alloc s ~count:1 in
    let () = get_variant_to_type_constructor type_enum (coerce_ptr C.type_ptr.uninit new_type_ptr) x in
    Living_core.Default.return (coerce_ptr (ptr s) new_type_ptr)

  let ocaml_of_variant (x: C.variant_ptr structure ptr) : ocaml_t Living_core.Default.t = godot_of_variant x |> Living_core.Default.bind to_ocaml

  let godot_typ : godot_t typ = ptr s
end
    

  module type CALLABLE = sig
    include Api_types.API_TYPE

    val to_variant : 
    t structure ptr -> C.variant_ptr structure ptr

    val of_variant : 
    C.variant_ptr structure ptr-> t structure ptr
    end
  
module Callable = struct
  include Callable
  include Conv.Callable

  let godot_to_variant (x:godot_t) : C.variant_ptr structure ptr Living_core.Default.t = 
    let open Living_core.Default.Let_syntax in
    let* new_variant_ptr = Living_core.Default.map (coerce_ptr C.variant_ptr.uninit) (gc_alloc Variant.s ~count:1) in
    let () = get_variant_from_type_constructor type_enum new_variant_ptr (coerce_ptr C.type_ptr.plain x) in
    let inited_variant_ptr = coerce_ptr C.variant_ptr.plain new_variant_ptr in
    Living_core.Default.return inited_variant_ptr

  let ocaml_to_variant : ocaml_t -> C.variant_ptr structure ptr Living_core.Default.t = fun x ->
    of_ocaml x |> Living_core.Default.bind godot_to_variant

  let godot_of_variant : C.variant_ptr structure ptr -> godot_t Living_core.Default.t = fun x ->
    let open Living_core.Default.Let_syntax in
    let* new_type_ptr = gc_alloc s ~count:1 in
    let () = get_variant_to_type_constructor type_enum (coerce_ptr C.type_ptr.uninit new_type_ptr) x in
    Living_core.Default.return (coerce_ptr (ptr s) new_type_ptr)

  let ocaml_of_variant (x: C.variant_ptr structure ptr) : ocaml_t Living_core.Default.t = godot_of_variant x |> Living_core.Default.bind to_ocaml

  let godot_typ : godot_t typ = ptr s
end
    

  module type SIGNAL = sig
    include Api_types.API_TYPE

    val to_variant : 
    t structure ptr -> C.variant_ptr structure ptr

    val of_variant : 
    C.variant_ptr structure ptr-> t structure ptr
    end
  
module Signal = struct
  include Signal
  include Conv.Signal

  let godot_to_variant (x:godot_t) : C.variant_ptr structure ptr Living_core.Default.t = 
    let open Living_core.Default.Let_syntax in
    let* new_variant_ptr = Living_core.Default.map (coerce_ptr C.variant_ptr.uninit) (gc_alloc Variant.s ~count:1) in
    let () = get_variant_from_type_constructor type_enum new_variant_ptr (coerce_ptr C.type_ptr.plain x) in
    let inited_variant_ptr = coerce_ptr C.variant_ptr.plain new_variant_ptr in
    Living_core.Default.return inited_variant_ptr

  let ocaml_to_variant : ocaml_t -> C.variant_ptr structure ptr Living_core.Default.t = fun x ->
    of_ocaml x |> Living_core.Default.bind godot_to_variant

  let godot_of_variant : C.variant_ptr structure ptr -> godot_t Living_core.Default.t = fun x ->
    let open Living_core.Default.Let_syntax in
    let* new_type_ptr = gc_alloc s ~count:1 in
    let () = get_variant_to_type_constructor type_enum (coerce_ptr C.type_ptr.uninit new_type_ptr) x in
    Living_core.Default.return (coerce_ptr (ptr s) new_type_ptr)

  let ocaml_of_variant (x: C.variant_ptr structure ptr) : ocaml_t Living_core.Default.t = godot_of_variant x |> Living_core.Default.bind to_ocaml

  let godot_typ : godot_t typ = ptr s
end
    

  module type DICTIONARY = sig
    include Api_types.API_TYPE

    val to_variant : 
    t structure ptr -> C.variant_ptr structure ptr

    val of_variant : 
    C.variant_ptr structure ptr-> t structure ptr
    end
  
module Dictionary = struct
  include Dictionary
  include Conv.Dictionary

  let godot_to_variant (x:godot_t) : C.variant_ptr structure ptr Living_core.Default.t = 
    let open Living_core.Default.Let_syntax in
    let* new_variant_ptr = Living_core.Default.map (coerce_ptr C.variant_ptr.uninit) (gc_alloc Variant.s ~count:1) in
    let () = get_variant_from_type_constructor type_enum new_variant_ptr (coerce_ptr C.type_ptr.plain x) in
    let inited_variant_ptr = coerce_ptr C.variant_ptr.plain new_variant_ptr in
    Living_core.Default.return inited_variant_ptr

  let ocaml_to_variant : ocaml_t -> C.variant_ptr structure ptr Living_core.Default.t = fun x ->
    of_ocaml x |> Living_core.Default.bind godot_to_variant

  let godot_of_variant : C.variant_ptr structure ptr -> godot_t Living_core.Default.t = fun x ->
    let open Living_core.Default.Let_syntax in
    let* new_type_ptr = gc_alloc s ~count:1 in
    let () = get_variant_to_type_constructor type_enum (coerce_ptr C.type_ptr.uninit new_type_ptr) x in
    Living_core.Default.return (coerce_ptr (ptr s) new_type_ptr)

  let ocaml_of_variant (x: C.variant_ptr structure ptr) : ocaml_t Living_core.Default.t = godot_of_variant x |> Living_core.Default.bind to_ocaml

  let godot_typ : godot_t typ = ptr s
end
    

  module type ARRAY = sig
    include Api_types.API_TYPE

    val to_variant : 
    t structure ptr -> C.variant_ptr structure ptr

    val of_variant : 
    C.variant_ptr structure ptr-> t structure ptr
    end
  
module Array = struct
  include Array
  include Conv.Array

  let godot_to_variant (x:godot_t) : C.variant_ptr structure ptr Living_core.Default.t = 
    let open Living_core.Default.Let_syntax in
    let* new_variant_ptr = Living_core.Default.map (coerce_ptr C.variant_ptr.uninit) (gc_alloc Variant.s ~count:1) in
    let () = get_variant_from_type_constructor type_enum new_variant_ptr (coerce_ptr C.type_ptr.plain x) in
    let inited_variant_ptr = coerce_ptr C.variant_ptr.plain new_variant_ptr in
    Living_core.Default.return inited_variant_ptr

  let ocaml_to_variant : ocaml_t -> C.variant_ptr structure ptr Living_core.Default.t = fun x ->
    of_ocaml x |> Living_core.Default.bind godot_to_variant

  let godot_of_variant : C.variant_ptr structure ptr -> godot_t Living_core.Default.t = fun x ->
    let open Living_core.Default.Let_syntax in
    let* new_type_ptr = gc_alloc s ~count:1 in
    let () = get_variant_to_type_constructor type_enum (coerce_ptr C.type_ptr.uninit new_type_ptr) x in
    Living_core.Default.return (coerce_ptr (ptr s) new_type_ptr)

  let ocaml_of_variant (x: C.variant_ptr structure ptr) : ocaml_t Living_core.Default.t = godot_of_variant x |> Living_core.Default.bind to_ocaml

  let godot_typ : godot_t typ = ptr s
end
    

  module type PACKEDBYTEARRAY = sig
    include Api_types.API_TYPE

    val to_variant : 
    t structure ptr -> C.variant_ptr structure ptr

    val of_variant : 
    C.variant_ptr structure ptr-> t structure ptr
    end
  
module PackedByteArray = struct
  include PackedByteArray
  include Conv.PackedByteArray

  let godot_to_variant (x:godot_t) : C.variant_ptr structure ptr Living_core.Default.t = 
    let open Living_core.Default.Let_syntax in
    let* new_variant_ptr = Living_core.Default.map (coerce_ptr C.variant_ptr.uninit) (gc_alloc Variant.s ~count:1) in
    let () = get_variant_from_type_constructor type_enum new_variant_ptr (coerce_ptr C.type_ptr.plain x) in
    let inited_variant_ptr = coerce_ptr C.variant_ptr.plain new_variant_ptr in
    Living_core.Default.return inited_variant_ptr

  let ocaml_to_variant : ocaml_t -> C.variant_ptr structure ptr Living_core.Default.t = fun x ->
    of_ocaml x |> Living_core.Default.bind godot_to_variant

  let godot_of_variant : C.variant_ptr structure ptr -> godot_t Living_core.Default.t = fun x ->
    let open Living_core.Default.Let_syntax in
    let* new_type_ptr = gc_alloc s ~count:1 in
    let () = get_variant_to_type_constructor type_enum (coerce_ptr C.type_ptr.uninit new_type_ptr) x in
    Living_core.Default.return (coerce_ptr (ptr s) new_type_ptr)

  let ocaml_of_variant (x: C.variant_ptr structure ptr) : ocaml_t Living_core.Default.t = godot_of_variant x |> Living_core.Default.bind to_ocaml

  let godot_typ : godot_t typ = ptr s
end
    

  module type PACKEDINT32ARRAY = sig
    include Api_types.API_TYPE

    val to_variant : 
    t structure ptr -> C.variant_ptr structure ptr

    val of_variant : 
    C.variant_ptr structure ptr-> t structure ptr
    end
  
module PackedInt32Array = struct
  include PackedInt32Array
  include Conv.PackedInt32Array

  let godot_to_variant (x:godot_t) : C.variant_ptr structure ptr Living_core.Default.t = 
    let open Living_core.Default.Let_syntax in
    let* new_variant_ptr = Living_core.Default.map (coerce_ptr C.variant_ptr.uninit) (gc_alloc Variant.s ~count:1) in
    let () = get_variant_from_type_constructor type_enum new_variant_ptr (coerce_ptr C.type_ptr.plain x) in
    let inited_variant_ptr = coerce_ptr C.variant_ptr.plain new_variant_ptr in
    Living_core.Default.return inited_variant_ptr

  let ocaml_to_variant : ocaml_t -> C.variant_ptr structure ptr Living_core.Default.t = fun x ->
    of_ocaml x |> Living_core.Default.bind godot_to_variant

  let godot_of_variant : C.variant_ptr structure ptr -> godot_t Living_core.Default.t = fun x ->
    let open Living_core.Default.Let_syntax in
    let* new_type_ptr = gc_alloc s ~count:1 in
    let () = get_variant_to_type_constructor type_enum (coerce_ptr C.type_ptr.uninit new_type_ptr) x in
    Living_core.Default.return (coerce_ptr (ptr s) new_type_ptr)

  let ocaml_of_variant (x: C.variant_ptr structure ptr) : ocaml_t Living_core.Default.t = godot_of_variant x |> Living_core.Default.bind to_ocaml

  let godot_typ : godot_t typ = ptr s
end
    

  module type PACKEDINT64ARRAY = sig
    include Api_types.API_TYPE

    val to_variant : 
    t structure ptr -> C.variant_ptr structure ptr

    val of_variant : 
    C.variant_ptr structure ptr-> t structure ptr
    end
  
module PackedInt64Array = struct
  include PackedInt64Array
  include Conv.PackedInt64Array

  let godot_to_variant (x:godot_t) : C.variant_ptr structure ptr Living_core.Default.t = 
    let open Living_core.Default.Let_syntax in
    let* new_variant_ptr = Living_core.Default.map (coerce_ptr C.variant_ptr.uninit) (gc_alloc Variant.s ~count:1) in
    let () = get_variant_from_type_constructor type_enum new_variant_ptr (coerce_ptr C.type_ptr.plain x) in
    let inited_variant_ptr = coerce_ptr C.variant_ptr.plain new_variant_ptr in
    Living_core.Default.return inited_variant_ptr

  let ocaml_to_variant : ocaml_t -> C.variant_ptr structure ptr Living_core.Default.t = fun x ->
    of_ocaml x |> Living_core.Default.bind godot_to_variant

  let godot_of_variant : C.variant_ptr structure ptr -> godot_t Living_core.Default.t = fun x ->
    let open Living_core.Default.Let_syntax in
    let* new_type_ptr = gc_alloc s ~count:1 in
    let () = get_variant_to_type_constructor type_enum (coerce_ptr C.type_ptr.uninit new_type_ptr) x in
    Living_core.Default.return (coerce_ptr (ptr s) new_type_ptr)

  let ocaml_of_variant (x: C.variant_ptr structure ptr) : ocaml_t Living_core.Default.t = godot_of_variant x |> Living_core.Default.bind to_ocaml

  let godot_typ : godot_t typ = ptr s
end
    

  module type PACKEDFLOAT32ARRAY = sig
    include Api_types.API_TYPE

    val to_variant : 
    t structure ptr -> C.variant_ptr structure ptr

    val of_variant : 
    C.variant_ptr structure ptr-> t structure ptr
    end
  
module PackedFloat32Array = struct
  include PackedFloat32Array
  include Conv.PackedFloat32Array

  let godot_to_variant (x:godot_t) : C.variant_ptr structure ptr Living_core.Default.t = 
    let open Living_core.Default.Let_syntax in
    let* new_variant_ptr = Living_core.Default.map (coerce_ptr C.variant_ptr.uninit) (gc_alloc Variant.s ~count:1) in
    let () = get_variant_from_type_constructor type_enum new_variant_ptr (coerce_ptr C.type_ptr.plain x) in
    let inited_variant_ptr = coerce_ptr C.variant_ptr.plain new_variant_ptr in
    Living_core.Default.return inited_variant_ptr

  let ocaml_to_variant : ocaml_t -> C.variant_ptr structure ptr Living_core.Default.t = fun x ->
    of_ocaml x |> Living_core.Default.bind godot_to_variant

  let godot_of_variant : C.variant_ptr structure ptr -> godot_t Living_core.Default.t = fun x ->
    let open Living_core.Default.Let_syntax in
    let* new_type_ptr = gc_alloc s ~count:1 in
    let () = get_variant_to_type_constructor type_enum (coerce_ptr C.type_ptr.uninit new_type_ptr) x in
    Living_core.Default.return (coerce_ptr (ptr s) new_type_ptr)

  let ocaml_of_variant (x: C.variant_ptr structure ptr) : ocaml_t Living_core.Default.t = godot_of_variant x |> Living_core.Default.bind to_ocaml

  let godot_typ : godot_t typ = ptr s
end
    

  module type PACKEDFLOAT64ARRAY = sig
    include Api_types.API_TYPE

    val to_variant : 
    t structure ptr -> C.variant_ptr structure ptr

    val of_variant : 
    C.variant_ptr structure ptr-> t structure ptr
    end
  
module PackedFloat64Array = struct
  include PackedFloat64Array
  include Conv.PackedFloat64Array

  let godot_to_variant (x:godot_t) : C.variant_ptr structure ptr Living_core.Default.t = 
    let open Living_core.Default.Let_syntax in
    let* new_variant_ptr = Living_core.Default.map (coerce_ptr C.variant_ptr.uninit) (gc_alloc Variant.s ~count:1) in
    let () = get_variant_from_type_constructor type_enum new_variant_ptr (coerce_ptr C.type_ptr.plain x) in
    let inited_variant_ptr = coerce_ptr C.variant_ptr.plain new_variant_ptr in
    Living_core.Default.return inited_variant_ptr

  let ocaml_to_variant : ocaml_t -> C.variant_ptr structure ptr Living_core.Default.t = fun x ->
    of_ocaml x |> Living_core.Default.bind godot_to_variant

  let godot_of_variant : C.variant_ptr structure ptr -> godot_t Living_core.Default.t = fun x ->
    let open Living_core.Default.Let_syntax in
    let* new_type_ptr = gc_alloc s ~count:1 in
    let () = get_variant_to_type_constructor type_enum (coerce_ptr C.type_ptr.uninit new_type_ptr) x in
    Living_core.Default.return (coerce_ptr (ptr s) new_type_ptr)

  let ocaml_of_variant (x: C.variant_ptr structure ptr) : ocaml_t Living_core.Default.t = godot_of_variant x |> Living_core.Default.bind to_ocaml

  let godot_typ : godot_t typ = ptr s
end
    

  module type PACKEDSTRINGARRAY = sig
    include Api_types.API_TYPE

    val to_variant : 
    t structure ptr -> C.variant_ptr structure ptr

    val of_variant : 
    C.variant_ptr structure ptr-> t structure ptr
    end
  
module PackedStringArray = struct
  include PackedStringArray
  include Conv.PackedStringArray

  let godot_to_variant (x:godot_t) : C.variant_ptr structure ptr Living_core.Default.t = 
    let open Living_core.Default.Let_syntax in
    let* new_variant_ptr = Living_core.Default.map (coerce_ptr C.variant_ptr.uninit) (gc_alloc Variant.s ~count:1) in
    let () = get_variant_from_type_constructor type_enum new_variant_ptr (coerce_ptr C.type_ptr.plain x) in
    let inited_variant_ptr = coerce_ptr C.variant_ptr.plain new_variant_ptr in
    Living_core.Default.return inited_variant_ptr

  let ocaml_to_variant : ocaml_t -> C.variant_ptr structure ptr Living_core.Default.t = fun x ->
    of_ocaml x |> Living_core.Default.bind godot_to_variant

  let godot_of_variant : C.variant_ptr structure ptr -> godot_t Living_core.Default.t = fun x ->
    let open Living_core.Default.Let_syntax in
    let* new_type_ptr = gc_alloc s ~count:1 in
    let () = get_variant_to_type_constructor type_enum (coerce_ptr C.type_ptr.uninit new_type_ptr) x in
    Living_core.Default.return (coerce_ptr (ptr s) new_type_ptr)

  let ocaml_of_variant (x: C.variant_ptr structure ptr) : ocaml_t Living_core.Default.t = godot_of_variant x |> Living_core.Default.bind to_ocaml

  let godot_typ : godot_t typ = ptr s
end
    

  module type PACKEDVECTOR2ARRAY = sig
    include Api_types.API_TYPE

    val to_variant : 
    t structure ptr -> C.variant_ptr structure ptr

    val of_variant : 
    C.variant_ptr structure ptr-> t structure ptr
    end
  
module PackedVector2Array = struct
  include PackedVector2Array
  include Conv.PackedVector2Array

  let godot_to_variant (x:godot_t) : C.variant_ptr structure ptr Living_core.Default.t = 
    let open Living_core.Default.Let_syntax in
    let* new_variant_ptr = Living_core.Default.map (coerce_ptr C.variant_ptr.uninit) (gc_alloc Variant.s ~count:1) in
    let () = get_variant_from_type_constructor type_enum new_variant_ptr (coerce_ptr C.type_ptr.plain x) in
    let inited_variant_ptr = coerce_ptr C.variant_ptr.plain new_variant_ptr in
    Living_core.Default.return inited_variant_ptr

  let ocaml_to_variant : ocaml_t -> C.variant_ptr structure ptr Living_core.Default.t = fun x ->
    of_ocaml x |> Living_core.Default.bind godot_to_variant

  let godot_of_variant : C.variant_ptr structure ptr -> godot_t Living_core.Default.t = fun x ->
    let open Living_core.Default.Let_syntax in
    let* new_type_ptr = gc_alloc s ~count:1 in
    let () = get_variant_to_type_constructor type_enum (coerce_ptr C.type_ptr.uninit new_type_ptr) x in
    Living_core.Default.return (coerce_ptr (ptr s) new_type_ptr)

  let ocaml_of_variant (x: C.variant_ptr structure ptr) : ocaml_t Living_core.Default.t = godot_of_variant x |> Living_core.Default.bind to_ocaml

  let godot_typ : godot_t typ = ptr s
end
    

  module type PACKEDVECTOR3ARRAY = sig
    include Api_types.API_TYPE

    val to_variant : 
    t structure ptr -> C.variant_ptr structure ptr

    val of_variant : 
    C.variant_ptr structure ptr-> t structure ptr
    end
  
module PackedVector3Array = struct
  include PackedVector3Array
  include Conv.PackedVector3Array

  let godot_to_variant (x:godot_t) : C.variant_ptr structure ptr Living_core.Default.t = 
    let open Living_core.Default.Let_syntax in
    let* new_variant_ptr = Living_core.Default.map (coerce_ptr C.variant_ptr.uninit) (gc_alloc Variant.s ~count:1) in
    let () = get_variant_from_type_constructor type_enum new_variant_ptr (coerce_ptr C.type_ptr.plain x) in
    let inited_variant_ptr = coerce_ptr C.variant_ptr.plain new_variant_ptr in
    Living_core.Default.return inited_variant_ptr

  let ocaml_to_variant : ocaml_t -> C.variant_ptr structure ptr Living_core.Default.t = fun x ->
    of_ocaml x |> Living_core.Default.bind godot_to_variant

  let godot_of_variant : C.variant_ptr structure ptr -> godot_t Living_core.Default.t = fun x ->
    let open Living_core.Default.Let_syntax in
    let* new_type_ptr = gc_alloc s ~count:1 in
    let () = get_variant_to_type_constructor type_enum (coerce_ptr C.type_ptr.uninit new_type_ptr) x in
    Living_core.Default.return (coerce_ptr (ptr s) new_type_ptr)

  let ocaml_of_variant (x: C.variant_ptr structure ptr) : ocaml_t Living_core.Default.t = godot_of_variant x |> Living_core.Default.bind to_ocaml

  let godot_typ : godot_t typ = ptr s
end
    

  module type PACKEDCOLORARRAY = sig
    include Api_types.API_TYPE

    val to_variant : 
    t structure ptr -> C.variant_ptr structure ptr

    val of_variant : 
    C.variant_ptr structure ptr-> t structure ptr
    end
  
module PackedColorArray = struct
  include PackedColorArray
  include Conv.PackedColorArray

  let godot_to_variant (x:godot_t) : C.variant_ptr structure ptr Living_core.Default.t = 
    let open Living_core.Default.Let_syntax in
    let* new_variant_ptr = Living_core.Default.map (coerce_ptr C.variant_ptr.uninit) (gc_alloc Variant.s ~count:1) in
    let () = get_variant_from_type_constructor type_enum new_variant_ptr (coerce_ptr C.type_ptr.plain x) in
    let inited_variant_ptr = coerce_ptr C.variant_ptr.plain new_variant_ptr in
    Living_core.Default.return inited_variant_ptr

  let ocaml_to_variant : ocaml_t -> C.variant_ptr structure ptr Living_core.Default.t = fun x ->
    of_ocaml x |> Living_core.Default.bind godot_to_variant

  let godot_of_variant : C.variant_ptr structure ptr -> godot_t Living_core.Default.t = fun x ->
    let open Living_core.Default.Let_syntax in
    let* new_type_ptr = gc_alloc s ~count:1 in
    let () = get_variant_to_type_constructor type_enum (coerce_ptr C.type_ptr.uninit new_type_ptr) x in
    Living_core.Default.return (coerce_ptr (ptr s) new_type_ptr)

  let ocaml_of_variant (x: C.variant_ptr structure ptr) : ocaml_t Living_core.Default.t = godot_of_variant x |> Living_core.Default.bind to_ocaml

  let godot_typ : godot_t typ = ptr s
end
    

  module type PACKEDVECTOR4ARRAY = sig
    include Api_types.API_TYPE

    val to_variant : 
    t structure ptr -> C.variant_ptr structure ptr

    val of_variant : 
    C.variant_ptr structure ptr-> t structure ptr
    end
  
module PackedVector4Array = struct
  include PackedVector4Array
  include Conv.PackedVector4Array

  let godot_to_variant (x:godot_t) : C.variant_ptr structure ptr Living_core.Default.t = 
    let open Living_core.Default.Let_syntax in
    let* new_variant_ptr = Living_core.Default.map (coerce_ptr C.variant_ptr.uninit) (gc_alloc Variant.s ~count:1) in
    let () = get_variant_from_type_constructor type_enum new_variant_ptr (coerce_ptr C.type_ptr.plain x) in
    let inited_variant_ptr = coerce_ptr C.variant_ptr.plain new_variant_ptr in
    Living_core.Default.return inited_variant_ptr

  let ocaml_to_variant : ocaml_t -> C.variant_ptr structure ptr Living_core.Default.t = fun x ->
    of_ocaml x |> Living_core.Default.bind godot_to_variant

  let godot_of_variant : C.variant_ptr structure ptr -> godot_t Living_core.Default.t = fun x ->
    let open Living_core.Default.Let_syntax in
    let* new_type_ptr = gc_alloc s ~count:1 in
    let () = get_variant_to_type_constructor type_enum (coerce_ptr C.type_ptr.uninit new_type_ptr) x in
    Living_core.Default.return (coerce_ptr (ptr s) new_type_ptr)

  let ocaml_of_variant (x: C.variant_ptr structure ptr) : ocaml_t Living_core.Default.t = godot_of_variant x |> Living_core.Default.bind to_ocaml

  let godot_typ : godot_t typ = ptr s
end
    

  module type VARIANT = sig
    include Api_types.SUB_API_TYPE

    include Conv.CONV

    val ocaml_to_variant : t structure ptr -> C.variant_ptr structure ptr

    val godot_to_variant : t structure ptr -> C.variant_ptr structure ptr

    val ocaml_of_variant : C.variant_ptr structure ptr -> t structure ptr

    val godot_of_variant : C.variant_ptr structure ptr -> t structure ptr

    val godot_typ : godot_t typ
    end
  
module Variant = struct
  include Variant

  let ocaml_to_variant : t structure ptr -> C.variant_ptr structure ptr Living_core.Default.t = fun x -> Living_core.Default.return (coerce_ptr C.variant_ptr.plain x)
  let ocaml_of_variant : C.variant_ptr structure ptr -> t structure ptr Living_core.Default.t = fun x -> Living_core.Default.return (coerce_ptr (ptr s) x)
  let godot_to_variant : t structure ptr -> C.variant_ptr structure ptr Living_core.Default.t = fun x -> Living_core.Default.return (coerce_ptr C.variant_ptr.plain x)
  let godot_of_variant : C.variant_ptr structure ptr -> t structure ptr Living_core.Default.t = fun x -> Living_core.Default.return (coerce_ptr (ptr s) x)

  let to_string (x: t structure ptr) : string Living_core.Default.t =
    let open Living_core.Default.Let_syntax in
    let variant_ptr = coerce_ptr C.variant_ptr.const x in
    let* new_string_ptr = Living_core.Default.map (coerce_ptr C.string_ptr.plain) (gc_alloc String.s ~count:1) in
    let () = variant_stringify variant_ptr new_string_ptr in
    let* inited_string_ptr = coerce_ptr (ptr String.s) new_string_ptr |> String.to_ocaml in
    Living_core.Default.named_return "Variant.to_string" inited_string_ptr
end
      
  end

module GlobalEnum0 = struct
  let to_ocaml (x: int64) = x

  let of_ocaml (x: int64) = x

  module Side = struct
    let is_bitfield = 
    false

    type t = int64

    (** Left side, usually used for \[Control\] or \[StyleBox\]-derived classes. *)
    let _SIDE_LEFT = 
    0

    (** Top side, usually used for \[Control\] or \[StyleBox\]-derived classes. *)
    let _SIDE_TOP = 
    1

    (** Right side, usually used for \[Control\] or \[StyleBox\]-derived classes. *)
    let _SIDE_RIGHT = 
    2

    (** Bottom side, usually used for \[Control\] or \[StyleBox\]-derived classes. *)
    let _SIDE_BOTTOM = 
    3
    end

  module Corner = struct
    let is_bitfield = 
    false

    type t = int64

    (** Top-left corner. *)
    let _CORNER_TOP_LEFT = 
    0

    (** Top-right corner. *)
    let _CORNER_TOP_RIGHT = 
    1

    (** Bottom-right corner. *)
    let _CORNER_BOTTOM_RIGHT = 
    2

    (** Bottom-left corner. *)
    let _CORNER_BOTTOM_LEFT = 
    3
    end

  module Orientation = struct
    let is_bitfield = 
    false

    type t = int64

    (** General vertical alignment, usually used for \[Separator\], \[ScrollBar\], \[Slider\], etc. *)
    let _VERTICAL = 
    1

    (** General horizontal alignment, usually used for \[Separator\], \[ScrollBar\], \[Slider\], etc. *)
    let _HORIZONTAL = 
    0
    end

  module ClockDirection = struct
    let is_bitfield = 
    false

    type t = int64

    (** Clockwise rotation. Used by some methods (e.g. \[method Image.rotate_90\]). *)
    let _CLOCKWISE = 
    0

    (** Counter-clockwise rotation. Used by some methods (e.g. \[method Image.rotate_90\]). *)
    let _COUNTERCLOCKWISE = 
    1
    end

  module HorizontalAlignment = struct
    let is_bitfield = 
    false

    type t = int64

    (** Horizontal left alignment, usually for text-derived classes. *)
    let _HORIZONTAL_ALIGNMENT_LEFT = 
    0

    (** Horizontal center alignment, usually for text-derived classes. *)
    let _HORIZONTAL_ALIGNMENT_CENTER = 
    1

    (** Horizontal right alignment, usually for text-derived classes. *)
    let _HORIZONTAL_ALIGNMENT_RIGHT = 
    2

    (** Expand row to fit width, usually for text-derived classes. *)
    let _HORIZONTAL_ALIGNMENT_FILL = 
    3
    end

  module VerticalAlignment = struct
    let is_bitfield = 
    false

    type t = int64

    (** Vertical top alignment, usually for text-derived classes. *)
    let _VERTICAL_ALIGNMENT_TOP = 
    0

    (** Vertical center alignment, usually for text-derived classes. *)
    let _VERTICAL_ALIGNMENT_CENTER = 
    1

    (** Vertical bottom alignment, usually for text-derived classes. *)
    let _VERTICAL_ALIGNMENT_BOTTOM = 
    2

    (** Expand rows to fit height, usually for text-derived classes. *)
    let _VERTICAL_ALIGNMENT_FILL = 
    3
    end

  module InlineAlignment = struct
    let is_bitfield = 
    false

    type t = int64

    (** Aligns the top of the inline object (e.g. image, table) to the position of the text specified by \[code\]INLINE_ALIGNMENT_TO_ * \[/code\] constant. *)
    let _INLINE_ALIGNMENT_TOP_TO = 
    0

    (** Aligns the center of the inline object (e.g. image, table) to the position of the text specified by \[code\]INLINE_ALIGNMENT_TO_ * \[/code\] constant. *)
    let _INLINE_ALIGNMENT_CENTER_TO = 
    1

    (** Aligns the baseline (user defined) of the inline object (e.g. image, table) to the position of the text specified by \[code\]INLINE_ALIGNMENT_TO_ * \[/code\] constant. *)
    let _INLINE_ALIGNMENT_BASELINE_TO = 
    3

    (** Aligns the bottom of the inline object (e.g. image, table) to the position of the text specified by \[code\]INLINE_ALIGNMENT_TO_ * \[/code\] constant. *)
    let _INLINE_ALIGNMENT_BOTTOM_TO = 
    2

    (** Aligns the position of the inline object (e.g. image, table) specified by \[code\]INLINE_ALIGNMENT_ * _TO\[/code\] constant to the top of the text. *)
    let _INLINE_ALIGNMENT_TO_TOP = 
    0

    (** Aligns the position of the inline object (e.g. image, table) specified by \[code\]INLINE_ALIGNMENT_ * _TO\[/code\] constant to the center of the text. *)
    let _INLINE_ALIGNMENT_TO_CENTER = 
    4

    (** Aligns the position of the inline object (e.g. image, table) specified by \[code\]INLINE_ALIGNMENT_ * _TO\[/code\] constant to the baseline of the text. *)
    let _INLINE_ALIGNMENT_TO_BASELINE = 
    8

    (** Aligns inline object (e.g. image, table) to the bottom of the text. *)
    let _INLINE_ALIGNMENT_TO_BOTTOM = 
    12

    (** Aligns top of the inline object (e.g. image, table) to the top of the text. Equivalent to \[code\]INLINE_ALIGNMENT_TOP_TO | INLINE_ALIGNMENT_TO_TOP\[/code\]. *)
    let _INLINE_ALIGNMENT_TOP = 
    0

    (** Aligns center of the inline object (e.g. image, table) to the center of the text. Equivalent to \[code\]INLINE_ALIGNMENT_CENTER_TO | INLINE_ALIGNMENT_TO_CENTER\[/code\]. *)
    let _INLINE_ALIGNMENT_CENTER = 
    5

    (** Aligns bottom of the inline object (e.g. image, table) to the bottom of the text. Equivalent to \[code\]INLINE_ALIGNMENT_BOTTOM_TO | INLINE_ALIGNMENT_TO_BOTTOM\[/code\]. *)
    let _INLINE_ALIGNMENT_BOTTOM = 
    14

    (** A bit mask for \[code\]INLINE_ALIGNMENT_ * _TO\[/code\] alignment constants. *)
    let _INLINE_ALIGNMENT_IMAGE_MASK = 
    3

    (** A bit mask for \[code\]INLINE_ALIGNMENT_TO_ * \[/code\] alignment constants. *)
    let _INLINE_ALIGNMENT_TEXT_MASK = 
    12
    end

  module EulerOrder = struct
    let is_bitfield = 
    false

    type t = int64

    (** Specifies that Euler angles should be in XYZ order. When composing, the order is X, Y, Z. When decomposing, the order is reversed, first Z, then Y, and X last. *)
    let _EULER_ORDER_XYZ = 
    0

    (** Specifies that Euler angles should be in XZY order. When composing, the order is X, Z, Y. When decomposing, the order is reversed, first Y, then Z, and X last. *)
    let _EULER_ORDER_XZY = 
    1

    (** Specifies that Euler angles should be in YXZ order. When composing, the order is Y, X, Z. When decomposing, the order is reversed, first Z, then X, and Y last. *)
    let _EULER_ORDER_YXZ = 
    2

    (** Specifies that Euler angles should be in YZX order. When composing, the order is Y, Z, X. When decomposing, the order is reversed, first X, then Z, and Y last. *)
    let _EULER_ORDER_YZX = 
    3

    (** Specifies that Euler angles should be in ZXY order. When composing, the order is Z, X, Y. When decomposing, the order is reversed, first Y, then X, and Z last. *)
    let _EULER_ORDER_ZXY = 
    4

    (** Specifies that Euler angles should be in ZYX order. When composing, the order is Z, Y, X. When decomposing, the order is reversed, first X, then Y, and Z last. *)
    let _EULER_ORDER_ZYX = 
    5
    end

  module Key = struct
    let is_bitfield = 
    false

    type t = int64

    (** Enum value which doesn''t correspond to any key. This is used to initialize \[enum Key\] properties with a generic state. *)
    let _KEY_NONE = 
    0

    (** Keycodes with this bit applied are non-printable. *)
    let _KEY_SPECIAL = 
    4194304

    (** Escape key. *)
    let _KEY_ESCAPE = 
    4194305

    (** Tab key. *)
    let _KEY_TAB = 
    4194306

    (** Shift + Tab key. *)
    let _KEY_BACKTAB = 
    4194307

    (** Backspace key. *)
    let _KEY_BACKSPACE = 
    4194308

    (** Return key (on the main keyboard). *)
    let _KEY_ENTER = 
    4194309

    (** Enter key on the numeric keypad. *)
    let _KEY_KP_ENTER = 
    4194310

    (** Insert key. *)
    let _KEY_INSERT = 
    4194311

    (** Delete key. *)
    let _KEY_DELETE = 
    4194312

    (** Pause key. *)
    let _KEY_PAUSE = 
    4194313

    (** Print Screen key. *)
    let _KEY_PRINT = 
    4194314

    (** System Request key. *)
    let _KEY_SYSREQ = 
    4194315

    (** Clear key. *)
    let _KEY_CLEAR = 
    4194316

    (** Home key. *)
    let _KEY_HOME = 
    4194317

    (** End key. *)
    let _KEY_END = 
    4194318

    (** Left arrow key. *)
    let _KEY_LEFT = 
    4194319

    (** Up arrow key. *)
    let _KEY_UP = 
    4194320

    (** Right arrow key. *)
    let _KEY_RIGHT = 
    4194321

    (** Down arrow key. *)
    let _KEY_DOWN = 
    4194322

    (** Page Up key. *)
    let _KEY_PAGEUP = 
    4194323

    (** Page Down key. *)
    let _KEY_PAGEDOWN = 
    4194324

    (** Shift key. *)
    let _KEY_SHIFT = 
    4194325

    (** Control key. *)
    let _KEY_CTRL = 
    4194326

    (** Meta key. *)
    let _KEY_META = 
    4194327

    (** Alt key. *)
    let _KEY_ALT = 
    4194328

    (** Caps Lock key. *)
    let _KEY_CAPSLOCK = 
    4194329

    (** Num Lock key. *)
    let _KEY_NUMLOCK = 
    4194330

    (** Scroll Lock key. *)
    let _KEY_SCROLLLOCK = 
    4194331

    (** F1 key. *)
    let _KEY_F1 = 
    4194332

    (** F2 key. *)
    let _KEY_F2 = 
    4194333

    (** F3 key. *)
    let _KEY_F3 = 
    4194334

    (** F4 key. *)
    let _KEY_F4 = 
    4194335

    (** F5 key. *)
    let _KEY_F5 = 
    4194336

    (** F6 key. *)
    let _KEY_F6 = 
    4194337

    (** F7 key. *)
    let _KEY_F7 = 
    4194338

    (** F8 key. *)
    let _KEY_F8 = 
    4194339

    (** F9 key. *)
    let _KEY_F9 = 
    4194340

    (** F10 key. *)
    let _KEY_F10 = 
    4194341

    (** F11 key. *)
    let _KEY_F11 = 
    4194342

    (** F12 key. *)
    let _KEY_F12 = 
    4194343

    (** F13 key. *)
    let _KEY_F13 = 
    4194344

    (** F14 key. *)
    let _KEY_F14 = 
    4194345

    (** F15 key. *)
    let _KEY_F15 = 
    4194346

    (** F16 key. *)
    let _KEY_F16 = 
    4194347

    (** F17 key. *)
    let _KEY_F17 = 
    4194348

    (** F18 key. *)
    let _KEY_F18 = 
    4194349

    (** F19 key. *)
    let _KEY_F19 = 
    4194350

    (** F20 key. *)
    let _KEY_F20 = 
    4194351

    (** F21 key. *)
    let _KEY_F21 = 
    4194352

    (** F22 key. *)
    let _KEY_F22 = 
    4194353

    (** F23 key. *)
    let _KEY_F23 = 
    4194354

    (** F24 key. *)
    let _KEY_F24 = 
    4194355

    (** F25 key. Only supported on macOS and Linux due to a Windows limitation. *)
    let _KEY_F25 = 
    4194356

    (** F26 key. Only supported on macOS and Linux due to a Windows limitation. *)
    let _KEY_F26 = 
    4194357

    (** F27 key. Only supported on macOS and Linux due to a Windows limitation. *)
    let _KEY_F27 = 
    4194358

    (** F28 key. Only supported on macOS and Linux due to a Windows limitation. *)
    let _KEY_F28 = 
    4194359

    (** F29 key. Only supported on macOS and Linux due to a Windows limitation. *)
    let _KEY_F29 = 
    4194360

    (** F30 key. Only supported on macOS and Linux due to a Windows limitation. *)
    let _KEY_F30 = 
    4194361

    (** F31 key. Only supported on macOS and Linux due to a Windows limitation. *)
    let _KEY_F31 = 
    4194362

    (** F32 key. Only supported on macOS and Linux due to a Windows limitation. *)
    let _KEY_F32 = 
    4194363

    (** F33 key. Only supported on macOS and Linux due to a Windows limitation. *)
    let _KEY_F33 = 
    4194364

    (** F34 key. Only supported on macOS and Linux due to a Windows limitation. *)
    let _KEY_F34 = 
    4194365

    (** F35 key. Only supported on macOS and Linux due to a Windows limitation. *)
    let _KEY_F35 = 
    4194366

    (** Multiply ( * ) key on the numeric keypad. *)
    let _KEY_KP_MULTIPLY = 
    4194433

    (** Divide (/) key on the numeric keypad. *)
    let _KEY_KP_DIVIDE = 
    4194434

    (** Subtract (-) key on the numeric keypad. *)
    let _KEY_KP_SUBTRACT = 
    4194435

    (** Period (.) key on the numeric keypad. *)
    let _KEY_KP_PERIOD = 
    4194436

    (** Add (+) key on the numeric keypad. *)
    let _KEY_KP_ADD = 
    4194437

    (** Number 0 on the numeric keypad. *)
    let _KEY_KP_0 = 
    4194438

    (** Number 1 on the numeric keypad. *)
    let _KEY_KP_1 = 
    4194439

    (** Number 2 on the numeric keypad. *)
    let _KEY_KP_2 = 
    4194440

    (** Number 3 on the numeric keypad. *)
    let _KEY_KP_3 = 
    4194441

    (** Number 4 on the numeric keypad. *)
    let _KEY_KP_4 = 
    4194442

    (** Number 5 on the numeric keypad. *)
    let _KEY_KP_5 = 
    4194443

    (** Number 6 on the numeric keypad. *)
    let _KEY_KP_6 = 
    4194444

    (** Number 7 on the numeric keypad. *)
    let _KEY_KP_7 = 
    4194445

    (** Number 8 on the numeric keypad. *)
    let _KEY_KP_8 = 
    4194446

    (** Number 9 on the numeric keypad. *)
    let _KEY_KP_9 = 
    4194447

    (** Context menu key. *)
    let _KEY_MENU = 
    4194370

    (** Hyper key. (On Linux/X11 only). *)
    let _KEY_HYPER = 
    4194371

    (** Help key. *)
    let _KEY_HELP = 
    4194373

    (** Back key. *)
    let _KEY_BACK = 
    4194376

    (** Forward key. *)
    let _KEY_FORWARD = 
    4194377

    (** Media stop key. *)
    let _KEY_STOP = 
    4194378

    (** Refresh key. *)
    let _KEY_REFRESH = 
    4194379

    (** Volume down key. *)
    let _KEY_VOLUMEDOWN = 
    4194380

    (** Mute volume key. *)
    let _KEY_VOLUMEMUTE = 
    4194381

    (** Volume up key. *)
    let _KEY_VOLUMEUP = 
    4194382

    (** Media play key. *)
    let _KEY_MEDIAPLAY = 
    4194388

    (** Media stop key. *)
    let _KEY_MEDIASTOP = 
    4194389

    (** Previous song key. *)
    let _KEY_MEDIAPREVIOUS = 
    4194390

    (** Next song key. *)
    let _KEY_MEDIANEXT = 
    4194391

    (** Media record key. *)
    let _KEY_MEDIARECORD = 
    4194392

    (** Home page key. *)
    let _KEY_HOMEPAGE = 
    4194393

    (** Favorites key. *)
    let _KEY_FAVORITES = 
    4194394

    (** Search key. *)
    let _KEY_SEARCH = 
    4194395

    (** Standby key. *)
    let _KEY_STANDBY = 
    4194396

    (** Open URL / Launch Browser key. *)
    let _KEY_OPENURL = 
    4194397

    (** Launch Mail key. *)
    let _KEY_LAUNCHMAIL = 
    4194398

    (** Launch Media key. *)
    let _KEY_LAUNCHMEDIA = 
    4194399

    (** Launch Shortcut 0 key. *)
    let _KEY_LAUNCH0 = 
    4194400

    (** Launch Shortcut 1 key. *)
    let _KEY_LAUNCH1 = 
    4194401

    (** Launch Shortcut 2 key. *)
    let _KEY_LAUNCH2 = 
    4194402

    (** Launch Shortcut 3 key. *)
    let _KEY_LAUNCH3 = 
    4194403

    (** Launch Shortcut 4 key. *)
    let _KEY_LAUNCH4 = 
    4194404

    (** Launch Shortcut 5 key. *)
    let _KEY_LAUNCH5 = 
    4194405

    (** Launch Shortcut 6 key. *)
    let _KEY_LAUNCH6 = 
    4194406

    (** Launch Shortcut 7 key. *)
    let _KEY_LAUNCH7 = 
    4194407

    (** Launch Shortcut 8 key. *)
    let _KEY_LAUNCH8 = 
    4194408

    (** Launch Shortcut 9 key. *)
    let _KEY_LAUNCH9 = 
    4194409

    (** Launch Shortcut A key. *)
    let _KEY_LAUNCHA = 
    4194410

    (** Launch Shortcut B key. *)
    let _KEY_LAUNCHB = 
    4194411

    (** Launch Shortcut C key. *)
    let _KEY_LAUNCHC = 
    4194412

    (** Launch Shortcut D key. *)
    let _KEY_LAUNCHD = 
    4194413

    (** Launch Shortcut E key. *)
    let _KEY_LAUNCHE = 
    4194414

    (** Launch Shortcut F key. *)
    let _KEY_LAUNCHF = 
    4194415

    (** ""Globe"" key on Mac / iPad keyboard. *)
    let _KEY_GLOBE = 
    4194416

    (** ""On-screen keyboard"" key on iPad keyboard. *)
    let _KEY_KEYBOARD = 
    4194417

    (**  key on Mac keyboard. *)
    let _KEY_JIS_EISU = 
    4194418

    (**  key on Mac keyboard. *)
    let _KEY_JIS_KANA = 
    4194419

    (** Unknown key. *)
    let _KEY_UNKNOWN = 
    8388607

    (** Space key. *)
    let _KEY_SPACE = 
    32

    (** Exclamation mark (\[code\]!\[/code\]) key. *)
    let _KEY_EXCLAM = 
    33

    (** Double quotation mark (\[code\]""\[/code\]) key. *)
    let _KEY_QUOTEDBL = 
    34

    (** Number sign or \[i\]hash\[/i\] (\[code\]#\[/code\]) key. *)
    let _KEY_NUMBERSIGN = 
    35

    (** Dollar sign (\[code\]$\[/code\]) key. *)
    let _KEY_DOLLAR = 
    36

    (** Percent sign (\[code\]%\[/code\]) key. *)
    let _KEY_PERCENT = 
    37

    (** Ampersand (\[code\]&\[/code\]) key. *)
    let _KEY_AMPERSAND = 
    38

    (** Apostrophe (\[code\]''\[/code\]) key. *)
    let _KEY_APOSTROPHE = 
    39

    (** Left parenthesis (\[code\](\[/code\]) key. *)
    let _KEY_PARENLEFT = 
    40

    (** Right parenthesis (\[code\])\[/code\]) key. *)
    let _KEY_PARENRIGHT = 
    41

    (** Asterisk (\[code\] * \[/code\]) key. *)
    let _KEY_ASTERISK = 
    42

    (** Plus (\[code\]+\[/code\]) key. *)
    let _KEY_PLUS = 
    43

    (** Comma (\[code\],\[/code\]) key. *)
    let _KEY_COMMA = 
    44

    (** Minus (\[code\]-\[/code\]) key. *)
    let _KEY_MINUS = 
    45

    (** Period (\[code\].\[/code\]) key. *)
    let _KEY_PERIOD = 
    46

    (** Slash (\[code\]/\[/code\]) key. *)
    let _KEY_SLASH = 
    47

    (** Number 0 key. *)
    let _KEY_0 = 
    48

    (** Number 1 key. *)
    let _KEY_1 = 
    49

    (** Number 2 key. *)
    let _KEY_2 = 
    50

    (** Number 3 key. *)
    let _KEY_3 = 
    51

    (** Number 4 key. *)
    let _KEY_4 = 
    52

    (** Number 5 key. *)
    let _KEY_5 = 
    53

    (** Number 6 key. *)
    let _KEY_6 = 
    54

    (** Number 7 key. *)
    let _KEY_7 = 
    55

    (** Number 8 key. *)
    let _KEY_8 = 
    56

    (** Number 9 key. *)
    let _KEY_9 = 
    57

    (** Colon (\[code\]:\[/code\]) key. *)
    let _KEY_COLON = 
    58

    (** Semicolon (\[code\];\[/code\]) key. *)
    let _KEY_SEMICOLON = 
    59

    (** Less-than sign (\[code\]<\[/code\]) key. *)
    let _KEY_LESS = 
    60

    (** Equal sign (\[code\]=\[/code\]) key. *)
    let _KEY_EQUAL = 
    61

    (** Greater-than sign (\[code\]>\[/code\]) key. *)
    let _KEY_GREATER = 
    62

    (** Question mark (\[code\]?\[/code\]) key. *)
    let _KEY_QUESTION = 
    63

    (** At sign (\[code\]\@\[/code\]) key. *)
    let _KEY_AT = 
    64

    (** A key. *)
    let _KEY_A = 
    65

    (** B key. *)
    let _KEY_B = 
    66

    (** C key. *)
    let _KEY_C = 
    67

    (** D key. *)
    let _KEY_D = 
    68

    (** E key. *)
    let _KEY_E = 
    69

    (** F key. *)
    let _KEY_F = 
    70

    (** G key. *)
    let _KEY_G = 
    71

    (** H key. *)
    let _KEY_H = 
    72

    (** I key. *)
    let _KEY_I = 
    73

    (** J key. *)
    let _KEY_J = 
    74

    (** K key. *)
    let _KEY_K = 
    75

    (** L key. *)
    let _KEY_L = 
    76

    (** M key. *)
    let _KEY_M = 
    77

    (** N key. *)
    let _KEY_N = 
    78

    (** O key. *)
    let _KEY_O = 
    79

    (** P key. *)
    let _KEY_P = 
    80

    (** Q key. *)
    let _KEY_Q = 
    81

    (** R key. *)
    let _KEY_R = 
    82

    (** S key. *)
    let _KEY_S = 
    83

    (** T key. *)
    let _KEY_T = 
    84

    (** U key. *)
    let _KEY_U = 
    85

    (** V key. *)
    let _KEY_V = 
    86

    (** W key. *)
    let _KEY_W = 
    87

    (** X key. *)
    let _KEY_X = 
    88

    (** Y key. *)
    let _KEY_Y = 
    89

    (** Z key. *)
    let _KEY_Z = 
    90

    (** Left bracket (\[code\]\[lb\]\[/code\]) key. *)
    let _KEY_BRACKETLEFT = 
    91

    (** Backslash (\[code\]\\[/code\]) key. *)
    let _KEY_BACKSLASH = 
    92

    (** Right bracket (\[code\]\[rb\]\[/code\]) key. *)
    let _KEY_BRACKETRIGHT = 
    93

    (** Caret (\[code\]^\[/code\]) key. *)
    let _KEY_ASCIICIRCUM = 
    94

    (** Underscore (\[code\]_\[/code\]) key. *)
    let _KEY_UNDERSCORE = 
    95

    (** Backtick (\[code\]`\[/code\]) key. *)
    let _KEY_QUOTELEFT = 
    96

    (** Left brace (\[code\]\{!\[/code\]) key. *)
    let _KEY_BRACELEFT = 
    123

    (** Vertical bar or \[i\]pipe\[/i\] (\[code\]|\[/code\]) key. *)
    let _KEY_BAR = 
    124

    (** Right brace (\[code\]\}\[/code\]) key. *)
    let _KEY_BRACERIGHT = 
    125

    (** Tilde (\[code\]~\[/code\]) key. *)
    let _KEY_ASCIITILDE = 
    126

    (** Yen symbol (\[code\]\[/code\]) key. *)
    let _KEY_YEN = 
    165

    (** Section sign (\[code\]\[/code\]) key. *)
    let _KEY_SECTION = 
    167
    end

  module KeyModifierMask = struct
    let is_bitfield = 
    true

    type t = int64

    (** Key Code mask. *)
    let _KEY_CODE_MASK = 
    8388607

    (** Modifier key mask. *)
    let _KEY_MODIFIER_MASK = 
    2130706432

    (** Automatically remapped to \[constant KEY_META\] on macOS and \[constant KEY_CTRL\] on other platforms, this mask is never set in the actual events, and should be used for key mapping only. *)
    let _KEY_MASK_CMD_OR_CTRL = 
    16777216

    (** Shift key mask. *)
    let _KEY_MASK_SHIFT = 
    33554432

    (** Alt or Option (on macOS) key mask. *)
    let _KEY_MASK_ALT = 
    67108864

    (** Command (on macOS) or Meta/Windows key mask. *)
    let _KEY_MASK_META = 
    134217728

    (** Control key mask. *)
    let _KEY_MASK_CTRL = 
    268435456

    (** Keypad key mask. *)
    let _KEY_MASK_KPAD = 
    536870912

    (** Group Switch key mask. *)
    let _KEY_MASK_GROUP_SWITCH = 
    1073741824
    end

  module KeyLocation = struct
    let is_bitfield = 
    false

    type t = int64

    (** Used for keys which only appear once, or when a comparison doesn''t need to differentiate the \[code\]LEFT\[/code\] and \[code\]RIGHT\[/code\] versions.
For example, when using \[method InputEvent.is_match\], an event which has \[constant KEY_LOCATION_UNSPECIFIED\] will match any \[enum KeyLocation\] on the passed event. *)
    let _KEY_LOCATION_UNSPECIFIED = 
    0

    (** A key which is to the left of its twin. *)
    let _KEY_LOCATION_LEFT = 
    1

    (** A key which is to the right of its twin. *)
    let _KEY_LOCATION_RIGHT = 
    2
    end

  module MouseButton = struct
    let is_bitfield = 
    false

    type t = int64

    (** Enum value which doesn''t correspond to any mouse button. This is used to initialize \[enum MouseButton\] properties with a generic state. *)
    let _MOUSE_BUTTON_NONE = 
    0

    (** Primary mouse button, usually assigned to the left button. *)
    let _MOUSE_BUTTON_LEFT = 
    1

    (** Secondary mouse button, usually assigned to the right button. *)
    let _MOUSE_BUTTON_RIGHT = 
    2

    (** Middle mouse button. *)
    let _MOUSE_BUTTON_MIDDLE = 
    3

    (** Mouse wheel scrolling up. *)
    let _MOUSE_BUTTON_WHEEL_UP = 
    4

    (** Mouse wheel scrolling down. *)
    let _MOUSE_BUTTON_WHEEL_DOWN = 
    5

    (** Mouse wheel left button (only present on some mice). *)
    let _MOUSE_BUTTON_WHEEL_LEFT = 
    6

    (** Mouse wheel right button (only present on some mice). *)
    let _MOUSE_BUTTON_WHEEL_RIGHT = 
    7

    (** Extra mouse button 1. This is sometimes present, usually to the sides of the mouse. *)
    let _MOUSE_BUTTON_XBUTTON1 = 
    8

    (** Extra mouse button 2. This is sometimes present, usually to the sides of the mouse. *)
    let _MOUSE_BUTTON_XBUTTON2 = 
    9
    end

  module MouseButtonMask = struct
    let is_bitfield = 
    true

    type t = int64

    (** Primary mouse button mask, usually for the left button. *)
    let _MOUSE_BUTTON_MASK_LEFT = 
    1

    (** Secondary mouse button mask, usually for the right button. *)
    let _MOUSE_BUTTON_MASK_RIGHT = 
    2

    (** Middle mouse button mask. *)
    let _MOUSE_BUTTON_MASK_MIDDLE = 
    4

    (** Extra mouse button 1 mask. *)
    let _MOUSE_BUTTON_MASK_MB_XBUTTON1 = 
    128

    (** Extra mouse button 2 mask. *)
    let _MOUSE_BUTTON_MASK_MB_XBUTTON2 = 
    256
    end

  module JoyButton = struct
    let is_bitfield = 
    false

    type t = int64

    (** An invalid game controller button. *)
    let _JOY_BUTTON_INVALID = 
    -1

    (** Game controller SDL button A. Corresponds to the bottom action button: Sony Cross, Xbox A, Nintendo B. *)
    let _JOY_BUTTON_A = 
    0

    (** Game controller SDL button B. Corresponds to the right action button: Sony Circle, Xbox B, Nintendo A. *)
    let _JOY_BUTTON_B = 
    1

    (** Game controller SDL button X. Corresponds to the left action button: Sony Square, Xbox X, Nintendo Y. *)
    let _JOY_BUTTON_X = 
    2

    (** Game controller SDL button Y. Corresponds to the top action button: Sony Triangle, Xbox Y, Nintendo X. *)
    let _JOY_BUTTON_Y = 
    3

    (** Game controller SDL back button. Corresponds to the Sony Select, Xbox Back, Nintendo - button. *)
    let _JOY_BUTTON_BACK = 
    4

    (** Game controller SDL guide button. Corresponds to the Sony PS, Xbox Home button. *)
    let _JOY_BUTTON_GUIDE = 
    5

    (** Game controller SDL start button. Corresponds to the Sony Options, Xbox Menu, Nintendo + button. *)
    let _JOY_BUTTON_START = 
    6

    (** Game controller SDL left stick button. Corresponds to the Sony L3, Xbox L/LS button. *)
    let _JOY_BUTTON_LEFT_STICK = 
    7

    (** Game controller SDL right stick button. Corresponds to the Sony R3, Xbox R/RS button. *)
    let _JOY_BUTTON_RIGHT_STICK = 
    8

    (** Game controller SDL left shoulder button. Corresponds to the Sony L1, Xbox LB button. *)
    let _JOY_BUTTON_LEFT_SHOULDER = 
    9

    (** Game controller SDL right shoulder button. Corresponds to the Sony R1, Xbox RB button. *)
    let _JOY_BUTTON_RIGHT_SHOULDER = 
    10

    (** Game controller D-pad up button. *)
    let _JOY_BUTTON_DPAD_UP = 
    11

    (** Game controller D-pad down button. *)
    let _JOY_BUTTON_DPAD_DOWN = 
    12

    (** Game controller D-pad left button. *)
    let _JOY_BUTTON_DPAD_LEFT = 
    13

    (** Game controller D-pad right button. *)
    let _JOY_BUTTON_DPAD_RIGHT = 
    14

    (** Game controller SDL miscellaneous button. Corresponds to Xbox share button, PS5 microphone button, Nintendo Switch capture button. *)
    let _JOY_BUTTON_MISC1 = 
    15

    (** Game controller SDL paddle 1 button. *)
    let _JOY_BUTTON_PADDLE1 = 
    16

    (** Game controller SDL paddle 2 button. *)
    let _JOY_BUTTON_PADDLE2 = 
    17

    (** Game controller SDL paddle 3 button. *)
    let _JOY_BUTTON_PADDLE3 = 
    18

    (** Game controller SDL paddle 4 button. *)
    let _JOY_BUTTON_PADDLE4 = 
    19

    (** Game controller SDL touchpad button. *)
    let _JOY_BUTTON_TOUCHPAD = 
    20

    (** The number of SDL game controller buttons. *)
    let _JOY_BUTTON_SDL_MAX = 
    21

    (** The maximum number of game controller buttons supported by the engine. The actual limit may be lower on specific platforms:
- \[b\]Android:\[/b\] Up to 36 buttons.
- \[b\]Linux:\[/b\] Up to 80 buttons.
- \[b\]Windows\[/b\] and \[b\]macOS:\[/b\] Up to 128 buttons. *)
    let _JOY_BUTTON_MAX = 
    128
    end

  module JoyAxis = struct
    let is_bitfield = 
    false

    type t = int64

    (** An invalid game controller axis. *)
    let _JOY_AXIS_INVALID = 
    -1

    (** Game controller left joystick x-axis. *)
    let _JOY_AXIS_LEFT_X = 
    0

    (** Game controller left joystick y-axis. *)
    let _JOY_AXIS_LEFT_Y = 
    1

    (** Game controller right joystick x-axis. *)
    let _JOY_AXIS_RIGHT_X = 
    2

    (** Game controller right joystick y-axis. *)
    let _JOY_AXIS_RIGHT_Y = 
    3

    (** Game controller left trigger axis. *)
    let _JOY_AXIS_TRIGGER_LEFT = 
    4

    (** Game controller right trigger axis. *)
    let _JOY_AXIS_TRIGGER_RIGHT = 
    5

    (** The number of SDL game controller axes. *)
    let _JOY_AXIS_SDL_MAX = 
    6

    (** The maximum number of game controller axes: OpenVR supports up to 5 Joysticks making a total of 10 axes. *)
    let _JOY_AXIS_MAX = 
    10
    end

  module MIDIMessage = struct
    let is_bitfield = 
    false

    type t = int64

    (** Does not correspond to any MIDI message. This is the default value of \[member InputEventMIDI.message\]. *)
    let _MIDI_MESSAGE_NONE = 
    0

    (** MIDI message sent when a note is released.
\[b\]Note:\[/b\] Not all MIDI devices send this message; some may send \[constant MIDI_MESSAGE_NOTE_ON\] with \[member InputEventMIDI.velocity\] set to \[code\]0\[/code\]. *)
    let _MIDI_MESSAGE_NOTE_OFF = 
    8

    (** MIDI message sent when a note is pressed. *)
    let _MIDI_MESSAGE_NOTE_ON = 
    9

    (** MIDI message sent to indicate a change in pressure while a note is being pressed down, also called aftertouch. *)
    let _MIDI_MESSAGE_AFTERTOUCH = 
    10

    (** MIDI message sent when a controller value changes. In a MIDI device, a controller is any input that doesn''t play notes. These may include sliders for volume, balance, and panning, as well as switches and pedals. See the \[url=https://en.wikipedia.org/wiki/General_MIDI#Controller_events\]General MIDI specification\[/url\] for a small list. *)
    let _MIDI_MESSAGE_CONTROL_CHANGE = 
    11

    (** MIDI message sent when the MIDI device changes its current instrument (also called \[i\]program\[/i\] or \[i\]preset\[/i\]). *)
    let _MIDI_MESSAGE_PROGRAM_CHANGE = 
    12

    (** MIDI message sent to indicate a change in pressure for the whole channel. Some MIDI devices may send this instead of \[constant MIDI_MESSAGE_AFTERTOUCH\]. *)
    let _MIDI_MESSAGE_CHANNEL_PRESSURE = 
    13

    (** MIDI message sent when the value of the pitch bender changes, usually a wheel on the MIDI device. *)
    let _MIDI_MESSAGE_PITCH_BEND = 
    14

    (** MIDI system exclusive (SysEx) message. This type of message is not standardized and it''s highly dependent on the MIDI device sending it.
\[b\]Note:\[/b\] Getting this message''s data from \[InputEventMIDI\] is not implemented. *)
    let _MIDI_MESSAGE_SYSTEM_EXCLUSIVE = 
    240

    (** MIDI message sent every quarter frame to keep connected MIDI devices synchronized. Related to \[constant MIDI_MESSAGE_TIMING_CLOCK\].
\[b\]Note:\[/b\] Getting this message''s data from \[InputEventMIDI\] is not implemented. *)
    let _MIDI_MESSAGE_QUARTER_FRAME = 
    241

    (** MIDI message sent to jump onto a new position in the current sequence or song.
\[b\]Note:\[/b\] Getting this message''s data from \[InputEventMIDI\] is not implemented. *)
    let _MIDI_MESSAGE_SONG_POSITION_POINTER = 
    242

    (** MIDI message sent to select a sequence or song to play.
\[b\]Note:\[/b\] Getting this message''s data from \[InputEventMIDI\] is not implemented. *)
    let _MIDI_MESSAGE_SONG_SELECT = 
    243

    (** MIDI message sent to request a tuning calibration. Used on analog synthesizers. Most modern MIDI devices do not need this message. *)
    let _MIDI_MESSAGE_TUNE_REQUEST = 
    246

    (** MIDI message sent 24 times after \[constant MIDI_MESSAGE_QUARTER_FRAME\], to keep connected MIDI devices synchronized. *)
    let _MIDI_MESSAGE_TIMING_CLOCK = 
    248

    (** MIDI message sent to start the current sequence or song from the beginning. *)
    let _MIDI_MESSAGE_START = 
    250

    (** MIDI message sent to resume from the point the current sequence or song was paused. *)
    let _MIDI_MESSAGE_CONTINUE = 
    251

    (** MIDI message sent to pause the current sequence or song. *)
    let _MIDI_MESSAGE_STOP = 
    252

    (** MIDI message sent repeatedly while the MIDI device is idle, to tell the receiver that the connection is alive. Most MIDI devices do not send this message. *)
    let _MIDI_MESSAGE_ACTIVE_SENSING = 
    254

    (** MIDI message sent to reset a MIDI device to its default state, as if it was just turned on. It should not be sent when the MIDI device is being turned on. *)
    let _MIDI_MESSAGE_SYSTEM_RESET = 
    255
    end

  module Error = struct
    let is_bitfield = 
    false

    type t = int64

    (** Methods that return \[enum Error\] return \[constant OK\] when no error occurred.
Since \[constant OK\] has value \[code\]0\[/code\], and all other error constants are positive integers, it can also be used in boolean checks.
\[codeblock\]
var error = method_that_returns_error()
if error != OK:
    printerr(""Failure!"")

# Or, alternatively:
if error:
    printerr(""Still failing!"")
\[/codeblock\]
\[b\]Note:\[/b\] Many functions do not return an error code, but will print error messages to standard output. *)
    let _OK = 
    0

    (** Generic error. *)
    let _FAILED = 
    1

    (** Unavailable error. *)
    let _ERR_UNAVAILABLE = 
    2

    (** Unconfigured error. *)
    let _ERR_UNCONFIGURED = 
    3

    (** Unauthorized error. *)
    let _ERR_UNAUTHORIZED = 
    4

    (** Parameter range error. *)
    let _ERR_PARAMETER_RANGE_ERROR = 
    5

    (** Out of memory (OOM) error. *)
    let _ERR_OUT_OF_MEMORY = 
    6

    (** File: Not found error. *)
    let _ERR_FILE_NOT_FOUND = 
    7

    (** File: Bad drive error. *)
    let _ERR_FILE_BAD_DRIVE = 
    8

    (** File: Bad path error. *)
    let _ERR_FILE_BAD_PATH = 
    9

    (** File: No permission error. *)
    let _ERR_FILE_NO_PERMISSION = 
    10

    (** File: Already in use error. *)
    let _ERR_FILE_ALREADY_IN_USE = 
    11

    (** File: Can''t open error. *)
    let _ERR_FILE_CANT_OPEN = 
    12

    (** File: Can''t write error. *)
    let _ERR_FILE_CANT_WRITE = 
    13

    (** File: Can''t read error. *)
    let _ERR_FILE_CANT_READ = 
    14

    (** File: Unrecognized error. *)
    let _ERR_FILE_UNRECOGNIZED = 
    15

    (** File: Corrupt error. *)
    let _ERR_FILE_CORRUPT = 
    16

    (** File: Missing dependencies error. *)
    let _ERR_FILE_MISSING_DEPENDENCIES = 
    17

    (** File: End of file (EOF) error. *)
    let _ERR_FILE_EOF = 
    18

    (** Can''t open error. *)
    let _ERR_CANT_OPEN = 
    19

    (** Can''t create error. *)
    let _ERR_CANT_CREATE = 
    20

    (** Query failed error. *)
    let _ERR_QUERY_FAILED = 
    21

    (** Already in use error. *)
    let _ERR_ALREADY_IN_USE = 
    22

    (** Locked error. *)
    let _ERR_LOCKED = 
    23

    (** Timeout error. *)
    let _ERR_TIMEOUT = 
    24

    (** Can''t connect error. *)
    let _ERR_CANT_CONNECT = 
    25

    (** Can''t resolve error. *)
    let _ERR_CANT_RESOLVE = 
    26

    (** Connection error. *)
    let _ERR_CONNECTION_ERROR = 
    27

    (** Can''t acquire resource error. *)
    let _ERR_CANT_ACQUIRE_RESOURCE = 
    28

    (** Can''t fork process error. *)
    let _ERR_CANT_FORK = 
    29

    (** Invalid data error. *)
    let _ERR_INVALID_DATA = 
    30

    (** Invalid parameter error. *)
    let _ERR_INVALID_PARAMETER = 
    31

    (** Already exists error. *)
    let _ERR_ALREADY_EXISTS = 
    32

    (** Does not exist error. *)
    let _ERR_DOES_NOT_EXIST = 
    33

    (** Database: Read error. *)
    let _ERR_DATABASE_CANT_READ = 
    34

    (** Database: Write error. *)
    let _ERR_DATABASE_CANT_WRITE = 
    35

    (** Compilation failed error. *)
    let _ERR_COMPILATION_FAILED = 
    36

    (** Method not found error. *)
    let _ERR_METHOD_NOT_FOUND = 
    37

    (** Linking failed error. *)
    let _ERR_LINK_FAILED = 
    38

    (** Script failed error. *)
    let _ERR_SCRIPT_FAILED = 
    39

    (** Cycling link (import cycle) error. *)
    let _ERR_CYCLIC_LINK = 
    40

    (** Invalid declaration error. *)
    let _ERR_INVALID_DECLARATION = 
    41

    (** Duplicate symbol error. *)
    let _ERR_DUPLICATE_SYMBOL = 
    42

    (** Parse error. *)
    let _ERR_PARSE_ERROR = 
    43

    (** Busy error. *)
    let _ERR_BUSY = 
    44

    (** Skip error. *)
    let _ERR_SKIP = 
    45

    (** Help error. Used internally when passing \[code\]--version\[/code\] or \[code\]--help\[/code\] as executable options. *)
    let _ERR_HELP = 
    46

    (** Bug error, caused by an implementation issue in the method.
\[b\]Note:\[/b\] If a built-in method returns this code, please open an issue on \[url=https://github.com/godotengine/godot/issues\]the GitHub Issue Tracker\[/url\]. *)
    let _ERR_BUG = 
    47

    (** Printer on fire error (This is an easter egg, no built-in methods return this error code). *)
    let _ERR_PRINTER_ON_FIRE = 
    48
    end

  module PropertyHint = struct
    let is_bitfield = 
    false

    type t = int64

    (** The property has no hint for the editor. *)
    let _PROPERTY_HINT_NONE = 
    0

    (** Hints that an \[int\] or \[float\] property should be within a range specified via the hint string \[code\]""min,max""\[/code\] or \[code\]""min,max,step""\[/code\]. The hint string can optionally include \[code\]""or_greater""\[/code\] and/or \[code\]""or_less""\[/code\] to allow manual input going respectively above the max or below the min values.
\[b\]Example:\[/b\] \[code\]""-360,360,1,or_greater,or_less""\[/code\].
Additionally, other keywords can be included: \[code\]""exp""\[/code\] for exponential range editing, \[code\]""radians_as_degrees""\[/code\] for editing radian angles in degrees (the range values are also in degrees), \[code\]""degrees""\[/code\] to hint at an angle and \[code\]""hide_slider""\[/code\] to hide the slider. *)
    let _PROPERTY_HINT_RANGE = 
    1

    (** Hints that an \[int\] or \[String\] property is an enumerated value to pick in a list specified via a hint string.
The hint string is a comma separated list of names such as \[code\]""Hello,Something,Else""\[/code\]. Whitespaces are \[b\]not\[/b\] removed from either end of a name. For integer properties, the first name in the list has value 0, the next 1, and so on. Explicit values can also be specified by appending \[code\]:integer\[/code\] to the name, e.g. \[code\]""Zero,One,Three:3,Four,Six:6""\[/code\]. *)
    let _PROPERTY_HINT_ENUM = 
    2

    (** Hints that a \[String\] property can be an enumerated value to pick in a list specified via a hint string such as \[code\]""Hello,Something,Else""\[/code\].
Unlike \[constant PROPERTY_HINT_ENUM\], a property with this hint still accepts arbitrary values and can be empty. The list of values serves to suggest possible values. *)
    let _PROPERTY_HINT_ENUM_SUGGESTION = 
    3

    (** Hints that a \[float\] property should be edited via an exponential easing function. The hint string can include \[code\]""attenuation""\[/code\] to flip the curve horizontally and/or \[code\]""positive_only""\[/code\] to exclude in/out easing and limit values to be greater than or equal to zero. *)
    let _PROPERTY_HINT_EXP_EASING = 
    4

    (** Hints that a vector property should allow its components to be linked. For example, this allows \[member Vector2.x\] and \[member Vector2.y\] to be edited together. *)
    let _PROPERTY_HINT_LINK = 
    5

    (** Hints that an \[int\] property is a bitmask with named bit flags.
The hint string is a comma separated list of names such as \[code\]""Bit0,Bit1,Bit2,Bit3""\[/code\]. Whitespaces are \[b\]not\[/b\] removed from either end of a name. The first name in the list has value 1, the next 2, then 4, 8, 16 and so on. Explicit values can also be specified by appending \[code\]:integer\[/code\] to the name, e.g. \[code\]""A:4,B:8,C:16""\[/code\]. You can also combine several flags (\[code\]""A:4,B:8,AB:12,C:16""\[/code\]).
\[b\]Note:\[/b\] A flag value must be at least \[code\]1\[/code\] and at most \[code\]2  *  *  32 - 1\[/code\].
\[b\]Note:\[/b\] Unlike \[constant PROPERTY_HINT_ENUM\], the previous explicit value is not taken into account. For the hint \[code\]""A:16,B,C""\[/code\], A is 16, B is 2, C is 4. *)
    let _PROPERTY_HINT_FLAGS = 
    6

    (** Hints that an \[int\] property is a bitmask using the optionally named 2D render layers. *)
    let _PROPERTY_HINT_LAYERS_2D_RENDER = 
    7

    (** Hints that an \[int\] property is a bitmask using the optionally named 2D physics layers. *)
    let _PROPERTY_HINT_LAYERS_2D_PHYSICS = 
    8

    (** Hints that an \[int\] property is a bitmask using the optionally named 2D navigation layers. *)
    let _PROPERTY_HINT_LAYERS_2D_NAVIGATION = 
    9

    (** Hints that an \[int\] property is a bitmask using the optionally named 3D render layers. *)
    let _PROPERTY_HINT_LAYERS_3D_RENDER = 
    10

    (** Hints that an \[int\] property is a bitmask using the optionally named 3D physics layers. *)
    let _PROPERTY_HINT_LAYERS_3D_PHYSICS = 
    11

    (** Hints that an \[int\] property is a bitmask using the optionally named 3D navigation layers. *)
    let _PROPERTY_HINT_LAYERS_3D_NAVIGATION = 
    12

    (** Hints that an integer property is a bitmask using the optionally named avoidance layers. *)
    let _PROPERTY_HINT_LAYERS_AVOIDANCE = 
    37

    (** Hints that a \[String\] property is a path to a file. Editing it will show a file dialog for picking the path. The hint string can be a set of filters with wildcards like \[code\]"" * .png, * .jpg""\[/code\]. *)
    let _PROPERTY_HINT_FILE = 
    13

    (** Hints that a \[String\] property is a path to a directory. Editing it will show a file dialog for picking the path. *)
    let _PROPERTY_HINT_DIR = 
    14

    (** Hints that a \[String\] property is an absolute path to a file outside the project folder. Editing it will show a file dialog for picking the path. The hint string can be a set of filters with wildcards, like \[code\]"" * .png, * .jpg""\[/code\]. *)
    let _PROPERTY_HINT_GLOBAL_FILE = 
    15

    (** Hints that a \[String\] property is an absolute path to a directory outside the project folder. Editing it will show a file dialog for picking the path. *)
    let _PROPERTY_HINT_GLOBAL_DIR = 
    16

    (** Hints that a property is an instance of a \[Resource\]-derived type, optionally specified via the hint string (e.g. \[code\]""Texture2D""\[/code\]). Editing it will show a popup menu of valid resource types to instantiate. *)
    let _PROPERTY_HINT_RESOURCE_TYPE = 
    17

    (** Hints that a \[String\] property is text with line breaks. Editing it will show a text input field where line breaks can be typed. *)
    let _PROPERTY_HINT_MULTILINE_TEXT = 
    18

    (** Hints that a \[String\] property is an \[Expression\]. *)
    let _PROPERTY_HINT_EXPRESSION = 
    19

    (** Hints that a \[String\] property should show a placeholder text on its input field, if empty. The hint string is the placeholder text to use. *)
    let _PROPERTY_HINT_PLACEHOLDER_TEXT = 
    20

    (** Hints that a \[Color\] property should be edited without affecting its transparency (\[member Color.a\] is not editable). *)
    let _PROPERTY_HINT_COLOR_NO_ALPHA = 
    21

    (** Hints that the property''s value is an object encoded as object ID, with its type specified in the hint string. Used by the debugger. *)
    let _PROPERTY_HINT_OBJECT_ID = 
    22

    (** If a property is \[String\], hints that the property represents a particular type (class). This allows to select a type from the create dialog. The property will store the selected type as a string.
If a property is \[Array\], hints the editor how to show elements. The \[code\]hint_string\[/code\] must encode nested types using \[code\]"":""\[/code\] and \[code\]""/""\[/code\].
\[codeblocks\]
\[gdscript\]
# Array of elem_type.
hint_string = ""%d:"" % \[elem_type\]
hint_string = ""%d/%d:%s"" % \[elem_type, elem_hint, elem_hint_string\]
# Two-dimensional array of elem_type (array of arrays of elem_type).
hint_string = ""%d:%d:"" % \[TYPE_ARRAY, elem_type\]
hint_string = ""%d:%d/%d:%s"" % \[TYPE_ARRAY, elem_type, elem_hint, elem_hint_string\]
# Three-dimensional array of elem_type (array of arrays of arrays of elem_type).
hint_string = ""%d:%d:%d:"" % \[TYPE_ARRAY, TYPE_ARRAY, elem_type\]
hint_string = ""%d:%d:%d/%d:%s"" % \[TYPE_ARRAY, TYPE_ARRAY, elem_type, elem_hint, elem_hint_string\]
\[/gdscript\]
\[csharp\]
// Array of elemType.
hintString = $""\{!elemType:D\}:"";
hintString = $""\{!elemType:\}/\{!elemHint:D\}:\{!elemHintString\}"";
// Two-dimensional array of elemType (array of arrays of elemType).
hintString = $""\{!Variant.Type.Array:D\}:\{!elemType:D\}:"";
hintString = $""\{!Variant.Type.Array:D\}:\{!elemType:D\}/\{!elemHint:D\}:\{!elemHintString\}"";
// Three-dimensional array of elemType (array of arrays of arrays of elemType).
hintString = $""\{!Variant.Type.Array:D\}:\{!Variant.Type.Array:D\}:\{!elemType:D\}:"";
hintString = $""\{!Variant.Type.Array:D\}:\{!Variant.Type.Array:D\}:\{!elemType:D\}/\{!elemHint:D\}:\{!elemHintString\}"";
\[/csharp\]
\[/codeblocks\]
\[b\]Examples:\[/b\]
\[codeblocks\]
\[gdscript\]
hint_string = ""%d:"" % \[TYPE_INT\] # Array of integers.
hint_string = ""%d/%d:1,10,1"" % \[TYPE_INT, PROPERTY_HINT_RANGE\] # Array of integers (in range from 1 to 10).
hint_string = ""%d/%d:Zero,One,Two"" % \[TYPE_INT, PROPERTY_HINT_ENUM\] # Array of integers (an enum).
hint_string = ""%d/%d:Zero,One,Three:3,Six:6"" % \[TYPE_INT, PROPERTY_HINT_ENUM\] # Array of integers (an enum).
hint_string = ""%d/%d: * .png"" % \[TYPE_STRING, PROPERTY_HINT_FILE\] # Array of strings (file paths).
hint_string = ""%d/%d:Texture2D"" % \[TYPE_OBJECT, PROPERTY_HINT_RESOURCE_TYPE\] # Array of textures.

hint_string = ""%d:%d:"" % \[TYPE_ARRAY, TYPE_FLOAT\] # Two-dimensional array of floats.
hint_string = ""%d:%d/%d:"" % \[TYPE_ARRAY, TYPE_STRING, PROPERTY_HINT_MULTILINE_TEXT\] # Two-dimensional array of multiline strings.
hint_string = ""%d:%d/%d:-1,1,0.1"" % \[TYPE_ARRAY, TYPE_FLOAT, PROPERTY_HINT_RANGE\] # Two-dimensional array of floats (in range from -1 to 1).
hint_string = ""%d:%d/%d:Texture2D"" % \[TYPE_ARRAY, TYPE_OBJECT, PROPERTY_HINT_RESOURCE_TYPE\] # Two-dimensional array of textures.
\[/gdscript\]
\[csharp\]
hintString = $""\{!Variant.Type.Int:D\}/\{!PropertyHint.Range:D\}:1,10,1""; // Array of integers (in range from 1 to 10).
hintString = $""\{!Variant.Type.Int:D\}/\{!PropertyHint.Enum:D\}:Zero,One,Two""; // Array of integers (an enum).
hintString = $""\{!Variant.Type.Int:D\}/\{!PropertyHint.Enum:D\}:Zero,One,Three:3,Six:6""; // Array of integers (an enum).
hintString = $""\{!Variant.Type.String:D\}/\{!PropertyHint.File:D\}: * .png""; // Array of strings (file paths).
hintString = $""\{!Variant.Type.Object:D\}/\{!PropertyHint.ResourceType:D\}:Texture2D""; // Array of textures.

hintString = $""\{!Variant.Type.Array:D\}:\{!Variant.Type.Float:D\}:""; // Two-dimensional array of floats.
hintString = $""\{!Variant.Type.Array:D\}:\{!Variant.Type.String:D\}/\{!PropertyHint.MultilineText:D\}:""; // Two-dimensional array of multiline strings.
hintString = $""\{!Variant.Type.Array:D\}:\{!Variant.Type.Float:D\}/\{!PropertyHint.Range:D\}:-1,1,0.1""; // Two-dimensional array of floats (in range from -1 to 1).
hintString = $""\{!Variant.Type.Array:D\}:\{!Variant.Type.Object:D\}/\{!PropertyHint.ResourceType:D\}:Texture2D""; // Two-dimensional array of textures.
\[/csharp\]
\[/codeblocks\]
\[b\]Note:\[/b\] The trailing colon is required for properly detecting built-in types. *)
    let _PROPERTY_HINT_TYPE_STRING = 
    23

    (**  *)
    let _PROPERTY_HINT_NODE_PATH_TO_EDITED_NODE = 
    24

    (** Hints that an object is too big to be sent via the debugger. *)
    let _PROPERTY_HINT_OBJECT_TOO_BIG = 
    25

    (** Hints that the hint string specifies valid node types for property of type \[NodePath\]. *)
    let _PROPERTY_HINT_NODE_PATH_VALID_TYPES = 
    26

    (** Hints that a \[String\] property is a path to a file. Editing it will show a file dialog for picking the path for the file to be saved at. The dialog has access to the project''s directory. The hint string can be a set of filters with wildcards like \[code\]"" * .png, * .jpg""\[/code\]. See also \[member FileDialog.filters\]. *)
    let _PROPERTY_HINT_SAVE_FILE = 
    27

    (** Hints that a \[String\] property is a path to a file. Editing it will show a file dialog for picking the path for the file to be saved at. The dialog has access to the entire filesystem. The hint string can be a set of filters with wildcards like \[code\]"" * .png, * .jpg""\[/code\]. See also \[member FileDialog.filters\]. *)
    let _PROPERTY_HINT_GLOBAL_SAVE_FILE = 
    28

    (**  *)
    let _PROPERTY_HINT_INT_IS_OBJECTID = 
    29

    (** Hints that an \[int\] property is a pointer. Used by GDExtension. *)
    let _PROPERTY_HINT_INT_IS_POINTER = 
    30

    (** Hints that a property is an \[Array\] with the stored type specified in the hint string. *)
    let _PROPERTY_HINT_ARRAY_TYPE = 
    31

    (** Hints that a property is a \[Dictionary\] with the stored types specified in the hint string. *)
    let _PROPERTY_HINT_DICTIONARY_TYPE = 
    38

    (** Hints that a string property is a locale code. Editing it will show a locale dialog for picking language and country. *)
    let _PROPERTY_HINT_LOCALE_ID = 
    32

    (** Hints that a dictionary property is string translation map. Dictionary keys are locale codes and, values are translated strings. *)
    let _PROPERTY_HINT_LOCALIZABLE_STRING = 
    33

    (** Hints that a property is an instance of a \[Node\]-derived type, optionally specified via the hint string (e.g. \[code\]""Node2D""\[/code\]). Editing it will show a dialog for picking a node from the scene. *)
    let _PROPERTY_HINT_NODE_TYPE = 
    34

    (** Hints that a quaternion property should disable the temporary euler editor. *)
    let _PROPERTY_HINT_HIDE_QUATERNION_EDIT = 
    35

    (** Hints that a string property is a password, and every character is replaced with the secret character. *)
    let _PROPERTY_HINT_PASSWORD = 
    36

    (** Hints that a \[Callable\] property should be displayed as a clickable button. When the button is pressed, the callable is called. The hint string specifies the button text and optionally an icon from the \[code\]""EditorIcons""\[/code\] theme type.
\[codeblock lang=text\]
""Click me!"" - A button with the text ""Click me!"" and the default ""Callable"" icon.
""Click me!,ColorRect"" - A button with the text ""Click me!"" and the ""ColorRect"" icon.
\[/codeblock\]
\[b\]Note:\[/b\] A \[Callable\] cannot be properly serialized and stored in a file, so it is recommended to use \[constant PROPERTY_USAGE_EDITOR\] instead of \[constant PROPERTY_USAGE_DEFAULT\]. *)
    let _PROPERTY_HINT_TOOL_BUTTON = 
    39

    (** Hints that a property will be changed on its own after setting, such as \[member AudioStreamPlayer.playing\] or \[member GPUParticles3D.emitting\]. *)
    let _PROPERTY_HINT_ONESHOT = 
    40

    (** Represents the size of the \[enum PropertyHint\] enum. *)
    let _PROPERTY_HINT_MAX = 
    42
    end

  module PropertyUsageFlags = struct
    let is_bitfield = 
    true

    type t = int64

    (** The property is not stored, and does not display in the editor. This is the default for non-exported properties. *)
    let _PROPERTY_USAGE_NONE = 
    0

    (** The property is serialized and saved in the scene file (default for exported properties). *)
    let _PROPERTY_USAGE_STORAGE = 
    2

    (** The property is shown in the \[EditorInspector\] (default for exported properties). *)
    let _PROPERTY_USAGE_EDITOR = 
    4

    (** The property is excluded from the class reference. *)
    let _PROPERTY_USAGE_INTERNAL = 
    8

    (** The property can be checked in the \[EditorInspector\]. *)
    let _PROPERTY_USAGE_CHECKABLE = 
    16

    (** The property is checked in the \[EditorInspector\]. *)
    let _PROPERTY_USAGE_CHECKED = 
    32

    (** Used to group properties together in the editor. See \[EditorInspector\]. *)
    let _PROPERTY_USAGE_GROUP = 
    64

    (** Used to categorize properties together in the editor. *)
    let _PROPERTY_USAGE_CATEGORY = 
    128

    (** Used to group properties together in the editor in a subgroup (under a group). See \[EditorInspector\]. *)
    let _PROPERTY_USAGE_SUBGROUP = 
    256

    (** The property is a bitfield, i.e. it contains multiple flags represented as bits. *)
    let _PROPERTY_USAGE_CLASS_IS_BITFIELD = 
    512

    (** The property does not save its state in \[PackedScene\]. *)
    let _PROPERTY_USAGE_NO_INSTANCE_STATE = 
    1024

    (** Editing the property prompts the user for restarting the editor. *)
    let _PROPERTY_USAGE_RESTART_IF_CHANGED = 
    2048

    (** The property is a script variable. \[constant PROPERTY_USAGE_SCRIPT_VARIABLE\] can be used to distinguish between exported script variables from built-in variables (which don''t have this usage flag). By default, \[constant PROPERTY_USAGE_SCRIPT_VARIABLE\] is \[b\]not\[/b\] applied to variables that are created by overriding \[method Object._get_property_list\] in a script. *)
    let _PROPERTY_USAGE_SCRIPT_VARIABLE = 
    4096

    (** The property value of type \[Object\] will be stored even if its value is \[code\]null\[/code\]. *)
    let _PROPERTY_USAGE_STORE_IF_NULL = 
    8192

    (** If this property is modified, all inspector fields will be refreshed. *)
    let _PROPERTY_USAGE_UPDATE_ALL_IF_MODIFIED = 
    16384

    (**  *)
    let _PROPERTY_USAGE_SCRIPT_DEFAULT_VALUE = 
    32768

    (** The property is a variable of enum type, i.e. it only takes named integer constants from its associated enumeration. *)
    let _PROPERTY_USAGE_CLASS_IS_ENUM = 
    65536

    (** If property has \[code\]nil\[/code\] as default value, its type will be \[Variant\]. *)
    let _PROPERTY_USAGE_NIL_IS_VARIANT = 
    131072

    (** The property is an array. *)
    let _PROPERTY_USAGE_ARRAY = 
    262144

    (** When duplicating a resource with \[method Resource.duplicate\], and this flag is set on a property of that resource, the property should always be duplicated, regardless of the \[code\]subresources\[/code\] bool parameter. *)
    let _PROPERTY_USAGE_ALWAYS_DUPLICATE = 
    524288

    (** When duplicating a resource with \[method Resource.duplicate\], and this flag is set on a property of that resource, the property should never be duplicated, regardless of the \[code\]subresources\[/code\] bool parameter. *)
    let _PROPERTY_USAGE_NEVER_DUPLICATE = 
    1048576

    (** The property is only shown in the editor if modern renderers are supported (the Compatibility rendering method is excluded). *)
    let _PROPERTY_USAGE_HIGH_END_GFX = 
    2097152

    (** The \[NodePath\] property will always be relative to the scene''s root. Mostly useful for local resources. *)
    let _PROPERTY_USAGE_NODE_PATH_FROM_SCENE_ROOT = 
    4194304

    (** Use when a resource is created on the fly, i.e. the getter will always return a different instance. \[ResourceSaver\] needs this information to properly save such resources. *)
    let _PROPERTY_USAGE_RESOURCE_NOT_PERSISTENT = 
    8388608

    (** Inserting an animation key frame of this property will automatically increment the value, allowing to easily keyframe multiple values in a row. *)
    let _PROPERTY_USAGE_KEYING_INCREMENTS = 
    16777216

    (**  *)
    let _PROPERTY_USAGE_DEFERRED_SET_RESOURCE = 
    33554432

    (** When this property is a \[Resource\] and base object is a \[Node\], a resource instance will be automatically created whenever the node is created in the editor. *)
    let _PROPERTY_USAGE_EDITOR_INSTANTIATE_OBJECT = 
    67108864

    (** The property is considered a basic setting and will appear even when advanced mode is disabled. Used for project settings. *)
    let _PROPERTY_USAGE_EDITOR_BASIC_SETTING = 
    134217728

    (** The property is read-only in the \[EditorInspector\]. *)
    let _PROPERTY_USAGE_READ_ONLY = 
    268435456

    (** An export preset property with this flag contains confidential information and is stored separately from the rest of the export preset configuration. *)
    let _PROPERTY_USAGE_SECRET = 
    536870912

    (** Default usage (storage and editor). *)
    let _PROPERTY_USAGE_DEFAULT = 
    6

    (** Default usage but without showing the property in the editor (storage). *)
    let _PROPERTY_USAGE_NO_EDITOR = 
    2
    end

  module MethodFlags = struct
    let is_bitfield = 
    true

    type t = int64

    (** Flag for a normal method. *)
    let _METHOD_FLAG_NORMAL = 
    1

    (** Flag for an editor method. *)
    let _METHOD_FLAG_EDITOR = 
    2

    (** Flag for a constant method. *)
    let _METHOD_FLAG_CONST = 
    4

    (** Flag for a virtual method. *)
    let _METHOD_FLAG_VIRTUAL = 
    8

    (** Flag for a method with a variable number of arguments. *)
    let _METHOD_FLAG_VARARG = 
    16

    (** Flag for a static method. *)
    let _METHOD_FLAG_STATIC = 
    32

    (** Used internally. Allows to not dump core virtual methods (such as \[method Object._notification\]) to the JSON API. *)
    let _METHOD_FLAG_OBJECT_CORE = 
    64

    (** Flag for a virtual method that is required. *)
    let _METHOD_FLAG_VIRTUAL_REQUIRED = 
    128

    (** Default method flags (normal). *)
    let _METHOD_FLAGS_DEFAULT = 
    1
    end

  module VariantType = struct
    let is_bitfield = 
    false

    type t = int64

    (** Variable is \[code\]null\[/code\]. *)
    let _TYPE_NIL = 
    0

    (** Variable is of type \[bool\]. *)
    let _TYPE_BOOL = 
    1

    (** Variable is of type \[int\]. *)
    let _TYPE_INT = 
    2

    (** Variable is of type \[float\]. *)
    let _TYPE_FLOAT = 
    3

    (** Variable is of type \[String\]. *)
    let _TYPE_STRING = 
    4

    (** Variable is of type \[Vector2\]. *)
    let _TYPE_VECTOR2 = 
    5

    (** Variable is of type \[Vector2i\]. *)
    let _TYPE_VECTOR2I = 
    6

    (** Variable is of type \[Rect2\]. *)
    let _TYPE_RECT2 = 
    7

    (** Variable is of type \[Rect2i\]. *)
    let _TYPE_RECT2I = 
    8

    (** Variable is of type \[Vector3\]. *)
    let _TYPE_VECTOR3 = 
    9

    (** Variable is of type \[Vector3i\]. *)
    let _TYPE_VECTOR3I = 
    10

    (** Variable is of type \[Transform2D\]. *)
    let _TYPE_TRANSFORM2D = 
    11

    (** Variable is of type \[Vector4\]. *)
    let _TYPE_VECTOR4 = 
    12

    (** Variable is of type \[Vector4i\]. *)
    let _TYPE_VECTOR4I = 
    13

    (** Variable is of type \[Plane\]. *)
    let _TYPE_PLANE = 
    14

    (** Variable is of type \[Quaternion\]. *)
    let _TYPE_QUATERNION = 
    15

    (** Variable is of type \[AABB\]. *)
    let _TYPE_AABB = 
    16

    (** Variable is of type \[Basis\]. *)
    let _TYPE_BASIS = 
    17

    (** Variable is of type \[Transform3D\]. *)
    let _TYPE_TRANSFORM3D = 
    18

    (** Variable is of type \[Projection\]. *)
    let _TYPE_PROJECTION = 
    19

    (** Variable is of type \[Color\]. *)
    let _TYPE_COLOR = 
    20

    (** Variable is of type \[StringName\]. *)
    let _TYPE_STRING_NAME = 
    21

    (** Variable is of type \[NodePath\]. *)
    let _TYPE_NODE_PATH = 
    22

    (** Variable is of type \[RID\]. *)
    let _TYPE_RID = 
    23

    (** Variable is of type \[Object\]. *)
    let _TYPE_OBJECT = 
    24

    (** Variable is of type \[Callable\]. *)
    let _TYPE_CALLABLE = 
    25

    (** Variable is of type \[Signal\]. *)
    let _TYPE_SIGNAL = 
    26

    (** Variable is of type \[Dictionary\]. *)
    let _TYPE_DICTIONARY = 
    27

    (** Variable is of type \[Array\]. *)
    let _TYPE_ARRAY = 
    28

    (** Variable is of type \[PackedByteArray\]. *)
    let _TYPE_PACKED_BYTE_ARRAY = 
    29

    (** Variable is of type \[PackedInt32Array\]. *)
    let _TYPE_PACKED_INT32_ARRAY = 
    30

    (** Variable is of type \[PackedInt64Array\]. *)
    let _TYPE_PACKED_INT64_ARRAY = 
    31

    (** Variable is of type \[PackedFloat32Array\]. *)
    let _TYPE_PACKED_FLOAT32_ARRAY = 
    32

    (** Variable is of type \[PackedFloat64Array\]. *)
    let _TYPE_PACKED_FLOAT64_ARRAY = 
    33

    (** Variable is of type \[PackedStringArray\]. *)
    let _TYPE_PACKED_STRING_ARRAY = 
    34

    (** Variable is of type \[PackedVector2Array\]. *)
    let _TYPE_PACKED_VECTOR2_ARRAY = 
    35

    (** Variable is of type \[PackedVector3Array\]. *)
    let _TYPE_PACKED_VECTOR3_ARRAY = 
    36

    (** Variable is of type \[PackedColorArray\]. *)
    let _TYPE_PACKED_COLOR_ARRAY = 
    37

    (** Variable is of type \[PackedVector4Array\]. *)
    let _TYPE_PACKED_VECTOR4_ARRAY = 
    38

    (** Represents the size of the \[enum Variant.Type\] enum. *)
    let _TYPE_MAX = 
    39
    end

  module VariantOperator = struct
    let is_bitfield = 
    false

    type t = int64

    (** Equality operator (\[code\]==\[/code\]). *)
    let _OP_EQUAL = 
    0

    (** Inequality operator (\[code\]!=\[/code\]). *)
    let _OP_NOT_EQUAL = 
    1

    (** Less than operator (\[code\]<\[/code\]). *)
    let _OP_LESS = 
    2

    (** Less than or equal operator (\[code\]<=\[/code\]). *)
    let _OP_LESS_EQUAL = 
    3

    (** Greater than operator (\[code\]>\[/code\]). *)
    let _OP_GREATER = 
    4

    (** Greater than or equal operator (\[code\]>=\[/code\]). *)
    let _OP_GREATER_EQUAL = 
    5

    (** Addition operator (\[code\]+\[/code\]). *)
    let _OP_ADD = 
    6

    (** Subtraction operator (\[code\]-\[/code\]). *)
    let _OP_SUBTRACT = 
    7

    (** Multiplication operator (\[code\] * \[/code\]). *)
    let _OP_MULTIPLY = 
    8

    (** Division operator (\[code\]/\[/code\]). *)
    let _OP_DIVIDE = 
    9

    (** Unary negation operator (\[code\]-\[/code\]). *)
    let _OP_NEGATE = 
    10

    (** Unary plus operator (\[code\]+\[/code\]). *)
    let _OP_POSITIVE = 
    11

    (** Remainder/modulo operator (\[code\]%\[/code\]). *)
    let _OP_MODULE = 
    12

    (** Power operator (\[code\] *  * \[/code\]). *)
    let _OP_POWER = 
    13

    (** Left shift operator (\[code\]<<\[/code\]). *)
    let _OP_SHIFT_LEFT = 
    14

    (** Right shift operator (\[code\]>>\[/code\]). *)
    let _OP_SHIFT_RIGHT = 
    15

    (** Bitwise AND operator (\[code\]&\[/code\]). *)
    let _OP_BIT_AND = 
    16

    (** Bitwise OR operator (\[code\]|\[/code\]). *)
    let _OP_BIT_OR = 
    17

    (** Bitwise XOR operator (\[code\]^\[/code\]). *)
    let _OP_BIT_XOR = 
    18

    (** Bitwise NOT operator (\[code\]~\[/code\]). *)
    let _OP_BIT_NEGATE = 
    19

    (** Logical AND operator (\[code\]and\[/code\] or \[code\]&&\[/code\]). *)
    let _OP_AND = 
    20

    (** Logical OR operator (\[code\]or\[/code\] or \[code\]||\[/code\]). *)
    let _OP_OR = 
    21

    (** Logical XOR operator (not implemented in GDScript). *)
    let _OP_XOR = 
    22

    (** Logical NOT operator (\[code\]not\[/code\] or \[code\]!\[/code\]). *)
    let _OP_NOT = 
    23

    (** Logical IN operator (\[code\]in\[/code\]). *)
    let _OP_IN = 
    24

    (** Represents the size of the \[enum Variant.Operator\] enum. *)
    let _OP_MAX = 
    25
    end
  end

module GlobalEnum = struct
  
module Side = struct
  include GlobalEnum0.Side

  let godot_to_variant = ApiTypes.Int.godot_to_variant
  let ocaml_to_variant = ApiTypes.Int.ocaml_to_variant
  let godot_of_variant = ApiTypes.Int.godot_of_variant
  let ocaml_of_variant = ApiTypes.Int.ocaml_of_variant
  let to_ocaml = ApiTypes.Int.to_ocaml
  let of_ocaml = ApiTypes.Int.of_ocaml

  type t = ApiTypes.Int.t structure ptr
  let s = ApiTypes.Int.s
  let typ = ApiTypes.Int.typ
end
      

  
module Corner = struct
  include GlobalEnum0.Corner

  let godot_to_variant = ApiTypes.Int.godot_to_variant
  let ocaml_to_variant = ApiTypes.Int.ocaml_to_variant
  let godot_of_variant = ApiTypes.Int.godot_of_variant
  let ocaml_of_variant = ApiTypes.Int.ocaml_of_variant
  let to_ocaml = ApiTypes.Int.to_ocaml
  let of_ocaml = ApiTypes.Int.of_ocaml

  type t = ApiTypes.Int.t structure ptr
  let s = ApiTypes.Int.s
  let typ = ApiTypes.Int.typ
end
      

  
module Orientation = struct
  include GlobalEnum0.Orientation

  let godot_to_variant = ApiTypes.Int.godot_to_variant
  let ocaml_to_variant = ApiTypes.Int.ocaml_to_variant
  let godot_of_variant = ApiTypes.Int.godot_of_variant
  let ocaml_of_variant = ApiTypes.Int.ocaml_of_variant
  let to_ocaml = ApiTypes.Int.to_ocaml
  let of_ocaml = ApiTypes.Int.of_ocaml

  type t = ApiTypes.Int.t structure ptr
  let s = ApiTypes.Int.s
  let typ = ApiTypes.Int.typ
end
      

  
module ClockDirection = struct
  include GlobalEnum0.ClockDirection

  let godot_to_variant = ApiTypes.Int.godot_to_variant
  let ocaml_to_variant = ApiTypes.Int.ocaml_to_variant
  let godot_of_variant = ApiTypes.Int.godot_of_variant
  let ocaml_of_variant = ApiTypes.Int.ocaml_of_variant
  let to_ocaml = ApiTypes.Int.to_ocaml
  let of_ocaml = ApiTypes.Int.of_ocaml

  type t = ApiTypes.Int.t structure ptr
  let s = ApiTypes.Int.s
  let typ = ApiTypes.Int.typ
end
      

  
module HorizontalAlignment = struct
  include GlobalEnum0.HorizontalAlignment

  let godot_to_variant = ApiTypes.Int.godot_to_variant
  let ocaml_to_variant = ApiTypes.Int.ocaml_to_variant
  let godot_of_variant = ApiTypes.Int.godot_of_variant
  let ocaml_of_variant = ApiTypes.Int.ocaml_of_variant
  let to_ocaml = ApiTypes.Int.to_ocaml
  let of_ocaml = ApiTypes.Int.of_ocaml

  type t = ApiTypes.Int.t structure ptr
  let s = ApiTypes.Int.s
  let typ = ApiTypes.Int.typ
end
      

  
module VerticalAlignment = struct
  include GlobalEnum0.VerticalAlignment

  let godot_to_variant = ApiTypes.Int.godot_to_variant
  let ocaml_to_variant = ApiTypes.Int.ocaml_to_variant
  let godot_of_variant = ApiTypes.Int.godot_of_variant
  let ocaml_of_variant = ApiTypes.Int.ocaml_of_variant
  let to_ocaml = ApiTypes.Int.to_ocaml
  let of_ocaml = ApiTypes.Int.of_ocaml

  type t = ApiTypes.Int.t structure ptr
  let s = ApiTypes.Int.s
  let typ = ApiTypes.Int.typ
end
      

  
module InlineAlignment = struct
  include GlobalEnum0.InlineAlignment

  let godot_to_variant = ApiTypes.Int.godot_to_variant
  let ocaml_to_variant = ApiTypes.Int.ocaml_to_variant
  let godot_of_variant = ApiTypes.Int.godot_of_variant
  let ocaml_of_variant = ApiTypes.Int.ocaml_of_variant
  let to_ocaml = ApiTypes.Int.to_ocaml
  let of_ocaml = ApiTypes.Int.of_ocaml

  type t = ApiTypes.Int.t structure ptr
  let s = ApiTypes.Int.s
  let typ = ApiTypes.Int.typ
end
      

  
module EulerOrder = struct
  include GlobalEnum0.EulerOrder

  let godot_to_variant = ApiTypes.Int.godot_to_variant
  let ocaml_to_variant = ApiTypes.Int.ocaml_to_variant
  let godot_of_variant = ApiTypes.Int.godot_of_variant
  let ocaml_of_variant = ApiTypes.Int.ocaml_of_variant
  let to_ocaml = ApiTypes.Int.to_ocaml
  let of_ocaml = ApiTypes.Int.of_ocaml

  type t = ApiTypes.Int.t structure ptr
  let s = ApiTypes.Int.s
  let typ = ApiTypes.Int.typ
end
      

  
module Key = struct
  include GlobalEnum0.Key

  let godot_to_variant = ApiTypes.Int.godot_to_variant
  let ocaml_to_variant = ApiTypes.Int.ocaml_to_variant
  let godot_of_variant = ApiTypes.Int.godot_of_variant
  let ocaml_of_variant = ApiTypes.Int.ocaml_of_variant
  let to_ocaml = ApiTypes.Int.to_ocaml
  let of_ocaml = ApiTypes.Int.of_ocaml

  type t = ApiTypes.Int.t structure ptr
  let s = ApiTypes.Int.s
  let typ = ApiTypes.Int.typ
end
      

  
module KeyModifierMask = struct
  include GlobalEnum0.KeyModifierMask

  let godot_to_variant = ApiTypes.Int.godot_to_variant
  let ocaml_to_variant = ApiTypes.Int.ocaml_to_variant
  let godot_of_variant = ApiTypes.Int.godot_of_variant
  let ocaml_of_variant = ApiTypes.Int.ocaml_of_variant
  let to_ocaml = ApiTypes.Int.to_ocaml
  let of_ocaml = ApiTypes.Int.of_ocaml

  type t = ApiTypes.Int.t structure ptr
  let s = ApiTypes.Int.s
  let typ = ApiTypes.Int.typ
end
      

  
module KeyLocation = struct
  include GlobalEnum0.KeyLocation

  let godot_to_variant = ApiTypes.Int.godot_to_variant
  let ocaml_to_variant = ApiTypes.Int.ocaml_to_variant
  let godot_of_variant = ApiTypes.Int.godot_of_variant
  let ocaml_of_variant = ApiTypes.Int.ocaml_of_variant
  let to_ocaml = ApiTypes.Int.to_ocaml
  let of_ocaml = ApiTypes.Int.of_ocaml

  type t = ApiTypes.Int.t structure ptr
  let s = ApiTypes.Int.s
  let typ = ApiTypes.Int.typ
end
      

  
module MouseButton = struct
  include GlobalEnum0.MouseButton

  let godot_to_variant = ApiTypes.Int.godot_to_variant
  let ocaml_to_variant = ApiTypes.Int.ocaml_to_variant
  let godot_of_variant = ApiTypes.Int.godot_of_variant
  let ocaml_of_variant = ApiTypes.Int.ocaml_of_variant
  let to_ocaml = ApiTypes.Int.to_ocaml
  let of_ocaml = ApiTypes.Int.of_ocaml

  type t = ApiTypes.Int.t structure ptr
  let s = ApiTypes.Int.s
  let typ = ApiTypes.Int.typ
end
      

  
module MouseButtonMask = struct
  include GlobalEnum0.MouseButtonMask

  let godot_to_variant = ApiTypes.Int.godot_to_variant
  let ocaml_to_variant = ApiTypes.Int.ocaml_to_variant
  let godot_of_variant = ApiTypes.Int.godot_of_variant
  let ocaml_of_variant = ApiTypes.Int.ocaml_of_variant
  let to_ocaml = ApiTypes.Int.to_ocaml
  let of_ocaml = ApiTypes.Int.of_ocaml

  type t = ApiTypes.Int.t structure ptr
  let s = ApiTypes.Int.s
  let typ = ApiTypes.Int.typ
end
      

  
module JoyButton = struct
  include GlobalEnum0.JoyButton

  let godot_to_variant = ApiTypes.Int.godot_to_variant
  let ocaml_to_variant = ApiTypes.Int.ocaml_to_variant
  let godot_of_variant = ApiTypes.Int.godot_of_variant
  let ocaml_of_variant = ApiTypes.Int.ocaml_of_variant
  let to_ocaml = ApiTypes.Int.to_ocaml
  let of_ocaml = ApiTypes.Int.of_ocaml

  type t = ApiTypes.Int.t structure ptr
  let s = ApiTypes.Int.s
  let typ = ApiTypes.Int.typ
end
      

  
module JoyAxis = struct
  include GlobalEnum0.JoyAxis

  let godot_to_variant = ApiTypes.Int.godot_to_variant
  let ocaml_to_variant = ApiTypes.Int.ocaml_to_variant
  let godot_of_variant = ApiTypes.Int.godot_of_variant
  let ocaml_of_variant = ApiTypes.Int.ocaml_of_variant
  let to_ocaml = ApiTypes.Int.to_ocaml
  let of_ocaml = ApiTypes.Int.of_ocaml

  type t = ApiTypes.Int.t structure ptr
  let s = ApiTypes.Int.s
  let typ = ApiTypes.Int.typ
end
      

  
module MIDIMessage = struct
  include GlobalEnum0.MIDIMessage

  let godot_to_variant = ApiTypes.Int.godot_to_variant
  let ocaml_to_variant = ApiTypes.Int.ocaml_to_variant
  let godot_of_variant = ApiTypes.Int.godot_of_variant
  let ocaml_of_variant = ApiTypes.Int.ocaml_of_variant
  let to_ocaml = ApiTypes.Int.to_ocaml
  let of_ocaml = ApiTypes.Int.of_ocaml

  type t = ApiTypes.Int.t structure ptr
  let s = ApiTypes.Int.s
  let typ = ApiTypes.Int.typ
end
      

  
module Error = struct
  include GlobalEnum0.Error

  let godot_to_variant = ApiTypes.Int.godot_to_variant
  let ocaml_to_variant = ApiTypes.Int.ocaml_to_variant
  let godot_of_variant = ApiTypes.Int.godot_of_variant
  let ocaml_of_variant = ApiTypes.Int.ocaml_of_variant
  let to_ocaml = ApiTypes.Int.to_ocaml
  let of_ocaml = ApiTypes.Int.of_ocaml

  type t = ApiTypes.Int.t structure ptr
  let s = ApiTypes.Int.s
  let typ = ApiTypes.Int.typ
end
      

  
module PropertyHint = struct
  include GlobalEnum0.PropertyHint

  let godot_to_variant = ApiTypes.Int.godot_to_variant
  let ocaml_to_variant = ApiTypes.Int.ocaml_to_variant
  let godot_of_variant = ApiTypes.Int.godot_of_variant
  let ocaml_of_variant = ApiTypes.Int.ocaml_of_variant
  let to_ocaml = ApiTypes.Int.to_ocaml
  let of_ocaml = ApiTypes.Int.of_ocaml

  type t = ApiTypes.Int.t structure ptr
  let s = ApiTypes.Int.s
  let typ = ApiTypes.Int.typ
end
      

  
module PropertyUsageFlags = struct
  include GlobalEnum0.PropertyUsageFlags

  let godot_to_variant = ApiTypes.Int.godot_to_variant
  let ocaml_to_variant = ApiTypes.Int.ocaml_to_variant
  let godot_of_variant = ApiTypes.Int.godot_of_variant
  let ocaml_of_variant = ApiTypes.Int.ocaml_of_variant
  let to_ocaml = ApiTypes.Int.to_ocaml
  let of_ocaml = ApiTypes.Int.of_ocaml

  type t = ApiTypes.Int.t structure ptr
  let s = ApiTypes.Int.s
  let typ = ApiTypes.Int.typ
end
      

  
module MethodFlags = struct
  include GlobalEnum0.MethodFlags

  let godot_to_variant = ApiTypes.Int.godot_to_variant
  let ocaml_to_variant = ApiTypes.Int.ocaml_to_variant
  let godot_of_variant = ApiTypes.Int.godot_of_variant
  let ocaml_of_variant = ApiTypes.Int.ocaml_of_variant
  let to_ocaml = ApiTypes.Int.to_ocaml
  let of_ocaml = ApiTypes.Int.of_ocaml

  type t = ApiTypes.Int.t structure ptr
  let s = ApiTypes.Int.s
  let typ = ApiTypes.Int.typ
end
      

  
module VariantType = struct
  include GlobalEnum0.VariantType

  let godot_to_variant = ApiTypes.Int.godot_to_variant
  let ocaml_to_variant = ApiTypes.Int.ocaml_to_variant
  let godot_of_variant = ApiTypes.Int.godot_of_variant
  let ocaml_of_variant = ApiTypes.Int.ocaml_of_variant
  let to_ocaml = ApiTypes.Int.to_ocaml
  let of_ocaml = ApiTypes.Int.of_ocaml

  type t = ApiTypes.Int.t structure ptr
  let s = ApiTypes.Int.s
  let typ = ApiTypes.Int.typ
end
      

  
module VariantOperator = struct
  include GlobalEnum0.VariantOperator

  let godot_to_variant = ApiTypes.Int.godot_to_variant
  let ocaml_to_variant = ApiTypes.Int.ocaml_to_variant
  let godot_of_variant = ApiTypes.Int.godot_of_variant
  let ocaml_of_variant = ApiTypes.Int.ocaml_of_variant
  let to_ocaml = ApiTypes.Int.to_ocaml
  let of_ocaml = ApiTypes.Int.of_ocaml

  type t = ApiTypes.Int.t structure ptr
  let s = ApiTypes.Int.s
  let typ = ApiTypes.Int.typ
end
      
  end

module UtilityFunction = struct
  (** Returns the sine of angle \[param angle_rad\] in radians.
\[codeblock\]
sin(0.523599)       # Returns 0.5
sin(deg_to_rad(90)) # Returns 1.0
\[/codeblock\] *)
  let sin x0  = 
  foreign_utility_function1
    "sin"
    2140049587L
    Float.s
    Conv.Float.to_ocaml
    Conv.Float.of_ocaml x0 

  (** Returns the cosine of angle \[param angle_rad\] in radians.
\[codeblock\]
cos(PI  *  2)         # Returns 1.0
cos(PI)             # Returns -1.0
cos(deg_to_rad(90)) # Returns 0.0
\[/codeblock\] *)
  let cos x0  = 
  foreign_utility_function1
    "cos"
    2140049587L
    Float.s
    Conv.Float.to_ocaml
    Conv.Float.of_ocaml x0 

  (** Returns the tangent of angle \[param angle_rad\] in radians.
\[codeblock\]
tan(deg_to_rad(45)) # Returns 1
\[/codeblock\] *)
  let tan x0  = 
  foreign_utility_function1
    "tan"
    2140049587L
    Float.s
    Conv.Float.to_ocaml
    Conv.Float.of_ocaml x0 

  (** Returns the hyperbolic sine of \[param x\].
\[codeblock\]
var a = log(2.0) # Returns 0.693147
sinh(a) # Returns 0.75
\[/codeblock\] *)
  let sinh x0  = 
  foreign_utility_function1
    "sinh"
    2140049587L
    Float.s
    Conv.Float.to_ocaml
    Conv.Float.of_ocaml x0 

  (** Returns the hyperbolic cosine of \[param x\] in radians.
\[codeblock\]
print(cosh(1)) # Prints 1.543081
\[/codeblock\] *)
  let cosh x0  = 
  foreign_utility_function1
    "cosh"
    2140049587L
    Float.s
    Conv.Float.to_ocaml
    Conv.Float.of_ocaml x0 

  (** Returns the hyperbolic tangent of \[param x\].
\[codeblock\]
var a = log(2.0) # Returns 0.693147
tanh(a)          # Returns 0.6
\[/codeblock\] *)
  let tanh x0  = 
  foreign_utility_function1
    "tanh"
    2140049587L
    Float.s
    Conv.Float.to_ocaml
    Conv.Float.of_ocaml x0 

  (** Returns the arc sine of \[param x\] in radians. Use to get the angle of sine \[param x\]. \[param x\] will be clamped between \[code\]-1.0\[/code\] and \[code\]1.0\[/code\] (inclusive), in order to prevent \[method asin\] from returning \[constant \@GDScript.NAN\].
\[codeblock\]
# s is 0.523599 or 30 degrees if converted with rad_to_deg(s)
var s = asin(0.5)
\[/codeblock\] *)
  let asin x0  = 
  foreign_utility_function1
    "asin"
    2140049587L
    Float.s
    Conv.Float.to_ocaml
    Conv.Float.of_ocaml x0 

  (** Returns the arc cosine of \[param x\] in radians. Use to get the angle of cosine \[param x\]. \[param x\] will be clamped between \[code\]-1.0\[/code\] and \[code\]1.0\[/code\] (inclusive), in order to prevent \[method acos\] from returning \[constant \@GDScript.NAN\].
\[codeblock\]
# c is 0.523599 or 30 degrees if converted with rad_to_deg(c)
var c = acos(0.866025)
\[/codeblock\] *)
  let acos x0  = 
  foreign_utility_function1
    "acos"
    2140049587L
    Float.s
    Conv.Float.to_ocaml
    Conv.Float.of_ocaml x0 

  (** Returns the arc tangent of \[param x\] in radians. Use it to get the angle from an angle''s tangent in trigonometry.
The method cannot know in which quadrant the angle should fall. See \[method atan2\] if you have both \[code\]y\[/code\] and \[code skip-lint\]x\[/code\].
\[codeblock\]
var a = atan(0.5) # a is 0.463648
\[/codeblock\]
If \[param x\] is between \[code\]-PI / 2\[/code\] and \[code\]PI / 2\[/code\] (inclusive), \[code\]atan(tan(x))\[/code\] is equal to \[param x\]. *)
  let atan x0  = 
  foreign_utility_function1
    "atan"
    2140049587L
    Float.s
    Conv.Float.to_ocaml
    Conv.Float.of_ocaml x0 

  (** Returns the arc tangent of \[code\]y/x\[/code\] in radians. Use to get the angle of tangent \[code\]y/x\[/code\]. To compute the value, the method takes into account the sign of both arguments in order to determine the quadrant.
Important note: The Y coordinate comes first, by convention.
\[codeblock\]
var a = atan2(0, -1) # a is 3.141593
\[/codeblock\] *)
  let atan2 x0  x1  = 
  foreign_utility_function2
    "atan2"
    92296394L
    Float.s
    Conv.Float.to_ocaml
    Conv.Float.of_ocaml Conv.Float.of_ocaml x0  x1 

  (** Returns the hyperbolic arc (also called inverse) sine of \[param x\], returning a value in radians. Use it to get the angle from an angle''s sine in hyperbolic space.
\[codeblock\]
var a = asinh(0.9) # Returns 0.8088669356527824
sinh(a) # Returns 0.9
\[/codeblock\] *)
  let asinh x0  = 
  foreign_utility_function1
    "asinh"
    2140049587L
    Float.s
    Conv.Float.to_ocaml
    Conv.Float.of_ocaml x0 

  (** Returns the hyperbolic arc (also called inverse) cosine of \[param x\], returning a value in radians. Use it to get the angle from an angle''s cosine in hyperbolic space if \[param x\] is larger or equal to 1. For values of \[param x\] lower than 1, it will return 0, in order to prevent \[method acosh\] from returning \[constant \@GDScript.NAN\].
\[codeblock\]
var a = acosh(2) # Returns 1.31695789692482
cosh(a) # Returns 2

var b = acosh(-1) # Returns 0
\[/codeblock\] *)
  let acosh x0  = 
  foreign_utility_function1
    "acosh"
    2140049587L
    Float.s
    Conv.Float.to_ocaml
    Conv.Float.of_ocaml x0 

  (** Returns the hyperbolic arc (also called inverse) tangent of \[param x\], returning a value in radians. Use it to get the angle from an angle''s tangent in hyperbolic space if \[param x\] is between -1 and 1 (non-inclusive).
In mathematics, the inverse hyperbolic tangent is only defined for -1 < \[param x\] < 1 in the real set, so values equal or lower to -1 for \[param x\] return negative \[constant \@GDScript.INF\] and values equal or higher than 1 return positive \[constant \@GDScript.INF\] in order to prevent \[method atanh\] from returning \[constant \@GDScript.NAN\].
\[codeblock\]
var a = atanh(0.9) # Returns 1.47221948958322
tanh(a) # Returns 0.9

var b = atanh(-2) # Returns -inf
tanh(b) # Returns -1
\[/codeblock\] *)
  let atanh x0  = 
  foreign_utility_function1
    "atanh"
    2140049587L
    Float.s
    Conv.Float.to_ocaml
    Conv.Float.of_ocaml x0 

  (** Returns the square root of \[param x\], where \[param x\] is a non-negative number.
\[codeblock\]
sqrt(9)     # Returns 3
sqrt(10.24) # Returns 3.2
sqrt(-1)    # Returns NaN
\[/codeblock\]
\[b\]Note:\[/b\] Negative values of \[param x\] return NaN (""Not a Number""). in C#, if you need negative inputs, use \[code\]System.Numerics.Complex\[/code\]. *)
  let sqrt x0  = 
  foreign_utility_function1
    "sqrt"
    2140049587L
    Float.s
    Conv.Float.to_ocaml
    Conv.Float.of_ocaml x0 

  (** Returns the floating-point remainder of \[param x\] divided by \[param y\], keeping the sign of \[param x\].
\[codeblock\]
var remainder = fmod(7, 5.5) # remainder is 1.5
\[/codeblock\]
For the integer remainder operation, use the \[code\]%\[/code\] operator. *)
  let fmod x0  x1  = 
  foreign_utility_function2
    "fmod"
    92296394L
    Float.s
    Conv.Float.to_ocaml
    Conv.Float.of_ocaml Conv.Float.of_ocaml x0  x1 

  (** Returns the floating-point modulus of \[param x\] divided by \[param y\], wrapping equally in positive and negative.
\[codeblock\]
print("" (x)  (fmod(x, 1.5))   (fposmod(x, 1.5))"")
for i in 7:
    var x = i  *  0.5 - 1.5
    print(""%4.1f           %4.1f  | %4.1f"" % \[x, fmod(x, 1.5), fposmod(x, 1.5)\])
\[/codeblock\]
Prints:
\[codeblock lang=text\]
 (x)  (fmod(x, 1.5))   (fposmod(x, 1.5))
-1.5           -0.0  |  0.0
-1.0           -1.0  |  0.5
-0.5           -0.5  |  1.0
 0.0            0.0  |  0.0
 0.5            0.5  |  0.5
 1.0            1.0  |  1.0
 1.5            0.0  |  0.0
\[/codeblock\] *)
  let fposmod x0  x1  = 
  foreign_utility_function2
    "fposmod"
    92296394L
    Float.s
    Conv.Float.to_ocaml
    Conv.Float.of_ocaml Conv.Float.of_ocaml x0  x1 

  (** Returns the integer modulus of \[param x\] divided by \[param y\] that wraps equally in positive and negative.
\[codeblock\]
print(""#(i)  (i % 3)   (posmod(i, 3))"")
for i in range(-3, 4):
    print(""%2d       %2d  | %2d"" % \[i, i % 3, posmod(i, 3)\])
\[/codeblock\]
Prints:
\[codeblock lang=text\]
(i)  (i % 3)   (posmod(i, 3))
-3        0  |  0
-2       -2  |  1
-1       -1  |  2
 0        0  |  0
 1        1  |  1
 2        2  |  2
 3        0  |  0
\[/codeblock\] *)
  let posmod x0  x1  = 
  foreign_utility_function2
    "posmod"
    3133453818L
    Int.s
    Conv.Int.to_ocaml
    Conv.Int.of_ocaml Conv.Int.of_ocaml x0  x1 

  (** Rounds \[param x\] downward (towards negative infinity), returning the largest whole number that is not more than \[param x\]. Supported types: \[int\], \[float\], \[Vector2\], \[Vector2i\], \[Vector3\], \[Vector3i\], \[Vector4\], \[Vector4i\].
\[codeblock\]
var a = floor(2.99) # a is 2.0
a = floor(-2.99)    # a is -3.0
\[/codeblock\]
See also \[method ceil\], \[method round\], and \[method snapped\].
\[b\]Note:\[/b\] For better type safety, use \[method floorf\], \[method floori\], \[method Vector2.floor\], \[method Vector3.floor\], or \[method Vector4.floor\]. *)
  let floor x0  = 
  foreign_utility_function1
    "floor"
    4776452L
    Variant.s
    Conv.Variant.to_ocaml
    Conv.Variant.of_ocaml x0 

  (** Rounds \[param x\] downward (towards negative infinity), returning the largest whole number that is not more than \[param x\].
A type-safe version of \[method floor\], returning a \[float\]. *)
  let floorf x0  = 
  foreign_utility_function1
    "floorf"
    2140049587L
    Float.s
    Conv.Float.to_ocaml
    Conv.Float.of_ocaml x0 

  (** Rounds \[param x\] downward (towards negative infinity), returning the largest whole number that is not more than \[param x\].
A type-safe version of \[method floor\], returning an \[int\].
\[b\]Note:\[/b\] This function is \[i\]not\[/i\] the same as \[code\]int(x)\[/code\], which rounds towards 0. *)
  let floori x0  = 
  foreign_utility_function1
    "floori"
    2780425386L
    Int.s
    Conv.Int.to_ocaml
    Conv.Float.of_ocaml x0 

  (** Rounds \[param x\] upward (towards positive infinity), returning the smallest whole number that is not less than \[param x\]. Supported types: \[int\], \[float\], \[Vector2\], \[Vector2i\], \[Vector3\], \[Vector3i\], \[Vector4\], \[Vector4i\].
\[codeblock\]
var i = ceil(1.45) # i is 2.0
i = ceil(1.001)    # i is 2.0
\[/codeblock\]
See also \[method floor\], \[method round\], and \[method snapped\].
\[b\]Note:\[/b\] For better type safety, use \[method ceilf\], \[method ceili\], \[method Vector2.ceil\], \[method Vector3.ceil\], or \[method Vector4.ceil\]. *)
  let ceil x0  = 
  foreign_utility_function1
    "ceil"
    4776452L
    Variant.s
    Conv.Variant.to_ocaml
    Conv.Variant.of_ocaml x0 

  (** Rounds \[param x\] upward (towards positive infinity), returning the smallest whole number that is not less than \[param x\].
A type-safe version of \[method ceil\], returning a \[float\]. *)
  let ceilf x0  = 
  foreign_utility_function1
    "ceilf"
    2140049587L
    Float.s
    Conv.Float.to_ocaml
    Conv.Float.of_ocaml x0 

  (** Rounds \[param x\] upward (towards positive infinity), returning the smallest whole number that is not less than \[param x\].
A type-safe version of \[method ceil\], returning an \[int\]. *)
  let ceili x0  = 
  foreign_utility_function1
    "ceili"
    2780425386L
    Int.s
    Conv.Int.to_ocaml
    Conv.Float.of_ocaml x0 

  (** Rounds \[param x\] to the nearest whole number, with halfway cases rounded away from 0. Supported types: \[int\], \[float\], \[Vector2\], \[Vector2i\], \[Vector3\], \[Vector3i\], \[Vector4\], \[Vector4i\].
\[codeblock\]
round(2.4) # Returns 2
round(2.5) # Returns 3
round(2.6) # Returns 3
\[/codeblock\]
See also \[method floor\], \[method ceil\], and \[method snapped\].
\[b\]Note:\[/b\] For better type safety, use \[method roundf\], \[method roundi\], \[method Vector2.round\], \[method Vector3.round\], or \[method Vector4.round\]. *)
  let round x0  = 
  foreign_utility_function1
    "round"
    4776452L
    Variant.s
    Conv.Variant.to_ocaml
    Conv.Variant.of_ocaml x0 

  (** Rounds \[param x\] to the nearest whole number, with halfway cases rounded away from 0.
A type-safe version of \[method round\], returning a \[float\]. *)
  let roundf x0  = 
  foreign_utility_function1
    "roundf"
    2140049587L
    Float.s
    Conv.Float.to_ocaml
    Conv.Float.of_ocaml x0 

  (** Rounds \[param x\] to the nearest whole number, with halfway cases rounded away from 0.
A type-safe version of \[method round\], returning an \[int\]. *)
  let roundi x0  = 
  foreign_utility_function1
    "roundi"
    2780425386L
    Int.s
    Conv.Int.to_ocaml
    Conv.Float.of_ocaml x0 

  (** Returns the absolute value of a \[Variant\] parameter \[param x\] (i.e. non-negative value). Supported types: \[int\], \[float\], \[Vector2\], \[Vector2i\], \[Vector3\], \[Vector3i\], \[Vector4\], \[Vector4i\].
\[codeblock\]
var a = abs(-1)
# a is 1

var b = abs(-1.2)
# b is 1.2

var c = abs(Vector2(-3.5, -4))
# c is (3.5, 4)

var d = abs(Vector2i(-5, -6))
# d is (5, 6)

var e = abs(Vector3(-7, 8.5, -3.8))
# e is (7, 8.5, 3.8)

var f = abs(Vector3i(-7, -8, -9))
# f is (7, 8, 9)
\[/codeblock\]
\[b\]Note:\[/b\] For better type safety, use \[method absf\], \[method absi\], \[method Vector2.abs\], \[method Vector2i.abs\], \[method Vector3.abs\], \[method Vector3i.abs\], \[method Vector4.abs\], or \[method Vector4i.abs\]. *)
  let abs x0  = 
  foreign_utility_function1
    "abs"
    4776452L
    Variant.s
    Conv.Variant.to_ocaml
    Conv.Variant.of_ocaml x0 

  (** Returns the absolute value of float parameter \[param x\] (i.e. positive value).
\[codeblock\]
# a is 1.2
var a = absf(-1.2)
\[/codeblock\] *)
  let absf x0  = 
  foreign_utility_function1
    "absf"
    2140049587L
    Float.s
    Conv.Float.to_ocaml
    Conv.Float.of_ocaml x0 

  (** Returns the absolute value of int parameter \[param x\] (i.e. positive value).
\[codeblock\]
# a is 1
var a = absi(-1)
\[/codeblock\] *)
  let absi x0  = 
  foreign_utility_function1
    "absi"
    2157319888L
    Int.s
    Conv.Int.to_ocaml
    Conv.Int.of_ocaml x0 

  (** Returns the same type of \[Variant\] as \[param x\], with \[code\]-1\[/code\] for negative values, \[code\]1\[/code\] for positive values, and \[code\]0\[/code\] for zeros. For \[code\]nan\[/code\] values it returns 0.
Supported types: \[int\], \[float\], \[Vector2\], \[Vector2i\], \[Vector3\], \[Vector3i\], \[Vector4\], \[Vector4i\].
\[codeblock\]
sign(-6.0) # Returns -1
sign(0.0)  # Returns 0
sign(6.0)  # Returns 1
sign(NAN)  # Returns 0

sign(Vector3(-6.0, 0.0, 6.0)) # Returns (-1, 0, 1)
\[/codeblock\]
\[b\]Note:\[/b\] For better type safety, use \[method signf\], \[method signi\], \[method Vector2.sign\], \[method Vector2i.sign\], \[method Vector3.sign\], \[method Vector3i.sign\], \[method Vector4.sign\], or \[method Vector4i.sign\]. *)
  let sign x0  = 
  foreign_utility_function1
    "sign"
    4776452L
    Variant.s
    Conv.Variant.to_ocaml
    Conv.Variant.of_ocaml x0 

  (** Returns \[code\]-1.0\[/code\] if \[param x\] is negative, \[code\]1.0\[/code\] if \[param x\] is positive, and \[code\]0.0\[/code\] if \[param x\] is zero. For \[code\]nan\[/code\] values of \[param x\] it returns 0.0.
\[codeblock\]
signf(-6.5) # Returns -1.0
signf(0.0)  # Returns 0.0
signf(6.5)  # Returns 1.0
signf(NAN)  # Returns 0.0
\[/codeblock\] *)
  let signf x0  = 
  foreign_utility_function1
    "signf"
    2140049587L
    Float.s
    Conv.Float.to_ocaml
    Conv.Float.of_ocaml x0 

  (** Returns \[code\]-1\[/code\] if \[param x\] is negative, \[code\]1\[/code\] if \[param x\] is positive, and \[code\]0\[/code\] if \[param x\] is zero.
\[codeblock\]
signi(-6) # Returns -1
signi(0)  # Returns 0
signi(6)  # Returns 1
\[/codeblock\] *)
  let signi x0  = 
  foreign_utility_function1
    "signi"
    2157319888L
    Int.s
    Conv.Int.to_ocaml
    Conv.Int.of_ocaml x0 

  (** Returns the multiple of \[param step\] that is the closest to \[param x\]. This can also be used to round a floating-point number to an arbitrary number of decimals.
The returned value is the same type of \[Variant\] as \[param step\]. Supported types: \[int\], \[float\], \[Vector2\], \[Vector2i\], \[Vector3\], \[Vector3i\], \[Vector4\], \[Vector4i\].
\[codeblock\]
snapped(100, 32)  # Returns 96
snapped(3.14159, 0.01)  # Returns 3.14

snapped(Vector2(34, 70), Vector2(8, 8))  # Returns (32, 72)
\[/codeblock\]
See also \[method ceil\], \[method floor\], and \[method round\].
\[b\]Note:\[/b\] For better type safety, use \[method snappedf\], \[method snappedi\], \[method Vector2.snapped\], \[method Vector2i.snapped\], \[method Vector3.snapped\], \[method Vector3i.snapped\], \[method Vector4.snapped\], or \[method Vector4i.snapped\]. *)
  let snapped x0  x1  = 
  foreign_utility_function2
    "snapped"
    459914704L
    Variant.s
    Conv.Variant.to_ocaml
    Conv.Variant.of_ocaml Conv.Variant.of_ocaml x0  x1 

  (** Returns the multiple of \[param step\] that is the closest to \[param x\]. This can also be used to round a floating-point number to an arbitrary number of decimals.
A type-safe version of \[method snapped\], returning a \[float\].
\[codeblock\]
snappedf(32.0, 2.5)  # Returns 32.5
snappedf(3.14159, 0.01)  # Returns 3.14
\[/codeblock\] *)
  let snappedf x0  x1  = 
  foreign_utility_function2
    "snappedf"
    92296394L
    Float.s
    Conv.Float.to_ocaml
    Conv.Float.of_ocaml Conv.Float.of_ocaml x0  x1 

  (** Returns the multiple of \[param step\] that is the closest to \[param x\].
A type-safe version of \[method snapped\], returning an \[int\].
\[codeblock\]
snappedi(53, 16)  # Returns 48
snappedi(4096, 100)  # Returns 4100
\[/codeblock\] *)
  let snappedi x0  x1  = 
  foreign_utility_function2
    "snappedi"
    3570758393L
    Int.s
    Conv.Int.to_ocaml
    Conv.Float.of_ocaml Conv.Int.of_ocaml x0  x1 

  (** Returns the result of \[param base\] raised to the power of \[param exp\].
In GDScript, this is the equivalent of the \[code\] *  * \[/code\] operator.
\[codeblock\]
pow(2, 5)   # Returns 32.0
pow(4, 1.5) # Returns 8.0
\[/codeblock\] *)
  let pow x0  x1  = 
  foreign_utility_function2
    "pow"
    92296394L
    Float.s
    Conv.Float.to_ocaml
    Conv.Float.of_ocaml Conv.Float.of_ocaml x0  x1 

  (** Returns the \[url=https://en.wikipedia.org/wiki/Natural_logarithm\]natural logarithm\[/url\] of \[param x\] (base \[url=https://en.wikipedia.org/wiki/E_(mathematical_constant)\]\[i\]e\[/i\]\[/url\], with \[i\]e\[/i\] being approximately 2.71828). This is the amount of time needed to reach a certain level of continuous growth.
\[b\]Note:\[/b\] This is not the same as the ""log"" function on most calculators, which uses a base 10 logarithm. To use base 10 logarithm, use \[code\]log(x) / log(10)\[/code\].
\[codeblock\]
log(10) # Returns 2.302585
\[/codeblock\]
\[b\]Note:\[/b\] The logarithm of \[code\]0\[/code\] returns \[code\]-inf\[/code\], while negative values return \[code\]-nan\[/code\]. *)
  let log x0  = 
  foreign_utility_function1
    "log"
    2140049587L
    Float.s
    Conv.Float.to_ocaml
    Conv.Float.of_ocaml x0 

  (** The natural exponential function. It raises the mathematical constant \[i\]e\[/i\] to the power of \[param x\] and returns it.
\[i\]e\[/i\] has an approximate value of 2.71828, and can be obtained with \[code\]exp(1)\[/code\].
For exponents to other bases use the method \[method pow\].
\[codeblock\]
var a = exp(2) # Approximately 7.39
\[/codeblock\] *)
  let exp x0  = 
  foreign_utility_function1
    "exp"
    2140049587L
    Float.s
    Conv.Float.to_ocaml
    Conv.Float.of_ocaml x0 

  (** Returns \[code\]true\[/code\] if \[param x\] is a NaN (""Not a Number"" or invalid) value. *)
  let is_nan x0  = 
  foreign_utility_function1
    "is_nan"
    3569215213L
    Bool.s
    Conv.Bool.to_ocaml
    Conv.Float.of_ocaml x0 

  (** Returns \[code\]true\[/code\] if \[param x\] is either positive infinity or negative infinity. *)
  let is_inf x0  = 
  foreign_utility_function1
    "is_inf"
    3569215213L
    Bool.s
    Conv.Bool.to_ocaml
    Conv.Float.of_ocaml x0 

  (** Returns \[code\]true\[/code\] if \[param a\] and \[param b\] are approximately equal to each other.
Here, ""approximately equal"" means that \[param a\] and \[param b\] are within a small internal epsilon of each other, which scales with the magnitude of the numbers.
Infinity values of the same sign are considered equal. *)
  let is_equal_approx x0  x1  = 
  foreign_utility_function2
    "is_equal_approx"
    1400789633L
    Bool.s
    Conv.Bool.to_ocaml
    Conv.Float.of_ocaml Conv.Float.of_ocaml x0  x1 

  (** Returns \[code\]true\[/code\] if \[param x\] is zero or almost zero. The comparison is done using a tolerance calculation with a small internal epsilon.
This function is faster than using \[method is_equal_approx\] with one value as zero. *)
  let is_zero_approx x0  = 
  foreign_utility_function1
    "is_zero_approx"
    3569215213L
    Bool.s
    Conv.Bool.to_ocaml
    Conv.Float.of_ocaml x0 

  (** Returns whether \[param x\] is a finite value, i.e. it is not \[constant \@GDScript.NAN\], positive infinity, or negative infinity. *)
  let is_finite x0  = 
  foreign_utility_function1
    "is_finite"
    3569215213L
    Bool.s
    Conv.Bool.to_ocaml
    Conv.Float.of_ocaml x0 

  (** Returns an ""eased"" value of \[param x\] based on an easing function defined with \[param curve\]. This easing function is based on an exponent. The \[param curve\] can be any floating-point number, with specific values leading to the following behaviors:
\[codeblock lang=text\]
- Lower than -1.0 (exclusive): Ease in-out
- -1.0: Linear
- Between -1.0 and 0.0 (exclusive): Ease out-in
- 0.0: Constant
- Between 0.0 to 1.0 (exclusive): Ease out
- 1.0: Linear
- Greater than 1.0 (exclusive): Ease in
\[/codeblock\]
\[url=https://raw.githubusercontent.com/godotengine/godot-docs/master/img/ease_cheatsheet.png\]ease() curve values cheatsheet\[/url\]
See also \[method smoothstep\]. If you need to perform more advanced transitions, use \[method Tween.interpolate_value\]. *)
  let ease x0  x1  = 
  foreign_utility_function2
    "ease"
    92296394L
    Float.s
    Conv.Float.to_ocaml
    Conv.Float.of_ocaml Conv.Float.of_ocaml x0  x1 

  (** Returns the position of the first non-zero digit, after the decimal point. Note that the maximum return value is 10, which is a design decision in the implementation.
\[codeblock\]
var n = step_decimals(5)       # n is 0
n = step_decimals(1.0005)      # n is 4
n = step_decimals(0.000000005) # n is 9
\[/codeblock\] *)
  let step_decimals x0  = 
  foreign_utility_function1
    "step_decimals"
    2780425386L
    Int.s
    Conv.Int.to_ocaml
    Conv.Float.of_ocaml x0 

  (** Linearly interpolates between two values by the factor defined in \[param weight\]. To perform interpolation, \[param weight\] should be between \[code\]0.0\[/code\] and \[code\]1.0\[/code\] (inclusive). However, values outside this range are allowed and can be used to perform \[i\]extrapolation\[/i\]. If this is not desired, use \[method clampf\] to limit \[param weight\].
Both \[param from\] and \[param to\] must be the same type. Supported types: \[int\], \[float\], \[Vector2\], \[Vector3\], \[Vector4\], \[Color\], \[Quaternion\], \[Basis\], \[Transform2D\], \[Transform3D\].
\[codeblock\]
lerp(0, 4, 0.75) # Returns 3.0
\[/codeblock\]
See also \[method inverse_lerp\] which performs the reverse of this operation. To perform eased interpolation with \[method lerp\], combine it with \[method ease\] or \[method smoothstep\]. See also \[method remap\] to map a continuous series of values to another.
\[b\]Note:\[/b\] For better type safety, use \[method lerpf\], \[method Vector2.lerp\], \[method Vector3.lerp\], \[method Vector4.lerp\], \[method Color.lerp\], \[method Quaternion.slerp\], \[method Basis.slerp\], \[method Transform2D.interpolate_with\], or \[method Transform3D.interpolate_with\]. *)
  let lerp x0  x1  x2  = 
  foreign_utility_function3
    "lerp"
    3389874542L
    Variant.s
    Conv.Variant.to_ocaml
    Conv.Variant.of_ocaml Conv.Variant.of_ocaml Conv.Variant.of_ocaml x0  x1  x2 

  (** Linearly interpolates between two values by the factor defined in \[param weight\]. To perform interpolation, \[param weight\] should be between \[code\]0.0\[/code\] and \[code\]1.0\[/code\] (inclusive). However, values outside this range are allowed and can be used to perform \[i\]extrapolation\[/i\]. If this is not desired, use \[method clampf\] on the result of this function.
\[codeblock\]
lerpf(0, 4, 0.75) # Returns 3.0
\[/codeblock\]
See also \[method inverse_lerp\] which performs the reverse of this operation. To perform eased interpolation with \[method lerp\], combine it with \[method ease\] or \[method smoothstep\]. *)
  let lerpf x0  x1  x2  = 
  foreign_utility_function3
    "lerpf"
    998901048L
    Float.s
    Conv.Float.to_ocaml
    Conv.Float.of_ocaml Conv.Float.of_ocaml Conv.Float.of_ocaml x0  x1  x2 

  (** Cubic interpolates between two values by the factor defined in \[param weight\] with \[param pre\] and \[param post\] values. *)
  let cubic_interpolate x0  x1  x2  x3  x4  = 
  foreign_utility_function5
    "cubic_interpolate"
    1090965791L
    Float.s
    Conv.Float.to_ocaml
    Conv.Float.of_ocaml Conv.Float.of_ocaml Conv.Float.of_ocaml Conv.Float.of_ocaml Conv.Float.of_ocaml x0  x1  x2  x3  x4 

  (** Cubic interpolates between two rotation values with shortest path by the factor defined in \[param weight\] with \[param pre\] and \[param post\] values. See also \[method lerp_angle\]. *)
  let cubic_interpolate_angle x0  x1  x2  x3  x4  = 
  foreign_utility_function5
    "cubic_interpolate_angle"
    1090965791L
    Float.s
    Conv.Float.to_ocaml
    Conv.Float.of_ocaml Conv.Float.of_ocaml Conv.Float.of_ocaml Conv.Float.of_ocaml Conv.Float.of_ocaml x0  x1  x2  x3  x4 

  (** Cubic interpolates between two values by the factor defined in \[param weight\] with \[param pre\] and \[param post\] values.
It can perform smoother interpolation than \[method cubic_interpolate\] by the time values. *)
  let cubic_interpolate_in_time x0  x1  x2  x3  x4  x5  x6  x7  = 
  foreign_utility_function8
    "cubic_interpolate_in_time"
    388121036L
    Float.s
    Conv.Float.to_ocaml
    Conv.Float.of_ocaml Conv.Float.of_ocaml Conv.Float.of_ocaml Conv.Float.of_ocaml Conv.Float.of_ocaml Conv.Float.of_ocaml Conv.Float.of_ocaml Conv.Float.of_ocaml x0  x1  x2  x3  x4  x5  x6  x7 

  (** Cubic interpolates between two rotation values with shortest path by the factor defined in \[param weight\] with \[param pre\] and \[param post\] values. See also \[method lerp_angle\].
It can perform smoother interpolation than \[method cubic_interpolate\] by the time values. *)
  let cubic_interpolate_angle_in_time x0  x1  x2  x3  x4  x5  x6  x7  = 
  foreign_utility_function8
    "cubic_interpolate_angle_in_time"
    388121036L
    Float.s
    Conv.Float.to_ocaml
    Conv.Float.of_ocaml Conv.Float.of_ocaml Conv.Float.of_ocaml Conv.Float.of_ocaml Conv.Float.of_ocaml Conv.Float.of_ocaml Conv.Float.of_ocaml Conv.Float.of_ocaml x0  x1  x2  x3  x4  x5  x6  x7 

  (** Returns the point at the given \[param t\] on a one-dimensional \[url=https://en.wikipedia.org/wiki/B%C3%A9zier_curve\]Bzier curve\[/url\] defined by the given \[param control_1\], \[param control_2\], and \[param end\] points. *)
  let bezier_interpolate x0  x1  x2  x3  x4  = 
  foreign_utility_function5
    "bezier_interpolate"
    1090965791L
    Float.s
    Conv.Float.to_ocaml
    Conv.Float.of_ocaml Conv.Float.of_ocaml Conv.Float.of_ocaml Conv.Float.of_ocaml Conv.Float.of_ocaml x0  x1  x2  x3  x4 

  (** Returns the derivative at the given \[param t\] on a one-dimensional \[url=https://en.wikipedia.org/wiki/B%C3%A9zier_curve\]Bzier curve\[/url\] defined by the given \[param control_1\], \[param control_2\], and \[param end\] points. *)
  let bezier_derivative x0  x1  x2  x3  x4  = 
  foreign_utility_function5
    "bezier_derivative"
    1090965791L
    Float.s
    Conv.Float.to_ocaml
    Conv.Float.of_ocaml Conv.Float.of_ocaml Conv.Float.of_ocaml Conv.Float.of_ocaml Conv.Float.of_ocaml x0  x1  x2  x3  x4 

  (** Returns the difference between the two angles (in radians), in the range of \[code\]\[-PI, +PI\]\[/code\]. When \[param from\] and \[param to\] are opposite, returns \[code\]-PI\[/code\] if \[param from\] is smaller than \[param to\], or \[code\]PI\[/code\] otherwise. *)
  let angle_difference x0  x1  = 
  foreign_utility_function2
    "angle_difference"
    92296394L
    Float.s
    Conv.Float.to_ocaml
    Conv.Float.of_ocaml Conv.Float.of_ocaml x0  x1 

  (** Linearly interpolates between two angles (in radians) by a \[param weight\] value between 0.0 and 1.0.
Similar to \[method lerp\], but interpolates correctly when the angles wrap around \[constant \@GDScript.TAU\]. To perform eased interpolation with \[method lerp_angle\], combine it with \[method ease\] or \[method smoothstep\].
\[codeblock\]
extends Sprite
var elapsed = 0.0
func _process(delta):
    var min_angle = deg_to_rad(0.0)
    var max_angle = deg_to_rad(90.0)
    rotation = lerp_angle(min_angle, max_angle, elapsed)
    elapsed += delta
\[/codeblock\]
\[b\]Note:\[/b\] This function lerps through the shortest path between \[param from\] and \[param to\]. However, when these two angles are approximately \[code\]PI + k  *  TAU\[/code\] apart for any integer \[code\]k\[/code\], it''s not obvious which way they lerp due to floating-point precision errors. For example, \[code\]lerp_angle(0, PI, weight)\[/code\] lerps counter-clockwise, while \[code\]lerp_angle(0, PI + 5  *  TAU, weight)\[/code\] lerps clockwise. *)
  let lerp_angle x0  x1  x2  = 
  foreign_utility_function3
    "lerp_angle"
    998901048L
    Float.s
    Conv.Float.to_ocaml
    Conv.Float.of_ocaml Conv.Float.of_ocaml Conv.Float.of_ocaml x0  x1  x2 

  (** Returns an interpolation or extrapolation factor considering the range specified in \[param from\] and \[param to\], and the interpolated value specified in \[param weight\]. The returned value will be between \[code\]0.0\[/code\] and \[code\]1.0\[/code\] if \[param weight\] is between \[param from\] and \[param to\] (inclusive). If \[param weight\] is located outside this range, then an extrapolation factor will be returned (return value lower than \[code\]0.0\[/code\] or greater than \[code\]1.0\[/code\]). Use \[method clamp\] on the result of \[method inverse_lerp\] if this is not desired.
\[codeblock\]
# The interpolation ratio in the `lerp()` call below is 0.75.
var middle = lerp(20, 30, 0.75)
# middle is now 27.5.

# Now, we pretend to have forgotten the original ratio and want to get it back.
var ratio = inverse_lerp(20, 30, 27.5)
# ratio is now 0.75.
\[/codeblock\]
See also \[method lerp\], which performs the reverse of this operation, and \[method remap\] to map a continuous series of values to another. *)
  let inverse_lerp x0  x1  x2  = 
  foreign_utility_function3
    "inverse_lerp"
    998901048L
    Float.s
    Conv.Float.to_ocaml
    Conv.Float.of_ocaml Conv.Float.of_ocaml Conv.Float.of_ocaml x0  x1  x2 

  (** Maps a \[param value\] from range \[code\]\[istart, istop\]\[/code\] to \[code\]\[ostart, ostop\]\[/code\]. See also \[method lerp\] and \[method inverse_lerp\]. If \[param value\] is outside \[code\]\[istart, istop\]\[/code\], then the resulting value will also be outside \[code\]\[ostart, ostop\]\[/code\]. If this is not desired, use \[method clamp\] on the result of this function.
\[codeblock\]
remap(75, 0, 100, -1, 1) # Returns 0.5
\[/codeblock\]
For complex use cases where multiple ranges are needed, consider using \[Curve\] or \[Gradient\] instead.
\[b\]Note:\[/b\] If \[code\]istart == istop\[/code\], the return value is undefined (most likely NaN, INF, or -INF). *)
  let remap x0  x1  x2  x3  x4  = 
  foreign_utility_function5
    "remap"
    1090965791L
    Float.s
    Conv.Float.to_ocaml
    Conv.Float.of_ocaml Conv.Float.of_ocaml Conv.Float.of_ocaml Conv.Float.of_ocaml Conv.Float.of_ocaml x0  x1  x2  x3  x4 

  (** Returns a smooth cubic Hermite interpolation between \[code\]0\[/code\] and \[code\]1\[/code\].
For positive ranges (when \[code\]from <= to\[/code\]) the return value is \[code\]0\[/code\] when \[code\]x <= from\[/code\], and \[code\]1\[/code\] when \[code\]x >= to\[/code\]. If \[param x\] lies between \[param from\] and \[param to\], the return value follows an S-shaped curve that smoothly transitions from \[code\]0\[/code\] to \[code\]1\[/code\].
For negative ranges (when \[code\]from > to\[/code\]) the function is mirrored and returns \[code\]1\[/code\] when \[code\]x <= to\[/code\] and \[code\]0\[/code\] when \[code\]x >= from\[/code\].
This S-shaped curve is the cubic Hermite interpolator, given by \[code\]f(y) = 3 * y^2 - 2 * y^3\[/code\] where \[code\]y = (x-from) / (to-from)\[/code\].
\[codeblock\]
smoothstep(0, 2, -5.0) # Returns 0.0
smoothstep(0, 2, 0.5) # Returns 0.15625
smoothstep(0, 2, 1.0) # Returns 0.5
smoothstep(0, 2, 2.0) # Returns 1.0
\[/codeblock\]
Compared to \[method ease\] with a curve value of \[code\]-1.6521\[/code\], \[method smoothstep\] returns the smoothest possible curve with no sudden changes in the derivative. If you need to perform more advanced transitions, use \[Tween\] or \[AnimationPlayer\].
\[url=https://raw.githubusercontent.com/godotengine/godot-docs/master/img/smoothstep_ease_comparison.png\]Comparison between smoothstep() and ease(x, -1.6521) return values\[/url\]
\[url=https://raw.githubusercontent.com/godotengine/godot-docs/master/img/smoothstep_range.webp\]Smoothstep() return values with positive, zero, and negative ranges\[/url\] *)
  let smoothstep x0  x1  x2  = 
  foreign_utility_function3
    "smoothstep"
    998901048L
    Float.s
    Conv.Float.to_ocaml
    Conv.Float.of_ocaml Conv.Float.of_ocaml Conv.Float.of_ocaml x0  x1  x2 

  (** Moves \[param from\] toward \[param to\] by the \[param delta\] amount. Will not go past \[param to\].
Use a negative \[param delta\] value to move away.
\[codeblock\]
move_toward(5, 10, 4)    # Returns 9
move_toward(10, 5, 4)    # Returns 6
move_toward(5, 10, 9)    # Returns 10
move_toward(10, 5, -1.5) # Returns 11.5
\[/codeblock\] *)
  let move_toward x0  x1  x2  = 
  foreign_utility_function3
    "move_toward"
    998901048L
    Float.s
    Conv.Float.to_ocaml
    Conv.Float.of_ocaml Conv.Float.of_ocaml Conv.Float.of_ocaml x0  x1  x2 

  (** Rotates \[param from\] toward \[param to\] by the \[param delta\] amount. Will not go past \[param to\].
Similar to \[method move_toward\], but interpolates correctly when the angles wrap around \[constant \@GDScript.TAU\].
If \[param delta\] is negative, this function will rotate away from \[param to\], toward the opposite angle, and will not go past the opposite angle. *)
  let rotate_toward x0  x1  x2  = 
  foreign_utility_function3
    "rotate_toward"
    998901048L
    Float.s
    Conv.Float.to_ocaml
    Conv.Float.of_ocaml Conv.Float.of_ocaml Conv.Float.of_ocaml x0  x1  x2 

  (** Converts an angle expressed in degrees to radians.
\[codeblock\]
var r = deg_to_rad(180) # r is 3.141593
\[/codeblock\] *)
  let deg_to_rad x0  = 
  foreign_utility_function1
    "deg_to_rad"
    2140049587L
    Float.s
    Conv.Float.to_ocaml
    Conv.Float.of_ocaml x0 

  (** Converts an angle expressed in radians to degrees.
\[codeblock\]
rad_to_deg(0.523599) # Returns 30
rad_to_deg(PI)       # Returns 180
rad_to_deg(PI  *  2)   # Returns 360
\[/codeblock\] *)
  let rad_to_deg x0  = 
  foreign_utility_function1
    "rad_to_deg"
    2140049587L
    Float.s
    Conv.Float.to_ocaml
    Conv.Float.of_ocaml x0 

  (** Converts from linear energy to decibels (audio). Since volume is not normally linear, this can be used to implement volume sliders that behave as expected.
\[b\]Example:\[/b\] Change the Master bus''s volume through a \[Slider\] node, which ranges from \[code\]0.0\[/code\] to \[code\]1.0\[/code\]:
\[codeblock\]
AudioServer.set_bus_volume_db(AudioServer.get_bus_index(""Master""), linear_to_db($Slider.value))
\[/codeblock\] *)
  let linear_to_db x0  = 
  foreign_utility_function1
    "linear_to_db"
    2140049587L
    Float.s
    Conv.Float.to_ocaml
    Conv.Float.of_ocaml x0 

  (** Converts from decibels to linear energy (audio). *)
  let db_to_linear x0  = 
  foreign_utility_function1
    "db_to_linear"
    2140049587L
    Float.s
    Conv.Float.to_ocaml
    Conv.Float.of_ocaml x0 

  (** Wraps the \[Variant\] \[param value\] between \[param min\] and \[param max\]. Can be used for creating loop-alike behavior or infinite surfaces.
Variant types \[int\] and \[float\] are supported. If any of the arguments is \[float\] this function returns a \[float\], otherwise it returns an \[int\].
\[codeblock\]
var a = wrap(4, 5, 10)
# a is 9 (int)

var a = wrap(7, 5, 10)
# a is 7 (int)

var a = wrap(10.5, 5, 10)
# a is 5.5 (float)
\[/codeblock\] *)
  let wrap x0  x1  x2  = 
  foreign_utility_function3
    "wrap"
    3389874542L
    Variant.s
    Conv.Variant.to_ocaml
    Conv.Variant.of_ocaml Conv.Variant.of_ocaml Conv.Variant.of_ocaml x0  x1  x2 

  (** Wraps the integer \[param value\] between \[param min\] and \[param max\]. Can be used for creating loop-alike behavior or infinite surfaces.
\[codeblock\]
# Infinite loop between 5 and 9
frame = wrapi(frame + 1, 5, 10)
\[/codeblock\]
\[codeblock\]
# result is -2
var result = wrapi(-6, -5, -1)
\[/codeblock\] *)
  let wrapi x0  x1  x2  = 
  foreign_utility_function3
    "wrapi"
    650295447L
    Int.s
    Conv.Int.to_ocaml
    Conv.Int.of_ocaml Conv.Int.of_ocaml Conv.Int.of_ocaml x0  x1  x2 

  (** Wraps the float \[param value\] between \[param min\] and \[param max\]. Can be used for creating loop-alike behavior or infinite surfaces.
\[codeblock\]
# Infinite loop between 5.0 and 9.9
value = wrapf(value + 0.1, 5.0, 10.0)
\[/codeblock\]
\[codeblock\]
# Infinite rotation (in radians)
angle = wrapf(angle + 0.1, 0.0, TAU)
\[/codeblock\]
\[codeblock\]
# Infinite rotation (in radians)
angle = wrapf(angle + 0.1, -PI, PI)
\[/codeblock\]
\[b\]Note:\[/b\] If \[param min\] is \[code\]0\[/code\], this is equivalent to \[method fposmod\], so prefer using that instead.
\[method wrapf\] is more flexible than using the \[method fposmod\] approach by giving the user control over the minimum value. *)
  let wrapf x0  x1  x2  = 
  foreign_utility_function3
    "wrapf"
    998901048L
    Float.s
    Conv.Float.to_ocaml
    Conv.Float.of_ocaml Conv.Float.of_ocaml Conv.Float.of_ocaml x0  x1  x2 

  (** Returns the maximum of the given numeric values. This function can take any number of arguments.
\[codeblock\]
max(1, 7, 3, -6, 5) # Returns 7
\[/codeblock\]
\[b\]Note:\[/b\] When using this on vectors it will \[i\]not\[/i\] perform component-wise maximum, and will pick the largest value when compared using \[code\]x < y\[/code\]. To perform component-wise maximum, use \[method Vector2.max\], \[method Vector2i.max\], \[method Vector3.max\], \[method Vector3i.max\], \[method Vector4.max\], and \[method Vector4i.max\]. *)
  let max x0  x1  = 
  foreign_utility_function2
    "max"
    3896050336L
    Variant.s
    Conv.Variant.to_ocaml
    Conv.Variant.of_ocaml Conv.Variant.of_ocaml x0  x1 

  (** Returns the maximum of two \[int\] values.
\[codeblock\]
maxi(1, 2)   # Returns 2
maxi(-3, -4) # Returns -3
\[/codeblock\] *)
  let maxi x0  x1  = 
  foreign_utility_function2
    "maxi"
    3133453818L
    Int.s
    Conv.Int.to_ocaml
    Conv.Int.of_ocaml Conv.Int.of_ocaml x0  x1 

  (** Returns the maximum of two \[float\] values.
\[codeblock\]
maxf(3.6, 24)   # Returns 24.0
maxf(-3.99, -4) # Returns -3.99
\[/codeblock\] *)
  let maxf x0  x1  = 
  foreign_utility_function2
    "maxf"
    92296394L
    Float.s
    Conv.Float.to_ocaml
    Conv.Float.of_ocaml Conv.Float.of_ocaml x0  x1 

  (** Returns the minimum of the given numeric values. This function can take any number of arguments.
\[codeblock\]
min(1, 7, 3, -6, 5) # Returns -6
\[/codeblock\]
\[b\]Note:\[/b\] When using this on vectors it will \[i\]not\[/i\] perform component-wise minimum, and will pick the smallest value when compared using \[code\]x < y\[/code\]. To perform component-wise minimum, use \[method Vector2.min\], \[method Vector2i.min\], \[method Vector3.min\], \[method Vector3i.min\], \[method Vector4.min\], and \[method Vector4i.min\]. *)
  let min x0  x1  = 
  foreign_utility_function2
    "min"
    3896050336L
    Variant.s
    Conv.Variant.to_ocaml
    Conv.Variant.of_ocaml Conv.Variant.of_ocaml x0  x1 

  (** Returns the minimum of two \[int\] values.
\[codeblock\]
mini(1, 2)   # Returns 1
mini(-3, -4) # Returns -4
\[/codeblock\] *)
  let mini x0  x1  = 
  foreign_utility_function2
    "mini"
    3133453818L
    Int.s
    Conv.Int.to_ocaml
    Conv.Int.of_ocaml Conv.Int.of_ocaml x0  x1 

  (** Returns the minimum of two \[float\] values.
\[codeblock\]
minf(3.6, 24)   # Returns 3.6
minf(-3.99, -4) # Returns -4.0
\[/codeblock\] *)
  let minf x0  x1  = 
  foreign_utility_function2
    "minf"
    92296394L
    Float.s
    Conv.Float.to_ocaml
    Conv.Float.of_ocaml Conv.Float.of_ocaml x0  x1 

  (** Clamps the \[param value\], returning a \[Variant\] not less than \[param min\] and not more than \[param max\]. Any values that can be compared with the less than and greater than operators will work.
\[codeblock\]
var a = clamp(-10, -1, 5)
# a is -1

var b = clamp(8.1, 0.9, 5.5)
# b is 5.5
\[/codeblock\]
\[b\]Note:\[/b\] For better type safety, use \[method clampf\], \[method clampi\], \[method Vector2.clamp\], \[method Vector2i.clamp\], \[method Vector3.clamp\], \[method Vector3i.clamp\], \[method Vector4.clamp\], \[method Vector4i.clamp\], or \[method Color.clamp\] (not currently supported by this method).
\[b\]Note:\[/b\] When using this on vectors it will \[i\]not\[/i\] perform component-wise clamping, and will pick \[param min\] if \[code\]value < min\[/code\] or \[param max\] if \[code\]value > max\[/code\]. To perform component-wise clamping use the methods listed above. *)
  let clamp x0  x1  x2  = 
  foreign_utility_function3
    "clamp"
    3389874542L
    Variant.s
    Conv.Variant.to_ocaml
    Conv.Variant.of_ocaml Conv.Variant.of_ocaml Conv.Variant.of_ocaml x0  x1  x2 

  (** Clamps the \[param value\], returning an \[int\] not less than \[param min\] and not more than \[param max\].
\[codeblock\]
var speed = 42
var a = clampi(speed, 1, 20) # a is 20

speed = -10
var b = clampi(speed, -1, 1) # b is -1
\[/codeblock\] *)
  let clampi x0  x1  x2  = 
  foreign_utility_function3
    "clampi"
    650295447L
    Int.s
    Conv.Int.to_ocaml
    Conv.Int.of_ocaml Conv.Int.of_ocaml Conv.Int.of_ocaml x0  x1  x2 

  (** Clamps the \[param value\], returning a \[float\] not less than \[param min\] and not more than \[param max\].
\[codeblock\]
var speed = 42.1
var a = clampf(speed, 1.0, 20.5) # a is 20.5

speed = -10.0
var b = clampf(speed, -1.0, 1.0) # b is -1.0
\[/codeblock\] *)
  let clampf x0  x1  x2  = 
  foreign_utility_function3
    "clampf"
    998901048L
    Float.s
    Conv.Float.to_ocaml
    Conv.Float.of_ocaml Conv.Float.of_ocaml Conv.Float.of_ocaml x0  x1  x2 

  (** Returns the smallest integer power of 2 that is greater than or equal to \[param value\].
\[codeblock\]
nearest_po2(3) # Returns 4
nearest_po2(4) # Returns 4
nearest_po2(5) # Returns 8

nearest_po2(0)  # Returns 0 (this may not be expected)
nearest_po2(-1) # Returns 0 (this may not be expected)
\[/codeblock\]
\[b\]Warning:\[/b\] Due to its implementation, this method returns \[code\]0\[/code\] rather than \[code\]1\[/code\] for values less than or equal to \[code\]0\[/code\], with an exception for \[param value\] being the smallest negative 64-bit integer (\[code\]-9223372036854775808\[/code\]) in which case the \[param value\] is returned unchanged. *)
  let nearest_po2 x0  = 
  foreign_utility_function1
    "nearest_po2"
    2157319888L
    Int.s
    Conv.Int.to_ocaml
    Conv.Int.of_ocaml x0 

  (** Wraps \[param value\] between \[code\]0\[/code\] and the \[param length\]. If the limit is reached, the next value the function returns is decreased to the \[code\]0\[/code\] side or increased to the \[param length\] side (like a triangle wave). If \[param length\] is less than zero, it becomes positive.
\[codeblock\]
pingpong(-3.0, 3.0) # Returns 3.0
pingpong(-2.0, 3.0) # Returns 2.0
pingpong(-1.0, 3.0) # Returns 1.0
pingpong(0.0, 3.0)  # Returns 0.0
pingpong(1.0, 3.0)  # Returns 1.0
pingpong(2.0, 3.0)  # Returns 2.0
pingpong(3.0, 3.0)  # Returns 3.0
pingpong(4.0, 3.0)  # Returns 2.0
pingpong(5.0, 3.0)  # Returns 1.0
pingpong(6.0, 3.0)  # Returns 0.0
\[/codeblock\] *)
  let pingpong x0  x1  = 
  foreign_utility_function2
    "pingpong"
    92296394L
    Float.s
    Conv.Float.to_ocaml
    Conv.Float.of_ocaml Conv.Float.of_ocaml x0  x1 

  (** Randomizes the seed (or the internal state) of the random number generator. The current implementation uses a number based on the device''s time.
\[b\]Note:\[/b\] This function is called automatically when the project is run. If you need to fix the seed to have consistent, reproducible results, use \[method seed\] to initialize the random number generator. *)
  let randomize x0  = 
  foreign_utility_function0_void
    "randomize"
    1691721052L
    Void.s
    Conv.Void.to_ocaml
     x0 

  (** Returns a random unsigned 32-bit integer. Use remainder to obtain a random value in the interval \[code\]\[0, N - 1\]\[/code\] (where N is smaller than 2^32).
\[codeblocks\]
\[gdscript\]
randi()           # Returns random integer between 0 and 2^32 - 1
randi() % 20      # Returns random integer between 0 and 19
randi() % 100     # Returns random integer between 0 and 99
randi() % 100 + 1 # Returns random integer between 1 and 100
\[/gdscript\]
\[csharp\]
GD.Randi();           // Returns random integer between 0 and 2^32 - 1
GD.Randi() % 20;      // Returns random integer between 0 and 19
GD.Randi() % 100;     // Returns random integer between 0 and 99
GD.Randi() % 100 + 1; // Returns random integer between 1 and 100
\[/csharp\]
\[/codeblocks\] *)
  let randi x0  = 
  foreign_utility_function0
    "randi"
    701202648L
    Int.s
    Conv.Int.to_ocaml
     x0 

  (** Returns a random floating-point value between \[code\]0.0\[/code\] and \[code\]1.0\[/code\] (inclusive).
\[codeblocks\]
\[gdscript\]
randf() # Returns e.g. 0.375671
\[/gdscript\]
\[csharp\]
GD.Randf(); // Returns e.g. 0.375671
\[/csharp\]
\[/codeblocks\] *)
  let randf x0  = 
  foreign_utility_function0
    "randf"
    2086227845L
    Float.s
    Conv.Float.to_ocaml
     x0 

  (** Returns a random signed 32-bit integer between \[param from\] and \[param to\] (inclusive). If \[param to\] is lesser than \[param from\], they are swapped.
\[codeblocks\]
\[gdscript\]
randi_range(0, 1)      # Returns either 0 or 1
randi_range(-10, 1000) # Returns random integer between -10 and 1000
\[/gdscript\]
\[csharp\]
GD.RandRange(0, 1);      // Returns either 0 or 1
GD.RandRange(-10, 1000); // Returns random integer between -10 and 1000
\[/csharp\]
\[/codeblocks\] *)
  let randi_range x0  x1  = 
  foreign_utility_function2
    "randi_range"
    3133453818L
    Int.s
    Conv.Int.to_ocaml
    Conv.Int.of_ocaml Conv.Int.of_ocaml x0  x1 

  (** Returns a random floating-point value between \[param from\] and \[param to\] (inclusive).
\[codeblocks\]
\[gdscript\]
randf_range(0, 20.5) # Returns e.g. 7.45315
randf_range(-10, 10) # Returns e.g. -3.844535
\[/gdscript\]
\[csharp\]
GD.RandRange(0.0, 20.5);   // Returns e.g. 7.45315
GD.RandRange(-10.0, 10.0); // Returns e.g. -3.844535
\[/csharp\]
\[/codeblocks\] *)
  let randf_range x0  x1  = 
  foreign_utility_function2
    "randf_range"
    92296394L
    Float.s
    Conv.Float.to_ocaml
    Conv.Float.of_ocaml Conv.Float.of_ocaml x0  x1 

  (** Returns a \[url=https://en.wikipedia.org/wiki/Normal_distribution\]normally-distributed\[/url\], pseudo-random floating-point value from the specified \[param mean\] and a standard \[param deviation\]. This is also known as a Gaussian distribution.
\[b\]Note:\[/b\] This method uses the \[url=https://en.wikipedia.org/wiki/Box%E2%80%93Muller_transform\]Box-Muller transform\[/url\] algorithm. *)
  let randfn x0  x1  = 
  foreign_utility_function2
    "randfn"
    92296394L
    Float.s
    Conv.Float.to_ocaml
    Conv.Float.of_ocaml Conv.Float.of_ocaml x0  x1 

  (** Sets the seed for the random number generator to \[param base\]. Setting the seed manually can ensure consistent, repeatable results for most random functions.
\[codeblocks\]
\[gdscript\]
var my_seed = ""Godot Rocks"".hash()
seed(my_seed)
var a = randf() + randi()
seed(my_seed)
var b = randf() + randi()
# a and b are now identical
\[/gdscript\]
\[csharp\]
ulong mySeed = (ulong)GD.Hash(""Godot Rocks"");
GD.Seed(mySeed);
var a = GD.Randf() + GD.Randi();
GD.Seed(mySeed);
var b = GD.Randf() + GD.Randi();
// a and b are now identical
\[/csharp\]
\[/codeblocks\] *)
  let seed x0  = 
  foreign_utility_function1_void
    "seed"
    382931173L
    Void.s
    Conv.Void.to_ocaml
    Conv.Int.of_ocaml x0 

  (** Given a \[param seed\], returns a \[PackedInt64Array\] of size \[code\]2\[/code\], where its first element is the randomized \[int\] value, and the second element is the same as \[param seed\]. Passing the same \[param seed\] consistently returns the same array.
\[b\]Note:\[/b\] ""Seed"" here refers to the internal state of the pseudo random number generator, currently implemented as a 64 bit integer.
\[codeblock\]
var a = rand_from_seed(4)

print(a\[0\]) # Prints 2879024997
print(a\[1\]) # Prints 4
\[/codeblock\] *)
  let rand_from_seed x0  = 
  foreign_utility_function1
    "rand_from_seed"
    1391063685L
    PackedInt64Array.s
    Conv.PackedInt64Array.to_ocaml
    Conv.Int.of_ocaml x0 

  (** Returns a \[WeakRef\] instance holding a weak reference to \[param obj\]. Returns an empty \[WeakRef\] instance if \[param obj\] is \[code\]null\[/code\]. Prints an error and returns \[code\]null\[/code\] if \[param obj\] is neither \[Object\]-derived nor \[code\]null\[/code\].
A weak reference to an object is not enough to keep the object alive: when the only remaining references to a referent are weak references, garbage collection is free to destroy the referent and reuse its memory for something else. However, until the object is actually destroyed the weak reference may return the object even if there are no strong references to it. *)
  let weakref x0  = 
  foreign_utility_function1
    "weakref"
    4776452L
    Variant.s
    Conv.Variant.to_ocaml
    Conv.Variant.of_ocaml x0 

  (** Returns the internal type of the given \[param variable\], using the \[enum Variant.Type\] values.
\[codeblock\]
var json = JSON.new()
json.parse(''\[""a"", ""b"", ""c""\]'')
var result = json.get_data()
if result is Array:
    print(result\[0\]) # Prints ""a""
else:
    print(""Unexpected result!"")
\[/codeblock\]
See also \[method type_string\]. *)
  let typeof x0  = 
  foreign_utility_function1
    "typeof"
    326422594L
    Int.s
    Conv.Int.to_ocaml
    Conv.Variant.of_ocaml x0 

  (** Converts the given \[param variant\] to the given \[param type\], using the \[enum Variant.Type\] values. This method is generous with how it handles types, it can automatically convert between array types, convert numeric \[String\]s to \[int\], and converting most things to \[String\].
If the type conversion cannot be done, this method will return the default value for that type, for example converting \[Rect2\] to \[Vector2\] will always return \[constant Vector2.ZERO\]. This method will never show error messages as long as \[param type\] is a valid Variant type.
The returned value is a \[Variant\], but the data inside and its type will be the same as the requested type.
\[codeblock\]
type_convert(""Hi!"", TYPE_INT) # Returns 0
type_convert(""123"", TYPE_INT) # Returns 123
type_convert(123.4, TYPE_INT) # Returns 123
type_convert(5, TYPE_VECTOR2) # Returns (0, 0)
type_convert(""Hi!"", TYPE_NIL) # Returns null
\[/codeblock\] *)
  let type_convert x0  x1  = 
  foreign_utility_function2
    "type_convert"
    2453062746L
    Variant.s
    Conv.Variant.to_ocaml
    Conv.Variant.of_ocaml Conv.Int.of_ocaml x0  x1 

  (** Converts one or more arguments of any \[Variant\] type to a \[String\] in the best way possible.
\[codeblock\]
var a = \[10, 20, 30\]
var b = str(a)
print(len(a)) # Prints 3 (the number of elements in the array).
print(len(b)) # Prints 12 (the length of the string ""\[10, 20, 30\]"").
\[/codeblock\] *)
  let str x0  = 
  foreign_utility_function1
    "str"
    32569176L
    String.s
    Conv.String.to_ocaml
    Conv.Variant.of_ocaml x0 

  (** Returns a human-readable name for the given \[enum Error\] code.
\[codeblock\]
print(OK)                              # Prints 0
print(error_string(OK))                # Prints ""OK""
print(error_string(ERR_BUSY))          # Prints ""Busy""
print(error_string(ERR_OUT_OF_MEMORY)) # Prints ""Out of memory""
\[/codeblock\] *)
  let error_string x0  = 
  foreign_utility_function1
    "error_string"
    942708242L
    String.s
    Conv.String.to_ocaml
    Conv.Int.of_ocaml x0 

  (** Returns a human-readable name of the given \[param type\], using the \[enum Variant.Type\] values.
\[codeblock\]
print(TYPE_INT) # Prints 2
print(type_string(TYPE_INT)) # Prints ""int""
print(type_string(TYPE_STRING)) # Prints ""String""
\[/codeblock\]
See also \[method typeof\]. *)
  let type_string x0  = 
  foreign_utility_function1
    "type_string"
    942708242L
    String.s
    Conv.String.to_ocaml
    Conv.Int.of_ocaml x0 

  (** Converts one or more arguments of any type to string in the best way possible and prints them to the console.
\[codeblocks\]
\[gdscript\]
var a = \[1, 2, 3\]
print(""a"", ""b"", a) # Prints ""ab\[1, 2, 3\]""
\[/gdscript\]
\[csharp\]
Godot.Collections.Array a = \[1, 2, 3\];
GD.Print(""a"", ""b"", a); // Prints ""ab\[1, 2, 3\]""
\[/csharp\]
\[/codeblocks\]
\[b\]Note:\[/b\] Consider using \[method push_error\] and \[method push_warning\] to print error and warning messages instead of \[method print\] or \[method print_rich\]. This distinguishes them from print messages used for debugging purposes, while also displaying a stack trace when an error or warning is printed. See also \[member Engine.print_to_stdout\] and \[member ProjectSettings.application/run/disable_stdout\]. *)
  let print x0  = 
  foreign_utility_function1_void
    "print"
    2648703342L
    Void.s
    Conv.Void.to_ocaml
    Conv.Variant.of_ocaml x0 

  (** Converts one or more arguments of any type to string in the best way possible and prints them to the console.
The following BBCode tags are supported: \[code\]b\[/code\], \[code\]i\[/code\], \[code\]u\[/code\], \[code\]s\[/code\], \[code\]indent\[/code\], \[code\]code\[/code\], \[code\]url\[/code\], \[code\]center\[/code\], \[code\]right\[/code\], \[code\]color\[/code\], \[code\]bgcolor\[/code\], \[code\]fgcolor\[/code\].
URL tags only support URLs wrapped by a URL tag, not URLs with a different title.
When printing to standard output, the supported subset of BBCode is converted to ANSI escape codes for the terminal emulator to display. Support for ANSI escape codes varies across terminal emulators, especially for italic and strikethrough. In standard output, \[code\]code\[/code\] is represented with faint text but without any font change. Unsupported tags are left as-is in standard output.
\[codeblocks\]
\[gdscript skip-lint\]
print_rich(""\[color=green\]\[b\]Hello world!\[/b\]\[/color\]"") # Prints ""Hello world!"", in green with a bold font.
\[/gdscript\]
\[csharp skip-lint\]
GD.PrintRich(""\[color=green\]\[b\]Hello world!\[/b\]\[/color\]""); // Prints ""Hello world!"", in green with a bold font.
\[/csharp\]
\[/codeblocks\]
\[b\]Note:\[/b\] Consider using \[method push_error\] and \[method push_warning\] to print error and warning messages instead of \[method print\] or \[method print_rich\]. This distinguishes them from print messages used for debugging purposes, while also displaying a stack trace when an error or warning is printed.
\[b\]Note:\[/b\] On Windows, only Windows 10 and later correctly displays ANSI escape codes in standard output.
\[b\]Note:\[/b\] Output displayed in the editor supports clickable \[code skip-lint\]\[url=address\]text\[/url\]\[/code\] tags. The \[code skip-lint\]\[url\]\[/code\] tag''s \[code\]address\[/code\] value is handled by \[method OS.shell_open\] when clicked. *)
  let print_rich x0  = 
  foreign_utility_function1_void
    "print_rich"
    2648703342L
    Void.s
    Conv.Void.to_ocaml
    Conv.Variant.of_ocaml x0 

  (** Prints one or more arguments to strings in the best way possible to standard error line.
\[codeblocks\]
\[gdscript\]
printerr(""prints to stderr"")
\[/gdscript\]
\[csharp\]
GD.PrintErr(""prints to stderr"");
\[/csharp\]
\[/codeblocks\] *)
  let printerr x0  = 
  foreign_utility_function1_void
    "printerr"
    2648703342L
    Void.s
    Conv.Void.to_ocaml
    Conv.Variant.of_ocaml x0 

  (** Prints one or more arguments to the console with a tab between each argument.
\[codeblocks\]
\[gdscript\]
printt(""A"", ""B"", ""C"") # Prints ""A       B       C""
\[/gdscript\]
\[csharp\]
GD.PrintT(""A"", ""B"", ""C""); // Prints ""A       B       C""
\[/csharp\]
\[/codeblocks\] *)
  let printt x0  = 
  foreign_utility_function1_void
    "printt"
    2648703342L
    Void.s
    Conv.Void.to_ocaml
    Conv.Variant.of_ocaml x0 

  (** Prints one or more arguments to the console with a space between each argument.
\[codeblocks\]
\[gdscript\]
prints(""A"", ""B"", ""C"") # Prints ""A B C""
\[/gdscript\]
\[csharp\]
GD.PrintS(""A"", ""B"", ""C""); // Prints ""A B C""
\[/csharp\]
\[/codeblocks\] *)
  let prints x0  = 
  foreign_utility_function1_void
    "prints"
    2648703342L
    Void.s
    Conv.Void.to_ocaml
    Conv.Variant.of_ocaml x0 

  (** Prints one or more arguments to strings in the best way possible to the OS terminal. Unlike \[method print\], no newline is automatically added at the end.
\[b\]Note:\[/b\] The OS terminal is \[i\]not\[/i\] the same as the editor''s Output dock. The output sent to the OS terminal can be seen when running Godot from a terminal. On Windows, this requires using the \[code\]console.exe\[/code\] executable.
\[codeblocks\]
\[gdscript\]
# Prints ""ABC"" to terminal.
printraw(""A"")
printraw(""B"")
printraw(""C"")
\[/gdscript\]
\[csharp\]
// Prints ""ABC"" to terminal.
GD.PrintRaw(""A"");
GD.PrintRaw(""B"");
GD.PrintRaw(""C"");
\[/csharp\]
\[/codeblocks\] *)
  let printraw x0  = 
  foreign_utility_function1_void
    "printraw"
    2648703342L
    Void.s
    Conv.Void.to_ocaml
    Conv.Variant.of_ocaml x0 

  (** If verbose mode is enabled (\[method OS.is_stdout_verbose\] returning \[code\]true\[/code\]), converts one or more arguments of any type to string in the best way possible and prints them to the console. *)
  let print_verbose x0  = 
  foreign_utility_function1_void
    "print_verbose"
    2648703342L
    Void.s
    Conv.Void.to_ocaml
    Conv.Variant.of_ocaml x0 

  (** Pushes an error message to Godot''s built-in debugger and to the OS terminal.
\[codeblocks\]
\[gdscript\]
push_error(""test error"") # Prints ""test error"" to debugger and terminal as an error.
\[/gdscript\]
\[csharp\]
GD.PushError(""test error""); // Prints ""test error"" to debugger and terminal as an error.
\[/csharp\]
\[/codeblocks\]
\[b\]Note:\[/b\] This function does not pause project execution. To print an error message and pause project execution in debug builds, use \[code\]assert(false, ""test error"")\[/code\] instead. *)
  let push_error x0  = 
  foreign_utility_function1_void
    "push_error"
    2648703342L
    Void.s
    Conv.Void.to_ocaml
    Conv.Variant.of_ocaml x0 

  (** Pushes a warning message to Godot''s built-in debugger and to the OS terminal.
\[codeblocks\]
\[gdscript\]
push_warning(""test warning"") # Prints ""test warning"" to debugger and terminal as a warning.
\[/gdscript\]
\[csharp\]
GD.PushWarning(""test warning""); // Prints ""test warning"" to debugger and terminal as a warning.
\[/csharp\]
\[/codeblocks\] *)
  let push_warning x0  = 
  foreign_utility_function1_void
    "push_warning"
    2648703342L
    Void.s
    Conv.Void.to_ocaml
    Conv.Variant.of_ocaml x0 

  (** Converts a \[Variant\] \[param variable\] to a formatted \[String\] that can then be parsed using \[method str_to_var\].
\[codeblocks\]
\[gdscript\]
var a = \{! ""a"": 1, ""b"": 2 \}
print(var_to_str(a))
\[/gdscript\]
\[csharp\]
var a = new Godot.Collections.Dictionary \{! \[""a""\] = 1, \[""b""\] = 2 \};
GD.Print(GD.VarToStr(a));
\[/csharp\]
\[/codeblocks\]
Prints:
\[codeblock lang=text\]
\{!
    ""a"": 1,
    ""b"": 2
\}
\[/codeblock\]
\[b\]Note:\[/b\] Converting \[Signal\] or \[Callable\] is not supported and will result in an empty value for these types, regardless of their data. *)
  let var_to_str x0  = 
  foreign_utility_function1
    "var_to_str"
    866625479L
    String.s
    Conv.String.to_ocaml
    Conv.Variant.of_ocaml x0 

  (** Converts a formatted \[param string\] that was returned by \[method var_to_str\] to the original \[Variant\].
\[codeblocks\]
\[gdscript\]
var data = ''\{! ""a"": 1, ""b"": 2 \}'' # data is a String
var dict = str_to_var(data)     # dict is a Dictionary
print(dict\[""a""\])                # Prints 1
\[/gdscript\]
\[csharp\]
string data = ""\{! \""a\"": 1, \""b\"": 2 \}"";           // data is a string
var dict = GD.StrToVar(data).AsGodotDictionary(); // dict is a Dictionary
GD.Print(dict\[""a""\]);                              // Prints 1
\[/csharp\]
\[/codeblocks\] *)
  let str_to_var x0  = 
  foreign_utility_function1
    "str_to_var"
    1891498491L
    Variant.s
    Conv.Variant.to_ocaml
    Conv.String.of_ocaml x0 

  (** Encodes a \[Variant\] value to a byte array, without encoding objects. Deserialization can be done with \[method bytes_to_var\].
\[b\]Note:\[/b\] If you need object serialization, see \[method var_to_bytes_with_objects\].
\[b\]Note:\[/b\] Encoding \[Callable\] is not supported and will result in an empty value, regardless of the data. *)
  let var_to_bytes x0  = 
  foreign_utility_function1
    "var_to_bytes"
    2947269930L
    PackedByteArray.s
    Conv.PackedByteArray.to_ocaml
    Conv.Variant.of_ocaml x0 

  (** Decodes a byte array back to a \[Variant\] value, without decoding objects.
\[b\]Note:\[/b\] If you need object deserialization, see \[method bytes_to_var_with_objects\]. *)
  let bytes_to_var x0  = 
  foreign_utility_function1
    "bytes_to_var"
    4249819452L
    Variant.s
    Conv.Variant.to_ocaml
    Conv.PackedByteArray.of_ocaml x0 

  (** Encodes a \[Variant\] value to a byte array. Encoding objects is allowed (and can potentially include executable code). Deserialization can be done with \[method bytes_to_var_with_objects\].
\[b\]Note:\[/b\] Encoding \[Callable\] is not supported and will result in an empty value, regardless of the data. *)
  let var_to_bytes_with_objects x0  = 
  foreign_utility_function1
    "var_to_bytes_with_objects"
    2947269930L
    PackedByteArray.s
    Conv.PackedByteArray.to_ocaml
    Conv.Variant.of_ocaml x0 

  (** Decodes a byte array back to a \[Variant\] value. Decoding objects is allowed.
\[b\]Warning:\[/b\] Deserialized object can contain code which gets executed. Do not use this option if the serialized object comes from untrusted sources to avoid potential security threats (remote code execution). *)
  let bytes_to_var_with_objects x0  = 
  foreign_utility_function1
    "bytes_to_var_with_objects"
    4249819452L
    Variant.s
    Conv.Variant.to_ocaml
    Conv.PackedByteArray.of_ocaml x0 

  (** Returns the integer hash of the passed \[param variable\].
\[codeblocks\]
\[gdscript\]
print(hash(""a"")) # Prints 177670
\[/gdscript\]
\[csharp\]
GD.Print(GD.Hash(""a"")); // Prints 177670
\[/csharp\]
\[/codeblocks\] *)
  let hash x0  = 
  foreign_utility_function1
    "hash"
    326422594L
    Int.s
    Conv.Int.to_ocaml
    Conv.Variant.of_ocaml x0 

  (** Returns the \[Object\] that corresponds to \[param instance_id\]. All Objects have a unique instance ID. See also \[method Object.get_instance_id\].
\[codeblocks\]
\[gdscript\]
var drink = ""water""

func _ready():
    var id = get_instance_id()
    var instance = instance_from_id(id)
    print(instance.foo) # Prints ""water""
\[/gdscript\]
\[csharp\]
public partial class MyNode : Node
\{!
    public string Drink \{! get; set; \} = ""water"";

    public override void _Ready()
    \{!
        ulong id = GetInstanceId();
        var instance = (MyNode)InstanceFromId(Id);
        GD.Print(instance.Drink); // Prints ""water""
    \}
\}
\[/csharp\]
\[/codeblocks\] *)
  let instance_from_id x0  = 
  foreign_utility_function1
    "instance_from_id"
    1156694636L
    Object.s
    Conv.Object.to_ocaml
    Conv.Int.of_ocaml x0 

  (** Returns \[code\]true\[/code\] if the Object that corresponds to \[param id\] is a valid object (e.g. has not been deleted from memory). All Objects have a unique instance ID. *)
  let is_instance_id_valid x0  = 
  foreign_utility_function1
    "is_instance_id_valid"
    2232439758L
    Bool.s
    Conv.Bool.to_ocaml
    Conv.Int.of_ocaml x0 

  (** Returns \[code\]true\[/code\] if \[param instance\] is a valid Object (e.g. has not been deleted from memory). *)
  let is_instance_valid x0  = 
  foreign_utility_function1
    "is_instance_valid"
    996128841L
    Bool.s
    Conv.Bool.to_ocaml
    Conv.Variant.of_ocaml x0 

  (** Allocates a unique ID which can be used by the implementation to construct an RID. This is used mainly from native extensions to implement servers. *)
  let rid_allocate_id x0  = 
  foreign_utility_function0
    "rid_allocate_id"
    701202648L
    Int.s
    Conv.Int.to_ocaml
     x0 

  (** Creates an RID from a \[param base\]. This is used mainly from native extensions to build servers. *)
  let rid_from_int64 x0  = 
  foreign_utility_function1
    "rid_from_int64"
    3426892196L
    RID.s
    Conv.RID.to_ocaml
    Conv.Int.of_ocaml x0 

  (** Returns \[code\]true\[/code\], for value types, if \[param a\] and \[param b\] share the same value. Returns \[code\]true\[/code\], for reference types, if the references of \[param a\] and \[param b\] are the same.
\[codeblock\]
# Vector2 is a value type
var vec2_a = Vector2(0, 0)
var vec2_b = Vector2(0, 0)
var vec2_c = Vector2(1, 1)
is_same(vec2_a, vec2_a)  # true
is_same(vec2_a, vec2_b)  # true
is_same(vec2_a, vec2_c)  # false

# Array is a reference type
var arr_a = \[\]
var arr_b = \[\]
is_same(arr_a, arr_a)  # true
is_same(arr_a, arr_b)  # false
\[/codeblock\]
These are \[Variant\] value types: \[code\]null\[/code\], \[bool\], \[int\], \[float\], \[String\], \[StringName\], \[Vector2\], \[Vector2i\], \[Vector3\], \[Vector3i\], \[Vector4\], \[Vector4i\], \[Rect2\], \[Rect2i\], \[Transform2D\], \[Transform3D\], \[Plane\], \[Quaternion\], \[AABB\], \[Basis\], \[Projection\], \[Color\], \[NodePath\], \[RID\], \[Callable\] and \[Signal\].
These are \[Variant\] reference types: \[Object\], \[Dictionary\], \[Array\], \[PackedByteArray\], \[PackedInt32Array\], \[PackedInt64Array\], \[PackedFloat32Array\], \[PackedFloat64Array\], \[PackedStringArray\], \[PackedVector2Array\], \[PackedVector3Array\], \[PackedVector4Array\], and \[PackedColorArray\]. *)
  let is_same x0  x1  = 
  foreign_utility_function2
    "is_same"
    1409423524L
    Bool.s
    Conv.Bool.to_ocaml
    Conv.Variant.of_ocaml Conv.Variant.of_ocaml x0  x1 
  end

module BuiltinClass0 = struct
  module Object = struct
    include ApiTypes.Object


    end


  module Variant = struct
    include ApiTypes.Variant


    end


  module Nil = struct
    include ApiTypes.Nil


    end


  module Bool = struct
    include ApiTypes.Bool


    end


  module Int = struct
    include ApiTypes.Int


    end


  module Float = struct
    include ApiTypes.Float


    end


  module String = struct
    include ApiTypes.String


    end


  module Vector2 = struct
    include ApiTypes.Vector2

    module Axis = struct
      include ApiTypes.Int
      end

    end


  module Vector2i = struct
    include ApiTypes.Vector2i

    module Axis = struct
      include ApiTypes.Int
      end

    end


  module Rect2 = struct
    include ApiTypes.Rect2


    end


  module Rect2i = struct
    include ApiTypes.Rect2i


    end


  module Vector3 = struct
    include ApiTypes.Vector3

    module Axis = struct
      include ApiTypes.Int
      end

    end


  module Vector3i = struct
    include ApiTypes.Vector3i

    module Axis = struct
      include ApiTypes.Int
      end

    end


  module Transform2D = struct
    include ApiTypes.Transform2D


    end


  module Vector4 = struct
    include ApiTypes.Vector4

    module Axis = struct
      include ApiTypes.Int
      end

    end


  module Vector4i = struct
    include ApiTypes.Vector4i

    module Axis = struct
      include ApiTypes.Int
      end

    end


  module Plane = struct
    include ApiTypes.Plane


    end


  module Quaternion = struct
    include ApiTypes.Quaternion


    end


  module AABB = struct
    include ApiTypes.AABB


    end


  module Basis = struct
    include ApiTypes.Basis


    end


  module Transform3D = struct
    include ApiTypes.Transform3D


    end


  module Projection = struct
    include ApiTypes.Projection

    module Planes = struct
      include ApiTypes.Int
      end

    end


  module Color = struct
    include ApiTypes.Color


    end


  module StringName = struct
    include ApiTypes.StringName


    end


  module NodePath = struct
    include ApiTypes.NodePath


    end


  module RID = struct
    include ApiTypes.RID


    end


  module Callable = struct
    include ApiTypes.Callable


    end


  module Signal = struct
    include ApiTypes.Signal


    end


  module Dictionary = struct
    include ApiTypes.Dictionary


    end


  module Array = struct
    include ApiTypes.Array


    end


  module PackedByteArray = struct
    include ApiTypes.PackedByteArray


    end


  module PackedInt32Array = struct
    include ApiTypes.PackedInt32Array


    end


  module PackedInt64Array = struct
    include ApiTypes.PackedInt64Array


    end


  module PackedFloat32Array = struct
    include ApiTypes.PackedFloat32Array


    end


  module PackedFloat64Array = struct
    include ApiTypes.PackedFloat64Array


    end


  module PackedStringArray = struct
    include ApiTypes.PackedStringArray


    end


  module PackedVector2Array = struct
    include ApiTypes.PackedVector2Array


    end


  module PackedVector3Array = struct
    include ApiTypes.PackedVector3Array


    end


  module PackedColorArray = struct
    include ApiTypes.PackedColorArray


    end


  module PackedVector4Array = struct
    include ApiTypes.PackedVector4Array


    end

  end

module BuiltinClass = struct
  module type NIL = sig
    type t


    include Api_types.API_TYPE with type t := t










    val not : 
    (Nil.t structure ptr -> Nil.t structure ptr -> Bool.t structure ptr)






































































































































    val mem_Dictionary : 
    (Nil.t structure ptr -> Dictionary.t structure ptr -> Bool.t structure ptr)






    val mem_Array : 
    (Nil.t structure ptr -> Array.t structure ptr -> Bool.t structure ptr)








































    end

  module type BOOL = sig
    type t


    include Api_types.API_TYPE with type t := t














    val not : 
    (Bool.t structure ptr -> Bool.t structure ptr -> Bool.t structure ptr)

    (** Returns \[code\]true\[/code\] if the two booleans are equal. That is, both are \[code\]true\[/code\] or both are \[code\]false\[/code\]. This operation can be seen as a logical EQ or XNOR. *)
    val (=) : 
    (Bool.t structure ptr -> Bool.t structure ptr -> Bool.t structure ptr)

    (** Returns \[code\]true\[/code\] if the two booleans are not equal. That is, one is \[code\]true\[/code\] and the other is \[code\]false\[/code\]. This operation can be seen as a logical XOR. *)
    val (<>) : 
    (Bool.t structure ptr -> Bool.t structure ptr -> Bool.t structure ptr)

    (** Returns \[code\]true\[/code\] if the left operand is \[code\]false\[/code\] and the right operand is \[code\]true\[/code\]. *)
    val (<) : 
    (Bool.t structure ptr -> Bool.t structure ptr -> Bool.t structure ptr)

    (** Returns \[code\]true\[/code\] if the left operand is \[code\]true\[/code\] and the right operand is \[code\]false\[/code\]. *)
    val (>) : 
    (Bool.t structure ptr -> Bool.t structure ptr -> Bool.t structure ptr)


    val (&&) : 
    (Bool.t structure ptr -> Bool.t structure ptr -> Bool.t structure ptr)


    val (||) : 
    (Bool.t structure ptr -> Bool.t structure ptr -> Bool.t structure ptr)


    val xor : 
    (Bool.t structure ptr -> Bool.t structure ptr -> Bool.t structure ptr)




















    val mem_Dictionary : 
    (Bool.t structure ptr -> Dictionary.t structure ptr -> Bool.t structure ptr)


    val mem_Array : 
    (Bool.t structure ptr -> Array.t structure ptr -> Bool.t structure ptr)
    end

  module type INT = sig
    type t


    include Api_types.API_TYPE with type t := t







    (** Returns the negated value of the \[int\]. If positive, turns the number negative. If negative, turns the number positive. If zero, does nothing. *)
    val (~-) : 
    (Int.t structure ptr -> Int.t structure ptr -> Int.t structure ptr)

    (** Returns the same value as if the \[code\]+\[/code\] was not there. Unary \[code\]+\[/code\] does nothing, but sometimes it can make your code more readable. *)
    val (~+) : 
    (Int.t structure ptr -> Int.t structure ptr -> Int.t structure ptr)

    (** Performs the bitwise \[code\]NOT\[/code\] operation on the \[int\]. Due to \[url=https://en.wikipedia.org/wiki/Two%27s_complement\]2''s complement\[/url\], it''s effectively equal to \[code\]-(int + 1)\[/code\].
\[codeblock\]
print(~4) # Prints -5
print(~(-7)) # Prints 6
\[/codeblock\] *)
    val (~~~) : 
    (Int.t structure ptr -> Int.t structure ptr -> Int.t structure ptr)








    val not : 
    (Int.t structure ptr -> Int.t structure ptr -> Bool.t structure ptr)







    (** Returns \[code\]true\[/code\] if the two \[int\]s are equal. *)
    val (=) : 
    (Int.t structure ptr -> Int.t structure ptr -> Bool.t structure ptr)

    (** Returns \[code\]true\[/code\] if the \[int\]s are not equal. *)
    val (<>) : 
    (Int.t structure ptr -> Int.t structure ptr -> Bool.t structure ptr)

    (** Returns \[code\]true\[/code\] if the left \[int\] is less than the right \[int\]. *)
    val (<) : 
    (Int.t structure ptr -> Int.t structure ptr -> Bool.t structure ptr)

    (** Returns \[code\]true\[/code\] if the left \[int\] is less than or equal to the right \[int\]. *)
    val (<=) : 
    (Int.t structure ptr -> Int.t structure ptr -> Bool.t structure ptr)

    (** Returns \[code\]true\[/code\] if the left \[int\] is greater than the right \[int\]. *)
    val (>) : 
    (Int.t structure ptr -> Int.t structure ptr -> Bool.t structure ptr)

    (** Returns \[code\]true\[/code\] if the left \[int\] is greater than or equal to the right \[int\]. *)
    val (>=) : 
    (Int.t structure ptr -> Int.t structure ptr -> Bool.t structure ptr)

    (** Adds the two \[int\]s. *)
    val (+) : 
    (Int.t structure ptr -> Int.t structure ptr -> Int.t structure ptr)

    (** Subtracts the two \[int\]s. *)
    val (-) : 
    (Int.t structure ptr -> Int.t structure ptr -> Int.t structure ptr)

    (** Multiplies the two \[int\]s. *)
    val ( * ) : 
    (Int.t structure ptr -> Int.t structure ptr -> Int.t structure ptr)

    (** Divides the two \[int\]s. The result is an \[int\]. This will truncate the \[float\], discarding anything after the floating point.
\[codeblock\]
print(6 / 2) # Prints 3
print(5 / 3) # Prints 1
\[/codeblock\] *)
    val (/) : 
    (Int.t structure ptr -> Int.t structure ptr -> Int.t structure ptr)

    (** Returns the remainder after dividing two \[int\]s. Uses truncated division, which returns a negative number if the dividend is negative. If this is not desired, consider using \[method \@GlobalScope.posmod\].
\[codeblock\]
print(6 % 2) # Prints 0
print(11 % 4) # Prints 3
print(-5 % 3) # Prints -2
\[/codeblock\] *)
    val (%) : 
    (Int.t structure ptr -> Int.t structure ptr -> Int.t structure ptr)

    (** Raises the left \[int\] to a power of the right \[int\].
\[codeblock\]
print(3  *  *  4) # Prints 81
\[/codeblock\] *)
    val ( ** ) : 
    (Int.t structure ptr -> Int.t structure ptr -> Int.t structure ptr)

    (** Performs the bitwise shift left operation. Effectively the same as multiplying by a power of 2.
\[codeblock\]
print(0b1010 << 1) # Prints 20 (binary 10100)
print(0b1010 << 3) # Prints 80 (binary 1010000)
\[/codeblock\] *)
    val (<<<) : 
    (Int.t structure ptr -> Int.t structure ptr -> Int.t structure ptr)

    (** Performs the bitwise shift right operation. Effectively the same as dividing by a power of 2.
\[codeblock\]
print(0b1010 >> 1) # Prints 5 (binary 101)
print(0b1010 >> 2) # Prints 2 (binary 10)
\[/codeblock\] *)
    val (>>>) : 
    (Int.t structure ptr -> Int.t structure ptr -> Int.t structure ptr)

    (** Performs the bitwise \[code\]AND\[/code\] operation.
\[codeblock\]
print(0b1100 & 0b1010) # Prints 8 (binary 1000)
\[/codeblock\]
This is useful for retrieving binary flags from a variable.
\[codeblock\]
var flags = 0b101
# Check if the first or second bit are enabled.
if flags & 0b011:
    do_stuff() # This line will run.
\[/codeblock\] *)
    val (&&&) : 
    (Int.t structure ptr -> Int.t structure ptr -> Int.t structure ptr)

    (** Performs the bitwise \[code\]OR\[/code\] operation.
\[codeblock\]
print(0b1100 | 0b1010) # Prints 14 (binary 1110)
\[/codeblock\]
This is useful for storing binary flags in a variable.
\[codeblock\]
var flags = 0
flags |= 0b101 # Turn the first and third bits on.
\[/codeblock\] *)
    val (|||) : 
    (Int.t structure ptr -> Int.t structure ptr -> Int.t structure ptr)

    (** Performs the bitwise \[code\]XOR\[/code\] operation.
\[codeblock\]
print(0b1100 ^ 0b1010) # Prints 6 (binary 110)
\[/codeblock\] *)
    val (^^^) : 
    (Int.t structure ptr -> Int.t structure ptr -> Int.t structure ptr)


    val (&&) : 
    (Int.t structure ptr -> Int.t structure ptr -> Bool.t structure ptr)


    val (||) : 
    (Int.t structure ptr -> Int.t structure ptr -> Bool.t structure ptr)


    val xor : 
    (Int.t structure ptr -> Int.t structure ptr -> Bool.t structure ptr)




















































    val mem_Dictionary : 
    (Int.t structure ptr -> Dictionary.t structure ptr -> Bool.t structure ptr)


    val mem_Array : 
    (Int.t structure ptr -> Array.t structure ptr -> Bool.t structure ptr)


    val mem_PackedByteArray : 
    (Int.t structure ptr -> PackedByteArray.t structure ptr -> Bool.t structure ptr)


    val mem_PackedInt32Array : 
    (Int.t structure ptr -> PackedInt32Array.t structure ptr -> Bool.t structure ptr)


    val mem_PackedInt64Array : 
    (Int.t structure ptr -> PackedInt64Array.t structure ptr -> Bool.t structure ptr)


    val mem_PackedFloat32Array : 
    (Int.t structure ptr -> PackedFloat32Array.t structure ptr -> Bool.t structure ptr)


    val mem_PackedFloat64Array : 
    (Int.t structure ptr -> PackedFloat64Array.t structure ptr -> Bool.t structure ptr)
    end

  module type FLOAT = sig
    type t


    include Api_types.API_TYPE with type t := t







    (** Returns the negative value of the \[float\]. If positive, turns the number negative. If negative, turns the number positive. With floats, the number zero can be either positive or negative. *)
    val (~-) : 
    (Float.t structure ptr -> Float.t structure ptr -> Float.t structure ptr)

    (** Returns the same value as if the \[code\]+\[/code\] was not there. Unary \[code\]+\[/code\] does nothing, but sometimes it can make your code more readable. *)
    val (~+) : 
    (Float.t structure ptr -> Float.t structure ptr -> Float.t structure ptr)








    val not : 
    (Float.t structure ptr -> Float.t structure ptr -> Bool.t structure ptr)



































    (** Returns \[code\]true\[/code\] if both floats are exactly equal.
\[b\]Note:\[/b\] Due to floating-point precision errors, consider using \[method \@GlobalScope.is_equal_approx\] or \[method \@GlobalScope.is_zero_approx\] instead, which are more reliable.
\[b\]Note:\[/b\] \[constant \@GDScript.NAN\] doesn''t behave the same as other numbers. Therefore, the results from this operator may not be accurate if NaNs are included. *)
    val (=) : 
    (Float.t structure ptr -> Float.t structure ptr -> Bool.t structure ptr)

    (** Returns \[code\]true\[/code\] if two floats are different from each other.
\[b\]Note:\[/b\] \[constant \@GDScript.NAN\] doesn''t behave the same as other numbers. Therefore, the results from this operator may not be accurate if NaNs are included. *)
    val (<>) : 
    (Float.t structure ptr -> Float.t structure ptr -> Bool.t structure ptr)

    (** Returns \[code\]true\[/code\] if the left float is less than the right one.
\[b\]Note:\[/b\] \[constant \@GDScript.NAN\] doesn''t behave the same as other numbers. Therefore, the results from this operator may not be accurate if NaNs are included. *)
    val (<) : 
    (Float.t structure ptr -> Float.t structure ptr -> Bool.t structure ptr)

    (** Returns \[code\]true\[/code\] if the left float is less than or equal to the right one.
\[b\]Note:\[/b\] \[constant \@GDScript.NAN\] doesn''t behave the same as other numbers. Therefore, the results from this operator may not be accurate if NaNs are included. *)
    val (<=) : 
    (Float.t structure ptr -> Float.t structure ptr -> Bool.t structure ptr)

    (** Returns \[code\]true\[/code\] if the left float is greater than the right one.
\[b\]Note:\[/b\] \[constant \@GDScript.NAN\] doesn''t behave the same as other numbers. Therefore, the results from this operator may not be accurate if NaNs are included. *)
    val (>) : 
    (Float.t structure ptr -> Float.t structure ptr -> Bool.t structure ptr)

    (** Returns \[code\]true\[/code\] if the left float is greater than or equal to the right one.
\[b\]Note:\[/b\] \[constant \@GDScript.NAN\] doesn''t behave the same as other numbers. Therefore, the results from this operator may not be accurate if NaNs are included. *)
    val (>=) : 
    (Float.t structure ptr -> Float.t structure ptr -> Bool.t structure ptr)

    (** Adds two floats. *)
    val (+) : 
    (Float.t structure ptr -> Float.t structure ptr -> Float.t structure ptr)

    (** Subtracts a float from a float. *)
    val (-) : 
    (Float.t structure ptr -> Float.t structure ptr -> Float.t structure ptr)

    (** Multiplies two \[float\]s. *)
    val ( * ) : 
    (Float.t structure ptr -> Float.t structure ptr -> Float.t structure ptr)

    (** Divides two floats. *)
    val (/) : 
    (Float.t structure ptr -> Float.t structure ptr -> Float.t structure ptr)

    (** Raises a \[float\] to a power of a \[float\].
\[codeblock\]
print(39.0625 *  * 0.25) # 2.5
\[/codeblock\] *)
    val ( ** ) : 
    (Float.t structure ptr -> Float.t structure ptr -> Float.t structure ptr)


    val (&&) : 
    (Float.t structure ptr -> Float.t structure ptr -> Bool.t structure ptr)


    val (||) : 
    (Float.t structure ptr -> Float.t structure ptr -> Bool.t structure ptr)


    val xor : 
    (Float.t structure ptr -> Float.t structure ptr -> Bool.t structure ptr)
























    val mem_Dictionary : 
    (Float.t structure ptr -> Dictionary.t structure ptr -> Bool.t structure ptr)


    val mem_Array : 
    (Float.t structure ptr -> Array.t structure ptr -> Bool.t structure ptr)


    val mem_PackedByteArray : 
    (Float.t structure ptr -> PackedByteArray.t structure ptr -> Bool.t structure ptr)


    val mem_PackedInt32Array : 
    (Float.t structure ptr -> PackedInt32Array.t structure ptr -> Bool.t structure ptr)


    val mem_PackedInt64Array : 
    (Float.t structure ptr -> PackedInt64Array.t structure ptr -> Bool.t structure ptr)


    val mem_PackedFloat32Array : 
    (Float.t structure ptr -> PackedFloat32Array.t structure ptr -> Bool.t structure ptr)


    val mem_PackedFloat64Array : 
    (Float.t structure ptr -> PackedFloat64Array.t structure ptr -> Bool.t structure ptr)
    end

  module type STRING = sig
    type t


    include Api_types.API_TYPE with type t := t



    (** Performs a case-sensitive comparison to another string. Returns \[code\]-1\[/code\] if less than, \[code\]1\[/code\] if greater than, or \[code\]0\[/code\] if equal. ""Less than"" and ""greater than"" are determined by the \[url=https://en.wikipedia.org/wiki/List_of_Unicode_characters\]Unicode code points\[/url\] of each string, which roughly matches the alphabetical order.
With different string lengths, returns \[code\]1\[/code\] if this string is longer than the \[param to\] string, or \[code\]-1\[/code\] if shorter. Note that the length of empty strings is \[i\]always\[/i\] \[code\]0\[/code\].
To get a \[bool\] result from a string comparison, use the \[code\]==\[/code\] operator instead. See also \[method nocasecmp_to\], \[method filecasecmp_to\], and \[method naturalcasecmp_to\]. *)
    val casecmp_to : 
    (BuiltinClass0.String.t structure ptr -> BuiltinClass0.String.t structure ptr -> BuiltinClass0.Int.t structure ptr)

    (** Performs a \[b\]case-insensitive\[/b\] comparison to another string. Returns \[code\]-1\[/code\] if less than, \[code\]1\[/code\] if greater than, or \[code\]0\[/code\] if equal. ""Less than"" or ""greater than"" are determined by the \[url=https://en.wikipedia.org/wiki/List_of_Unicode_characters\]Unicode code points\[/url\] of each string, which roughly matches the alphabetical order. Internally, lowercase characters are converted to uppercase for the comparison.
With different string lengths, returns \[code\]1\[/code\] if this string is longer than the \[param to\] string, or \[code\]-1\[/code\] if shorter. Note that the length of empty strings is \[i\]always\[/i\] \[code\]0\[/code\].
To get a \[bool\] result from a string comparison, use the \[code\]==\[/code\] operator instead. See also \[method casecmp_to\], \[method filenocasecmp_to\], and \[method naturalnocasecmp_to\]. *)
    val nocasecmp_to : 
    (BuiltinClass0.String.t structure ptr -> BuiltinClass0.String.t structure ptr -> BuiltinClass0.Int.t structure ptr)

    (** Performs a \[b\]case-sensitive\[/b\], \[i\]natural order\[/i\] comparison to another string. Returns \[code\]-1\[/code\] if less than, \[code\]1\[/code\] if greater than, or \[code\]0\[/code\] if equal. ""Less than"" or ""greater than"" are determined by the \[url=https://en.wikipedia.org/wiki/List_of_Unicode_characters\]Unicode code points\[/url\] of each string, which roughly matches the alphabetical order.
When used for sorting, natural order comparison orders sequences of numbers by the combined value of each digit as is often expected, instead of the single digit''s value. A sorted sequence of numbered strings will be \[code\]\[""1"", ""2"", ""3"", ...\]\[/code\], not \[code\]\[""1"", ""10"", ""2"", ""3"", ...\]\[/code\].
With different string lengths, returns \[code\]1\[/code\] if this string is longer than the \[param to\] string, or \[code\]-1\[/code\] if shorter. Note that the length of empty strings is \[i\]always\[/i\] \[code\]0\[/code\].
To get a \[bool\] result from a string comparison, use the \[code\]==\[/code\] operator instead. See also \[method naturalnocasecmp_to\], \[method filecasecmp_to\], and \[method nocasecmp_to\]. *)
    val naturalcasecmp_to : 
    (BuiltinClass0.String.t structure ptr -> BuiltinClass0.String.t structure ptr -> BuiltinClass0.Int.t structure ptr)

    (** Performs a \[b\]case-insensitive\[/b\], \[i\]natural order\[/i\] comparison to another string. Returns \[code\]-1\[/code\] if less than, \[code\]1\[/code\] if greater than, or \[code\]0\[/code\] if equal. ""Less than"" or ""greater than"" are determined by the \[url=https://en.wikipedia.org/wiki/List_of_Unicode_characters\]Unicode code points\[/url\] of each string, which roughly matches the alphabetical order. Internally, lowercase characters are converted to uppercase for the comparison.
When used for sorting, natural order comparison orders sequences of numbers by the combined value of each digit as is often expected, instead of the single digit''s value. A sorted sequence of numbered strings will be \[code\]\[""1"", ""2"", ""3"", ...\]\[/code\], not \[code\]\[""1"", ""10"", ""2"", ""3"", ...\]\[/code\].
With different string lengths, returns \[code\]1\[/code\] if this string is longer than the \[param to\] string, or \[code\]-1\[/code\] if shorter. Note that the length of empty strings is \[i\]always\[/i\] \[code\]0\[/code\].
To get a \[bool\] result from a string comparison, use the \[code\]==\[/code\] operator instead. See also \[method naturalcasecmp_to\], \[method filenocasecmp_to\], and \[method casecmp_to\]. *)
    val naturalnocasecmp_to : 
    (BuiltinClass0.String.t structure ptr -> BuiltinClass0.String.t structure ptr -> BuiltinClass0.Int.t structure ptr)

    (** Like \[method naturalcasecmp_to\] but prioritizes strings that begin with periods (\[code\].\[/code\]) and underscores (\[code\]_\[/code\]) before any other character. Useful when sorting folders or file names.
To get a \[bool\] result from a string comparison, use the \[code\]==\[/code\] operator instead. See also \[method filenocasecmp_to\], \[method naturalcasecmp_to\], and \[method casecmp_to\]. *)
    val filecasecmp_to : 
    (BuiltinClass0.String.t structure ptr -> BuiltinClass0.String.t structure ptr -> BuiltinClass0.Int.t structure ptr)

    (** Like \[method naturalnocasecmp_to\] but prioritizes strings that begin with periods (\[code\].\[/code\]) and underscores (\[code\]_\[/code\]) before any other character. Useful when sorting folders or file names.
To get a \[bool\] result from a string comparison, use the \[code\]==\[/code\] operator instead. See also \[method filecasecmp_to\], \[method naturalnocasecmp_to\], and \[method nocasecmp_to\]. *)
    val filenocasecmp_to : 
    (BuiltinClass0.String.t structure ptr -> BuiltinClass0.String.t structure ptr -> BuiltinClass0.Int.t structure ptr)

    (** Returns the number of characters in the string. Empty strings (\[code\]""""\[/code\]) always return \[code\]0\[/code\]. See also \[method is_empty\]. *)
    val length : 
    (BuiltinClass0.String.t structure ptr -> BuiltinClass0.Int.t structure ptr)

    (** Returns part of the string from the position \[param from\] with length \[param len\]. If \[param len\] is \[code\]-1\[/code\] (as by default), returns the rest of the string starting from the given position. *)
    val substr : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.Int.t structure ptr -> BuiltinClass0.String.t structure ptr -> BuiltinClass0.String.t structure ptr)

    (** Splits the string using a \[param delimiter\] and returns the substring at index \[param slice\]. Returns the original string if \[param delimiter\] does not occur in the string. Returns an empty string if the \[param slice\] does not exist.
This is faster than \[method split\], if you only need one substring.
\[codeblock\]
print(""i/am/example/hi"".get_slice(""/"", 2)) # Prints ""example""
\[/codeblock\] *)
    val get_slice : 
    (BuiltinClass0.String.t structure ptr -> BuiltinClass0.Int.t structure ptr -> BuiltinClass0.String.t structure ptr -> BuiltinClass0.String.t structure ptr)

    (** Splits the string using a Unicode character with code \[param delimiter\] and returns the substring at index \[param slice\]. Returns an empty string if the \[param slice\] does not exist.
This is faster than \[method split\], if you only need one substring. *)
    val get_slicec : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.Int.t structure ptr -> BuiltinClass0.String.t structure ptr -> BuiltinClass0.String.t structure ptr)

    (** Returns the total number of slices when the string is split with the given \[param delimiter\] (see \[method split\]). *)
    val get_slice_count : 
    (BuiltinClass0.String.t structure ptr -> BuiltinClass0.String.t structure ptr -> BuiltinClass0.Int.t structure ptr)

    (** Returns the index of the \[b\]first\[/b\] occurrence of \[param what\] in this string, or \[code\]-1\[/code\] if there are none. The search''s start can be specified with \[param from\], continuing to the end of the string.
\[codeblocks\]
\[gdscript\]
print(""Team"".find(""I"")) # Prints -1

print(""Potato"".find(""t""))    # Prints 2
print(""Potato"".find(""t"", 3)) # Prints 4
print(""Potato"".find(""t"", 5)) # Prints -1
\[/gdscript\]
\[csharp\]
GD.Print(""Team"".Find(""I"")); // Prints -1

GD.Print(""Potato"".Find(""t""));    // Prints 2
GD.Print(""Potato"".Find(""t"", 3)); // Prints 4
GD.Print(""Potato"".Find(""t"", 5)); // Prints -1
\[/csharp\]
\[/codeblocks\]
\[b\]Note:\[/b\] If you just want to know whether the string contains \[param what\], use \[method contains\]. In GDScript, you may also use the \[code\]in\[/code\] operator. *)
    val find : 
    (BuiltinClass0.String.t structure ptr -> BuiltinClass0.Int.t structure ptr -> BuiltinClass0.String.t structure ptr -> BuiltinClass0.Int.t structure ptr)

    (** Returns the index of the \[b\]first\[/b\] \[b\]case-insensitive\[/b\] occurrence of \[param what\] in this string, or \[code\]-1\[/code\] if there are none. The starting search index can be specified with \[param from\], continuing to the end of the string. *)
    val findn : 
    (BuiltinClass0.String.t structure ptr -> BuiltinClass0.Int.t structure ptr -> BuiltinClass0.String.t structure ptr -> BuiltinClass0.Int.t structure ptr)

    (** Returns the number of occurrences of the substring \[param what\] between \[param from\] and \[param to\] positions. If \[param to\] is 0, the search continues until the end of the string. *)
    val count : 
    (BuiltinClass0.String.t structure ptr -> BuiltinClass0.Int.t structure ptr -> BuiltinClass0.Int.t structure ptr -> BuiltinClass0.String.t structure ptr -> BuiltinClass0.Int.t structure ptr)

    (** Returns the number of occurrences of the substring \[param what\] between \[param from\] and \[param to\] positions, \[b\]ignoring case\[/b\]. If \[param to\] is 0, the search continues until the end of the string. *)
    val countn : 
    (BuiltinClass0.String.t structure ptr -> BuiltinClass0.Int.t structure ptr -> BuiltinClass0.Int.t structure ptr -> BuiltinClass0.String.t structure ptr -> BuiltinClass0.Int.t structure ptr)

    (** Returns the index of the \[b\]last\[/b\] occurrence of \[param what\] in this string, or \[code\]-1\[/code\] if there are none. The search''s start can be specified with \[param from\], continuing to the beginning of the string. This method is the reverse of \[method find\]. *)
    val rfind : 
    (BuiltinClass0.String.t structure ptr -> BuiltinClass0.Int.t structure ptr -> BuiltinClass0.String.t structure ptr -> BuiltinClass0.Int.t structure ptr)

    (** Returns the index of the \[b\]last\[/b\] \[b\]case-insensitive\[/b\] occurrence of \[param what\] in this string, or \[code\]-1\[/code\] if there are none. The starting search index can be specified with \[param from\], continuing to the beginning of the string. This method is the reverse of \[method findn\]. *)
    val rfindn : 
    (BuiltinClass0.String.t structure ptr -> BuiltinClass0.Int.t structure ptr -> BuiltinClass0.String.t structure ptr -> BuiltinClass0.Int.t structure ptr)

    (** Does a simple expression match (also called ""glob"" or ""globbing""), where \[code\] * \[/code\] matches zero or more arbitrary characters and \[code\]?\[/code\] matches any single character except a period (\[code\].\[/code\]). An empty string or empty expression always evaluates to \[code\]false\[/code\]. *)
    val match_ : 
    (BuiltinClass0.String.t structure ptr -> BuiltinClass0.String.t structure ptr -> BuiltinClass0.Bool.t structure ptr)

    (** Does a simple \[b\]case-insensitive\[/b\] expression match, where \[code\] * \[/code\] matches zero or more arbitrary characters and \[code\]?\[/code\] matches any single character except a period (\[code\].\[/code\]). An empty string or empty expression always evaluates to \[code\]false\[/code\]. *)
    val matchn : 
    (BuiltinClass0.String.t structure ptr -> BuiltinClass0.String.t structure ptr -> BuiltinClass0.Bool.t structure ptr)

    (** Returns \[code\]true\[/code\] if the string begins with the given \[param text\]. See also \[method ends_with\]. *)
    val begins_with : 
    (BuiltinClass0.String.t structure ptr -> BuiltinClass0.String.t structure ptr -> BuiltinClass0.Bool.t structure ptr)

    (** Returns \[code\]true\[/code\] if the string ends with the given \[param text\]. See also \[method begins_with\]. *)
    val ends_with : 
    (BuiltinClass0.String.t structure ptr -> BuiltinClass0.String.t structure ptr -> BuiltinClass0.Bool.t structure ptr)

    (** Returns \[code\]true\[/code\] if all characters of this string can be found in \[param text\] in their original order.
\[codeblock\]
var text = ""Wow, incredible!""

print(""inedible"".is_subsequence_of(text)) # Prints true
print(""Word!"".is_subsequence_of(text))    # Prints true
print(""Window"".is_subsequence_of(text))   # Prints false
print("""".is_subsequence_of(text))         # Prints true
\[/codeblock\] *)
    val is_subsequence_of : 
    (BuiltinClass0.String.t structure ptr -> BuiltinClass0.String.t structure ptr -> BuiltinClass0.Bool.t structure ptr)

    (** Returns \[code\]true\[/code\] if all characters of this string can be found in \[param text\] in their original order, \[b\]ignoring case\[/b\]. *)
    val is_subsequence_ofn : 
    (BuiltinClass0.String.t structure ptr -> BuiltinClass0.String.t structure ptr -> BuiltinClass0.Bool.t structure ptr)

    (** Returns an array containing the bigrams (pairs of consecutive characters) of this string.
\[codeblock\]
print(""Get up!"".bigrams()) # Prints \[""Ge"", ""et"", ""t "", "" u"", ""up"", ""p!""\]
\[/codeblock\] *)
    val bigrams : 
    (BuiltinClass0.String.t structure ptr -> BuiltinClass0.PackedStringArray.t structure ptr)

    (** Returns the similarity index (\[url=https://en.wikipedia.org/wiki/S%C3%B8rensen%E2%80%93Dice_coefficient\]Srensen-Dice coefficient\[/url\]) of this string compared to another. A result of \[code\]1.0\[/code\] means totally similar, while \[code\]0.0\[/code\] means totally dissimilar.
\[codeblock\]
print(""ABC123"".similarity(""ABC123"")) # Prints 1.0
print(""ABC123"".similarity(""XYZ456"")) # Prints 0.0
print(""ABC123"".similarity(""123ABC"")) # Prints 0.8
print(""ABC123"".similarity(""abc123"")) # Prints 0.4
\[/codeblock\] *)
    val similarity : 
    (BuiltinClass0.String.t structure ptr -> BuiltinClass0.String.t structure ptr -> BuiltinClass0.Float.t structure ptr)

    (** Formats the string by replacing all occurrences of \[param placeholder\] with the elements of \[param values\].
\[param values\] can be a \[Dictionary\], an \[Array\], or an \[Object\]. Any underscores in \[param placeholder\] will be replaced with the corresponding keys in advance. Array elements use their index as keys.
\[codeblock\]
# Prints ""Waiting for Godot is a play by Samuel Beckett, and Godot Engine is named after it.""
var use_array_values = ""Waiting for \{!0\} is a play by \{!1\}, and \{!0\} Engine is named after it.""
print(use_array_values.format(\[""Godot"", ""Samuel Beckett""\]))

# Prints ""User 42 is Godot.""
print(""User \{!id\} is \{!name\}."".format(\{!""id"": 42, ""name"": ""Godot""\}))
\[/codeblock\]
Some additional handling is performed when \[param values\] is an \[Array\]. If \[param placeholder\] does not contain an underscore, the elements of the \[param values\] array will be used to replace one occurrence of the placeholder in order; If an element of \[param values\] is another 2-element array, it''ll be interpreted as a key-value pair.
\[codeblock\]
# Prints ""User 42 is Godot.""
print(""User \{!\} is \{!\}."".format(\[42, ""Godot""\], ""\{!\}""))
print(""User \{!id\} is \{!name\}."".format(\[\[""id"", 42\], \[""name"", ""Godot""\]\]))
\[/codeblock\]
When passing an \[Object\], the property names from \[method Object.get_property_list\] are used as keys.
\[codeblock\]
# Prints ""Visible true, position (0, 0)""
var node = Node2D.new()
print(""Visible \{!visible\}, position \{!position\}"".format(node))
\[/codeblock\]
See also the \[url=$DOCS_URL/tutorials/scripting/gdscript/gdscript_format_string.html\]GDScript format string\[/url\] tutorial.
\[b\]Note:\[/b\] Each replacement is done sequentially for each element of \[param values\], \[b\]not\[/b\] all at once. This means that if any element is inserted and it contains another placeholder, it may be changed by the next replacement. While this can be very useful, it often causes unexpected results. If not necessary, make sure \[param values\]''s elements do not contain placeholders.
\[codeblock\]
print(""\{!0\} \{!1\}"".format(\[""\{!1\}"", ""x""\]))           # Prints ""x x""
print(""\{!0\} \{!1\}"".format(\[""x"", ""\{!0\}""\]))           # Prints ""x \{!0\}""
print(""\{!a\} \{!b\}"".format(\{!""a"": ""\{!b\}"", ""b"": ""c""\})) # Prints ""c c""
print(""\{!a\} \{!b\}"".format(\{!""b"": ""c"", ""a"": ""\{!b\}""\})) # Prints ""\{!b\} c""
\[/codeblock\]
\[b\]Note:\[/b\] In C#, it''s recommended to \[url=https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/tokens/interpolated\]interpolate strings with ""$""\[/url\], instead. *)
    val format : 
    (BuiltinClass0.Variant.t structure ptr -> BuiltinClass0.String.t structure ptr -> BuiltinClass0.String.t structure ptr -> BuiltinClass0.String.t structure ptr)

    (** Replaces all occurrences of \[param what\] inside the string with the given \[param forwhat\]. *)
    val replace : 
    (BuiltinClass0.String.t structure ptr -> BuiltinClass0.String.t structure ptr -> BuiltinClass0.String.t structure ptr -> BuiltinClass0.String.t structure ptr)

    (** Replaces all \[b\]case-insensitive\[/b\] occurrences of \[param what\] inside the string with the given \[param forwhat\]. *)
    val replacen : 
    (BuiltinClass0.String.t structure ptr -> BuiltinClass0.String.t structure ptr -> BuiltinClass0.String.t structure ptr -> BuiltinClass0.String.t structure ptr)

    (** Repeats this string a number of times. \[param count\] needs to be greater than \[code\]0\[/code\]. Otherwise, returns an empty string. *)
    val repeat : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.String.t structure ptr -> BuiltinClass0.String.t structure ptr)

    (** Returns the copy of this string in reverse order. This operation works on unicode codepoints, rather than sequences of codepoints, and may break things like compound letters or emojis. *)
    val reverse : 
    (BuiltinClass0.String.t structure ptr -> BuiltinClass0.String.t structure ptr)

    (** Inserts \[param what\] at the given \[param position\] in the string. *)
    val insert : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.String.t structure ptr -> BuiltinClass0.String.t structure ptr -> BuiltinClass0.String.t structure ptr)

    (** Returns a string with \[param chars\] characters erased starting from \[param position\]. If \[param chars\] goes beyond the string''s length given the specified \[param position\], fewer characters will be erased from the returned string. Returns an empty string if either \[param position\] or \[param chars\] is negative. Returns the original string unmodified if \[param chars\] is \[code\]0\[/code\]. *)
    val erase : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.Int.t structure ptr -> BuiltinClass0.String.t structure ptr -> BuiltinClass0.String.t structure ptr)

    (** Changes the appearance of the string: replaces underscores (\[code\]_\[/code\]) with spaces, adds spaces before uppercase letters in the middle of a word, converts all letters to lowercase, then converts the first one and each one following a space to uppercase.
\[codeblocks\]
\[gdscript\]
""move_local_x"".capitalize()   # Returns ""Move Local X""
""sceneFile_path"".capitalize() # Returns ""Scene File Path""
""2D, FPS, PNG"".capitalize()   # Returns ""2d, Fps, Png""
\[/gdscript\]
\[csharp\]
""move_local_x"".Capitalize();   // Returns ""Move Local X""
""sceneFile_path"".Capitalize(); // Returns ""Scene File Path""
""2D, FPS, PNG"".Capitalize();   // Returns ""2d, Fps, Png""
\[/csharp\]
\[/codeblocks\] *)
    val capitalize : 
    (BuiltinClass0.String.t structure ptr -> BuiltinClass0.String.t structure ptr)

    (** Returns the string converted to \[code\]camelCase\[/code\]. *)
    val to_camel_case : 
    (BuiltinClass0.String.t structure ptr -> BuiltinClass0.String.t structure ptr)

    (** Returns the string converted to \[code\]PascalCase\[/code\]. *)
    val to_pascal_case : 
    (BuiltinClass0.String.t structure ptr -> BuiltinClass0.String.t structure ptr)

    (** Returns the string converted to \[code\]snake_case\[/code\].
\[b\]Note:\[/b\] Numbers followed by a \[i\]single\[/i\] letter are not separated in the conversion to keep some words (such as ""2D"") together.
\[codeblocks\]
\[gdscript\]
""Node2D"".to_snake_case()               # Returns ""node_2d""
""2nd place"".to_snake_case()            # Returns ""2_nd_place""
""Texture3DAssetFolder"".to_snake_case() # Returns ""texture_3d_asset_folder""
\[/gdscript\]
\[csharp\]
""Node2D"".ToSnakeCase();               // Returns ""node_2d""
""2nd place"".ToSnakeCase();            // Returns ""2_nd_place""
""Texture3DAssetFolder"".ToSnakeCase(); // Returns ""texture_3d_asset_folder""
\[/csharp\]
\[/codeblocks\] *)
    val to_snake_case : 
    (BuiltinClass0.String.t structure ptr -> BuiltinClass0.String.t structure ptr)

    (** Splits the string using a \[param delimiter\] and returns an array of the substrings. If \[param delimiter\] is an empty string, each substring will be a single character. This method is the opposite of \[method join\].
If \[param allow_empty\] is \[code\]false\[/code\], empty strings between adjacent delimiters are excluded from the array.
If \[param maxsplit\] is greater than \[code\]0\[/code\], the number of splits may not exceed \[param maxsplit\]. By default, the entire string is split.
\[codeblocks\]
\[gdscript\]
var some_array = ""One,Two,Three,Four"".split("","", true, 2)

print(some_array.size()) # Prints 3
print(some_array\[0\])     # Prints ""One""
print(some_array\[1\])     # Prints ""Two""
print(some_array\[2\])     # Prints ""Three,Four""
\[/gdscript\]
\[csharp\]
// C#''s `Split()` does not support the `maxsplit` parameter.
var someArray = ""One,Two,Three"".Split("","");

GD.Print(someArray\[0\]); // Prints ""One""
GD.Print(someArray\[1\]); // Prints ""Two""
GD.Print(someArray\[2\]); // Prints ""Three""
\[/csharp\]
\[/codeblocks\]
\[b\]Note:\[/b\] If you only need one substring from the array, consider using \[method get_slice\] which is faster. If you need to split strings with more complex rules, use the \[RegEx\] class instead. *)
    val split : 
    (BuiltinClass0.String.t structure ptr -> BuiltinClass0.Bool.t structure ptr -> BuiltinClass0.Int.t structure ptr -> BuiltinClass0.String.t structure ptr -> BuiltinClass0.PackedStringArray.t structure ptr)

    (** Splits the string using a \[param delimiter\] and returns an array of the substrings, starting from the end of the string. The splits in the returned array appear in the same order as the original string. If \[param delimiter\] is an empty string, each substring will be a single character.
If \[param allow_empty\] is \[code\]false\[/code\], empty strings between adjacent delimiters are excluded from the array.
If \[param maxsplit\] is greater than \[code\]0\[/code\], the number of splits may not exceed \[param maxsplit\]. By default, the entire string is split, which is mostly identical to \[method split\].
\[codeblocks\]
\[gdscript\]
var some_string = ""One,Two,Three,Four""
var some_array = some_string.rsplit("","", true, 1)

print(some_array.size()) # Prints 2
print(some_array\[0\])     # Prints ""One,Two,Three""
print(some_array\[1\])     # Prints ""Four""
\[/gdscript\]
\[csharp\]
// In C#, there is no String.RSplit() method.
\[/csharp\]
\[/codeblocks\] *)
    val rsplit : 
    (BuiltinClass0.String.t structure ptr -> BuiltinClass0.Bool.t structure ptr -> BuiltinClass0.Int.t structure ptr -> BuiltinClass0.String.t structure ptr -> BuiltinClass0.PackedStringArray.t structure ptr)

    (** Splits the string into floats by using a \[param delimiter\] and returns a \[PackedFloat64Array\].
If \[param allow_empty\] is \[code\]false\[/code\], empty or invalid \[float\] conversions between adjacent delimiters are excluded.
\[codeblock\]
var a = ""1,2,4.5"".split_floats("","")         # a is \[1.0, 2.0, 4.5\]
var c = ""1| ||4.5"".split_floats(""|"")        # c is \[1.0, 0.0, 0.0, 4.5\]
var b = ""1| ||4.5"".split_floats(""|"", false) # b is \[1.0, 4.5\]
\[/codeblock\] *)
    val split_floats : 
    (BuiltinClass0.String.t structure ptr -> BuiltinClass0.Bool.t structure ptr -> BuiltinClass0.String.t structure ptr -> BuiltinClass0.PackedFloat64Array.t structure ptr)

    (** Returns the concatenation of \[param parts\]'' elements, with each element separated by the string calling this method. This method is the opposite of \[method split\].
\[codeblocks\]
\[gdscript\]
var fruits = \[""Apple"", ""Orange"", ""Pear"", ""Kiwi""\]

print("", "".join(fruits))  # Prints ""Apple, Orange, Pear, Kiwi""
print(""---"".join(fruits)) # Prints ""Apple---Orange---Pear---Kiwi""
\[/gdscript\]
\[csharp\]
string\[\] fruits = \[""Apple"", ""Orange"", ""Pear"", ""Kiwi""\];

// In C#, this method is static.
GD.Print(string.Join("", "", fruits));  // Prints ""Apple, Orange, Pear, Kiwi""
GD.Print(string.Join(""---"", fruits)); // Prints ""Apple---Orange---Pear---Kiwi""
\[/csharp\]
\[/codeblocks\] *)
    val join : 
    (BuiltinClass0.PackedStringArray.t structure ptr -> BuiltinClass0.String.t structure ptr -> BuiltinClass0.String.t structure ptr)

    (** Returns the string converted to \[code\]UPPERCASE\[/code\]. *)
    val to_upper : 
    (BuiltinClass0.String.t structure ptr -> BuiltinClass0.String.t structure ptr)

    (** Returns the string converted to \[code\]lowercase\[/code\]. *)
    val to_lower : 
    (BuiltinClass0.String.t structure ptr -> BuiltinClass0.String.t structure ptr)

    (** Returns the first \[param length\] characters from the beginning of the string. If \[param length\] is negative, strips the last \[param length\] characters from the string''s end.
\[codeblock\]
print(""Hello World!"".left(3))  # Prints ""Hel""
print(""Hello World!"".left(-4)) # Prints ""Hello Wo""
\[/codeblock\] *)
    val left : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.String.t structure ptr -> BuiltinClass0.String.t structure ptr)

    (** Returns the last \[param length\] characters from the end of the string. If \[param length\] is negative, strips the first \[param length\] characters from the string''s beginning.
\[codeblock\]
print(""Hello World!"".right(3))  # Prints ""ld!""
print(""Hello World!"".right(-4)) # Prints ""o World!""
\[/codeblock\] *)
    val right : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.String.t structure ptr -> BuiltinClass0.String.t structure ptr)

    (** Strips all non-printable characters from the beginning and the end of the string. These include spaces, tabulations (\[code\]\t\[/code\]), and newlines (\[code\]\n\[/code\] \[code\]\r\[/code\]).
If \[param left\] is \[code\]false\[/code\], ignores the string''s beginning. Likewise, if \[param right\] is \[code\]false\[/code\], ignores the string''s end. *)
    val strip_edges : 
    (BuiltinClass0.Bool.t structure ptr -> BuiltinClass0.Bool.t structure ptr -> BuiltinClass0.String.t structure ptr -> BuiltinClass0.String.t structure ptr)

    (** Strips all escape characters from the string. These include all non-printable control characters of the first page of the ASCII table (values from 0 to 31), such as tabulation (\[code\]\t\[/code\]) and newline (\[code\]\n\[/code\], \[code\]\r\[/code\]) characters, but \[i\]not\[/i\] spaces. *)
    val strip_escapes : 
    (BuiltinClass0.String.t structure ptr -> BuiltinClass0.String.t structure ptr)

    (** Removes a set of characters defined in \[param chars\] from the string''s beginning. See also \[method rstrip\].
\[b\]Note:\[/b\] \[param chars\] is not a prefix. Use \[method trim_prefix\] to remove a single prefix, rather than a set of characters. *)
    val lstrip : 
    (BuiltinClass0.String.t structure ptr -> BuiltinClass0.String.t structure ptr -> BuiltinClass0.String.t structure ptr)

    (** Removes a set of characters defined in \[param chars\] from the string''s end. See also \[method lstrip\].
\[b\]Note:\[/b\] \[param chars\] is not a suffix. Use \[method trim_suffix\] to remove a single suffix, rather than a set of characters. *)
    val rstrip : 
    (BuiltinClass0.String.t structure ptr -> BuiltinClass0.String.t structure ptr -> BuiltinClass0.String.t structure ptr)

    (** If the string is a valid file name or path, returns the file extension without the leading period (\[code\].\[/code\]). Otherwise, returns an empty string.
\[codeblock\]
var a = ""/path/to/file.txt"".get_extension() # a is ""txt""
var b = ""cool.txt"".get_extension()          # b is ""txt""
var c = ""cool.font.tres"".get_extension()    # c is ""tres""
var d = "".pack1"".get_extension()            # d is ""pack1""

var e = ""file.txt."".get_extension()  # e is """"
var f = ""file.txt.."".get_extension() # f is """"
var g = ""txt"".get_extension()        # g is """"
var h = """".get_extension()           # h is """"
\[/codeblock\] *)
    val get_extension : 
    (BuiltinClass0.String.t structure ptr -> BuiltinClass0.String.t structure ptr)

    (** If the string is a valid file path, returns the full file path, without the extension.
\[codeblock\]
var base = ""/path/to/file.txt"".get_basename() # base is ""/path/to/file""
\[/codeblock\] *)
    val get_basename : 
    (BuiltinClass0.String.t structure ptr -> BuiltinClass0.String.t structure ptr)

    (** Concatenates \[param file\] at the end of the string as a subpath, adding \[code\]/\[/code\] if necessary.
\[b\]Example:\[/b\] \[code\]""this/is"".path_join(""path"") == ""this/is/path""\[/code\]. *)
    val path_join : 
    (BuiltinClass0.String.t structure ptr -> BuiltinClass0.String.t structure ptr -> BuiltinClass0.String.t structure ptr)

    (** Returns the character code at position \[param at\]. *)
    val unicode_at : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.String.t structure ptr -> BuiltinClass0.Int.t structure ptr)

    (** Indents every line of the string with the given \[param prefix\]. Empty lines are not indented. See also \[method dedent\] to remove indentation.
For example, the string can be indented with two tabulations using \[code\]""\t\t""\[/code\], or four spaces using \[code\]""    ""\[/code\]. *)
    val indent : 
    (BuiltinClass0.String.t structure ptr -> BuiltinClass0.String.t structure ptr -> BuiltinClass0.String.t structure ptr)

    (** Returns a copy of the string with indentation (leading tabs and spaces) removed. See also \[method indent\] to add indentation. *)
    val dedent : 
    (BuiltinClass0.String.t structure ptr -> BuiltinClass0.String.t structure ptr)

    (** Returns the 32-bit hash value representing the string''s contents.
\[b\]Note:\[/b\] Strings with equal hash values are \[i\]not\[/i\] guaranteed to be the same, as a result of hash collisions. On the contrary, strings with different hash values are guaranteed to be different. *)
    val hash : 
    (BuiltinClass0.String.t structure ptr -> BuiltinClass0.Int.t structure ptr)

    (** Returns the \[url=https://en.wikipedia.org/wiki/MD5\]MD5 hash\[/url\] of the string as another \[String\]. *)
    val md5_text : 
    (BuiltinClass0.String.t structure ptr -> BuiltinClass0.String.t structure ptr)

    (** Returns the \[url=https://en.wikipedia.org/wiki/SHA-1\]SHA-1\[/url\] hash of the string as another \[String\]. *)
    val sha1_text : 
    (BuiltinClass0.String.t structure ptr -> BuiltinClass0.String.t structure ptr)

    (** Returns the \[url=https://en.wikipedia.org/wiki/SHA-2\]SHA-256\[/url\] hash of the string as another \[String\]. *)
    val sha256_text : 
    (BuiltinClass0.String.t structure ptr -> BuiltinClass0.String.t structure ptr)

    (** Returns the \[url=https://en.wikipedia.org/wiki/MD5\]MD5 hash\[/url\] of the string as a \[PackedByteArray\]. *)
    val md5_buffer : 
    (BuiltinClass0.String.t structure ptr -> BuiltinClass0.PackedByteArray.t structure ptr)

    (** Returns the \[url=https://en.wikipedia.org/wiki/SHA-1\]SHA-1\[/url\] hash of the string as a \[PackedByteArray\]. *)
    val sha1_buffer : 
    (BuiltinClass0.String.t structure ptr -> BuiltinClass0.PackedByteArray.t structure ptr)

    (** Returns the \[url=https://en.wikipedia.org/wiki/SHA-2\]SHA-256\[/url\] hash of the string as a \[PackedByteArray\]. *)
    val sha256_buffer : 
    (BuiltinClass0.String.t structure ptr -> BuiltinClass0.PackedByteArray.t structure ptr)

    (** Returns \[code\]true\[/code\] if the string''s length is \[code\]0\[/code\] (\[code\]""""\[/code\]). See also \[method length\]. *)
    val is_empty : 
    (BuiltinClass0.String.t structure ptr -> BuiltinClass0.Bool.t structure ptr)

    (** Returns \[code\]true\[/code\] if the string contains \[param what\]. In GDScript, this corresponds to the \[code\]in\[/code\] operator.
\[codeblocks\]
\[gdscript\]
print(""Node"".contains(""de"")) # Prints true
print(""team"".contains(""I""))  # Prints false
print(""I"" in ""team"")         # Prints false
\[/gdscript\]
\[csharp\]
GD.Print(""Node"".Contains(""de"")); // Prints True
GD.Print(""team"".Contains(""I""));  // Prints False
\[/csharp\]
\[/codeblocks\]
If you need to know where \[param what\] is within the string, use \[method find\]. See also \[method containsn\]. *)
    val contains : 
    (BuiltinClass0.String.t structure ptr -> BuiltinClass0.String.t structure ptr -> BuiltinClass0.Bool.t structure ptr)

    (** Returns \[code\]true\[/code\] if the string contains \[param what\], \[b\]ignoring case\[/b\].
If you need to know where \[param what\] is within the string, use \[method findn\]. See also \[method contains\]. *)
    val containsn : 
    (BuiltinClass0.String.t structure ptr -> BuiltinClass0.String.t structure ptr -> BuiltinClass0.Bool.t structure ptr)

    (** Returns \[code\]true\[/code\] if the string is a path to a file or directory, and its starting point is explicitly defined. This method is the opposite of \[method is_relative_path\].
This includes all paths starting with \[code\]""res://""\[/code\], \[code\]""user://""\[/code\], \[code\]""C:\""\[/code\], \[code\]""/""\[/code\], etc. *)
    val is_absolute_path : 
    (BuiltinClass0.String.t structure ptr -> BuiltinClass0.Bool.t structure ptr)

    (** Returns \[code\]true\[/code\] if the string is a path, and its starting point is dependent on context. The path could begin from the current directory, or the current \[Node\] (if the string is derived from a \[NodePath\]), and may sometimes be prefixed with \[code\]""./""\[/code\]. This method is the opposite of \[method is_absolute_path\]. *)
    val is_relative_path : 
    (BuiltinClass0.String.t structure ptr -> BuiltinClass0.Bool.t structure ptr)

    (** If the string is a valid file path, converts the string into a canonical path. This is the shortest possible path, without \[code\]""./""\[/code\], and all the unnecessary \[code\]""..""\[/code\] and \[code\]""/""\[/code\].
\[codeblock\]
var simple_path = ""./path/to///../file"".simplify_path()
print(simple_path) # Prints ""path/file""
\[/codeblock\] *)
    val simplify_path : 
    (BuiltinClass0.String.t structure ptr -> BuiltinClass0.String.t structure ptr)

    (** If the string is a valid file path, returns the base directory name.
\[codeblock\]
var dir_path = ""/path/to/file.txt"".get_base_dir() # dir_path is ""/path/to""
\[/codeblock\] *)
    val get_base_dir : 
    (BuiltinClass0.String.t structure ptr -> BuiltinClass0.String.t structure ptr)

    (** If the string is a valid file path, returns the file name, including the extension.
\[codeblock\]
var file = ""/path/to/icon.png"".get_file() # file is ""icon.png""
\[/codeblock\] *)
    val get_file : 
    (BuiltinClass0.String.t structure ptr -> BuiltinClass0.String.t structure ptr)

    (** Returns a copy of the string with special characters escaped using the XML standard. If \[param escape_quotes\] is \[code\]true\[/code\], the single quote (\[code\]''\[/code\]) and double quote (\[code\]""\[/code\]) characters are also escaped. *)
    val xml_escape : 
    (BuiltinClass0.Bool.t structure ptr -> BuiltinClass0.String.t structure ptr -> BuiltinClass0.String.t structure ptr)

    (** Returns a copy of the string with escaped characters replaced by their meanings according to the XML standard. *)
    val xml_unescape : 
    (BuiltinClass0.String.t structure ptr -> BuiltinClass0.String.t structure ptr)

    (** Encodes the string to URL-friendly format. This method is meant to properly encode the parameters in a URL when sending an HTTP request. See also \[method uri_decode\].
\[codeblocks\]
\[gdscript\]
var prefix = ""$DOCS_URL/?highlight=""
var url = prefix + ""Godot Engine:docs"".uri_encode()

print(url) # Prints ""$DOCS_URL/?highlight=Godot%20Engine%3%docs""
\[/gdscript\]
\[csharp\]
var prefix = ""$DOCS_URL/?highlight="";
var url = prefix + ""Godot Engine:docs"".URIEncode();

GD.Print(url); // Prints ""$DOCS_URL/?highlight=Godot%20Engine%3%docs""
\[/csharp\]
\[/codeblocks\] *)
    val uri_encode : 
    (BuiltinClass0.String.t structure ptr -> BuiltinClass0.String.t structure ptr)

    (** Decodes the string from its URL-encoded format. This method is meant to properly decode the parameters in a URL when receiving an HTTP request. See also \[method uri_encode\].
\[codeblocks\]
\[gdscript\]
var url = ""$DOCS_URL/?highlight=Godot%20Engine%3%docs""
print(url.uri_decode()) # Prints ""$DOCS_URL/?highlight=Godot Engine:docs""
\[/gdscript\]
\[csharp\]
var url = ""$DOCS_URL/?highlight=Godot%20Engine%3%docs""
GD.Print(url.URIDecode()) // Prints ""$DOCS_URL/?highlight=Godot Engine:docs""
\[/csharp\]
\[/codeblocks\] *)
    val uri_decode : 
    (BuiltinClass0.String.t structure ptr -> BuiltinClass0.String.t structure ptr)

    (** Returns a copy of the string with special characters escaped using the C language standard. *)
    val c_escape : 
    (BuiltinClass0.String.t structure ptr -> BuiltinClass0.String.t structure ptr)

    (** Returns a copy of the string with escaped characters replaced by their meanings. Supported escape sequences are \[code\]\''\[/code\], \[code\]\""\[/code\], \[code\]\\\[/code\], \[code\]\a\[/code\], \[code\]\b\[/code\], \[code\]\f\[/code\], \[code\]\n\[/code\], \[code\]\r\[/code\], \[code\]\t\[/code\], \[code\]\v\[/code\].
\[b\]Note:\[/b\] Unlike the GDScript parser, this method doesn''t support the \[code\]\uXXXX\[/code\] escape sequence. *)
    val c_unescape : 
    (BuiltinClass0.String.t structure ptr -> BuiltinClass0.String.t structure ptr)

    (** Returns a copy of the string with special characters escaped using the JSON standard. Because it closely matches the C standard, it is possible to use \[method c_unescape\] to unescape the string, if necessary. *)
    val json_escape : 
    (BuiltinClass0.String.t structure ptr -> BuiltinClass0.String.t structure ptr)

    (** Returns a copy of the string with all characters that are not allowed in \[member Node.name\] (\[code\].\[/code\] \[code\]:\[/code\] \[code\]\@\[/code\] \[code\]/\[/code\] \[code\]""\[/code\] \[code\]%\[/code\]) replaced with underscores. *)
    val validate_node_name : 
    (BuiltinClass0.String.t structure ptr -> BuiltinClass0.String.t structure ptr)

    (** Returns a copy of the string with all characters that are not allowed in \[method is_valid_filename\] replaced with underscores. *)
    val validate_filename : 
    (BuiltinClass0.String.t structure ptr -> BuiltinClass0.String.t structure ptr)

    (** Returns \[code\]true\[/code\] if this string is a valid ASCII identifier. A valid ASCII identifier may contain only letters, digits, and underscores (\[code\]_\[/code\]), and the first character may not be a digit.
\[codeblock\]
print(""node_2d"".is_valid_ascii_identifier())    # Prints true
print(""TYPE_FLOAT"".is_valid_ascii_identifier()) # Prints true
print(""1st_method"".is_valid_ascii_identifier()) # Prints false
print(""MyMethod#2"".is_valid_ascii_identifier()) # Prints false
\[/codeblock\]
See also \[method is_valid_unicode_identifier\]. *)
    val is_valid_ascii_identifier : 
    (BuiltinClass0.String.t structure ptr -> BuiltinClass0.Bool.t structure ptr)

    (** Returns \[code\]true\[/code\] if this string is a valid Unicode identifier.
A valid Unicode identifier must begin with a Unicode character of class \[code\]XID_Start\[/code\] or \[code\]""_""\[/code\], and may contain Unicode characters of class \[code\]XID_Continue\[/code\] in the other positions.
\[codeblock\]
print(""node_2d"".is_valid_unicode_identifier())      # Prints true
print(""1st_method"".is_valid_unicode_identifier())   # Prints false
print(""MyMethod#2"".is_valid_unicode_identifier())   # Prints false
print(""llkpessg"".is_valid_unicode_identifier()) # Prints true
print("""".is_valid_unicode_identifier()) # Prints true
print("""".is_valid_unicode_identifier())         # Prints true
\[/codeblock\]
See also \[method is_valid_ascii_identifier\].
\[b\]Note:\[/b\] This method checks identifiers the same way as GDScript. See \[method TextServer.is_valid_identifier\] for more advanced checks. *)
    val is_valid_unicode_identifier : 
    (BuiltinClass0.String.t structure ptr -> BuiltinClass0.Bool.t structure ptr)

    (** Returns \[code\]true\[/code\] if this string is a valid identifier. A valid identifier may contain only letters, digits and underscores (\[code\]_\[/code\]), and the first character may not be a digit.
\[codeblock\]
print(""node_2d"".is_valid_identifier())    # Prints true
print(""TYPE_FLOAT"".is_valid_identifier()) # Prints true
print(""1st_method"".is_valid_identifier()) # Prints false
print(""MyMethod#2"".is_valid_identifier()) # Prints false
\[/codeblock\] *)
    val is_valid_identifier : 
    (BuiltinClass0.String.t structure ptr -> BuiltinClass0.Bool.t structure ptr)

    (** Returns \[code\]true\[/code\] if this string represents a valid integer. A valid integer only contains digits, and may be prefixed with a positive (\[code\]+\[/code\]) or negative (\[code\]-\[/code\]) sign. See also \[method to_int\].
\[codeblock\]
print(""7"".is_valid_int())    # Prints true
print(""1.65"".is_valid_int()) # Prints false
print(""Hi"".is_valid_int())   # Prints false
print(""+3"".is_valid_int())   # Prints true
print(""-12"".is_valid_int())  # Prints true
\[/codeblock\] *)
    val is_valid_int : 
    (BuiltinClass0.String.t structure ptr -> BuiltinClass0.Bool.t structure ptr)

    (** Returns \[code\]true\[/code\] if this string represents a valid floating-point number. A valid float may contain only digits, one decimal point (\[code\].\[/code\]), and the exponent letter (\[code\]e\[/code\]). It may also be prefixed with a positive (\[code\]+\[/code\]) or negative (\[code\]-\[/code\]) sign. Any valid integer is also a valid float (see \[method is_valid_int\]). See also \[method to_float\].
\[codeblock\]
print(""1.7"".is_valid_float())   # Prints true
print(""24"".is_valid_float())    # Prints true
print(""7e3"".is_valid_float())   # Prints true
print(""Hello"".is_valid_float()) # Prints false
\[/codeblock\] *)
    val is_valid_float : 
    (BuiltinClass0.String.t structure ptr -> BuiltinClass0.Bool.t structure ptr)

    (** Returns \[code\]true\[/code\] if this string is a valid hexadecimal number. A valid hexadecimal number only contains digits or letters \[code\]A\[/code\] to \[code\]F\[/code\] (either uppercase or lowercase), and may be prefixed with a positive (\[code\]+\[/code\]) or negative (\[code\]-\[/code\]) sign.
If \[param with_prefix\] is \[code\]true\[/code\], the hexadecimal number needs to prefixed by \[code\]""0x""\[/code\] to be considered valid.
\[codeblock\]
print(""A08E"".is_valid_hex_number())    # Prints true
print(""-AbCdEf"".is_valid_hex_number()) # Prints true
print(""2.5"".is_valid_hex_number())     # Prints false

print(""0xDEADC0DE"".is_valid_hex_number(true)) # Prints true
\[/codeblock\] *)
    val is_valid_hex_number : 
    (BuiltinClass0.Bool.t structure ptr -> BuiltinClass0.String.t structure ptr -> BuiltinClass0.Bool.t structure ptr)

    (** Returns \[code\]true\[/code\] if this string is a valid color in hexadecimal HTML notation. The string must be a hexadecimal value (see \[method is_valid_hex_number\]) of either 3, 4, 6 or 8 digits, and may be prefixed by a hash sign (\[code\]#\[/code\]). Other HTML notations for colors, such as names or \[code\]hsl()\[/code\], are not considered valid. See also \[method Color.html\]. *)
    val is_valid_html_color : 
    (BuiltinClass0.String.t structure ptr -> BuiltinClass0.Bool.t structure ptr)

    (** Returns \[code\]true\[/code\] if this string represents a well-formatted IPv4 or IPv6 address. This method considers \[url=https://en.wikipedia.org/wiki/Reserved_IP_addresses\]reserved IP addresses\[/url\] such as \[code\]""0.0.0.0""\[/code\] and \[code\]""ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff""\[/code\] as valid. *)
    val is_valid_ip_address : 
    (BuiltinClass0.String.t structure ptr -> BuiltinClass0.Bool.t structure ptr)

    (** Returns \[code\]true\[/code\] if this string does not contain characters that are not allowed in file names (\[code\]:\[/code\] \[code\]/\[/code\] \[code\]\\[/code\] \[code\]?\[/code\] \[code\] * \[/code\] \[code\]""\[/code\] \[code\]|\[/code\] \[code\]%\[/code\] \[code\]<\[/code\] \[code\]>\[/code\]). *)
    val is_valid_filename : 
    (BuiltinClass0.String.t structure ptr -> BuiltinClass0.Bool.t structure ptr)

    (** Converts the string representing an integer number into an \[int\]. This method removes any non-number character and stops at the first decimal point (\[code\].\[/code\]). See also \[method is_valid_int\].
\[codeblock\]
var a = ""123"".to_int()    # a is 123
var b = ""x1y2z3"".to_int() # b is 123
var c = ""-1.2.3"".to_int() # c is -1
var d = ""Hello!"".to_int() # d is 0
\[/codeblock\] *)
    val to_int : 
    (BuiltinClass0.String.t structure ptr -> BuiltinClass0.Int.t structure ptr)

    (** Converts the string representing a decimal number into a \[float\]. This method stops on the first non-number character, except the first decimal point (\[code\].\[/code\]) and the exponent letter (\[code\]e\[/code\]). See also \[method is_valid_float\].
\[codeblock\]
var a = ""12.35"".to_float()  # a is 12.35
var b = ""1.2.3"".to_float()  # b is 1.2
var c = ""12xy3"".to_float()  # c is 12.0
var d = ""1e3"".to_float()    # d is 1000.0
var e = ""Hello!"".to_float() # e is 0.0
\[/codeblock\] *)
    val to_float : 
    (BuiltinClass0.String.t structure ptr -> BuiltinClass0.Float.t structure ptr)

    (** Converts the string representing a hexadecimal number into an \[int\]. The string may be optionally prefixed with \[code\]""0x""\[/code\], and an additional \[code\]-\[/code\] prefix for negative numbers.
\[codeblocks\]
\[gdscript\]
print(""0xff"".hex_to_int()) # Prints 255
print(""ab"".hex_to_int())   # Prints 171
\[/gdscript\]
\[csharp\]
GD.Print(""0xff"".HexToInt()); // Prints 255
GD.Print(""ab"".HexToInt());   // Prints 171
\[/csharp\]
\[/codeblocks\] *)
    val hex_to_int : 
    (BuiltinClass0.String.t structure ptr -> BuiltinClass0.Int.t structure ptr)

    (** Converts the string representing a binary number into an \[int\]. The string may optionally be prefixed with \[code\]""0b""\[/code\], and an additional \[code\]-\[/code\] prefix for negative numbers.
\[codeblocks\]
\[gdscript\]
print(""101"".bin_to_int())   # Prints 5
print(""0b101"".bin_to_int()) # Prints 5
print(""-0b10"".bin_to_int()) # Prints -2
\[/gdscript\]
\[csharp\]
GD.Print(""101"".BinToInt());   // Prints 5
GD.Print(""0b101"".BinToInt()); // Prints 5
GD.Print(""-0b10"".BinToInt()); // Prints -2
\[/csharp\]
\[/codeblocks\] *)
    val bin_to_int : 
    (BuiltinClass0.String.t structure ptr -> BuiltinClass0.Int.t structure ptr)

    (** Formats the string to be at least \[param min_length\] long by adding \[param character\]s to the left of the string, if necessary. See also \[method rpad\]. *)
    val lpad : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.String.t structure ptr -> BuiltinClass0.String.t structure ptr -> BuiltinClass0.String.t structure ptr)

    (** Formats the string to be at least \[param min_length\] long, by adding \[param character\]s to the right of the string, if necessary. See also \[method lpad\]. *)
    val rpad : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.String.t structure ptr -> BuiltinClass0.String.t structure ptr -> BuiltinClass0.String.t structure ptr)

    (** Formats the string representing a number to have an exact number of \[param digits\] \[i\]after\[/i\] the decimal point. *)
    val pad_decimals : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.String.t structure ptr -> BuiltinClass0.String.t structure ptr)

    (** Formats the string representing a number to have an exact number of \[param digits\] \[i\]before\[/i\] the decimal point. *)
    val pad_zeros : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.String.t structure ptr -> BuiltinClass0.String.t structure ptr)

    (** Removes the given \[param prefix\] from the start of the string, or returns the string unchanged. *)
    val trim_prefix : 
    (BuiltinClass0.String.t structure ptr -> BuiltinClass0.String.t structure ptr -> BuiltinClass0.String.t structure ptr)

    (** Removes the given \[param suffix\] from the end of the string, or returns the string unchanged. *)
    val trim_suffix : 
    (BuiltinClass0.String.t structure ptr -> BuiltinClass0.String.t structure ptr -> BuiltinClass0.String.t structure ptr)

    (** Converts the string to an \[url=https://en.wikipedia.org/wiki/ASCII\]ASCII\[/url\]/Latin-1 encoded \[PackedByteArray\]. This method is slightly faster than \[method to_utf8_buffer\], but replaces all unsupported characters with spaces. This is the inverse of \[method PackedByteArray.get_string_from_ascii\]. *)
    val to_ascii_buffer : 
    (BuiltinClass0.String.t structure ptr -> BuiltinClass0.PackedByteArray.t structure ptr)

    (** Converts the string to a \[url=https://en.wikipedia.org/wiki/UTF-8\]UTF-8\[/url\] encoded \[PackedByteArray\]. This method is slightly slower than \[method to_ascii_buffer\], but supports all UTF-8 characters. For most cases, prefer using this method. This is the inverse of \[method PackedByteArray.get_string_from_utf8\]. *)
    val to_utf8_buffer : 
    (BuiltinClass0.String.t structure ptr -> BuiltinClass0.PackedByteArray.t structure ptr)

    (** Converts the string to a \[url=https://en.wikipedia.org/wiki/UTF-16\]UTF-16\[/url\] encoded \[PackedByteArray\]. This is the inverse of \[method PackedByteArray.get_string_from_utf16\]. *)
    val to_utf16_buffer : 
    (BuiltinClass0.String.t structure ptr -> BuiltinClass0.PackedByteArray.t structure ptr)

    (** Converts the string to a \[url=https://en.wikipedia.org/wiki/UTF-32\]UTF-32\[/url\] encoded \[PackedByteArray\]. This is the inverse of \[method PackedByteArray.get_string_from_utf32\]. *)
    val to_utf32_buffer : 
    (BuiltinClass0.String.t structure ptr -> BuiltinClass0.PackedByteArray.t structure ptr)

    (** Decodes a hexadecimal string as a \[PackedByteArray\].
\[codeblocks\]
\[gdscript\]
var text = ""hello world""
var encoded = text.to_utf8_buffer().hex_encode() # outputs ""68656c6c6f20776f726c64""
print(buf.hex_decode().get_string_from_utf8())
\[/gdscript\]
\[csharp\]
var text = ""hello world"";
var encoded = text.ToUtf8Buffer().HexEncode(); // outputs ""68656c6c6f20776f726c64""
GD.Print(buf.HexDecode().GetStringFromUtf8());
\[/csharp\]
\[/codeblocks\] *)
    val hex_decode : 
    (BuiltinClass0.String.t structure ptr -> BuiltinClass0.PackedByteArray.t structure ptr)

    (** Converts the string to a \[url=https://en.wikipedia.org/wiki/Wide_character\]wide character\[/url\] (\[code\]wchar_t\[/code\], UTF-16 on Windows, UTF-32 on other platforms) encoded \[PackedByteArray\]. This is the inverse of \[method PackedByteArray.get_string_from_wchar\]. *)
    val to_wchar_buffer : 
    (BuiltinClass0.String.t structure ptr -> BuiltinClass0.PackedByteArray.t structure ptr)

    (** Converts the given \[param number\] to a string representation, in scientific notation.
\[codeblocks\]
\[gdscript\]
var n = -5.2e8
print(n)                        # Prints -520000000
print(String.num_scientific(n)) # Prints -5.2e+08
\[/gdscript\]
\[csharp\]
// This method is not implemented in C#.
// Use `string.ToString()` with ""e"" to achieve similar results.
var n = -5.2e8f;
GD.Print(n);                // Prints -520000000
GD.Print(n.ToString(""e1"")); // Prints -5.2e+008
\[/csharp\]
\[/codeblocks\]
\[b\]Note:\[/b\] In C#, this method is not implemented. To achieve similar results, see C#''s \[url=https://learn.microsoft.com/en-us/dotnet/standard/base-types/standard-numeric-format-strings\]Standard numeric format strings\[/url\] *)
    val num_scientific : 
    (BuiltinClass0.Float.t structure ptr -> BuiltinClass0.String.t structure ptr)

    (** Converts a \[float\] to a string representation of a decimal number, with the number of decimal places specified in \[param decimals\].
If \[param decimals\] is \[code\]-1\[/code\] as by default, the string representation may only have up to 14 significant digits, with digits before the decimal point having priority over digits after.
Trailing zeros are not included in the string. The last digit is rounded, not truncated.
\[codeblock\]
String.num(3.141593)     # Returns ""3.141593""
String.num(3.141593, 3)  # Returns ""3.142""
String.num(3.14159300)   # Returns ""3.141593""

# Here, the last digit will be rounded up,
# which reduces the total digit count, since trailing zeros are removed:
String.num(42.129999, 5) # Returns ""42.13""

# If `decimals` is not specified, the maximum number of significant digits is 14:
String.num(-0.0000012345432123454321)     # Returns ""-0.00000123454321""
String.num(-10000.0000012345432123454321) # Returns ""-10000.0000012345""
\[/codeblock\] *)
    val num : 
    (BuiltinClass0.Float.t structure ptr -> BuiltinClass0.Int.t structure ptr -> BuiltinClass0.String.t structure ptr)

    (** Converts the given \[param number\] to a string representation, with the given \[param base\].
By default, \[param base\] is set to decimal (\[code\]10\[/code\]). Other common bases in programming include binary (\[code\]2\[/code\]), \[url=https://en.wikipedia.org/wiki/Octal\]octal\[/url\] (\[code\]8\[/code\]), hexadecimal (\[code\]16\[/code\]).
If \[param capitalize_hex\] is \[code\]true\[/code\], digits higher than 9 are represented in uppercase. *)
    val num_int64 : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.Int.t structure ptr -> BuiltinClass0.Bool.t structure ptr -> BuiltinClass0.String.t structure ptr)

    (** Converts the given unsigned \[int\] to a string representation, with the given \[param base\].
By default, \[param base\] is set to decimal (\[code\]10\[/code\]). Other common bases in programming include binary (\[code\]2\[/code\]), \[url=https://en.wikipedia.org/wiki/Octal\]octal\[/url\] (\[code\]8\[/code\]), hexadecimal (\[code\]16\[/code\]).
If \[param capitalize_hex\] is \[code\]true\[/code\], digits higher than 9 are represented in uppercase. *)
    val num_uint64 : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.Int.t structure ptr -> BuiltinClass0.Bool.t structure ptr -> BuiltinClass0.String.t structure ptr)

    (** Returns a single Unicode character from the decimal \[param char\]. You may use \[url=https://unicodelookup.com/\]unicodelookup.com\[/url\] or \[url=https://www.unicode.org/charts/\]unicode.org\[/url\] as points of reference.
\[codeblock\]
print(String.chr(65))     # Prints ""A""
print(String.chr(129302)) # Prints """" (robot face emoji)
\[/codeblock\] *)
    val chr : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.String.t structure ptr)

    (** Converts \[param size\] which represents a number of bytes into a human-readable form.
The result is in \[url=https://en.wikipedia.org/wiki/Binary_prefix#IEC_prefixes\]IEC prefix format\[/url\], which may end in either \[code\]""B""\[/code\], \[code\]""KiB""\[/code\], \[code\]""MiB""\[/code\], \[code\]""GiB""\[/code\], \[code\]""TiB""\[/code\], \[code\]""PiB""\[/code\], or \[code\]""EiB""\[/code\]. *)
    val humanize_size : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.String.t structure ptr)








    val not : 
    (String.t structure ptr -> String.t structure ptr -> Bool.t structure ptr)







    (** Returns \[code\]true\[/code\] if both strings contain the same sequence of characters. *)
    val (=) : 
    (String.t structure ptr -> String.t structure ptr -> Bool.t structure ptr)

    (** Returns \[code\]true\[/code\] if both strings do not contain the same sequence of characters. *)
    val (<>) : 
    (String.t structure ptr -> String.t structure ptr -> Bool.t structure ptr)

    (** Returns \[code\]true\[/code\] if the left \[String\] comes before \[param right\] in \[url=https://en.wikipedia.org/wiki/List_of_Unicode_characters\]Unicode order\[/url\], which roughly matches the alphabetical order. Useful for sorting. *)
    val (<) : 
    (String.t structure ptr -> String.t structure ptr -> Bool.t structure ptr)

    (** Returns \[code\]true\[/code\] if the left \[String\] comes before \[param right\] in \[url=https://en.wikipedia.org/wiki/List_of_Unicode_characters\]Unicode order\[/url\], which roughly matches the alphabetical order, or if both are equal. *)
    val (<=) : 
    (String.t structure ptr -> String.t structure ptr -> Bool.t structure ptr)

    (** Returns \[code\]true\[/code\] if the left \[String\] comes after \[param right\] in \[url=https://en.wikipedia.org/wiki/List_of_Unicode_characters\]Unicode order\[/url\], which roughly matches the alphabetical order. Useful for sorting. *)
    val (>) : 
    (String.t structure ptr -> String.t structure ptr -> Bool.t structure ptr)

    (** Returns \[code\]true\[/code\] if the left \[String\] comes after \[param right\] in \[url=https://en.wikipedia.org/wiki/List_of_Unicode_characters\]Unicode order\[/url\], which roughly matches the alphabetical order, or if both are equal. *)
    val (>=) : 
    (String.t structure ptr -> String.t structure ptr -> Bool.t structure ptr)

    (** Appends \[param right\] at the end of this \[String\], also known as a string concatenation. *)
    val (+) : 
    (String.t structure ptr -> String.t structure ptr -> String.t structure ptr)


    val (%) : 
    (String.t structure ptr -> String.t structure ptr -> String.t structure ptr)


    val mem_String : 
    (String.t structure ptr -> String.t structure ptr -> Bool.t structure ptr)










































    val mem_StringName : 
    (String.t structure ptr -> StringName.t structure ptr -> Bool.t structure ptr)






    val mem_Object : 
    (String.t structure ptr -> Object.t structure ptr -> Bool.t structure ptr)








    val mem_Dictionary : 
    (String.t structure ptr -> Dictionary.t structure ptr -> Bool.t structure ptr)




    val mem_Array : 
    (String.t structure ptr -> Array.t structure ptr -> Bool.t structure ptr)














    val mem_PackedStringArray : 
    (String.t structure ptr -> PackedStringArray.t structure ptr -> Bool.t structure ptr)








    end

  module type VECTOR2 = sig
    type t


    include Api_types.API_TYPE with type t := t



    (** Returns this vector''s angle with respect to the positive X axis, or \[code\](1, 0)\[/code\] vector, in radians.
For example, \[code\]Vector2.RIGHT.angle()\[/code\] will return zero, \[code\]Vector2.DOWN.angle()\[/code\] will return \[code\]PI / 2\[/code\] (a quarter turn, or 90 degrees), and \[code\]Vector2(1, -1).angle()\[/code\] will return \[code\]-PI / 4\[/code\] (a negative eighth turn, or -45 degrees).
\[url=https://raw.githubusercontent.com/godotengine/godot-docs/master/img/vector2_angle.png\]Illustration of the returned angle.\[/url\]
Equivalent to the result of \[method \@GlobalScope.atan2\] when called with the vector''s \[member y\] and \[member x\] as parameters: \[code\]atan2(y, x)\[/code\]. *)
    val angle : 
    (BuiltinClass0.Vector2.t structure ptr -> BuiltinClass0.Float.t structure ptr)

    (** Returns the signed angle to the given vector, in radians.
\[url=https://raw.githubusercontent.com/godotengine/godot-docs/master/img/vector2_angle_to.png\]Illustration of the returned angle.\[/url\] *)
    val angle_to : 
    (BuiltinClass0.Vector2.t structure ptr -> BuiltinClass0.Vector2.t structure ptr -> BuiltinClass0.Float.t structure ptr)

    (** Returns the angle between the line connecting the two points and the X axis, in radians.
\[code\]a.angle_to_point(b)\[/code\] is equivalent of doing \[code\](b - a).angle()\[/code\].
\[url=https://raw.githubusercontent.com/godotengine/godot-docs/master/img/vector2_angle_to_point.png\]Illustration of the returned angle.\[/url\] *)
    val angle_to_point : 
    (BuiltinClass0.Vector2.t structure ptr -> BuiltinClass0.Vector2.t structure ptr -> BuiltinClass0.Float.t structure ptr)

    (** Returns the normalized vector pointing from this vector to \[param to\]. This is equivalent to using \[code\](b - a).normalized()\[/code\]. *)
    val direction_to : 
    (BuiltinClass0.Vector2.t structure ptr -> BuiltinClass0.Vector2.t structure ptr -> BuiltinClass0.Vector2.t structure ptr)

    (** Returns the distance between this vector and \[param to\]. *)
    val distance_to : 
    (BuiltinClass0.Vector2.t structure ptr -> BuiltinClass0.Vector2.t structure ptr -> BuiltinClass0.Float.t structure ptr)

    (** Returns the squared distance between this vector and \[param to\].
This method runs faster than \[method distance_to\], so prefer it if you need to compare vectors or need the squared distance for some formula. *)
    val distance_squared_to : 
    (BuiltinClass0.Vector2.t structure ptr -> BuiltinClass0.Vector2.t structure ptr -> BuiltinClass0.Float.t structure ptr)

    (** Returns the length (magnitude) of this vector. *)
    val length : 
    (BuiltinClass0.Vector2.t structure ptr -> BuiltinClass0.Float.t structure ptr)

    (** Returns the squared length (squared magnitude) of this vector.
This method runs faster than \[method length\], so prefer it if you need to compare vectors or need the squared distance for some formula. *)
    val length_squared : 
    (BuiltinClass0.Vector2.t structure ptr -> BuiltinClass0.Float.t structure ptr)

    (** Returns the vector with a maximum length by limiting its length to \[param length\]. If the vector is non-finite, the result is undefined. *)
    val limit_length : 
    (BuiltinClass0.Float.t structure ptr -> BuiltinClass0.Vector2.t structure ptr -> BuiltinClass0.Vector2.t structure ptr)

    (** Returns the result of scaling the vector to unit length. Equivalent to \[code\]v / v.length()\[/code\]. Returns \[code\](0, 0)\[/code\] if \[code\]v.length() == 0\[/code\]. See also \[method is_normalized\].
\[b\]Note:\[/b\] This function may return incorrect values if the input vector length is near zero. *)
    val normalized : 
    (BuiltinClass0.Vector2.t structure ptr -> BuiltinClass0.Vector2.t structure ptr)

    (** Returns \[code\]true\[/code\] if the vector is normalized, i.e. its length is approximately equal to 1. *)
    val is_normalized : 
    (BuiltinClass0.Vector2.t structure ptr -> BuiltinClass0.Bool.t structure ptr)

    (** Returns \[code\]true\[/code\] if this vector and \[param to\] are approximately equal, by running \[method \@GlobalScope.is_equal_approx\] on each component. *)
    val is_equal_approx : 
    (BuiltinClass0.Vector2.t structure ptr -> BuiltinClass0.Vector2.t structure ptr -> BuiltinClass0.Bool.t structure ptr)

    (** Returns \[code\]true\[/code\] if this vector''s values are approximately zero, by running \[method \@GlobalScope.is_zero_approx\] on each component.
This method is faster than using \[method is_equal_approx\] with one value as a zero vector. *)
    val is_zero_approx : 
    (BuiltinClass0.Vector2.t structure ptr -> BuiltinClass0.Bool.t structure ptr)

    (** Returns \[code\]true\[/code\] if this vector is finite, by calling \[method \@GlobalScope.is_finite\] on each component. *)
    val is_finite : 
    (BuiltinClass0.Vector2.t structure ptr -> BuiltinClass0.Bool.t structure ptr)

    (** Returns a vector composed of the \[method \@GlobalScope.fposmod\] of this vector''s components and \[param mod\]. *)
    val posmod : 
    (BuiltinClass0.Float.t structure ptr -> BuiltinClass0.Vector2.t structure ptr -> BuiltinClass0.Vector2.t structure ptr)

    (** Returns a vector composed of the \[method \@GlobalScope.fposmod\] of this vector''s components and \[param modv\]''s components. *)
    val posmodv : 
    (BuiltinClass0.Vector2.t structure ptr -> BuiltinClass0.Vector2.t structure ptr -> BuiltinClass0.Vector2.t structure ptr)

    (** Returns a new vector resulting from projecting this vector onto the given vector \[param b\]. The resulting new vector is parallel to \[param b\]. See also \[method slide\].
\[b\]Note:\[/b\] If the vector \[param b\] is a zero vector, the components of the resulting new vector will be \[constant \@GDScript.NAN\]. *)
    val project : 
    (BuiltinClass0.Vector2.t structure ptr -> BuiltinClass0.Vector2.t structure ptr -> BuiltinClass0.Vector2.t structure ptr)

    (** Returns the result of the linear interpolation between this vector and \[param to\] by amount \[param weight\]. \[param weight\] is on the range of \[code\]0.0\[/code\] to \[code\]1.0\[/code\], representing the amount of interpolation. *)
    val lerp : 
    (BuiltinClass0.Vector2.t structure ptr -> BuiltinClass0.Float.t structure ptr -> BuiltinClass0.Vector2.t structure ptr -> BuiltinClass0.Vector2.t structure ptr)

    (** Returns the result of spherical linear interpolation between this vector and \[param to\], by amount \[param weight\]. \[param weight\] is on the range of 0.0 to 1.0, representing the amount of interpolation.
This method also handles interpolating the lengths if the input vectors have different lengths. For the special case of one or both input vectors having zero length, this method behaves like \[method lerp\]. *)
    val slerp : 
    (BuiltinClass0.Vector2.t structure ptr -> BuiltinClass0.Float.t structure ptr -> BuiltinClass0.Vector2.t structure ptr -> BuiltinClass0.Vector2.t structure ptr)

    (** Performs a cubic interpolation between this vector and \[param b\] using \[param pre_a\] and \[param post_b\] as handles, and returns the result at position \[param weight\]. \[param weight\] is on the range of 0.0 to 1.0, representing the amount of interpolation. *)
    val cubic_interpolate : 
    (BuiltinClass0.Vector2.t structure ptr -> BuiltinClass0.Vector2.t structure ptr -> BuiltinClass0.Vector2.t structure ptr -> BuiltinClass0.Float.t structure ptr -> BuiltinClass0.Vector2.t structure ptr -> BuiltinClass0.Vector2.t structure ptr)

    (** Performs a cubic interpolation between this vector and \[param b\] using \[param pre_a\] and \[param post_b\] as handles, and returns the result at position \[param weight\]. \[param weight\] is on the range of 0.0 to 1.0, representing the amount of interpolation.
It can perform smoother interpolation than \[method cubic_interpolate\] by the time values. *)
    val cubic_interpolate_in_time : 
    (BuiltinClass0.Vector2.t structure ptr -> BuiltinClass0.Vector2.t structure ptr -> BuiltinClass0.Vector2.t structure ptr -> BuiltinClass0.Float.t structure ptr -> BuiltinClass0.Float.t structure ptr -> BuiltinClass0.Float.t structure ptr -> BuiltinClass0.Float.t structure ptr -> BuiltinClass0.Vector2.t structure ptr -> BuiltinClass0.Vector2.t structure ptr)

    (** Returns the point at the given \[param t\] on the \[url=https://en.wikipedia.org/wiki/B%C3%A9zier_curve\]Bzier curve\[/url\] defined by this vector and the given \[param control_1\], \[param control_2\], and \[param end\] points. *)
    val bezier_interpolate : 
    (BuiltinClass0.Vector2.t structure ptr -> BuiltinClass0.Vector2.t structure ptr -> BuiltinClass0.Vector2.t structure ptr -> BuiltinClass0.Float.t structure ptr -> BuiltinClass0.Vector2.t structure ptr -> BuiltinClass0.Vector2.t structure ptr)

    (** Returns the derivative at the given \[param t\] on the \[url=https://en.wikipedia.org/wiki/B%C3%A9zier_curve\]Bzier curve\[/url\] defined by this vector and the given \[param control_1\], \[param control_2\], and \[param end\] points. *)
    val bezier_derivative : 
    (BuiltinClass0.Vector2.t structure ptr -> BuiltinClass0.Vector2.t structure ptr -> BuiltinClass0.Vector2.t structure ptr -> BuiltinClass0.Float.t structure ptr -> BuiltinClass0.Vector2.t structure ptr -> BuiltinClass0.Vector2.t structure ptr)

    (** Returns the axis of the vector''s highest value. See \[code\]AXIS_ * \[/code\] constants. If all components are equal, this method returns \[constant AXIS_X\]. *)
    val max_axis_index : 
    (BuiltinClass0.Vector2.t structure ptr -> BuiltinClass0.Int.t structure ptr)

    (** Returns the axis of the vector''s lowest value. See \[code\]AXIS_ * \[/code\] constants. If all components are equal, this method returns \[constant AXIS_Y\]. *)
    val min_axis_index : 
    (BuiltinClass0.Vector2.t structure ptr -> BuiltinClass0.Int.t structure ptr)

    (** Returns a new vector moved toward \[param to\] by the fixed \[param delta\] amount. Will not go past the final value. *)
    val move_toward : 
    (BuiltinClass0.Vector2.t structure ptr -> BuiltinClass0.Float.t structure ptr -> BuiltinClass0.Vector2.t structure ptr -> BuiltinClass0.Vector2.t structure ptr)

    (** Returns the result of rotating this vector by \[param angle\] (in radians). See also \[method \@GlobalScope.deg_to_rad\]. *)
    val rotated : 
    (BuiltinClass0.Float.t structure ptr -> BuiltinClass0.Vector2.t structure ptr -> BuiltinClass0.Vector2.t structure ptr)

    (** Returns a perpendicular vector rotated 90 degrees counter-clockwise compared to the original, with the same length. *)
    val orthogonal : 
    (BuiltinClass0.Vector2.t structure ptr -> BuiltinClass0.Vector2.t structure ptr)

    (** Returns a new vector with all components rounded down (towards negative infinity). *)
    val floor : 
    (BuiltinClass0.Vector2.t structure ptr -> BuiltinClass0.Vector2.t structure ptr)

    (** Returns a new vector with all components rounded up (towards positive infinity). *)
    val ceil : 
    (BuiltinClass0.Vector2.t structure ptr -> BuiltinClass0.Vector2.t structure ptr)

    (** Returns a new vector with all components rounded to the nearest integer, with halfway cases rounded away from zero. *)
    val round : 
    (BuiltinClass0.Vector2.t structure ptr -> BuiltinClass0.Vector2.t structure ptr)

    (** Returns the aspect ratio of this vector, the ratio of \[member x\] to \[member y\]. *)
    val aspect : 
    (BuiltinClass0.Vector2.t structure ptr -> BuiltinClass0.Float.t structure ptr)

    (** Returns the dot product of this vector and \[param with\]. This can be used to compare the angle between two vectors. For example, this can be used to determine whether an enemy is facing the player.
The dot product will be \[code\]0\[/code\] for a right angle (90 degrees), greater than 0 for angles narrower than 90 degrees and lower than 0 for angles wider than 90 degrees.
When using unit (normalized) vectors, the result will always be between \[code\]-1.0\[/code\] (180 degree angle) when the vectors are facing opposite directions, and \[code\]1.0\[/code\] (0 degree angle) when the vectors are aligned.
\[b\]Note:\[/b\] \[code\]a.dot(b)\[/code\] is equivalent to \[code\]b.dot(a)\[/code\]. *)
    val dot : 
    (BuiltinClass0.Vector2.t structure ptr -> BuiltinClass0.Vector2.t structure ptr -> BuiltinClass0.Float.t structure ptr)

    (** Returns a new vector resulting from sliding this vector along a line with normal \[param n\]. The resulting new vector is perpendicular to \[param n\], and is equivalent to this vector minus its projection on \[param n\]. See also \[method project\].
\[b\]Note:\[/b\] The vector \[param n\] must be normalized. See also \[method normalized\]. *)
    val slide : 
    (BuiltinClass0.Vector2.t structure ptr -> BuiltinClass0.Vector2.t structure ptr -> BuiltinClass0.Vector2.t structure ptr)

    (** Returns the vector ""bounced off"" from a line defined by the given normal \[param n\] perpendicular to the line.
\[b\]Note:\[/b\] \[method bounce\] performs the operation that most engines and frameworks call \[code skip-lint\]reflect()\[/code\]. *)
    val bounce : 
    (BuiltinClass0.Vector2.t structure ptr -> BuiltinClass0.Vector2.t structure ptr -> BuiltinClass0.Vector2.t structure ptr)

    (** Returns the result of reflecting the vector from a line defined by the given direction vector \[param line\].
\[b\]Note:\[/b\] \[method reflect\] differs from what other engines and frameworks call \[code skip-lint\]reflect()\[/code\]. In other engines, \[code skip-lint\]reflect()\[/code\] takes a normal direction which is a direction perpendicular to the line. In Godot, you specify the direction of the line directly. See also \[method bounce\] which does what most engines call \[code skip-lint\]reflect()\[/code\]. *)
    val reflect : 
    (BuiltinClass0.Vector2.t structure ptr -> BuiltinClass0.Vector2.t structure ptr -> BuiltinClass0.Vector2.t structure ptr)

    (** Returns the 2D analog of the cross product for this vector and \[param with\].
This is the signed area of the parallelogram formed by the two vectors. If the second vector is clockwise from the first vector, then the cross product is the positive area. If counter-clockwise, the cross product is the negative area. If the two vectors are parallel this returns zero, making it useful for testing if two vectors are parallel.
\[b\]Note:\[/b\] Cross product is not defined in 2D mathematically. This method embeds the 2D vectors in the XY plane of 3D space and uses their cross product''s Z component as the analog. *)
    val cross : 
    (BuiltinClass0.Vector2.t structure ptr -> BuiltinClass0.Vector2.t structure ptr -> BuiltinClass0.Float.t structure ptr)

    (** Returns a new vector with all components in absolute values (i.e. positive). *)
    val abs : 
    (BuiltinClass0.Vector2.t structure ptr -> BuiltinClass0.Vector2.t structure ptr)

    (** Returns a new vector with each component set to \[code\]1.0\[/code\] if it''s positive, \[code\]-1.0\[/code\] if it''s negative, and \[code\]0.0\[/code\] if it''s zero. The result is identical to calling \[method \@GlobalScope.sign\] on each component. *)
    val sign : 
    (BuiltinClass0.Vector2.t structure ptr -> BuiltinClass0.Vector2.t structure ptr)

    (** Returns a new vector with all components clamped between the components of \[param min\] and \[param max\], by running \[method \@GlobalScope.clamp\] on each component. *)
    val clamp : 
    (BuiltinClass0.Vector2.t structure ptr -> BuiltinClass0.Vector2.t structure ptr -> BuiltinClass0.Vector2.t structure ptr -> BuiltinClass0.Vector2.t structure ptr)

    (** Returns a new vector with all components clamped between \[param min\] and \[param max\], by running \[method \@GlobalScope.clamp\] on each component. *)
    val clampf : 
    (BuiltinClass0.Float.t structure ptr -> BuiltinClass0.Float.t structure ptr -> BuiltinClass0.Vector2.t structure ptr -> BuiltinClass0.Vector2.t structure ptr)

    (** Returns a new vector with each component snapped to the nearest multiple of the corresponding component in \[param step\]. This can also be used to round the components to an arbitrary number of decimals. *)
    val snapped : 
    (BuiltinClass0.Vector2.t structure ptr -> BuiltinClass0.Vector2.t structure ptr -> BuiltinClass0.Vector2.t structure ptr)

    (** Returns a new vector with each component snapped to the nearest multiple of \[param step\]. This can also be used to round the components to an arbitrary number of decimals. *)
    val snappedf : 
    (BuiltinClass0.Float.t structure ptr -> BuiltinClass0.Vector2.t structure ptr -> BuiltinClass0.Vector2.t structure ptr)

    (** Returns the component-wise minimum of this and \[param with\], equivalent to \[code\]Vector2(minf(x, with.x), minf(y, with.y))\[/code\]. *)
    val min : 
    (BuiltinClass0.Vector2.t structure ptr -> BuiltinClass0.Vector2.t structure ptr -> BuiltinClass0.Vector2.t structure ptr)

    (** Returns the component-wise minimum of this and \[param with\], equivalent to \[code\]Vector2(minf(x, with), minf(y, with))\[/code\]. *)
    val minf : 
    (BuiltinClass0.Float.t structure ptr -> BuiltinClass0.Vector2.t structure ptr -> BuiltinClass0.Vector2.t structure ptr)

    (** Returns the component-wise maximum of this and \[param with\], equivalent to \[code\]Vector2(maxf(x, with.x), maxf(y, with.y))\[/code\]. *)
    val max : 
    (BuiltinClass0.Vector2.t structure ptr -> BuiltinClass0.Vector2.t structure ptr -> BuiltinClass0.Vector2.t structure ptr)

    (** Returns the component-wise maximum of this and \[param with\], equivalent to \[code\]Vector2(maxf(x, with), maxf(y, with))\[/code\]. *)
    val maxf : 
    (BuiltinClass0.Float.t structure ptr -> BuiltinClass0.Vector2.t structure ptr -> BuiltinClass0.Vector2.t structure ptr)

    (** Creates a unit \[Vector2\] rotated to the given \[param angle\] in radians. This is equivalent to doing \[code\]Vector2(cos(angle), sin(angle))\[/code\] or \[code\]Vector2.RIGHT.rotated(angle)\[/code\].
\[codeblock\]
print(Vector2.from_angle(0)) # Prints (1.0, 0.0)
print(Vector2(1, 0).angle()) # Prints 0.0, which is the angle used above.
print(Vector2.from_angle(PI / 2)) # Prints (0.0, 1.0)
\[/codeblock\] *)
    val from_angle : 
    (BuiltinClass0.Float.t structure ptr -> BuiltinClass0.Vector2.t structure ptr)





    (** Returns the negative value of the \[Vector2\]. This is the same as writing \[code\]Vector2(-v.x, -v.y)\[/code\]. This operation flips the direction of the vector while keeping the same magnitude. With floats, the number zero can be either positive or negative. *)
    val (~-) : 
    (Vector2.t structure ptr -> Vector2.t structure ptr -> Vector2.t structure ptr)

    (** Returns the same value as if the \[code\]+\[/code\] was not there. Unary \[code\]+\[/code\] does nothing, but sometimes it can make your code more readable. *)
    val (~+) : 
    (Vector2.t structure ptr -> Vector2.t structure ptr -> Vector2.t structure ptr)


    val not : 
    (Vector2.t structure ptr -> Vector2.t structure ptr -> Bool.t structure ptr)









    (** Returns \[code\]true\[/code\] if the vectors are exactly equal.
\[b\]Note:\[/b\] Due to floating-point precision errors, consider using \[method is_equal_approx\] instead, which is more reliable.
\[b\]Note:\[/b\] Vectors with \[constant \@GDScript.NAN\] elements don''t behave the same as other vectors. Therefore, the results from this operator may not be accurate if NaNs are included. *)
    val (=) : 
    (Vector2.t structure ptr -> Vector2.t structure ptr -> Bool.t structure ptr)

    (** Returns \[code\]true\[/code\] if the vectors are not equal.
\[b\]Note:\[/b\] Due to floating-point precision errors, consider using \[method is_equal_approx\] instead, which is more reliable.
\[b\]Note:\[/b\] Vectors with \[constant \@GDScript.NAN\] elements don''t behave the same as other vectors. Therefore, the results from this operator may not be accurate if NaNs are included. *)
    val (<>) : 
    (Vector2.t structure ptr -> Vector2.t structure ptr -> Bool.t structure ptr)

    (** Compares two \[Vector2\] vectors by first checking if the X value of the left vector is less than the X value of the \[param right\] vector. If the X values are exactly equal, then it repeats this check with the Y values of the two vectors. This operator is useful for sorting vectors.
\[b\]Note:\[/b\] Vectors with \[constant \@GDScript.NAN\] elements don''t behave the same as other vectors. Therefore, the results from this operator may not be accurate if NaNs are included. *)
    val (<) : 
    (Vector2.t structure ptr -> Vector2.t structure ptr -> Bool.t structure ptr)

    (** Compares two \[Vector2\] vectors by first checking if the X value of the left vector is less than or equal to the X value of the \[param right\] vector. If the X values are exactly equal, then it repeats this check with the Y values of the two vectors. This operator is useful for sorting vectors.
\[b\]Note:\[/b\] Vectors with \[constant \@GDScript.NAN\] elements don''t behave the same as other vectors. Therefore, the results from this operator may not be accurate if NaNs are included. *)
    val (<=) : 
    (Vector2.t structure ptr -> Vector2.t structure ptr -> Bool.t structure ptr)

    (** Compares two \[Vector2\] vectors by first checking if the X value of the left vector is greater than the X value of the \[param right\] vector. If the X values are exactly equal, then it repeats this check with the Y values of the two vectors. This operator is useful for sorting vectors.
\[b\]Note:\[/b\] Vectors with \[constant \@GDScript.NAN\] elements don''t behave the same as other vectors. Therefore, the results from this operator may not be accurate if NaNs are included. *)
    val (>) : 
    (Vector2.t structure ptr -> Vector2.t structure ptr -> Bool.t structure ptr)

    (** Compares two \[Vector2\] vectors by first checking if the X value of the left vector is greater than or equal to the X value of the \[param right\] vector. If the X values are exactly equal, then it repeats this check with the Y values of the two vectors. This operator is useful for sorting vectors.
\[b\]Note:\[/b\] Vectors with \[constant \@GDScript.NAN\] elements don''t behave the same as other vectors. Therefore, the results from this operator may not be accurate if NaNs are included. *)
    val (>=) : 
    (Vector2.t structure ptr -> Vector2.t structure ptr -> Bool.t structure ptr)

    (** Adds each component of the \[Vector2\] by the components of the given \[Vector2\].
\[codeblock\]
print(Vector2(10, 20) + Vector2(3, 4)) # Prints (13.0, 24.0)
\[/codeblock\] *)
    val (+) : 
    (Vector2.t structure ptr -> Vector2.t structure ptr -> Vector2.t structure ptr)

    (** Subtracts each component of the \[Vector2\] by the components of the given \[Vector2\].
\[codeblock\]
print(Vector2(10, 20) - Vector2(3, 4)) # Prints (7.0, 16.0)
\[/codeblock\] *)
    val (-) : 
    (Vector2.t structure ptr -> Vector2.t structure ptr -> Vector2.t structure ptr)

    (** Multiplies each component of the \[Vector2\] by the components of the given \[Vector2\].
\[codeblock\]
print(Vector2(10, 20)  *  Vector2(3, 4)) # Prints (30.0, 80.0)
\[/codeblock\] *)
    val ( * ) : 
    (Vector2.t structure ptr -> Vector2.t structure ptr -> Vector2.t structure ptr)

    (** Divides each component of the \[Vector2\] by the components of the given \[Vector2\].
\[codeblock\]
print(Vector2(10, 20) / Vector2(2, 5)) # Prints (5.0, 4.0)
\[/codeblock\] *)
    val (/) : 
    (Vector2.t structure ptr -> Vector2.t structure ptr -> Vector2.t structure ptr)




    val mem_Dictionary : 
    (Vector2.t structure ptr -> Dictionary.t structure ptr -> Bool.t structure ptr)


    val mem_Array : 
    (Vector2.t structure ptr -> Array.t structure ptr -> Bool.t structure ptr)


    val mem_PackedVector2Array : 
    (Vector2.t structure ptr -> PackedVector2Array.t structure ptr -> Bool.t structure ptr)

    module AXIS : sig type t

    val typ : 
    Int.t structure ptr typ

    (** Enumerated value for the X axis. Returned by \[method max_axis_index\] and \[method min_axis_index\]. *)
    val _AXIS_X : 
    int

    (** Enumerated value for the Y axis. Returned by \[method max_axis_index\] and \[method min_axis_index\]. *)
    val _AXIS_Y : 
    int

    end
    end

  module type VECTOR2I = sig
    type t


    include Api_types.API_TYPE with type t := t



    (** Returns the aspect ratio of this vector, the ratio of \[member x\] to \[member y\]. *)
    val aspect : 
    (BuiltinClass0.Vector2i.t structure ptr -> BuiltinClass0.Float.t structure ptr)

    (** Returns the axis of the vector''s highest value. See \[code\]AXIS_ * \[/code\] constants. If all components are equal, this method returns \[constant AXIS_X\]. *)
    val max_axis_index : 
    (BuiltinClass0.Vector2i.t structure ptr -> BuiltinClass0.Int.t structure ptr)

    (** Returns the axis of the vector''s lowest value. See \[code\]AXIS_ * \[/code\] constants. If all components are equal, this method returns \[constant AXIS_Y\]. *)
    val min_axis_index : 
    (BuiltinClass0.Vector2i.t structure ptr -> BuiltinClass0.Int.t structure ptr)

    (** Returns the distance between this vector and \[param to\]. *)
    val distance_to : 
    (BuiltinClass0.Vector2i.t structure ptr -> BuiltinClass0.Vector2i.t structure ptr -> BuiltinClass0.Float.t structure ptr)

    (** Returns the squared distance between this vector and \[param to\].
This method runs faster than \[method distance_to\], so prefer it if you need to compare vectors or need the squared distance for some formula. *)
    val distance_squared_to : 
    (BuiltinClass0.Vector2i.t structure ptr -> BuiltinClass0.Vector2i.t structure ptr -> BuiltinClass0.Int.t structure ptr)

    (** Returns the length (magnitude) of this vector. *)
    val length : 
    (BuiltinClass0.Vector2i.t structure ptr -> BuiltinClass0.Float.t structure ptr)

    (** Returns the squared length (squared magnitude) of this vector.
This method runs faster than \[method length\], so prefer it if you need to compare vectors or need the squared distance for some formula. *)
    val length_squared : 
    (BuiltinClass0.Vector2i.t structure ptr -> BuiltinClass0.Int.t structure ptr)

    (** Returns a new vector with each component set to \[code\]1\[/code\] if it''s positive, \[code\]-1\[/code\] if it''s negative, and \[code\]0\[/code\] if it''s zero. The result is identical to calling \[method \@GlobalScope.sign\] on each component. *)
    val sign : 
    (BuiltinClass0.Vector2i.t structure ptr -> BuiltinClass0.Vector2i.t structure ptr)

    (** Returns a new vector with all components in absolute values (i.e. positive). *)
    val abs : 
    (BuiltinClass0.Vector2i.t structure ptr -> BuiltinClass0.Vector2i.t structure ptr)

    (** Returns a new vector with all components clamped between the components of \[param min\] and \[param max\], by running \[method \@GlobalScope.clamp\] on each component. *)
    val clamp : 
    (BuiltinClass0.Vector2i.t structure ptr -> BuiltinClass0.Vector2i.t structure ptr -> BuiltinClass0.Vector2i.t structure ptr -> BuiltinClass0.Vector2i.t structure ptr)

    (** Returns a new vector with all components clamped between \[param min\] and \[param max\], by running \[method \@GlobalScope.clamp\] on each component. *)
    val clampi : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.Int.t structure ptr -> BuiltinClass0.Vector2i.t structure ptr -> BuiltinClass0.Vector2i.t structure ptr)

    (** Returns a new vector with each component snapped to the closest multiple of the corresponding component in \[param step\]. *)
    val snapped : 
    (BuiltinClass0.Vector2i.t structure ptr -> BuiltinClass0.Vector2i.t structure ptr -> BuiltinClass0.Vector2i.t structure ptr)

    (** Returns a new vector with each component snapped to the closest multiple of \[param step\]. *)
    val snappedi : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.Vector2i.t structure ptr -> BuiltinClass0.Vector2i.t structure ptr)

    (** Returns the component-wise minimum of this and \[param with\], equivalent to \[code\]Vector2i(mini(x, with.x), mini(y, with.y))\[/code\]. *)
    val min : 
    (BuiltinClass0.Vector2i.t structure ptr -> BuiltinClass0.Vector2i.t structure ptr -> BuiltinClass0.Vector2i.t structure ptr)

    (** Returns the component-wise minimum of this and \[param with\], equivalent to \[code\]Vector2i(mini(x, with), mini(y, with))\[/code\]. *)
    val mini : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.Vector2i.t structure ptr -> BuiltinClass0.Vector2i.t structure ptr)

    (** Returns the component-wise maximum of this and \[param with\], equivalent to \[code\]Vector2i(maxi(x, with.x), maxi(y, with.y))\[/code\]. *)
    val max : 
    (BuiltinClass0.Vector2i.t structure ptr -> BuiltinClass0.Vector2i.t structure ptr -> BuiltinClass0.Vector2i.t structure ptr)

    (** Returns the component-wise maximum of this and \[param with\], equivalent to \[code\]Vector2i(maxi(x, with), maxi(y, with))\[/code\]. *)
    val maxi : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.Vector2i.t structure ptr -> BuiltinClass0.Vector2i.t structure ptr)





    (** Returns the negative value of the \[Vector2i\]. This is the same as writing \[code\]Vector2i(-v.x, -v.y)\[/code\]. This operation flips the direction of the vector while keeping the same magnitude. *)
    val (~-) : 
    (Vector2i.t structure ptr -> Vector2i.t structure ptr -> Vector2i.t structure ptr)

    (** Returns the same value as if the \[code\]+\[/code\] was not there. Unary \[code\]+\[/code\] does nothing, but sometimes it can make your code more readable. *)
    val (~+) : 
    (Vector2i.t structure ptr -> Vector2i.t structure ptr -> Vector2i.t structure ptr)


    val not : 
    (Vector2i.t structure ptr -> Vector2i.t structure ptr -> Bool.t structure ptr)











    (** Returns \[code\]true\[/code\] if the vectors are equal. *)
    val (=) : 
    (Vector2i.t structure ptr -> Vector2i.t structure ptr -> Bool.t structure ptr)

    (** Returns \[code\]true\[/code\] if the vectors are not equal. *)
    val (<>) : 
    (Vector2i.t structure ptr -> Vector2i.t structure ptr -> Bool.t structure ptr)

    (** Compares two \[Vector2i\] vectors by first checking if the X value of the left vector is less than the X value of the \[param right\] vector. If the X values are exactly equal, then it repeats this check with the Y values of the two vectors. This operator is useful for sorting vectors. *)
    val (<) : 
    (Vector2i.t structure ptr -> Vector2i.t structure ptr -> Bool.t structure ptr)

    (** Compares two \[Vector2i\] vectors by first checking if the X value of the left vector is less than or equal to the X value of the \[param right\] vector. If the X values are exactly equal, then it repeats this check with the Y values of the two vectors. This operator is useful for sorting vectors. *)
    val (<=) : 
    (Vector2i.t structure ptr -> Vector2i.t structure ptr -> Bool.t structure ptr)

    (** Compares two \[Vector2i\] vectors by first checking if the X value of the left vector is greater than the X value of the \[param right\] vector. If the X values are exactly equal, then it repeats this check with the Y values of the two vectors. This operator is useful for sorting vectors. *)
    val (>) : 
    (Vector2i.t structure ptr -> Vector2i.t structure ptr -> Bool.t structure ptr)

    (** Compares two \[Vector2i\] vectors by first checking if the X value of the left vector is greater than or equal to the X value of the \[param right\] vector. If the X values are exactly equal, then it repeats this check with the Y values of the two vectors. This operator is useful for sorting vectors. *)
    val (>=) : 
    (Vector2i.t structure ptr -> Vector2i.t structure ptr -> Bool.t structure ptr)

    (** Adds each component of the \[Vector2i\] by the components of the given \[Vector2i\].
\[codeblock\]
print(Vector2i(10, 20) + Vector2i(3, 4)) # Prints (13, 24)
\[/codeblock\] *)
    val (+) : 
    (Vector2i.t structure ptr -> Vector2i.t structure ptr -> Vector2i.t structure ptr)

    (** Subtracts each component of the \[Vector2i\] by the components of the given \[Vector2i\].
\[codeblock\]
print(Vector2i(10, 20) - Vector2i(3, 4)) # Prints (7, 16)
\[/codeblock\] *)
    val (-) : 
    (Vector2i.t structure ptr -> Vector2i.t structure ptr -> Vector2i.t structure ptr)

    (** Multiplies each component of the \[Vector2i\] by the components of the given \[Vector2i\].
\[codeblock\]
print(Vector2i(10, 20)  *  Vector2i(3, 4)) # Prints (30, 80)
\[/codeblock\] *)
    val ( * ) : 
    (Vector2i.t structure ptr -> Vector2i.t structure ptr -> Vector2i.t structure ptr)

    (** Divides each component of the \[Vector2i\] by the components of the given \[Vector2i\].
\[codeblock\]
print(Vector2i(10, 20) / Vector2i(2, 5)) # Prints (5, 4)
\[/codeblock\] *)
    val (/) : 
    (Vector2i.t structure ptr -> Vector2i.t structure ptr -> Vector2i.t structure ptr)

    (** Gets the remainder of each component of the \[Vector2i\] with the components of the given \[Vector2i\]. This operation uses truncated division, which is often not desired as it does not work well with negative numbers. Consider using \[method \@GlobalScope.posmod\] instead if you want to handle negative numbers.
\[codeblock\]
print(Vector2i(10, -20) % Vector2i(7, 8)) # Prints (3, -4)
\[/codeblock\] *)
    val (%) : 
    (Vector2i.t structure ptr -> Vector2i.t structure ptr -> Vector2i.t structure ptr)


    val mem_Dictionary : 
    (Vector2i.t structure ptr -> Dictionary.t structure ptr -> Bool.t structure ptr)


    val mem_Array : 
    (Vector2i.t structure ptr -> Array.t structure ptr -> Bool.t structure ptr)

    module AXIS : sig type t

    val typ : 
    Int.t structure ptr typ

    (** Enumerated value for the X axis. Returned by \[method max_axis_index\] and \[method min_axis_index\]. *)
    val _AXIS_X : 
    int

    (** Enumerated value for the Y axis. Returned by \[method max_axis_index\] and \[method min_axis_index\]. *)
    val _AXIS_Y : 
    int

    end
    end

  module type RECT2 = sig
    type t


    include Api_types.API_TYPE with type t := t



    (** Returns the center point of the rectangle. This is the same as \[code\]position + (size / 2.0)\[/code\]. *)
    val get_center : 
    (BuiltinClass0.Rect2.t structure ptr -> BuiltinClass0.Vector2.t structure ptr)

    (** Returns the rectangle''s area. This is equivalent to \[code\]size.x  *  size.y\[/code\]. See also \[method has_area\]. *)
    val get_area : 
    (BuiltinClass0.Rect2.t structure ptr -> BuiltinClass0.Float.t structure ptr)

    (** Returns \[code\]true\[/code\] if this rectangle has positive width and height. See also \[method get_area\]. *)
    val has_area : 
    (BuiltinClass0.Rect2.t structure ptr -> BuiltinClass0.Bool.t structure ptr)

    (** Returns \[code\]true\[/code\] if the rectangle contains the given \[param point\]. By convention, points on the right and bottom edges are \[b\]not\[/b\] included.
\[b\]Note:\[/b\] This method is not reliable for \[Rect2\] with a \[i\]negative\[/i\] \[member size\]. Use \[method abs\] first to get a valid rectangle. *)
    val has_point : 
    (BuiltinClass0.Vector2.t structure ptr -> BuiltinClass0.Rect2.t structure ptr -> BuiltinClass0.Bool.t structure ptr)

    (** Returns \[code\]true\[/code\] if this rectangle and \[param rect\] are approximately equal, by calling \[method Vector2.is_equal_approx\] on the \[member position\] and the \[member size\]. *)
    val is_equal_approx : 
    (BuiltinClass0.Rect2.t structure ptr -> BuiltinClass0.Rect2.t structure ptr -> BuiltinClass0.Bool.t structure ptr)

    (** Returns \[code\]true\[/code\] if this rectangle''s values are finite, by calling \[method Vector2.is_finite\] on the \[member position\] and the \[member size\]. *)
    val is_finite : 
    (BuiltinClass0.Rect2.t structure ptr -> BuiltinClass0.Bool.t structure ptr)

    (** Returns \[code\]true\[/code\] if this rectangle overlaps with the \[param b\] rectangle. The edges of both rectangles are excluded, unless \[param include_borders\] is \[code\]true\[/code\]. *)
    val intersects : 
    (BuiltinClass0.Rect2.t structure ptr -> BuiltinClass0.Bool.t structure ptr -> BuiltinClass0.Rect2.t structure ptr -> BuiltinClass0.Bool.t structure ptr)

    (** Returns \[code\]true\[/code\] if this rectangle \[i\]completely\[/i\] encloses the \[param b\] rectangle. *)
    val encloses : 
    (BuiltinClass0.Rect2.t structure ptr -> BuiltinClass0.Rect2.t structure ptr -> BuiltinClass0.Bool.t structure ptr)

    (** Returns the intersection between this rectangle and \[param b\]. If the rectangles do not intersect, returns an empty \[Rect2\].
\[codeblocks\]
\[gdscript\]
var rect1 = Rect2(0, 0, 5, 10)
var rect2 = Rect2(2, 0, 8, 4)

var a = rect1.intersection(rect2) # a is Rect2(2, 0, 3, 4)
\[/gdscript\]
\[csharp\]
var rect1 = new Rect2(0, 0, 5, 10);
var rect2 = new Rect2(2, 0, 8, 4);

var a = rect1.Intersection(rect2); // a is Rect2(2, 0, 3, 4)
\[/csharp\]
\[/codeblocks\]
\[b\]Note:\[/b\] If you only need to know whether two rectangles are overlapping, use \[method intersects\], instead. *)
    val intersection : 
    (BuiltinClass0.Rect2.t structure ptr -> BuiltinClass0.Rect2.t structure ptr -> BuiltinClass0.Rect2.t structure ptr)

    (** Returns a \[Rect2\] that encloses both this rectangle and \[param b\] around the edges. See also \[method encloses\]. *)
    val merge : 
    (BuiltinClass0.Rect2.t structure ptr -> BuiltinClass0.Rect2.t structure ptr -> BuiltinClass0.Rect2.t structure ptr)

    (** Returns a copy of this rectangle expanded to align the edges with the given \[param to\] point, if necessary.
\[codeblocks\]
\[gdscript\]
var rect = Rect2(0, 0, 5, 2)

rect = rect.expand(Vector2(10, 0)) # rect is Rect2(0, 0, 10, 2)
rect = rect.expand(Vector2(-5, 5)) # rect is Rect2(-5, 0, 15, 5)
\[/gdscript\]
\[csharp\]
var rect = new Rect2(0, 0, 5, 2);

rect = rect.Expand(new Vector2(10, 0)); // rect is Rect2(0, 0, 10, 2)
rect = rect.Expand(new Vector2(-5, 5)); // rect is Rect2(-5, 0, 15, 5)
\[/csharp\]
\[/codeblocks\] *)
    val expand : 
    (BuiltinClass0.Vector2.t structure ptr -> BuiltinClass0.Rect2.t structure ptr -> BuiltinClass0.Rect2.t structure ptr)

    (** Returns the vertex''s position of this rect that''s the farthest in the given direction. This point is commonly known as the support point in collision detection algorithms. *)
    val get_support : 
    (BuiltinClass0.Vector2.t structure ptr -> BuiltinClass0.Rect2.t structure ptr -> BuiltinClass0.Vector2.t structure ptr)

    (** Returns a copy of this rectangle extended on all sides by the given \[param amount\]. A negative \[param amount\] shrinks the rectangle instead. See also \[method grow_individual\] and \[method grow_side\].
\[codeblocks\]
\[gdscript\]
var a = Rect2(4, 4, 8, 8).grow(4) # a is Rect2(0, 0, 16, 16)
var b = Rect2(0, 0, 8, 4).grow(2) # b is Rect2(-2, -2, 12, 8)
\[/gdscript\]
\[csharp\]
var a = new Rect2(4, 4, 8, 8).Grow(4); // a is Rect2(0, 0, 16, 16)
var b = new Rect2(0, 0, 8, 4).Grow(2); // b is Rect2(-2, -2, 12, 8)
\[/csharp\]
\[/codeblocks\] *)
    val grow : 
    (BuiltinClass0.Float.t structure ptr -> BuiltinClass0.Rect2.t structure ptr -> BuiltinClass0.Rect2.t structure ptr)

    (** Returns a copy of this rectangle with its \[param side\] extended by the given \[param amount\] (see \[enum Side\] constants). A negative \[param amount\] shrinks the rectangle, instead. See also \[method grow\] and \[method grow_individual\]. *)
    val grow_side : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.Float.t structure ptr -> BuiltinClass0.Rect2.t structure ptr -> BuiltinClass0.Rect2.t structure ptr)

    (** Returns a copy of this rectangle with its \[param left\], \[param top\], \[param right\], and \[param bottom\] sides extended by the given amounts. Negative values shrink the sides, instead. See also \[method grow\] and \[method grow_side\]. *)
    val grow_individual : 
    (BuiltinClass0.Float.t structure ptr -> BuiltinClass0.Float.t structure ptr -> BuiltinClass0.Float.t structure ptr -> BuiltinClass0.Float.t structure ptr -> BuiltinClass0.Rect2.t structure ptr -> BuiltinClass0.Rect2.t structure ptr)

    (** Returns a \[Rect2\] equivalent to this rectangle, with its width and height modified to be non-negative values, and with its \[member position\] being the top-left corner of the rectangle.
\[codeblocks\]
\[gdscript\]
var rect = Rect2(25, 25, -100, -50)
var absolute = rect.abs() # absolute is Rect2(-75, -25, 100, 50)
\[/gdscript\]
\[csharp\]
var rect = new Rect2(25, 25, -100, -50);
var absolute = rect.Abs(); // absolute is Rect2(-75, -25, 100, 50)
\[/csharp\]
\[/codeblocks\]
\[b\]Note:\[/b\] It''s recommended to use this method when \[member size\] is negative, as most other methods in Godot assume that the \[member position\] is the top-left corner, and the \[member end\] is the bottom-right corner. *)
    val abs : 
    (BuiltinClass0.Rect2.t structure ptr -> BuiltinClass0.Rect2.t structure ptr)






    val not : 
    (Rect2.t structure ptr -> Rect2.t structure ptr -> Bool.t structure ptr)

    (** Returns \[code\]true\[/code\] if both \[member position\] and \[member size\] of the rectangles are exactly equal, respectively.
\[b\]Note:\[/b\] Due to floating-point precision errors, consider using \[method is_equal_approx\] instead, which is more reliable. *)
    val (=) : 
    (Rect2.t structure ptr -> Rect2.t structure ptr -> Bool.t structure ptr)

    (** Returns \[code\]true\[/code\] if the \[member position\] or \[member size\] of both rectangles are not equal.
\[b\]Note:\[/b\] Due to floating-point precision errors, consider using \[method is_equal_approx\] instead, which is more reliable. *)
    val (<>) : 
    (Rect2.t structure ptr -> Rect2.t structure ptr -> Bool.t structure ptr)




    val mem_Dictionary : 
    (Rect2.t structure ptr -> Dictionary.t structure ptr -> Bool.t structure ptr)


    val mem_Array : 
    (Rect2.t structure ptr -> Array.t structure ptr -> Bool.t structure ptr)
    end

  module type RECT2I = sig
    type t


    include Api_types.API_TYPE with type t := t



    (** Returns the center point of the rectangle. This is the same as \[code\]position + (size / 2)\[/code\].
\[b\]Note:\[/b\] If the \[member size\] is odd, the result will be rounded towards \[member position\]. *)
    val get_center : 
    (BuiltinClass0.Rect2i.t structure ptr -> BuiltinClass0.Vector2i.t structure ptr)

    (** Returns the rectangle''s area. This is equivalent to \[code\]size.x  *  size.y\[/code\]. See also \[method has_area\]. *)
    val get_area : 
    (BuiltinClass0.Rect2i.t structure ptr -> BuiltinClass0.Int.t structure ptr)

    (** Returns \[code\]true\[/code\] if this rectangle has positive width and height. See also \[method get_area\]. *)
    val has_area : 
    (BuiltinClass0.Rect2i.t structure ptr -> BuiltinClass0.Bool.t structure ptr)

    (** Returns \[code\]true\[/code\] if the rectangle contains the given \[param point\]. By convention, points on the right and bottom edges are \[b\]not\[/b\] included.
\[b\]Note:\[/b\] This method is not reliable for \[Rect2i\] with a \[i\]negative\[/i\] \[member size\]. Use \[method abs\] first to get a valid rectangle. *)
    val has_point : 
    (BuiltinClass0.Vector2i.t structure ptr -> BuiltinClass0.Rect2i.t structure ptr -> BuiltinClass0.Bool.t structure ptr)

    (** Returns \[code\]true\[/code\] if this rectangle overlaps with the \[param b\] rectangle. The edges of both rectangles are excluded. *)
    val intersects : 
    (BuiltinClass0.Rect2i.t structure ptr -> BuiltinClass0.Rect2i.t structure ptr -> BuiltinClass0.Bool.t structure ptr)

    (** Returns \[code\]true\[/code\] if this \[Rect2i\] completely encloses another one. *)
    val encloses : 
    (BuiltinClass0.Rect2i.t structure ptr -> BuiltinClass0.Rect2i.t structure ptr -> BuiltinClass0.Bool.t structure ptr)

    (** Returns the intersection between this rectangle and \[param b\]. If the rectangles do not intersect, returns an empty \[Rect2i\].
\[codeblocks\]
\[gdscript\]
var a = Rect2i(0, 0, 5, 10)
var b = Rect2i(2, 0, 8, 4)

var c = a.intersection(b) # c is Rect2i(2, 0, 3, 4)
\[/gdscript\]
\[csharp\]
var a = new Rect2I(0, 0, 5, 10);
var b = new Rect2I(2, 0, 8, 4);

var c = rect1.Intersection(rect2); // c is Rect2I(2, 0, 3, 4)
\[/csharp\]
\[/codeblocks\]
\[b\]Note:\[/b\] If you only need to know whether two rectangles are overlapping, use \[method intersects\], instead. *)
    val intersection : 
    (BuiltinClass0.Rect2i.t structure ptr -> BuiltinClass0.Rect2i.t structure ptr -> BuiltinClass0.Rect2i.t structure ptr)

    (** Returns a \[Rect2i\] that encloses both this rectangle and \[param b\] around the edges. See also \[method encloses\]. *)
    val merge : 
    (BuiltinClass0.Rect2i.t structure ptr -> BuiltinClass0.Rect2i.t structure ptr -> BuiltinClass0.Rect2i.t structure ptr)

    (** Returns a copy of this rectangle expanded to align the edges with the given \[param to\] point, if necessary.
\[codeblocks\]
\[gdscript\]
var rect = Rect2i(0, 0, 5, 2)

rect = rect.expand(Vector2i(10, 0)) # rect is Rect2i(0, 0, 10, 2)
rect = rect.expand(Vector2i(-5, 5)) # rect is Rect2i(-5, 0, 15, 5)
\[/gdscript\]
\[csharp\]
var rect = new Rect2I(0, 0, 5, 2);

rect = rect.Expand(new Vector2I(10, 0)); // rect is Rect2I(0, 0, 10, 2)
rect = rect.Expand(new Vector2I(-5, 5)); // rect is Rect2I(-5, 0, 15, 5)
\[/csharp\]
\[/codeblocks\] *)
    val expand : 
    (BuiltinClass0.Vector2i.t structure ptr -> BuiltinClass0.Rect2i.t structure ptr -> BuiltinClass0.Rect2i.t structure ptr)

    (** Returns a copy of this rectangle extended on all sides by the given \[param amount\]. A negative \[param amount\] shrinks the rectangle instead. See also \[method grow_individual\] and \[method grow_side\].
\[codeblocks\]
\[gdscript\]
var a = Rect2i(4, 4, 8, 8).grow(4) # a is Rect2i(0, 0, 16, 16)
var b = Rect2i(0, 0, 8, 4).grow(2) # b is Rect2i(-2, -2, 12, 8)
\[/gdscript\]
\[csharp\]
var a = new Rect2I(4, 4, 8, 8).Grow(4); // a is Rect2I(0, 0, 16, 16)
var b = new Rect2I(0, 0, 8, 4).Grow(2); // b is Rect2I(-2, -2, 12, 8)
\[/csharp\]
\[/codeblocks\] *)
    val grow : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.Rect2i.t structure ptr -> BuiltinClass0.Rect2i.t structure ptr)

    (** Returns a copy of this rectangle with its \[param side\] extended by the given \[param amount\] (see \[enum Side\] constants). A negative \[param amount\] shrinks the rectangle, instead. See also \[method grow\] and \[method grow_individual\]. *)
    val grow_side : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.Int.t structure ptr -> BuiltinClass0.Rect2i.t structure ptr -> BuiltinClass0.Rect2i.t structure ptr)

    (** Returns a copy of this rectangle with its \[param left\], \[param top\], \[param right\], and \[param bottom\] sides extended by the given amounts. Negative values shrink the sides, instead. See also \[method grow\] and \[method grow_side\]. *)
    val grow_individual : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.Int.t structure ptr -> BuiltinClass0.Int.t structure ptr -> BuiltinClass0.Int.t structure ptr -> BuiltinClass0.Rect2i.t structure ptr -> BuiltinClass0.Rect2i.t structure ptr)

    (** Returns a \[Rect2i\] equivalent to this rectangle, with its width and height modified to be non-negative values, and with its \[member position\] being the top-left corner of the rectangle.
\[codeblocks\]
\[gdscript\]
var rect = Rect2i(25, 25, -100, -50)
var absolute = rect.abs() # absolute is Rect2i(-75, -25, 100, 50)
\[/gdscript\]
\[csharp\]
var rect = new Rect2I(25, 25, -100, -50);
var absolute = rect.Abs(); // absolute is Rect2I(-75, -25, 100, 50)
\[/csharp\]
\[/codeblocks\]
\[b\]Note:\[/b\] It''s recommended to use this method when \[member size\] is negative, as most other methods in Godot assume that the \[member position\] is the top-left corner, and the \[member end\] is the bottom-right corner. *)
    val abs : 
    (BuiltinClass0.Rect2i.t structure ptr -> BuiltinClass0.Rect2i.t structure ptr)






    val not : 
    (Rect2i.t structure ptr -> Rect2i.t structure ptr -> Bool.t structure ptr)

    (** Returns \[code\]true\[/code\] if both \[member position\] and \[member size\] of the rectangles are equal, respectively. *)
    val (=) : 
    (Rect2i.t structure ptr -> Rect2i.t structure ptr -> Bool.t structure ptr)

    (** Returns \[code\]true\[/code\] if the \[member position\] or \[member size\] of both rectangles are not equal. *)
    val (<>) : 
    (Rect2i.t structure ptr -> Rect2i.t structure ptr -> Bool.t structure ptr)


    val mem_Dictionary : 
    (Rect2i.t structure ptr -> Dictionary.t structure ptr -> Bool.t structure ptr)


    val mem_Array : 
    (Rect2i.t structure ptr -> Array.t structure ptr -> Bool.t structure ptr)
    end

  module type VECTOR3 = sig
    type t


    include Api_types.API_TYPE with type t := t



    (** Returns the axis of the vector''s lowest value. See \[code\]AXIS_ * \[/code\] constants. If all components are equal, this method returns \[constant AXIS_Z\]. *)
    val min_axis_index : 
    (BuiltinClass0.Vector3.t structure ptr -> BuiltinClass0.Int.t structure ptr)

    (** Returns the axis of the vector''s highest value. See \[code\]AXIS_ * \[/code\] constants. If all components are equal, this method returns \[constant AXIS_X\]. *)
    val max_axis_index : 
    (BuiltinClass0.Vector3.t structure ptr -> BuiltinClass0.Int.t structure ptr)

    (** Returns the unsigned minimum angle to the given vector, in radians. *)
    val angle_to : 
    (BuiltinClass0.Vector3.t structure ptr -> BuiltinClass0.Vector3.t structure ptr -> BuiltinClass0.Float.t structure ptr)

    (** Returns the signed angle to the given vector, in radians. The sign of the angle is positive in a counter-clockwise direction and negative in a clockwise direction when viewed from the side specified by the \[param axis\]. *)
    val signed_angle_to : 
    (BuiltinClass0.Vector3.t structure ptr -> BuiltinClass0.Vector3.t structure ptr -> BuiltinClass0.Vector3.t structure ptr -> BuiltinClass0.Float.t structure ptr)

    (** Returns the normalized vector pointing from this vector to \[param to\]. This is equivalent to using \[code\](b - a).normalized()\[/code\]. *)
    val direction_to : 
    (BuiltinClass0.Vector3.t structure ptr -> BuiltinClass0.Vector3.t structure ptr -> BuiltinClass0.Vector3.t structure ptr)

    (** Returns the distance between this vector and \[param to\]. *)
    val distance_to : 
    (BuiltinClass0.Vector3.t structure ptr -> BuiltinClass0.Vector3.t structure ptr -> BuiltinClass0.Float.t structure ptr)

    (** Returns the squared distance between this vector and \[param to\].
This method runs faster than \[method distance_to\], so prefer it if you need to compare vectors or need the squared distance for some formula. *)
    val distance_squared_to : 
    (BuiltinClass0.Vector3.t structure ptr -> BuiltinClass0.Vector3.t structure ptr -> BuiltinClass0.Float.t structure ptr)

    (** Returns the length (magnitude) of this vector. *)
    val length : 
    (BuiltinClass0.Vector3.t structure ptr -> BuiltinClass0.Float.t structure ptr)

    (** Returns the squared length (squared magnitude) of this vector.
This method runs faster than \[method length\], so prefer it if you need to compare vectors or need the squared distance for some formula. *)
    val length_squared : 
    (BuiltinClass0.Vector3.t structure ptr -> BuiltinClass0.Float.t structure ptr)

    (** Returns the vector with a maximum length by limiting its length to \[param length\]. If the vector is non-finite, the result is undefined. *)
    val limit_length : 
    (BuiltinClass0.Float.t structure ptr -> BuiltinClass0.Vector3.t structure ptr -> BuiltinClass0.Vector3.t structure ptr)

    (** Returns the result of scaling the vector to unit length. Equivalent to \[code\]v / v.length()\[/code\]. Returns \[code\](0, 0, 0)\[/code\] if \[code\]v.length() == 0\[/code\]. See also \[method is_normalized\].
\[b\]Note:\[/b\] This function may return incorrect values if the input vector length is near zero. *)
    val normalized : 
    (BuiltinClass0.Vector3.t structure ptr -> BuiltinClass0.Vector3.t structure ptr)

    (** Returns \[code\]true\[/code\] if the vector is normalized, i.e. its length is approximately equal to 1. *)
    val is_normalized : 
    (BuiltinClass0.Vector3.t structure ptr -> BuiltinClass0.Bool.t structure ptr)

    (** Returns \[code\]true\[/code\] if this vector and \[param to\] are approximately equal, by running \[method \@GlobalScope.is_equal_approx\] on each component. *)
    val is_equal_approx : 
    (BuiltinClass0.Vector3.t structure ptr -> BuiltinClass0.Vector3.t structure ptr -> BuiltinClass0.Bool.t structure ptr)

    (** Returns \[code\]true\[/code\] if this vector''s values are approximately zero, by running \[method \@GlobalScope.is_zero_approx\] on each component.
This method is faster than using \[method is_equal_approx\] with one value as a zero vector. *)
    val is_zero_approx : 
    (BuiltinClass0.Vector3.t structure ptr -> BuiltinClass0.Bool.t structure ptr)

    (** Returns \[code\]true\[/code\] if this vector is finite, by calling \[method \@GlobalScope.is_finite\] on each component. *)
    val is_finite : 
    (BuiltinClass0.Vector3.t structure ptr -> BuiltinClass0.Bool.t structure ptr)

    (** Returns the inverse of the vector. This is the same as \[code\]Vector3(1.0 / v.x, 1.0 / v.y, 1.0 / v.z)\[/code\]. *)
    val inverse : 
    (BuiltinClass0.Vector3.t structure ptr -> BuiltinClass0.Vector3.t structure ptr)

    (** Returns a new vector with all components clamped between the components of \[param min\] and \[param max\], by running \[method \@GlobalScope.clamp\] on each component. *)
    val clamp : 
    (BuiltinClass0.Vector3.t structure ptr -> BuiltinClass0.Vector3.t structure ptr -> BuiltinClass0.Vector3.t structure ptr -> BuiltinClass0.Vector3.t structure ptr)

    (** Returns a new vector with all components clamped between \[param min\] and \[param max\], by running \[method \@GlobalScope.clamp\] on each component. *)
    val clampf : 
    (BuiltinClass0.Float.t structure ptr -> BuiltinClass0.Float.t structure ptr -> BuiltinClass0.Vector3.t structure ptr -> BuiltinClass0.Vector3.t structure ptr)

    (** Returns a new vector with each component snapped to the nearest multiple of the corresponding component in \[param step\]. This can also be used to round the components to an arbitrary number of decimals. *)
    val snapped : 
    (BuiltinClass0.Vector3.t structure ptr -> BuiltinClass0.Vector3.t structure ptr -> BuiltinClass0.Vector3.t structure ptr)

    (** Returns a new vector with each component snapped to the nearest multiple of \[param step\]. This can also be used to round the components to an arbitrary number of decimals. *)
    val snappedf : 
    (BuiltinClass0.Float.t structure ptr -> BuiltinClass0.Vector3.t structure ptr -> BuiltinClass0.Vector3.t structure ptr)

    (** Returns the result of rotating this vector around a given axis by \[param angle\] (in radians). The axis must be a normalized vector. See also \[method \@GlobalScope.deg_to_rad\]. *)
    val rotated : 
    (BuiltinClass0.Vector3.t structure ptr -> BuiltinClass0.Float.t structure ptr -> BuiltinClass0.Vector3.t structure ptr -> BuiltinClass0.Vector3.t structure ptr)

    (** Returns the result of the linear interpolation between this vector and \[param to\] by amount \[param weight\]. \[param weight\] is on the range of \[code\]0.0\[/code\] to \[code\]1.0\[/code\], representing the amount of interpolation. *)
    val lerp : 
    (BuiltinClass0.Vector3.t structure ptr -> BuiltinClass0.Float.t structure ptr -> BuiltinClass0.Vector3.t structure ptr -> BuiltinClass0.Vector3.t structure ptr)

    (** Returns the result of spherical linear interpolation between this vector and \[param to\], by amount \[param weight\]. \[param weight\] is on the range of 0.0 to 1.0, representing the amount of interpolation.
This method also handles interpolating the lengths if the input vectors have different lengths. For the special case of one or both input vectors having zero length, this method behaves like \[method lerp\]. *)
    val slerp : 
    (BuiltinClass0.Vector3.t structure ptr -> BuiltinClass0.Float.t structure ptr -> BuiltinClass0.Vector3.t structure ptr -> BuiltinClass0.Vector3.t structure ptr)

    (** Performs a cubic interpolation between this vector and \[param b\] using \[param pre_a\] and \[param post_b\] as handles, and returns the result at position \[param weight\]. \[param weight\] is on the range of 0.0 to 1.0, representing the amount of interpolation. *)
    val cubic_interpolate : 
    (BuiltinClass0.Vector3.t structure ptr -> BuiltinClass0.Vector3.t structure ptr -> BuiltinClass0.Vector3.t structure ptr -> BuiltinClass0.Float.t structure ptr -> BuiltinClass0.Vector3.t structure ptr -> BuiltinClass0.Vector3.t structure ptr)

    (** Performs a cubic interpolation between this vector and \[param b\] using \[param pre_a\] and \[param post_b\] as handles, and returns the result at position \[param weight\]. \[param weight\] is on the range of 0.0 to 1.0, representing the amount of interpolation.
It can perform smoother interpolation than \[method cubic_interpolate\] by the time values. *)
    val cubic_interpolate_in_time : 
    (BuiltinClass0.Vector3.t structure ptr -> BuiltinClass0.Vector3.t structure ptr -> BuiltinClass0.Vector3.t structure ptr -> BuiltinClass0.Float.t structure ptr -> BuiltinClass0.Float.t structure ptr -> BuiltinClass0.Float.t structure ptr -> BuiltinClass0.Float.t structure ptr -> BuiltinClass0.Vector3.t structure ptr -> BuiltinClass0.Vector3.t structure ptr)

    (** Returns the point at the given \[param t\] on the \[url=https://en.wikipedia.org/wiki/B%C3%A9zier_curve\]Bzier curve\[/url\] defined by this vector and the given \[param control_1\], \[param control_2\], and \[param end\] points. *)
    val bezier_interpolate : 
    (BuiltinClass0.Vector3.t structure ptr -> BuiltinClass0.Vector3.t structure ptr -> BuiltinClass0.Vector3.t structure ptr -> BuiltinClass0.Float.t structure ptr -> BuiltinClass0.Vector3.t structure ptr -> BuiltinClass0.Vector3.t structure ptr)

    (** Returns the derivative at the given \[param t\] on the \[url=https://en.wikipedia.org/wiki/B%C3%A9zier_curve\]Bzier curve\[/url\] defined by this vector and the given \[param control_1\], \[param control_2\], and \[param end\] points. *)
    val bezier_derivative : 
    (BuiltinClass0.Vector3.t structure ptr -> BuiltinClass0.Vector3.t structure ptr -> BuiltinClass0.Vector3.t structure ptr -> BuiltinClass0.Float.t structure ptr -> BuiltinClass0.Vector3.t structure ptr -> BuiltinClass0.Vector3.t structure ptr)

    (** Returns a new vector moved toward \[param to\] by the fixed \[param delta\] amount. Will not go past the final value. *)
    val move_toward : 
    (BuiltinClass0.Vector3.t structure ptr -> BuiltinClass0.Float.t structure ptr -> BuiltinClass0.Vector3.t structure ptr -> BuiltinClass0.Vector3.t structure ptr)

    (** Returns the dot product of this vector and \[param with\]. This can be used to compare the angle between two vectors. For example, this can be used to determine whether an enemy is facing the player.
The dot product will be \[code\]0\[/code\] for a right angle (90 degrees), greater than 0 for angles narrower than 90 degrees and lower than 0 for angles wider than 90 degrees.
When using unit (normalized) vectors, the result will always be between \[code\]-1.0\[/code\] (180 degree angle) when the vectors are facing opposite directions, and \[code\]1.0\[/code\] (0 degree angle) when the vectors are aligned.
\[b\]Note:\[/b\] \[code\]a.dot(b)\[/code\] is equivalent to \[code\]b.dot(a)\[/code\]. *)
    val dot : 
    (BuiltinClass0.Vector3.t structure ptr -> BuiltinClass0.Vector3.t structure ptr -> BuiltinClass0.Float.t structure ptr)

    (** Returns the cross product of this vector and \[param with\].
This returns a vector perpendicular to both this and \[param with\], which would be the normal vector of the plane defined by the two vectors. As there are two such vectors, in opposite directions, this method returns the vector defined by a right-handed coordinate system. If the two vectors are parallel this returns an empty vector, making it useful for testing if two vectors are parallel. *)
    val cross : 
    (BuiltinClass0.Vector3.t structure ptr -> BuiltinClass0.Vector3.t structure ptr -> BuiltinClass0.Vector3.t structure ptr)

    (** Returns the outer product with \[param with\]. *)
    val outer : 
    (BuiltinClass0.Vector3.t structure ptr -> BuiltinClass0.Vector3.t structure ptr -> BuiltinClass0.Basis.t structure ptr)

    (** Returns a new vector with all components in absolute values (i.e. positive). *)
    val abs : 
    (BuiltinClass0.Vector3.t structure ptr -> BuiltinClass0.Vector3.t structure ptr)

    (** Returns a new vector with all components rounded down (towards negative infinity). *)
    val floor : 
    (BuiltinClass0.Vector3.t structure ptr -> BuiltinClass0.Vector3.t structure ptr)

    (** Returns a new vector with all components rounded up (towards positive infinity). *)
    val ceil : 
    (BuiltinClass0.Vector3.t structure ptr -> BuiltinClass0.Vector3.t structure ptr)

    (** Returns a new vector with all components rounded to the nearest integer, with halfway cases rounded away from zero. *)
    val round : 
    (BuiltinClass0.Vector3.t structure ptr -> BuiltinClass0.Vector3.t structure ptr)

    (** Returns a vector composed of the \[method \@GlobalScope.fposmod\] of this vector''s components and \[param mod\]. *)
    val posmod : 
    (BuiltinClass0.Float.t structure ptr -> BuiltinClass0.Vector3.t structure ptr -> BuiltinClass0.Vector3.t structure ptr)

    (** Returns a vector composed of the \[method \@GlobalScope.fposmod\] of this vector''s components and \[param modv\]''s components. *)
    val posmodv : 
    (BuiltinClass0.Vector3.t structure ptr -> BuiltinClass0.Vector3.t structure ptr -> BuiltinClass0.Vector3.t structure ptr)

    (** Returns a new vector resulting from projecting this vector onto the given vector \[param b\]. The resulting new vector is parallel to \[param b\]. See also \[method slide\].
\[b\]Note:\[/b\] If the vector \[param b\] is a zero vector, the components of the resulting new vector will be \[constant \@GDScript.NAN\]. *)
    val project : 
    (BuiltinClass0.Vector3.t structure ptr -> BuiltinClass0.Vector3.t structure ptr -> BuiltinClass0.Vector3.t structure ptr)

    (** Returns a new vector resulting from sliding this vector along a plane with normal \[param n\]. The resulting new vector is perpendicular to \[param n\], and is equivalent to this vector minus its projection on \[param n\]. See also \[method project\].
\[b\]Note:\[/b\] The vector \[param n\] must be normalized. See also \[method normalized\]. *)
    val slide : 
    (BuiltinClass0.Vector3.t structure ptr -> BuiltinClass0.Vector3.t structure ptr -> BuiltinClass0.Vector3.t structure ptr)

    (** Returns the vector ""bounced off"" from a plane defined by the given normal \[param n\].
\[b\]Note:\[/b\] \[method bounce\] performs the operation that most engines and frameworks call \[code skip-lint\]reflect()\[/code\]. *)
    val bounce : 
    (BuiltinClass0.Vector3.t structure ptr -> BuiltinClass0.Vector3.t structure ptr -> BuiltinClass0.Vector3.t structure ptr)

    (** Returns the result of reflecting the vector through a plane defined by the given normal vector \[param n\].
\[b\]Note:\[/b\] \[method reflect\] differs from what other engines and frameworks call \[code skip-lint\]reflect()\[/code\]. In other engines, \[code skip-lint\]reflect()\[/code\] returns the result of the vector reflected by the given plane. The reflection thus passes through the given normal. While in Godot the reflection passes through the plane and can be thought of as bouncing off the normal. See also \[method bounce\] which does what most engines call \[code skip-lint\]reflect()\[/code\]. *)
    val reflect : 
    (BuiltinClass0.Vector3.t structure ptr -> BuiltinClass0.Vector3.t structure ptr -> BuiltinClass0.Vector3.t structure ptr)

    (** Returns a new vector with each component set to \[code\]1.0\[/code\] if it''s positive, \[code\]-1.0\[/code\] if it''s negative, and \[code\]0.0\[/code\] if it''s zero. The result is identical to calling \[method \@GlobalScope.sign\] on each component. *)
    val sign : 
    (BuiltinClass0.Vector3.t structure ptr -> BuiltinClass0.Vector3.t structure ptr)

    (** Returns the octahedral-encoded (oct32) form of this \[Vector3\] as a \[Vector2\]. Since a \[Vector2\] occupies 1/3 less memory compared to \[Vector3\], this form of compression can be used to pass greater amounts of \[method normalized\] \[Vector3\]s without increasing storage or memory requirements. See also \[method octahedron_decode\].
\[b\]Note:\[/b\] \[method octahedron_encode\] can only be used for \[method normalized\] vectors. \[method octahedron_encode\] does \[i\]not\[/i\] check whether this \[Vector3\] is normalized, and will return a value that does not decompress to the original value if the \[Vector3\] is not normalized.
\[b\]Note:\[/b\] Octahedral compression is \[i\]lossy\[/i\], although visual differences are rarely perceptible in real world scenarios. *)
    val octahedron_encode : 
    (BuiltinClass0.Vector3.t structure ptr -> BuiltinClass0.Vector2.t structure ptr)

    (** Returns the component-wise minimum of this and \[param with\], equivalent to \[code\]Vector3(minf(x, with.x), minf(y, with.y), minf(z, with.z))\[/code\]. *)
    val min : 
    (BuiltinClass0.Vector3.t structure ptr -> BuiltinClass0.Vector3.t structure ptr -> BuiltinClass0.Vector3.t structure ptr)

    (** Returns the component-wise minimum of this and \[param with\], equivalent to \[code\]Vector3(minf(x, with), minf(y, with), minf(z, with))\[/code\]. *)
    val minf : 
    (BuiltinClass0.Float.t structure ptr -> BuiltinClass0.Vector3.t structure ptr -> BuiltinClass0.Vector3.t structure ptr)

    (** Returns the component-wise maximum of this and \[param with\], equivalent to \[code\]Vector3(maxf(x, with.x), maxf(y, with.y), maxf(z, with.z))\[/code\]. *)
    val max : 
    (BuiltinClass0.Vector3.t structure ptr -> BuiltinClass0.Vector3.t structure ptr -> BuiltinClass0.Vector3.t structure ptr)

    (** Returns the component-wise maximum of this and \[param with\], equivalent to \[code\]Vector3(maxf(x, with), maxf(y, with), maxf(z, with))\[/code\]. *)
    val maxf : 
    (BuiltinClass0.Float.t structure ptr -> BuiltinClass0.Vector3.t structure ptr -> BuiltinClass0.Vector3.t structure ptr)

    (** Returns the \[Vector3\] from an octahedral-compressed form created using \[method octahedron_encode\] (stored as a \[Vector2\]). *)
    val octahedron_decode : 
    (BuiltinClass0.Vector2.t structure ptr -> BuiltinClass0.Vector3.t structure ptr)





    (** Returns the negative value of the \[Vector3\]. This is the same as writing \[code\]Vector3(-v.x, -v.y, -v.z)\[/code\]. This operation flips the direction of the vector while keeping the same magnitude. With floats, the number zero can be either positive or negative. *)
    val (~-) : 
    (Vector3.t structure ptr -> Vector3.t structure ptr -> Vector3.t structure ptr)

    (** Returns the same value as if the \[code\]+\[/code\] was not there. Unary \[code\]+\[/code\] does nothing, but sometimes it can make your code more readable. *)
    val (~+) : 
    (Vector3.t structure ptr -> Vector3.t structure ptr -> Vector3.t structure ptr)


    val not : 
    (Vector3.t structure ptr -> Vector3.t structure ptr -> Bool.t structure ptr)









    (** Returns \[code\]true\[/code\] if the vectors are exactly equal.
\[b\]Note:\[/b\] Due to floating-point precision errors, consider using \[method is_equal_approx\] instead, which is more reliable.
\[b\]Note:\[/b\] Vectors with \[constant \@GDScript.NAN\] elements don''t behave the same as other vectors. Therefore, the results from this operator may not be accurate if NaNs are included. *)
    val (=) : 
    (Vector3.t structure ptr -> Vector3.t structure ptr -> Bool.t structure ptr)

    (** Returns \[code\]true\[/code\] if the vectors are not equal.
\[b\]Note:\[/b\] Due to floating-point precision errors, consider using \[method is_equal_approx\] instead, which is more reliable.
\[b\]Note:\[/b\] Vectors with \[constant \@GDScript.NAN\] elements don''t behave the same as other vectors. Therefore, the results from this operator may not be accurate if NaNs are included. *)
    val (<>) : 
    (Vector3.t structure ptr -> Vector3.t structure ptr -> Bool.t structure ptr)

    (** Compares two \[Vector3\] vectors by first checking if the X value of the left vector is less than the X value of the \[param right\] vector. If the X values are exactly equal, then it repeats this check with the Y values of the two vectors, and then with the Z values. This operator is useful for sorting vectors.
\[b\]Note:\[/b\] Vectors with \[constant \@GDScript.NAN\] elements don''t behave the same as other vectors. Therefore, the results from this operator may not be accurate if NaNs are included. *)
    val (<) : 
    (Vector3.t structure ptr -> Vector3.t structure ptr -> Bool.t structure ptr)

    (** Compares two \[Vector3\] vectors by first checking if the X value of the left vector is less than or equal to the X value of the \[param right\] vector. If the X values are exactly equal, then it repeats this check with the Y values of the two vectors, and then with the Z values. This operator is useful for sorting vectors.
\[b\]Note:\[/b\] Vectors with \[constant \@GDScript.NAN\] elements don''t behave the same as other vectors. Therefore, the results from this operator may not be accurate if NaNs are included. *)
    val (<=) : 
    (Vector3.t structure ptr -> Vector3.t structure ptr -> Bool.t structure ptr)

    (** Compares two \[Vector3\] vectors by first checking if the X value of the left vector is greater than the X value of the \[param right\] vector. If the X values are exactly equal, then it repeats this check with the Y values of the two vectors, and then with the Z values. This operator is useful for sorting vectors.
\[b\]Note:\[/b\] Vectors with \[constant \@GDScript.NAN\] elements don''t behave the same as other vectors. Therefore, the results from this operator may not be accurate if NaNs are included. *)
    val (>) : 
    (Vector3.t structure ptr -> Vector3.t structure ptr -> Bool.t structure ptr)

    (** Compares two \[Vector3\] vectors by first checking if the X value of the left vector is greater than or equal to the X value of the \[param right\] vector. If the X values are exactly equal, then it repeats this check with the Y values of the two vectors, and then with the Z values. This operator is useful for sorting vectors.
\[b\]Note:\[/b\] Vectors with \[constant \@GDScript.NAN\] elements don''t behave the same as other vectors. Therefore, the results from this operator may not be accurate if NaNs are included. *)
    val (>=) : 
    (Vector3.t structure ptr -> Vector3.t structure ptr -> Bool.t structure ptr)

    (** Adds each component of the \[Vector3\] by the components of the given \[Vector3\].
\[codeblock\]
print(Vector3(10, 20, 30) + Vector3(3, 4, 5)) # Prints (13.0, 24.0, 35.0)
\[/codeblock\] *)
    val (+) : 
    (Vector3.t structure ptr -> Vector3.t structure ptr -> Vector3.t structure ptr)

    (** Subtracts each component of the \[Vector3\] by the components of the given \[Vector3\].
\[codeblock\]
print(Vector3(10, 20, 30) - Vector3(3, 4, 5)) # Prints (7.0, 16.0, 25.0)
\[/codeblock\] *)
    val (-) : 
    (Vector3.t structure ptr -> Vector3.t structure ptr -> Vector3.t structure ptr)

    (** Multiplies each component of the \[Vector3\] by the components of the given \[Vector3\].
\[codeblock\]
print(Vector3(10, 20, 30)  *  Vector3(3, 4, 5)) # Prints (30.0, 80.0, 150.0)
\[/codeblock\] *)
    val ( * ) : 
    (Vector3.t structure ptr -> Vector3.t structure ptr -> Vector3.t structure ptr)

    (** Divides each component of the \[Vector3\] by the components of the given \[Vector3\].
\[codeblock\]
print(Vector3(10, 20, 30) / Vector3(2, 5, 3)) # Prints (5.0, 4.0, 10.0)
\[/codeblock\] *)
    val (/) : 
    (Vector3.t structure ptr -> Vector3.t structure ptr -> Vector3.t structure ptr)








    val mem_Dictionary : 
    (Vector3.t structure ptr -> Dictionary.t structure ptr -> Bool.t structure ptr)


    val mem_Array : 
    (Vector3.t structure ptr -> Array.t structure ptr -> Bool.t structure ptr)


    val mem_PackedVector3Array : 
    (Vector3.t structure ptr -> PackedVector3Array.t structure ptr -> Bool.t structure ptr)

    module AXIS : sig type t

    val typ : 
    Int.t structure ptr typ

    (** Enumerated value for the X axis. Returned by \[method max_axis_index\] and \[method min_axis_index\]. *)
    val _AXIS_X : 
    int

    (** Enumerated value for the Y axis. Returned by \[method max_axis_index\] and \[method min_axis_index\]. *)
    val _AXIS_Y : 
    int

    (** Enumerated value for the Z axis. Returned by \[method max_axis_index\] and \[method min_axis_index\]. *)
    val _AXIS_Z : 
    int

    end
    end

  module type VECTOR3I = sig
    type t


    include Api_types.API_TYPE with type t := t



    (** Returns the axis of the vector''s lowest value. See \[code\]AXIS_ * \[/code\] constants. If all components are equal, this method returns \[constant AXIS_Z\]. *)
    val min_axis_index : 
    (BuiltinClass0.Vector3i.t structure ptr -> BuiltinClass0.Int.t structure ptr)

    (** Returns the axis of the vector''s highest value. See \[code\]AXIS_ * \[/code\] constants. If all components are equal, this method returns \[constant AXIS_X\]. *)
    val max_axis_index : 
    (BuiltinClass0.Vector3i.t structure ptr -> BuiltinClass0.Int.t structure ptr)

    (** Returns the distance between this vector and \[param to\]. *)
    val distance_to : 
    (BuiltinClass0.Vector3i.t structure ptr -> BuiltinClass0.Vector3i.t structure ptr -> BuiltinClass0.Float.t structure ptr)

    (** Returns the squared distance between this vector and \[param to\].
This method runs faster than \[method distance_to\], so prefer it if you need to compare vectors or need the squared distance for some formula. *)
    val distance_squared_to : 
    (BuiltinClass0.Vector3i.t structure ptr -> BuiltinClass0.Vector3i.t structure ptr -> BuiltinClass0.Int.t structure ptr)

    (** Returns the length (magnitude) of this vector. *)
    val length : 
    (BuiltinClass0.Vector3i.t structure ptr -> BuiltinClass0.Float.t structure ptr)

    (** Returns the squared length (squared magnitude) of this vector.
This method runs faster than \[method length\], so prefer it if you need to compare vectors or need the squared distance for some formula. *)
    val length_squared : 
    (BuiltinClass0.Vector3i.t structure ptr -> BuiltinClass0.Int.t structure ptr)

    (** Returns a new vector with each component set to \[code\]1\[/code\] if it''s positive, \[code\]-1\[/code\] if it''s negative, and \[code\]0\[/code\] if it''s zero. The result is identical to calling \[method \@GlobalScope.sign\] on each component. *)
    val sign : 
    (BuiltinClass0.Vector3i.t structure ptr -> BuiltinClass0.Vector3i.t structure ptr)

    (** Returns a new vector with all components in absolute values (i.e. positive). *)
    val abs : 
    (BuiltinClass0.Vector3i.t structure ptr -> BuiltinClass0.Vector3i.t structure ptr)

    (** Returns a new vector with all components clamped between the components of \[param min\] and \[param max\], by running \[method \@GlobalScope.clamp\] on each component. *)
    val clamp : 
    (BuiltinClass0.Vector3i.t structure ptr -> BuiltinClass0.Vector3i.t structure ptr -> BuiltinClass0.Vector3i.t structure ptr -> BuiltinClass0.Vector3i.t structure ptr)

    (** Returns a new vector with all components clamped between \[param min\] and \[param max\], by running \[method \@GlobalScope.clamp\] on each component. *)
    val clampi : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.Int.t structure ptr -> BuiltinClass0.Vector3i.t structure ptr -> BuiltinClass0.Vector3i.t structure ptr)

    (** Returns a new vector with each component snapped to the closest multiple of the corresponding component in \[param step\]. *)
    val snapped : 
    (BuiltinClass0.Vector3i.t structure ptr -> BuiltinClass0.Vector3i.t structure ptr -> BuiltinClass0.Vector3i.t structure ptr)

    (** Returns a new vector with each component snapped to the closest multiple of \[param step\]. *)
    val snappedi : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.Vector3i.t structure ptr -> BuiltinClass0.Vector3i.t structure ptr)

    (** Returns the component-wise minimum of this and \[param with\], equivalent to \[code\]Vector3i(mini(x, with.x), mini(y, with.y), mini(z, with.z))\[/code\]. *)
    val min : 
    (BuiltinClass0.Vector3i.t structure ptr -> BuiltinClass0.Vector3i.t structure ptr -> BuiltinClass0.Vector3i.t structure ptr)

    (** Returns the component-wise minimum of this and \[param with\], equivalent to \[code\]Vector3i(mini(x, with), mini(y, with), mini(z, with))\[/code\]. *)
    val mini : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.Vector3i.t structure ptr -> BuiltinClass0.Vector3i.t structure ptr)

    (** Returns the component-wise maximum of this and \[param with\], equivalent to \[code\]Vector3i(maxi(x, with.x), maxi(y, with.y), maxi(z, with.z))\[/code\]. *)
    val max : 
    (BuiltinClass0.Vector3i.t structure ptr -> BuiltinClass0.Vector3i.t structure ptr -> BuiltinClass0.Vector3i.t structure ptr)

    (** Returns the component-wise maximum of this and \[param with\], equivalent to \[code\]Vector3i(maxi(x, with), maxi(y, with), maxi(z, with))\[/code\]. *)
    val maxi : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.Vector3i.t structure ptr -> BuiltinClass0.Vector3i.t structure ptr)





    (** Returns the negative value of the \[Vector3i\]. This is the same as writing \[code\]Vector3i(-v.x, -v.y, -v.z)\[/code\]. This operation flips the direction of the vector while keeping the same magnitude. *)
    val (~-) : 
    (Vector3i.t structure ptr -> Vector3i.t structure ptr -> Vector3i.t structure ptr)

    (** Returns the same value as if the \[code\]+\[/code\] was not there. Unary \[code\]+\[/code\] does nothing, but sometimes it can make your code more readable. *)
    val (~+) : 
    (Vector3i.t structure ptr -> Vector3i.t structure ptr -> Vector3i.t structure ptr)


    val not : 
    (Vector3i.t structure ptr -> Vector3i.t structure ptr -> Bool.t structure ptr)











    (** Returns \[code\]true\[/code\] if the vectors are equal. *)
    val (=) : 
    (Vector3i.t structure ptr -> Vector3i.t structure ptr -> Bool.t structure ptr)

    (** Returns \[code\]true\[/code\] if the vectors are not equal. *)
    val (<>) : 
    (Vector3i.t structure ptr -> Vector3i.t structure ptr -> Bool.t structure ptr)

    (** Compares two \[Vector3i\] vectors by first checking if the X value of the left vector is less than the X value of the \[param right\] vector. If the X values are exactly equal, then it repeats this check with the Y values of the two vectors, and then with the Z values. This operator is useful for sorting vectors. *)
    val (<) : 
    (Vector3i.t structure ptr -> Vector3i.t structure ptr -> Bool.t structure ptr)

    (** Compares two \[Vector3i\] vectors by first checking if the X value of the left vector is less than or equal to the X value of the \[param right\] vector. If the X values are exactly equal, then it repeats this check with the Y values of the two vectors, and then with the Z values. This operator is useful for sorting vectors. *)
    val (<=) : 
    (Vector3i.t structure ptr -> Vector3i.t structure ptr -> Bool.t structure ptr)

    (** Compares two \[Vector3i\] vectors by first checking if the X value of the left vector is greater than the X value of the \[param right\] vector. If the X values are exactly equal, then it repeats this check with the Y values of the two vectors, and then with the Z values. This operator is useful for sorting vectors. *)
    val (>) : 
    (Vector3i.t structure ptr -> Vector3i.t structure ptr -> Bool.t structure ptr)

    (** Compares two \[Vector3i\] vectors by first checking if the X value of the left vector is greater than or equal to the X value of the \[param right\] vector. If the X values are exactly equal, then it repeats this check with the Y values of the two vectors, and then with the Z values. This operator is useful for sorting vectors. *)
    val (>=) : 
    (Vector3i.t structure ptr -> Vector3i.t structure ptr -> Bool.t structure ptr)

    (** Adds each component of the \[Vector3i\] by the components of the given \[Vector3i\].
\[codeblock\]
print(Vector3i(10, 20, 30) + Vector3i(3, 4, 5)) # Prints (13, 24, 35)
\[/codeblock\] *)
    val (+) : 
    (Vector3i.t structure ptr -> Vector3i.t structure ptr -> Vector3i.t structure ptr)

    (** Subtracts each component of the \[Vector3i\] by the components of the given \[Vector3i\].
\[codeblock\]
print(Vector3i(10, 20, 30) - Vector3i(3, 4, 5)) # Prints (7, 16, 25)
\[/codeblock\] *)
    val (-) : 
    (Vector3i.t structure ptr -> Vector3i.t structure ptr -> Vector3i.t structure ptr)

    (** Multiplies each component of the \[Vector3i\] by the components of the given \[Vector3i\].
\[codeblock\]
print(Vector3i(10, 20, 30)  *  Vector3i(3, 4, 5)) # Prints (30, 80, 150)
\[/codeblock\] *)
    val ( * ) : 
    (Vector3i.t structure ptr -> Vector3i.t structure ptr -> Vector3i.t structure ptr)

    (** Divides each component of the \[Vector3i\] by the components of the given \[Vector3i\].
\[codeblock\]
print(Vector3i(10, 20, 30) / Vector3i(2, 5, 3)) # Prints (5, 4, 10)
\[/codeblock\] *)
    val (/) : 
    (Vector3i.t structure ptr -> Vector3i.t structure ptr -> Vector3i.t structure ptr)

    (** Gets the remainder of each component of the \[Vector3i\] with the components of the given \[Vector3i\]. This operation uses truncated division, which is often not desired as it does not work well with negative numbers. Consider using \[method \@GlobalScope.posmod\] instead if you want to handle negative numbers.
\[codeblock\]
print(Vector3i(10, -20, 30) % Vector3i(7, 8, 9)) # Prints (3, -4, 3)
\[/codeblock\] *)
    val (%) : 
    (Vector3i.t structure ptr -> Vector3i.t structure ptr -> Vector3i.t structure ptr)


    val mem_Dictionary : 
    (Vector3i.t structure ptr -> Dictionary.t structure ptr -> Bool.t structure ptr)


    val mem_Array : 
    (Vector3i.t structure ptr -> Array.t structure ptr -> Bool.t structure ptr)

    module AXIS : sig type t

    val typ : 
    Int.t structure ptr typ

    (** Enumerated value for the X axis. Returned by \[method max_axis_index\] and \[method min_axis_index\]. *)
    val _AXIS_X : 
    int

    (** Enumerated value for the Y axis. Returned by \[method max_axis_index\] and \[method min_axis_index\]. *)
    val _AXIS_Y : 
    int

    (** Enumerated value for the Z axis. Returned by \[method max_axis_index\] and \[method min_axis_index\]. *)
    val _AXIS_Z : 
    int

    end
    end

  module type TRANSFORM2D = sig
    type t


    include Api_types.API_TYPE with type t := t



    (** Returns the \[url=https://en.wikipedia.org/wiki/Invertible_matrix\]inverted version of this transform\[/url\].
\[b\]Note:\[/b\] For this method to return correctly, the transform''s basis needs to be \[i\]orthonormal\[/i\] (see \[method orthonormalized\]). That means the basis should only represent a rotation. If it does not, use \[method affine_inverse\] instead. *)
    val inverse : 
    (BuiltinClass0.Transform2D.t structure ptr -> BuiltinClass0.Transform2D.t structure ptr)

    (** Returns the inverted version of this transform. Unlike \[method inverse\], this method works with almost any basis, including non-uniform ones, but is slower.
\[b\]Note:\[/b\] For this method to return correctly, the transform''s basis needs to have a determinant that is not exactly \[code\]0.0\[/code\] (see \[method determinant\]). *)
    val affine_inverse : 
    (BuiltinClass0.Transform2D.t structure ptr -> BuiltinClass0.Transform2D.t structure ptr)

    (** Returns this transform''s rotation (in radians). This is equivalent to \[member x\]''s angle (see \[method Vector2.angle\]). *)
    val get_rotation : 
    (BuiltinClass0.Transform2D.t structure ptr -> BuiltinClass0.Float.t structure ptr)

    (** Returns this transform''s translation. Equivalent to \[member origin\]. *)
    val get_origin : 
    (BuiltinClass0.Transform2D.t structure ptr -> BuiltinClass0.Vector2.t structure ptr)

    (** Returns the length of both \[member x\] and \[member y\], as a \[Vector2\]. If this transform''s basis is not skewed, this value is the scaling factor. It is not affected by rotation.
\[codeblocks\]
\[gdscript\]
var my_transform = Transform2D(
    Vector2(2, 0),
    Vector2(0, 4),
    Vector2(0, 0)
)
# Rotating the Transform2D in any way preserves its scale.
my_transform = my_transform.rotated(TAU / 2)

print(my_transform.get_scale()) # Prints (2.0, 4.0)
\[/gdscript\]
\[csharp\]
var myTransform = new Transform2D(
    Vector3(2.0f, 0.0f),
    Vector3(0.0f, 4.0f),
    Vector3(0.0f, 0.0f)
);
// Rotating the Transform2D in any way preserves its scale.
myTransform = myTransform.Rotated(Mathf.Tau / 2.0f);

GD.Print(myTransform.GetScale()); // Prints (2, 4)
\[/csharp\]
\[/codeblocks\]
\[b\]Note:\[/b\] If the value returned by \[method determinant\] is negative, the scale is also negative. *)
    val get_scale : 
    (BuiltinClass0.Transform2D.t structure ptr -> BuiltinClass0.Vector2.t structure ptr)

    (** Returns this transform''s skew (in radians). *)
    val get_skew : 
    (BuiltinClass0.Transform2D.t structure ptr -> BuiltinClass0.Float.t structure ptr)

    (** Returns a copy of this transform with its basis orthonormalized. An orthonormal basis is both \[i\]orthogonal\[/i\] (the axes are perpendicular to each other) and \[i\]normalized\[/i\] (the axes have a length of \[code\]1.0\[/code\]), which also means it can only represent a rotation. *)
    val orthonormalized : 
    (BuiltinClass0.Transform2D.t structure ptr -> BuiltinClass0.Transform2D.t structure ptr)

    (** Returns a copy of this transform rotated by the given \[param angle\] (in radians).
If \[param angle\] is positive, the transform is rotated clockwise.
This method is an optimized version of multiplying the given transform \[code\]X\[/code\] with a corresponding rotation transform \[code\]R\[/code\] from the left, i.e., \[code\]R  *  X\[/code\].
This can be seen as transforming with respect to the global/parent frame. *)
    val rotated : 
    (BuiltinClass0.Float.t structure ptr -> BuiltinClass0.Transform2D.t structure ptr -> BuiltinClass0.Transform2D.t structure ptr)

    (** Returns a copy of the transform rotated by the given \[param angle\] (in radians).
This method is an optimized version of multiplying the given transform \[code\]X\[/code\] with a corresponding rotation transform \[code\]R\[/code\] from the right, i.e., \[code\]X  *  R\[/code\].
This can be seen as transforming with respect to the local frame. *)
    val rotated_local : 
    (BuiltinClass0.Float.t structure ptr -> BuiltinClass0.Transform2D.t structure ptr -> BuiltinClass0.Transform2D.t structure ptr)

    (** Returns a copy of the transform scaled by the given \[param scale\] factor.
This method is an optimized version of multiplying the given transform \[code\]X\[/code\] with a corresponding scaling transform \[code\]S\[/code\] from the left, i.e., \[code\]S  *  X\[/code\].
This can be seen as transforming with respect to the global/parent frame. *)
    val scaled : 
    (BuiltinClass0.Vector2.t structure ptr -> BuiltinClass0.Transform2D.t structure ptr -> BuiltinClass0.Transform2D.t structure ptr)

    (** Returns a copy of the transform scaled by the given \[param scale\] factor.
This method is an optimized version of multiplying the given transform \[code\]X\[/code\] with a corresponding scaling transform \[code\]S\[/code\] from the right, i.e., \[code\]X  *  S\[/code\].
This can be seen as transforming with respect to the local frame. *)
    val scaled_local : 
    (BuiltinClass0.Vector2.t structure ptr -> BuiltinClass0.Transform2D.t structure ptr -> BuiltinClass0.Transform2D.t structure ptr)

    (** Returns a copy of the transform translated by the given \[param offset\].
This method is an optimized version of multiplying the given transform \[code\]X\[/code\] with a corresponding translation transform \[code\]T\[/code\] from the left, i.e., \[code\]T  *  X\[/code\].
This can be seen as transforming with respect to the global/parent frame. *)
    val translated : 
    (BuiltinClass0.Vector2.t structure ptr -> BuiltinClass0.Transform2D.t structure ptr -> BuiltinClass0.Transform2D.t structure ptr)

    (** Returns a copy of the transform translated by the given \[param offset\].
This method is an optimized version of multiplying the given transform \[code\]X\[/code\] with a corresponding translation transform \[code\]T\[/code\] from the right, i.e., \[code\]X  *  T\[/code\].
This can be seen as transforming with respect to the local frame. *)
    val translated_local : 
    (BuiltinClass0.Vector2.t structure ptr -> BuiltinClass0.Transform2D.t structure ptr -> BuiltinClass0.Transform2D.t structure ptr)

    (** Returns the \[url=https://en.wikipedia.org/wiki/Determinant\]determinant\[/url\] of this transform basis''s matrix. For advanced math, this number can be used to determine a few attributes:
- If the determinant is exactly \[code\]0.0\[/code\], the basis is not invertible (see \[method inverse\]).
- If the determinant is a negative number, the basis represents a negative scale.
\[b\]Note:\[/b\] If the basis''s scale is the same for every axis, its determinant is always that scale by the power of 2. *)
    val determinant : 
    (BuiltinClass0.Transform2D.t structure ptr -> BuiltinClass0.Float.t structure ptr)

    (** Returns a copy of the \[param v\] vector, transformed (multiplied) by the transform basis''s matrix. Unlike the multiplication operator (\[code\] * \[/code\]), this method ignores the \[member origin\]. *)
    val basis_xform : 
    (BuiltinClass0.Vector2.t structure ptr -> BuiltinClass0.Transform2D.t structure ptr -> BuiltinClass0.Vector2.t structure ptr)

    (** Returns a copy of the \[param v\] vector, transformed (multiplied) by the inverse transform basis''s matrix (see \[method inverse\]). This method ignores the \[member origin\].
\[b\]Note:\[/b\] This method assumes that this transform''s basis is \[i\]orthonormal\[/i\] (see \[method orthonormalized\]). If the basis is not orthonormal, \[code\]transform.affine_inverse().basis_xform(vector)\[/code\] should be used instead (see \[method affine_inverse\]). *)
    val basis_xform_inv : 
    (BuiltinClass0.Vector2.t structure ptr -> BuiltinClass0.Transform2D.t structure ptr -> BuiltinClass0.Vector2.t structure ptr)

    (** Returns the result of the linear interpolation between this transform and \[param xform\] by the given \[param weight\].
The \[param weight\] should be between \[code\]0.0\[/code\] and \[code\]1.0\[/code\] (inclusive). Values outside this range are allowed and can be used to perform \[i\]extrapolation\[/i\] instead. *)
    val interpolate_with : 
    (BuiltinClass0.Transform2D.t structure ptr -> BuiltinClass0.Float.t structure ptr -> BuiltinClass0.Transform2D.t structure ptr -> BuiltinClass0.Transform2D.t structure ptr)

    (** Returns \[code\]true\[/code\] if this transform''s basis is conformal. A conformal basis is both \[i\]orthogonal\[/i\] (the axes are perpendicular to each other) and \[i\]uniform\[/i\] (the axes share the same length). This method can be especially useful during physics calculations. *)
    val is_conformal : 
    (BuiltinClass0.Transform2D.t structure ptr -> BuiltinClass0.Bool.t structure ptr)

    (** Returns \[code\]true\[/code\] if this transform and \[param xform\] are approximately equal, by running \[method \@GlobalScope.is_equal_approx\] on each component. *)
    val is_equal_approx : 
    (BuiltinClass0.Transform2D.t structure ptr -> BuiltinClass0.Transform2D.t structure ptr -> BuiltinClass0.Bool.t structure ptr)

    (** Returns \[code\]true\[/code\] if this transform is finite, by calling \[method \@GlobalScope.is_finite\] on each component. *)
    val is_finite : 
    (BuiltinClass0.Transform2D.t structure ptr -> BuiltinClass0.Bool.t structure ptr)

    (** Returns a copy of the transform rotated such that the rotated X-axis points towards the \[param target\] position, in global space. *)
    val looking_at : 
    (BuiltinClass0.Vector2.t structure ptr -> BuiltinClass0.Transform2D.t structure ptr -> BuiltinClass0.Transform2D.t structure ptr)






    val not : 
    (Transform2D.t structure ptr -> Transform2D.t structure ptr -> Bool.t structure ptr)













    (** Returns \[code\]true\[/code\] if the components of both transforms are exactly equal.
\[b\]Note:\[/b\] Due to floating-point precision errors, consider using \[method is_equal_approx\] instead, which is more reliable. *)
    val (=) : 
    (Transform2D.t structure ptr -> Transform2D.t structure ptr -> Bool.t structure ptr)

    (** Returns \[code\]true\[/code\] if the components of both transforms are not equal.
\[b\]Note:\[/b\] Due to floating-point precision errors, consider using \[method is_equal_approx\] instead, which is more reliable. *)
    val (<>) : 
    (Transform2D.t structure ptr -> Transform2D.t structure ptr -> Bool.t structure ptr)

    (** Transforms (multiplies) this transform by the \[param right\] transform.
This is the operation performed between parent and child \[CanvasItem\] nodes.
\[b\]Note:\[/b\] If you need to only modify one attribute of this transform, consider using one of the following methods, instead:
- For translation, see \[method translated\] or \[method translated_local\].
- For rotation, see \[method rotated\] or \[method rotated_local\].
- For scale, see \[method scaled\] or \[method scaled_local\]. *)
    val ( * ) : 
    (Transform2D.t structure ptr -> Transform2D.t structure ptr -> Transform2D.t structure ptr)


    val mem_Dictionary : 
    (Transform2D.t structure ptr -> Dictionary.t structure ptr -> Bool.t structure ptr)


    val mem_Array : 
    (Transform2D.t structure ptr -> Array.t structure ptr -> Bool.t structure ptr)


    end

  module type VECTOR4 = sig
    type t


    include Api_types.API_TYPE with type t := t



    (** Returns the axis of the vector''s lowest value. See \[code\]AXIS_ * \[/code\] constants. If all components are equal, this method returns \[constant AXIS_W\]. *)
    val min_axis_index : 
    (BuiltinClass0.Vector4.t structure ptr -> BuiltinClass0.Int.t structure ptr)

    (** Returns the axis of the vector''s highest value. See \[code\]AXIS_ * \[/code\] constants. If all components are equal, this method returns \[constant AXIS_X\]. *)
    val max_axis_index : 
    (BuiltinClass0.Vector4.t structure ptr -> BuiltinClass0.Int.t structure ptr)

    (** Returns the length (magnitude) of this vector. *)
    val length : 
    (BuiltinClass0.Vector4.t structure ptr -> BuiltinClass0.Float.t structure ptr)

    (** Returns the squared length (squared magnitude) of this vector.
This method runs faster than \[method length\], so prefer it if you need to compare vectors or need the squared distance for some formula. *)
    val length_squared : 
    (BuiltinClass0.Vector4.t structure ptr -> BuiltinClass0.Float.t structure ptr)

    (** Returns a new vector with all components in absolute values (i.e. positive). *)
    val abs : 
    (BuiltinClass0.Vector4.t structure ptr -> BuiltinClass0.Vector4.t structure ptr)

    (** Returns a new vector with each component set to \[code\]1.0\[/code\] if it''s positive, \[code\]-1.0\[/code\] if it''s negative, and \[code\]0.0\[/code\] if it''s zero. The result is identical to calling \[method \@GlobalScope.sign\] on each component. *)
    val sign : 
    (BuiltinClass0.Vector4.t structure ptr -> BuiltinClass0.Vector4.t structure ptr)

    (** Returns a new vector with all components rounded down (towards negative infinity). *)
    val floor : 
    (BuiltinClass0.Vector4.t structure ptr -> BuiltinClass0.Vector4.t structure ptr)

    (** Returns a new vector with all components rounded up (towards positive infinity). *)
    val ceil : 
    (BuiltinClass0.Vector4.t structure ptr -> BuiltinClass0.Vector4.t structure ptr)

    (** Returns a new vector with all components rounded to the nearest integer, with halfway cases rounded away from zero. *)
    val round : 
    (BuiltinClass0.Vector4.t structure ptr -> BuiltinClass0.Vector4.t structure ptr)

    (** Returns the result of the linear interpolation between this vector and \[param to\] by amount \[param weight\]. \[param weight\] is on the range of \[code\]0.0\[/code\] to \[code\]1.0\[/code\], representing the amount of interpolation. *)
    val lerp : 
    (BuiltinClass0.Vector4.t structure ptr -> BuiltinClass0.Float.t structure ptr -> BuiltinClass0.Vector4.t structure ptr -> BuiltinClass0.Vector4.t structure ptr)

    (** Performs a cubic interpolation between this vector and \[param b\] using \[param pre_a\] and \[param post_b\] as handles, and returns the result at position \[param weight\]. \[param weight\] is on the range of 0.0 to 1.0, representing the amount of interpolation. *)
    val cubic_interpolate : 
    (BuiltinClass0.Vector4.t structure ptr -> BuiltinClass0.Vector4.t structure ptr -> BuiltinClass0.Vector4.t structure ptr -> BuiltinClass0.Float.t structure ptr -> BuiltinClass0.Vector4.t structure ptr -> BuiltinClass0.Vector4.t structure ptr)

    (** Performs a cubic interpolation between this vector and \[param b\] using \[param pre_a\] and \[param post_b\] as handles, and returns the result at position \[param weight\]. \[param weight\] is on the range of 0.0 to 1.0, representing the amount of interpolation.
It can perform smoother interpolation than \[method cubic_interpolate\] by the time values. *)
    val cubic_interpolate_in_time : 
    (BuiltinClass0.Vector4.t structure ptr -> BuiltinClass0.Vector4.t structure ptr -> BuiltinClass0.Vector4.t structure ptr -> BuiltinClass0.Float.t structure ptr -> BuiltinClass0.Float.t structure ptr -> BuiltinClass0.Float.t structure ptr -> BuiltinClass0.Float.t structure ptr -> BuiltinClass0.Vector4.t structure ptr -> BuiltinClass0.Vector4.t structure ptr)

    (** Returns a vector composed of the \[method \@GlobalScope.fposmod\] of this vector''s components and \[param mod\]. *)
    val posmod : 
    (BuiltinClass0.Float.t structure ptr -> BuiltinClass0.Vector4.t structure ptr -> BuiltinClass0.Vector4.t structure ptr)

    (** Returns a vector composed of the \[method \@GlobalScope.fposmod\] of this vector''s components and \[param modv\]''s components. *)
    val posmodv : 
    (BuiltinClass0.Vector4.t structure ptr -> BuiltinClass0.Vector4.t structure ptr -> BuiltinClass0.Vector4.t structure ptr)

    (** Returns a new vector with each component snapped to the nearest multiple of the corresponding component in \[param step\]. This can also be used to round the components to an arbitrary number of decimals. *)
    val snapped : 
    (BuiltinClass0.Vector4.t structure ptr -> BuiltinClass0.Vector4.t structure ptr -> BuiltinClass0.Vector4.t structure ptr)

    (** Returns a new vector with each component snapped to the nearest multiple of \[param step\]. This can also be used to round the components to an arbitrary number of decimals. *)
    val snappedf : 
    (BuiltinClass0.Float.t structure ptr -> BuiltinClass0.Vector4.t structure ptr -> BuiltinClass0.Vector4.t structure ptr)

    (** Returns a new vector with all components clamped between the components of \[param min\] and \[param max\], by running \[method \@GlobalScope.clamp\] on each component. *)
    val clamp : 
    (BuiltinClass0.Vector4.t structure ptr -> BuiltinClass0.Vector4.t structure ptr -> BuiltinClass0.Vector4.t structure ptr -> BuiltinClass0.Vector4.t structure ptr)

    (** Returns a new vector with all components clamped between \[param min\] and \[param max\], by running \[method \@GlobalScope.clamp\] on each component. *)
    val clampf : 
    (BuiltinClass0.Float.t structure ptr -> BuiltinClass0.Float.t structure ptr -> BuiltinClass0.Vector4.t structure ptr -> BuiltinClass0.Vector4.t structure ptr)

    (** Returns the result of scaling the vector to unit length. Equivalent to \[code\]v / v.length()\[/code\]. Returns \[code\](0, 0, 0, 0)\[/code\] if \[code\]v.length() == 0\[/code\]. See also \[method is_normalized\].
\[b\]Note:\[/b\] This function may return incorrect values if the input vector length is near zero. *)
    val normalized : 
    (BuiltinClass0.Vector4.t structure ptr -> BuiltinClass0.Vector4.t structure ptr)

    (** Returns \[code\]true\[/code\] if the vector is normalized, i.e. its length is approximately equal to 1. *)
    val is_normalized : 
    (BuiltinClass0.Vector4.t structure ptr -> BuiltinClass0.Bool.t structure ptr)

    (** Returns the normalized vector pointing from this vector to \[param to\]. This is equivalent to using \[code\](b - a).normalized()\[/code\]. *)
    val direction_to : 
    (BuiltinClass0.Vector4.t structure ptr -> BuiltinClass0.Vector4.t structure ptr -> BuiltinClass0.Vector4.t structure ptr)

    (** Returns the distance between this vector and \[param to\]. *)
    val distance_to : 
    (BuiltinClass0.Vector4.t structure ptr -> BuiltinClass0.Vector4.t structure ptr -> BuiltinClass0.Float.t structure ptr)

    (** Returns the squared distance between this vector and \[param to\].
This method runs faster than \[method distance_to\], so prefer it if you need to compare vectors or need the squared distance for some formula. *)
    val distance_squared_to : 
    (BuiltinClass0.Vector4.t structure ptr -> BuiltinClass0.Vector4.t structure ptr -> BuiltinClass0.Float.t structure ptr)

    (** Returns the dot product of this vector and \[param with\]. *)
    val dot : 
    (BuiltinClass0.Vector4.t structure ptr -> BuiltinClass0.Vector4.t structure ptr -> BuiltinClass0.Float.t structure ptr)

    (** Returns the inverse of the vector. This is the same as \[code\]Vector4(1.0 / v.x, 1.0 / v.y, 1.0 / v.z, 1.0 / v.w)\[/code\]. *)
    val inverse : 
    (BuiltinClass0.Vector4.t structure ptr -> BuiltinClass0.Vector4.t structure ptr)

    (** Returns \[code\]true\[/code\] if this vector and \[param to\] are approximately equal, by running \[method \@GlobalScope.is_equal_approx\] on each component. *)
    val is_equal_approx : 
    (BuiltinClass0.Vector4.t structure ptr -> BuiltinClass0.Vector4.t structure ptr -> BuiltinClass0.Bool.t structure ptr)

    (** Returns \[code\]true\[/code\] if this vector''s values are approximately zero, by running \[method \@GlobalScope.is_zero_approx\] on each component.
This method is faster than using \[method is_equal_approx\] with one value as a zero vector. *)
    val is_zero_approx : 
    (BuiltinClass0.Vector4.t structure ptr -> BuiltinClass0.Bool.t structure ptr)

    (** Returns \[code\]true\[/code\] if this vector is finite, by calling \[method \@GlobalScope.is_finite\] on each component. *)
    val is_finite : 
    (BuiltinClass0.Vector4.t structure ptr -> BuiltinClass0.Bool.t structure ptr)

    (** Returns the component-wise minimum of this and \[param with\], equivalent to \[code\]Vector4(minf(x, with.x), minf(y, with.y), minf(z, with.z), minf(w, with.w))\[/code\]. *)
    val min : 
    (BuiltinClass0.Vector4.t structure ptr -> BuiltinClass0.Vector4.t structure ptr -> BuiltinClass0.Vector4.t structure ptr)

    (** Returns the component-wise minimum of this and \[param with\], equivalent to \[code\]Vector4(minf(x, with), minf(y, with), minf(z, with), minf(w, with))\[/code\]. *)
    val minf : 
    (BuiltinClass0.Float.t structure ptr -> BuiltinClass0.Vector4.t structure ptr -> BuiltinClass0.Vector4.t structure ptr)

    (** Returns the component-wise maximum of this and \[param with\], equivalent to \[code\]Vector4(maxf(x, with.x), maxf(y, with.y), maxf(z, with.z), maxf(w, with.w))\[/code\]. *)
    val max : 
    (BuiltinClass0.Vector4.t structure ptr -> BuiltinClass0.Vector4.t structure ptr -> BuiltinClass0.Vector4.t structure ptr)

    (** Returns the component-wise maximum of this and \[param with\], equivalent to \[code\]Vector4(maxf(x, with), maxf(y, with), maxf(z, with), maxf(w, with))\[/code\]. *)
    val maxf : 
    (BuiltinClass0.Float.t structure ptr -> BuiltinClass0.Vector4.t structure ptr -> BuiltinClass0.Vector4.t structure ptr)





    (** Returns the negative value of the \[Vector4\]. This is the same as writing \[code\]Vector4(-v.x, -v.y, -v.z, -v.w)\[/code\]. This operation flips the direction of the vector while keeping the same magnitude. With floats, the number zero can be either positive or negative. *)
    val (~-) : 
    (Vector4.t structure ptr -> Vector4.t structure ptr -> Vector4.t structure ptr)

    (** Returns the same value as if the \[code\]+\[/code\] was not there. Unary \[code\]+\[/code\] does nothing, but sometimes it can make your code more readable. *)
    val (~+) : 
    (Vector4.t structure ptr -> Vector4.t structure ptr -> Vector4.t structure ptr)


    val not : 
    (Vector4.t structure ptr -> Vector4.t structure ptr -> Bool.t structure ptr)









    (** Returns \[code\]true\[/code\] if the vectors are exactly equal.
\[b\]Note:\[/b\] Due to floating-point precision errors, consider using \[method is_equal_approx\] instead, which is more reliable.
\[b\]Note:\[/b\] Vectors with \[constant \@GDScript.NAN\] elements don''t behave the same as other vectors. Therefore, the results from this operator may not be accurate if NaNs are included. *)
    val (=) : 
    (Vector4.t structure ptr -> Vector4.t structure ptr -> Bool.t structure ptr)

    (** Returns \[code\]true\[/code\] if the vectors are not equal.
\[b\]Note:\[/b\] Due to floating-point precision errors, consider using \[method is_equal_approx\] instead, which is more reliable.
\[b\]Note:\[/b\] Vectors with \[constant \@GDScript.NAN\] elements don''t behave the same as other vectors. Therefore, the results from this operator may not be accurate if NaNs are included. *)
    val (<>) : 
    (Vector4.t structure ptr -> Vector4.t structure ptr -> Bool.t structure ptr)

    (** Compares two \[Vector4\] vectors by first checking if the X value of the left vector is less than the X value of the \[param right\] vector. If the X values are exactly equal, then it repeats this check with the Y values of the two vectors, Z values of the two vectors, and then with the W values. This operator is useful for sorting vectors.
\[b\]Note:\[/b\] Vectors with \[constant \@GDScript.NAN\] elements don''t behave the same as other vectors. Therefore, the results from this operator may not be accurate if NaNs are included. *)
    val (<) : 
    (Vector4.t structure ptr -> Vector4.t structure ptr -> Bool.t structure ptr)

    (** Compares two \[Vector4\] vectors by first checking if the X value of the left vector is less than or equal to the X value of the \[param right\] vector. If the X values are exactly equal, then it repeats this check with the Y values of the two vectors, Z values of the two vectors, and then with the W values. This operator is useful for sorting vectors.
\[b\]Note:\[/b\] Vectors with \[constant \@GDScript.NAN\] elements don''t behave the same as other vectors. Therefore, the results from this operator may not be accurate if NaNs are included. *)
    val (<=) : 
    (Vector4.t structure ptr -> Vector4.t structure ptr -> Bool.t structure ptr)

    (** Compares two \[Vector4\] vectors by first checking if the X value of the left vector is greater than the X value of the \[param right\] vector. If the X values are exactly equal, then it repeats this check with the Y values of the two vectors, Z values of the two vectors, and then with the W values. This operator is useful for sorting vectors.
\[b\]Note:\[/b\] Vectors with \[constant \@GDScript.NAN\] elements don''t behave the same as other vectors. Therefore, the results from this operator may not be accurate if NaNs are included. *)
    val (>) : 
    (Vector4.t structure ptr -> Vector4.t structure ptr -> Bool.t structure ptr)

    (** Compares two \[Vector4\] vectors by first checking if the X value of the left vector is greater than or equal to the X value of the \[param right\] vector. If the X values are exactly equal, then it repeats this check with the Y values of the two vectors, Z values of the two vectors, and then with the W values. This operator is useful for sorting vectors.
\[b\]Note:\[/b\] Vectors with \[constant \@GDScript.NAN\] elements don''t behave the same as other vectors. Therefore, the results from this operator may not be accurate if NaNs are included. *)
    val (>=) : 
    (Vector4.t structure ptr -> Vector4.t structure ptr -> Bool.t structure ptr)

    (** Adds each component of the \[Vector4\] by the components of the given \[Vector4\].
\[codeblock\]
print(Vector4(10, 20, 30, 40) + Vector4(3, 4, 5, 6)) # Prints (13.0, 24.0, 35.0, 46.0)
\[/codeblock\] *)
    val (+) : 
    (Vector4.t structure ptr -> Vector4.t structure ptr -> Vector4.t structure ptr)

    (** Subtracts each component of the \[Vector4\] by the components of the given \[Vector4\].
\[codeblock\]
print(Vector4(10, 20, 30, 40) - Vector4(3, 4, 5, 6)) # Prints (7.0, 16.0, 25.0, 34.0)
\[/codeblock\] *)
    val (-) : 
    (Vector4.t structure ptr -> Vector4.t structure ptr -> Vector4.t structure ptr)

    (** Multiplies each component of the \[Vector4\] by the components of the given \[Vector4\].
\[codeblock\]
print(Vector4(10, 20, 30, 40)  *  Vector4(3, 4, 5, 6)) # Prints (30.0, 80.0, 150.0, 240.0)
\[/codeblock\] *)
    val ( * ) : 
    (Vector4.t structure ptr -> Vector4.t structure ptr -> Vector4.t structure ptr)

    (** Divides each component of the \[Vector4\] by the components of the given \[Vector4\].
\[codeblock\]
print(Vector4(10, 20, 30, 40) / Vector4(2, 5, 3, 4)) # Prints (5.0, 4.0, 10.0, 10.0)
\[/codeblock\] *)
    val (/) : 
    (Vector4.t structure ptr -> Vector4.t structure ptr -> Vector4.t structure ptr)




    val mem_Dictionary : 
    (Vector4.t structure ptr -> Dictionary.t structure ptr -> Bool.t structure ptr)


    val mem_Array : 
    (Vector4.t structure ptr -> Array.t structure ptr -> Bool.t structure ptr)


    val mem_PackedVector4Array : 
    (Vector4.t structure ptr -> PackedVector4Array.t structure ptr -> Bool.t structure ptr)

    module AXIS : sig type t

    val typ : 
    Int.t structure ptr typ

    (** Enumerated value for the X axis. Returned by \[method max_axis_index\] and \[method min_axis_index\]. *)
    val _AXIS_X : 
    int

    (** Enumerated value for the Y axis. Returned by \[method max_axis_index\] and \[method min_axis_index\]. *)
    val _AXIS_Y : 
    int

    (** Enumerated value for the Z axis. Returned by \[method max_axis_index\] and \[method min_axis_index\]. *)
    val _AXIS_Z : 
    int

    (** Enumerated value for the W axis. Returned by \[method max_axis_index\] and \[method min_axis_index\]. *)
    val _AXIS_W : 
    int

    end
    end

  module type VECTOR4I = sig
    type t


    include Api_types.API_TYPE with type t := t



    (** Returns the axis of the vector''s lowest value. See \[code\]AXIS_ * \[/code\] constants. If all components are equal, this method returns \[constant AXIS_W\]. *)
    val min_axis_index : 
    (BuiltinClass0.Vector4i.t structure ptr -> BuiltinClass0.Int.t structure ptr)

    (** Returns the axis of the vector''s highest value. See \[code\]AXIS_ * \[/code\] constants. If all components are equal, this method returns \[constant AXIS_X\]. *)
    val max_axis_index : 
    (BuiltinClass0.Vector4i.t structure ptr -> BuiltinClass0.Int.t structure ptr)

    (** Returns the length (magnitude) of this vector. *)
    val length : 
    (BuiltinClass0.Vector4i.t structure ptr -> BuiltinClass0.Float.t structure ptr)

    (** Returns the squared length (squared magnitude) of this vector.
This method runs faster than \[method length\], so prefer it if you need to compare vectors or need the squared distance for some formula. *)
    val length_squared : 
    (BuiltinClass0.Vector4i.t structure ptr -> BuiltinClass0.Int.t structure ptr)

    (** Returns a new vector with each component set to \[code\]1\[/code\] if it''s positive, \[code\]-1\[/code\] if it''s negative, and \[code\]0\[/code\] if it''s zero. The result is identical to calling \[method \@GlobalScope.sign\] on each component. *)
    val sign : 
    (BuiltinClass0.Vector4i.t structure ptr -> BuiltinClass0.Vector4i.t structure ptr)

    (** Returns a new vector with all components in absolute values (i.e. positive). *)
    val abs : 
    (BuiltinClass0.Vector4i.t structure ptr -> BuiltinClass0.Vector4i.t structure ptr)

    (** Returns a new vector with all components clamped between the components of \[param min\] and \[param max\], by running \[method \@GlobalScope.clamp\] on each component. *)
    val clamp : 
    (BuiltinClass0.Vector4i.t structure ptr -> BuiltinClass0.Vector4i.t structure ptr -> BuiltinClass0.Vector4i.t structure ptr -> BuiltinClass0.Vector4i.t structure ptr)

    (** Returns a new vector with all components clamped between \[param min\] and \[param max\], by running \[method \@GlobalScope.clamp\] on each component. *)
    val clampi : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.Int.t structure ptr -> BuiltinClass0.Vector4i.t structure ptr -> BuiltinClass0.Vector4i.t structure ptr)

    (** Returns a new vector with each component snapped to the closest multiple of the corresponding component in \[param step\]. *)
    val snapped : 
    (BuiltinClass0.Vector4i.t structure ptr -> BuiltinClass0.Vector4i.t structure ptr -> BuiltinClass0.Vector4i.t structure ptr)

    (** Returns a new vector with each component snapped to the closest multiple of \[param step\]. *)
    val snappedi : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.Vector4i.t structure ptr -> BuiltinClass0.Vector4i.t structure ptr)

    (** Returns the component-wise minimum of this and \[param with\], equivalent to \[code\]Vector4i(mini(x, with.x), mini(y, with.y), mini(z, with.z), mini(w, with.w))\[/code\]. *)
    val min : 
    (BuiltinClass0.Vector4i.t structure ptr -> BuiltinClass0.Vector4i.t structure ptr -> BuiltinClass0.Vector4i.t structure ptr)

    (** Returns the component-wise minimum of this and \[param with\], equivalent to \[code\]Vector4i(mini(x, with), mini(y, with), mini(z, with), mini(w, with))\[/code\]. *)
    val mini : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.Vector4i.t structure ptr -> BuiltinClass0.Vector4i.t structure ptr)

    (** Returns the component-wise maximum of this and \[param with\], equivalent to \[code\]Vector4i(maxi(x, with.x), maxi(y, with.y), maxi(z, with.z), maxi(w, with.w))\[/code\]. *)
    val max : 
    (BuiltinClass0.Vector4i.t structure ptr -> BuiltinClass0.Vector4i.t structure ptr -> BuiltinClass0.Vector4i.t structure ptr)

    (** Returns the component-wise maximum of this and \[param with\], equivalent to \[code\]Vector4i(maxi(x, with), maxi(y, with), maxi(z, with), maxi(w, with))\[/code\]. *)
    val maxi : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.Vector4i.t structure ptr -> BuiltinClass0.Vector4i.t structure ptr)

    (** Returns the distance between this vector and \[param to\]. *)
    val distance_to : 
    (BuiltinClass0.Vector4i.t structure ptr -> BuiltinClass0.Vector4i.t structure ptr -> BuiltinClass0.Float.t structure ptr)

    (** Returns the squared distance between this vector and \[param to\].
This method runs faster than \[method distance_to\], so prefer it if you need to compare vectors or need the squared distance for some formula. *)
    val distance_squared_to : 
    (BuiltinClass0.Vector4i.t structure ptr -> BuiltinClass0.Vector4i.t structure ptr -> BuiltinClass0.Int.t structure ptr)





    (** Returns the negative value of the \[Vector4i\]. This is the same as writing \[code\]Vector4i(-v.x, -v.y, -v.z, -v.w)\[/code\]. This operation flips the direction of the vector while keeping the same magnitude. *)
    val (~-) : 
    (Vector4i.t structure ptr -> Vector4i.t structure ptr -> Vector4i.t structure ptr)

    (** Returns the same value as if the \[code\]+\[/code\] was not there. Unary \[code\]+\[/code\] does nothing, but sometimes it can make your code more readable. *)
    val (~+) : 
    (Vector4i.t structure ptr -> Vector4i.t structure ptr -> Vector4i.t structure ptr)


    val not : 
    (Vector4i.t structure ptr -> Vector4i.t structure ptr -> Bool.t structure ptr)











    (** Returns \[code\]true\[/code\] if the vectors are exactly equal. *)
    val (=) : 
    (Vector4i.t structure ptr -> Vector4i.t structure ptr -> Bool.t structure ptr)

    (** Returns \[code\]true\[/code\] if the vectors are not equal. *)
    val (<>) : 
    (Vector4i.t structure ptr -> Vector4i.t structure ptr -> Bool.t structure ptr)

    (** Compares two \[Vector4i\] vectors by first checking if the X value of the left vector is less than the X value of the \[param right\] vector. If the X values are exactly equal, then it repeats this check with the Y values of the two vectors, Z values of the two vectors, and then with the W values. This operator is useful for sorting vectors. *)
    val (<) : 
    (Vector4i.t structure ptr -> Vector4i.t structure ptr -> Bool.t structure ptr)

    (** Compares two \[Vector4i\] vectors by first checking if the X value of the left vector is less than or equal to the X value of the \[param right\] vector. If the X values are exactly equal, then it repeats this check with the Y values of the two vectors, Z values of the two vectors, and then with the W values. This operator is useful for sorting vectors. *)
    val (<=) : 
    (Vector4i.t structure ptr -> Vector4i.t structure ptr -> Bool.t structure ptr)

    (** Compares two \[Vector4i\] vectors by first checking if the X value of the left vector is greater than the X value of the \[param right\] vector. If the X values are exactly equal, then it repeats this check with the Y values of the two vectors, Z values of the two vectors, and then with the W values. This operator is useful for sorting vectors. *)
    val (>) : 
    (Vector4i.t structure ptr -> Vector4i.t structure ptr -> Bool.t structure ptr)

    (** Compares two \[Vector4i\] vectors by first checking if the X value of the left vector is greater than or equal to the X value of the \[param right\] vector. If the X values are exactly equal, then it repeats this check with the Y values of the two vectors, Z values of the two vectors, and then with the W values. This operator is useful for sorting vectors. *)
    val (>=) : 
    (Vector4i.t structure ptr -> Vector4i.t structure ptr -> Bool.t structure ptr)

    (** Adds each component of the \[Vector4i\] by the components of the given \[Vector4i\].
\[codeblock\]
print(Vector4i(10, 20, 30, 40) + Vector4i(3, 4, 5, 6)) # Prints (13, 24, 35, 46)
\[/codeblock\] *)
    val (+) : 
    (Vector4i.t structure ptr -> Vector4i.t structure ptr -> Vector4i.t structure ptr)

    (** Subtracts each component of the \[Vector4i\] by the components of the given \[Vector4i\].
\[codeblock\]
print(Vector4i(10, 20, 30, 40) - Vector4i(3, 4, 5, 6)) # Prints (7, 16, 25, 34)
\[/codeblock\] *)
    val (-) : 
    (Vector4i.t structure ptr -> Vector4i.t structure ptr -> Vector4i.t structure ptr)

    (** Multiplies each component of the \[Vector4i\] by the components of the given \[Vector4i\].
\[codeblock\]
print(Vector4i(10, 20, 30, 40)  *  Vector4i(3, 4, 5, 6)) # Prints (30, 80, 150, 240)
\[/codeblock\] *)
    val ( * ) : 
    (Vector4i.t structure ptr -> Vector4i.t structure ptr -> Vector4i.t structure ptr)

    (** Divides each component of the \[Vector4i\] by the components of the given \[Vector4i\].
\[codeblock\]
print(Vector4i(10, 20, 30, 40) / Vector4i(2, 5, 3, 4)) # Prints (5, 4, 10, 10)
\[/codeblock\] *)
    val (/) : 
    (Vector4i.t structure ptr -> Vector4i.t structure ptr -> Vector4i.t structure ptr)

    (** Gets the remainder of each component of the \[Vector4i\] with the components of the given \[Vector4i\]. This operation uses truncated division, which is often not desired as it does not work well with negative numbers. Consider using \[method \@GlobalScope.posmod\] instead if you want to handle negative numbers.
\[codeblock\]
print(Vector4i(10, -20, 30, -40) % Vector4i(7, 8, 9, 10)) # Prints (3, -4, 3, 0)
\[/codeblock\] *)
    val (%) : 
    (Vector4i.t structure ptr -> Vector4i.t structure ptr -> Vector4i.t structure ptr)


    val mem_Dictionary : 
    (Vector4i.t structure ptr -> Dictionary.t structure ptr -> Bool.t structure ptr)


    val mem_Array : 
    (Vector4i.t structure ptr -> Array.t structure ptr -> Bool.t structure ptr)

    module AXIS : sig type t

    val typ : 
    Int.t structure ptr typ

    (** Enumerated value for the X axis. Returned by \[method max_axis_index\] and \[method min_axis_index\]. *)
    val _AXIS_X : 
    int

    (** Enumerated value for the Y axis. Returned by \[method max_axis_index\] and \[method min_axis_index\]. *)
    val _AXIS_Y : 
    int

    (** Enumerated value for the Z axis. Returned by \[method max_axis_index\] and \[method min_axis_index\]. *)
    val _AXIS_Z : 
    int

    (** Enumerated value for the W axis. Returned by \[method max_axis_index\] and \[method min_axis_index\]. *)
    val _AXIS_W : 
    int

    end
    end

  module type PLANE = sig
    type t


    include Api_types.API_TYPE with type t := t



    (** Returns a copy of the plane, with normalized \[member normal\] (so it''s a unit vector). Returns \[code\]Plane(0, 0, 0, 0)\[/code\] if \[member normal\] can''t be normalized (it has zero length). *)
    val normalized : 
    (BuiltinClass0.Plane.t structure ptr -> BuiltinClass0.Plane.t structure ptr)

    (** Returns the center of the plane. *)
    val get_center : 
    (BuiltinClass0.Plane.t structure ptr -> BuiltinClass0.Vector3.t structure ptr)

    (** Returns \[code\]true\[/code\] if this plane and \[param to_plane\] are approximately equal, by running \[method \@GlobalScope.is_equal_approx\] on each component. *)
    val is_equal_approx : 
    (BuiltinClass0.Plane.t structure ptr -> BuiltinClass0.Plane.t structure ptr -> BuiltinClass0.Bool.t structure ptr)

    (** Returns \[code\]true\[/code\] if this plane is finite, by calling \[method \@GlobalScope.is_finite\] on each component. *)
    val is_finite : 
    (BuiltinClass0.Plane.t structure ptr -> BuiltinClass0.Bool.t structure ptr)

    (** Returns \[code\]true\[/code\] if \[param point\] is located above the plane. *)
    val is_point_over : 
    (BuiltinClass0.Vector3.t structure ptr -> BuiltinClass0.Plane.t structure ptr -> BuiltinClass0.Bool.t structure ptr)

    (** Returns the shortest distance from the plane to the position \[param point\]. If the point is above the plane, the distance will be positive. If below, the distance will be negative. *)
    val distance_to : 
    (BuiltinClass0.Vector3.t structure ptr -> BuiltinClass0.Plane.t structure ptr -> BuiltinClass0.Float.t structure ptr)

    (** Returns \[code\]true\[/code\] if \[param point\] is inside the plane. Comparison uses a custom minimum \[param tolerance\] threshold. *)
    val has_point : 
    (BuiltinClass0.Vector3.t structure ptr -> BuiltinClass0.Float.t structure ptr -> BuiltinClass0.Plane.t structure ptr -> BuiltinClass0.Bool.t structure ptr)

    (** Returns the orthogonal projection of \[param point\] into a point in the plane. *)
    val project : 
    (BuiltinClass0.Vector3.t structure ptr -> BuiltinClass0.Plane.t structure ptr -> BuiltinClass0.Vector3.t structure ptr)

    (** Returns the intersection point of the three planes \[param b\], \[param c\] and this plane. If no intersection is found, \[code\]null\[/code\] is returned. *)
    val intersect_3 : 
    (BuiltinClass0.Plane.t structure ptr -> BuiltinClass0.Plane.t structure ptr -> BuiltinClass0.Plane.t structure ptr -> BuiltinClass0.Variant.t structure ptr)

    (** Returns the intersection point of a ray consisting of the position \[param from\] and the direction normal \[param dir\] with this plane. If no intersection is found, \[code\]null\[/code\] is returned. *)
    val intersects_ray : 
    (BuiltinClass0.Vector3.t structure ptr -> BuiltinClass0.Vector3.t structure ptr -> BuiltinClass0.Plane.t structure ptr -> BuiltinClass0.Variant.t structure ptr)

    (** Returns the intersection point of a segment from position \[param from\] to position \[param to\] with this plane. If no intersection is found, \[code\]null\[/code\] is returned. *)
    val intersects_segment : 
    (BuiltinClass0.Vector3.t structure ptr -> BuiltinClass0.Vector3.t structure ptr -> BuiltinClass0.Plane.t structure ptr -> BuiltinClass0.Variant.t structure ptr)





    (** Returns the negative value of the \[Plane\]. This is the same as writing \[code\]Plane(-p.normal, -p.d)\[/code\]. This operation flips the direction of the normal vector and also flips the distance value, resulting in a Plane that is in the same place, but facing the opposite direction. *)
    val (~-) : 
    (Plane.t structure ptr -> Plane.t structure ptr -> Plane.t structure ptr)

    (** Returns the same value as if the \[code\]+\[/code\] was not there. Unary \[code\]+\[/code\] does nothing, but sometimes it can make your code more readable. *)
    val (~+) : 
    (Plane.t structure ptr -> Plane.t structure ptr -> Plane.t structure ptr)


    val not : 
    (Plane.t structure ptr -> Plane.t structure ptr -> Bool.t structure ptr)

    (** Returns \[code\]true\[/code\] if the planes are exactly equal.
\[b\]Note:\[/b\] Due to floating-point precision errors, consider using \[method is_equal_approx\] instead, which is more reliable. *)
    val (=) : 
    (Plane.t structure ptr -> Plane.t structure ptr -> Bool.t structure ptr)

    (** Returns \[code\]true\[/code\] if the planes are not equal.
\[b\]Note:\[/b\] Due to floating-point precision errors, consider using \[method is_equal_approx\] instead, which is more reliable. *)
    val (<>) : 
    (Plane.t structure ptr -> Plane.t structure ptr -> Bool.t structure ptr)




    val mem_Dictionary : 
    (Plane.t structure ptr -> Dictionary.t structure ptr -> Bool.t structure ptr)


    val mem_Array : 
    (Plane.t structure ptr -> Array.t structure ptr -> Bool.t structure ptr)
    end

  module type QUATERNION = sig
    type t


    include Api_types.API_TYPE with type t := t



    (** Returns this quaternion''s length, also called magnitude. *)
    val length : 
    (BuiltinClass0.Quaternion.t structure ptr -> BuiltinClass0.Float.t structure ptr)

    (** Returns this quaternion''s length, squared.
\[b\]Note:\[/b\] This method is faster than \[method length\], so prefer it if you only need to compare quaternion lengths. *)
    val length_squared : 
    (BuiltinClass0.Quaternion.t structure ptr -> BuiltinClass0.Float.t structure ptr)

    (** Returns a copy of this quaternion, normalized so that its length is \[code\]1.0\[/code\]. See also \[method is_normalized\]. *)
    val normalized : 
    (BuiltinClass0.Quaternion.t structure ptr -> BuiltinClass0.Quaternion.t structure ptr)

    (** Returns \[code\]true\[/code\] if this quaternion is normalized. See also \[method normalized\]. *)
    val is_normalized : 
    (BuiltinClass0.Quaternion.t structure ptr -> BuiltinClass0.Bool.t structure ptr)

    (** Returns \[code\]true\[/code\] if this quaternion and \[param to\] are approximately equal, by calling \[method \@GlobalScope.is_equal_approx\] on each component. *)
    val is_equal_approx : 
    (BuiltinClass0.Quaternion.t structure ptr -> BuiltinClass0.Quaternion.t structure ptr -> BuiltinClass0.Bool.t structure ptr)

    (** Returns \[code\]true\[/code\] if this quaternion is finite, by calling \[method \@GlobalScope.is_finite\] on each component. *)
    val is_finite : 
    (BuiltinClass0.Quaternion.t structure ptr -> BuiltinClass0.Bool.t structure ptr)

    (** Returns the inverse version of this quaternion, inverting the sign of every component except \[member w\]. *)
    val inverse : 
    (BuiltinClass0.Quaternion.t structure ptr -> BuiltinClass0.Quaternion.t structure ptr)

    (** Returns the logarithm of this quaternion. Multiplies this quaternion''s rotation axis by its rotation angle, and stores the result in the returned quaternion''s vector part (\[member x\], \[member y\], and \[member z\]). The returned quaternion''s real part (\[member w\]) is always \[code\]0.0\[/code\]. *)
    val log : 
    (BuiltinClass0.Quaternion.t structure ptr -> BuiltinClass0.Quaternion.t structure ptr)

    (** Returns the exponential of this quaternion. The rotation axis of the result is the normalized rotation axis of this quaternion, the angle of the result is the length of the vector part of this quaternion. *)
    val exp : 
    (BuiltinClass0.Quaternion.t structure ptr -> BuiltinClass0.Quaternion.t structure ptr)

    (** Returns the angle between this quaternion and \[param to\]. This is the magnitude of the angle you would need to rotate by to get from one to the other.
\[b\]Note:\[/b\] The magnitude of the floating-point error for this method is abnormally high, so methods such as \[code\]is_zero_approx\[/code\] will not work reliably. *)
    val angle_to : 
    (BuiltinClass0.Quaternion.t structure ptr -> BuiltinClass0.Quaternion.t structure ptr -> BuiltinClass0.Float.t structure ptr)

    (** Returns the dot product between this quaternion and \[param with\].
This is equivalent to \[code\](quat.x  *  with.x) + (quat.y  *  with.y) + (quat.z  *  with.z) + (quat.w  *  with.w)\[/code\]. *)
    val dot : 
    (BuiltinClass0.Quaternion.t structure ptr -> BuiltinClass0.Quaternion.t structure ptr -> BuiltinClass0.Float.t structure ptr)

    (** Performs a spherical-linear interpolation with the \[param to\] quaternion, given a \[param weight\] and returns the result. Both this quaternion and \[param to\] must be normalized. *)
    val slerp : 
    (BuiltinClass0.Quaternion.t structure ptr -> BuiltinClass0.Float.t structure ptr -> BuiltinClass0.Quaternion.t structure ptr -> BuiltinClass0.Quaternion.t structure ptr)

    (** Performs a spherical-linear interpolation with the \[param to\] quaternion, given a \[param weight\] and returns the result. Unlike \[method slerp\], this method does not check if the rotation path is smaller than 90 degrees. Both this quaternion and \[param to\] must be normalized. *)
    val slerpni : 
    (BuiltinClass0.Quaternion.t structure ptr -> BuiltinClass0.Float.t structure ptr -> BuiltinClass0.Quaternion.t structure ptr -> BuiltinClass0.Quaternion.t structure ptr)

    (** Performs a spherical cubic interpolation between quaternions \[param pre_a\], this vector, \[param b\], and \[param post_b\], by the given amount \[param weight\]. *)
    val spherical_cubic_interpolate : 
    (BuiltinClass0.Quaternion.t structure ptr -> BuiltinClass0.Quaternion.t structure ptr -> BuiltinClass0.Quaternion.t structure ptr -> BuiltinClass0.Float.t structure ptr -> BuiltinClass0.Quaternion.t structure ptr -> BuiltinClass0.Quaternion.t structure ptr)

    (** Performs a spherical cubic interpolation between quaternions \[param pre_a\], this vector, \[param b\], and \[param post_b\], by the given amount \[param weight\].
It can perform smoother interpolation than \[method spherical_cubic_interpolate\] by the time values. *)
    val spherical_cubic_interpolate_in_time : 
    (BuiltinClass0.Quaternion.t structure ptr -> BuiltinClass0.Quaternion.t structure ptr -> BuiltinClass0.Quaternion.t structure ptr -> BuiltinClass0.Float.t structure ptr -> BuiltinClass0.Float.t structure ptr -> BuiltinClass0.Float.t structure ptr -> BuiltinClass0.Float.t structure ptr -> BuiltinClass0.Quaternion.t structure ptr -> BuiltinClass0.Quaternion.t structure ptr)

    (** Returns this quaternion''s rotation as a \[Vector3\] of \[url=https://en.wikipedia.org/wiki/Euler_angles\]Euler angles\[/url\], in radians.
The order of each consecutive rotation can be changed with \[param order\] (see \[enum EulerOrder\] constants). By default, the YXZ convention is used (\[constant EULER_ORDER_YXZ\]): Z (roll) is calculated first, then X (pitch), and lastly Y (yaw). When using the opposite method \[method from_euler\], this order is reversed. *)
    val get_euler : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.Quaternion.t structure ptr -> BuiltinClass0.Vector3.t structure ptr)

    (** Constructs a new \[Quaternion\] from the given \[Vector3\] of \[url=https://en.wikipedia.org/wiki/Euler_angles\]Euler angles\[/url\], in radians. This method always uses the YXZ convention (\[constant EULER_ORDER_YXZ\]). *)
    val from_euler : 
    (BuiltinClass0.Vector3.t structure ptr -> BuiltinClass0.Quaternion.t structure ptr)

    (** Returns the rotation axis of the rotation represented by this quaternion. *)
    val get_axis : 
    (BuiltinClass0.Quaternion.t structure ptr -> BuiltinClass0.Vector3.t structure ptr)

    (** Returns the angle of the rotation represented by this quaternion.
\[b\]Note:\[/b\] The quaternion must be normalized. *)
    val get_angle : 
    (BuiltinClass0.Quaternion.t structure ptr -> BuiltinClass0.Float.t structure ptr)





    (** Returns the negative value of the \[Quaternion\]. This is the same as multiplying all components by \[code\]-1\[/code\]. This operation results in a quaternion that represents the same rotation. *)
    val (~-) : 
    (Quaternion.t structure ptr -> Quaternion.t structure ptr -> Quaternion.t structure ptr)

    (** Returns the same value as if the \[code\]+\[/code\] was not there. Unary \[code\]+\[/code\] does nothing, but sometimes it can make your code more readable. *)
    val (~+) : 
    (Quaternion.t structure ptr -> Quaternion.t structure ptr -> Quaternion.t structure ptr)


    val not : 
    (Quaternion.t structure ptr -> Quaternion.t structure ptr -> Bool.t structure ptr)











    (** Returns \[code\]true\[/code\] if the components of both quaternions are exactly equal.
\[b\]Note:\[/b\] Due to floating-point precision errors, consider using \[method is_equal_approx\] instead, which is more reliable. *)
    val (=) : 
    (Quaternion.t structure ptr -> Quaternion.t structure ptr -> Bool.t structure ptr)

    (** Returns \[code\]true\[/code\] if the components of both quaternions are not exactly equal.
\[b\]Note:\[/b\] Due to floating-point precision errors, consider using \[method is_equal_approx\] instead, which is more reliable. *)
    val (<>) : 
    (Quaternion.t structure ptr -> Quaternion.t structure ptr -> Bool.t structure ptr)

    (** Adds each component of the left \[Quaternion\] to the right \[Quaternion\].
This operation is not meaningful on its own, but it can be used as a part of a larger expression, such as approximating an intermediate rotation between two nearby rotations. *)
    val (+) : 
    (Quaternion.t structure ptr -> Quaternion.t structure ptr -> Quaternion.t structure ptr)

    (** Subtracts each component of the left \[Quaternion\] by the right \[Quaternion\].
This operation is not meaningful on its own, but it can be used as a part of a larger expression. *)
    val (-) : 
    (Quaternion.t structure ptr -> Quaternion.t structure ptr -> Quaternion.t structure ptr)

    (** Composes (multiplies) two quaternions. This rotates the \[param right\] quaternion (the child) by this quaternion (the parent). *)
    val ( * ) : 
    (Quaternion.t structure ptr -> Quaternion.t structure ptr -> Quaternion.t structure ptr)


    val mem_Dictionary : 
    (Quaternion.t structure ptr -> Dictionary.t structure ptr -> Bool.t structure ptr)


    val mem_Array : 
    (Quaternion.t structure ptr -> Array.t structure ptr -> Bool.t structure ptr)
    end

  module type AABB = sig
    type t


    include Api_types.API_TYPE with type t := t



    (** Returns an \[AABB\] equivalent to this bounding box, with its width, height, and depth modified to be non-negative values.
\[codeblocks\]
\[gdscript\]
var box = AABB(Vector3(5, 0, 5), Vector3(-20, -10, -5))
var absolute = box.abs()
print(absolute.position) # Prints (-15.0, -10.0, 0.0)
print(absolute.size)     # Prints (20.0, 10.0, 5.0)
\[/gdscript\]
\[csharp\]
var box = new Aabb(new Vector3(5, 0, 5), new Vector3(-20, -10, -5));
var absolute = box.Abs();
GD.Print(absolute.Position); // Prints (-15, -10, 0)
GD.Print(absolute.Size);     // Prints (20, 10, 5)
\[/csharp\]
\[/codeblocks\]
\[b\]Note:\[/b\] It''s recommended to use this method when \[member size\] is negative, as most other methods in Godot assume that the \[member size\]''s components are greater than \[code\]0\[/code\]. *)
    val abs : 
    (BuiltinClass0.AABB.t structure ptr -> BuiltinClass0.AABB.t structure ptr)

    (** Returns the center point of the bounding box. This is the same as \[code\]position + (size / 2.0)\[/code\]. *)
    val get_center : 
    (BuiltinClass0.AABB.t structure ptr -> BuiltinClass0.Vector3.t structure ptr)

    (** Returns the bounding box''s volume. This is equivalent to \[code\]size.x  *  size.y  *  size.z\[/code\]. See also \[method has_volume\]. *)
    val get_volume : 
    (BuiltinClass0.AABB.t structure ptr -> BuiltinClass0.Float.t structure ptr)

    (** Returns \[code\]true\[/code\] if this bounding box''s width, height, and depth are all positive. See also \[method get_volume\]. *)
    val has_volume : 
    (BuiltinClass0.AABB.t structure ptr -> BuiltinClass0.Bool.t structure ptr)

    (** Returns \[code\]true\[/code\] if this bounding box has a surface or a length, that is, at least one component of \[member size\] is greater than \[code\]0\[/code\]. Otherwise, returns \[code\]false\[/code\]. *)
    val has_surface : 
    (BuiltinClass0.AABB.t structure ptr -> BuiltinClass0.Bool.t structure ptr)

    (** Returns \[code\]true\[/code\] if the bounding box contains the given \[param point\]. By convention, points exactly on the right, top, and front sides are \[b\]not\[/b\] included.
\[b\]Note:\[/b\] This method is not reliable for \[AABB\] with a \[i\]negative\[/i\] \[member size\]. Use \[method abs\] first to get a valid bounding box. *)
    val has_point : 
    (BuiltinClass0.Vector3.t structure ptr -> BuiltinClass0.AABB.t structure ptr -> BuiltinClass0.Bool.t structure ptr)

    (** Returns \[code\]true\[/code\] if this bounding box and \[param aabb\] are approximately equal, by calling \[method Vector3.is_equal_approx\] on the \[member position\] and the \[member size\]. *)
    val is_equal_approx : 
    (BuiltinClass0.AABB.t structure ptr -> BuiltinClass0.AABB.t structure ptr -> BuiltinClass0.Bool.t structure ptr)

    (** Returns \[code\]true\[/code\] if this bounding box''s values are finite, by calling \[method Vector3.is_finite\] on the \[member position\] and the \[member size\]. *)
    val is_finite : 
    (BuiltinClass0.AABB.t structure ptr -> BuiltinClass0.Bool.t structure ptr)

    (** Returns \[code\]true\[/code\] if this bounding box overlaps with the box \[param with\]. The edges of both boxes are \[i\]always\[/i\] excluded. *)
    val intersects : 
    (BuiltinClass0.AABB.t structure ptr -> BuiltinClass0.AABB.t structure ptr -> BuiltinClass0.Bool.t structure ptr)

    (** Returns \[code\]true\[/code\] if this bounding box \[i\]completely\[/i\] encloses the \[param with\] box. The edges of both boxes are included.
\[codeblocks\]
\[gdscript\]
var a = AABB(Vector3(0, 0, 0), Vector3(4, 4, 4))
var b = AABB(Vector3(1, 1, 1), Vector3(3, 3, 3))
var c = AABB(Vector3(2, 2, 2), Vector3(8, 8, 8))

print(a.encloses(a)) # Prints true
print(a.encloses(b)) # Prints true
print(a.encloses(c)) # Prints false
\[/gdscript\]
\[csharp\]
var a = new Aabb(new Vector3(0, 0, 0), new Vector3(4, 4, 4));
var b = new Aabb(new Vector3(1, 1, 1), new Vector3(3, 3, 3));
var c = new Aabb(new Vector3(2, 2, 2), new Vector3(8, 8, 8));

GD.Print(a.Encloses(a)); // Prints True
GD.Print(a.Encloses(b)); // Prints True
GD.Print(a.Encloses(c)); // Prints False
\[/csharp\]
\[/codeblocks\] *)
    val encloses : 
    (BuiltinClass0.AABB.t structure ptr -> BuiltinClass0.AABB.t structure ptr -> BuiltinClass0.Bool.t structure ptr)

    (** Returns \[code\]true\[/code\] if this bounding box is on both sides of the given \[param plane\]. *)
    val intersects_plane : 
    (BuiltinClass0.Plane.t structure ptr -> BuiltinClass0.AABB.t structure ptr -> BuiltinClass0.Bool.t structure ptr)

    (** Returns the intersection between this bounding box and \[param with\]. If the boxes do not intersect, returns an empty \[AABB\]. If the boxes intersect at the edge, returns a flat \[AABB\] with no volume (see \[method has_surface\] and \[method has_volume\]).
\[codeblocks\]
\[gdscript\]
var box1 = AABB(Vector3(0, 0, 0), Vector3(5, 2, 8))
var box2 = AABB(Vector3(2, 0, 2), Vector3(8, 4, 4))

var intersection = box1.intersection(box2)
print(intersection.position) # Prints (2.0, 0.0, 2.0)
print(intersection.size)     # Prints (3.0, 2.0, 4.0)
\[/gdscript\]
\[csharp\]
var box1 = new Aabb(new Vector3(0, 0, 0), new Vector3(5, 2, 8));
var box2 = new Aabb(new Vector3(2, 0, 2), new Vector3(8, 4, 4));

var intersection = box1.Intersection(box2);
GD.Print(intersection.Position); // Prints (2, 0, 2)
GD.Print(intersection.Size);     // Prints (3, 2, 4)
\[/csharp\]
\[/codeblocks\]
\[b\]Note:\[/b\] If you only need to know whether two bounding boxes are intersecting, use \[method intersects\], instead. *)
    val intersection : 
    (BuiltinClass0.AABB.t structure ptr -> BuiltinClass0.AABB.t structure ptr -> BuiltinClass0.AABB.t structure ptr)

    (** Returns an \[AABB\] that encloses both this bounding box and \[param with\] around the edges. See also \[method encloses\]. *)
    val merge : 
    (BuiltinClass0.AABB.t structure ptr -> BuiltinClass0.AABB.t structure ptr -> BuiltinClass0.AABB.t structure ptr)

    (** Returns a copy of this bounding box expanded to align the edges with the given \[param to_point\], if necessary.
\[codeblocks\]
\[gdscript\]
var box = AABB(Vector3(0, 0, 0), Vector3(5, 2, 5))

box = box.expand(Vector3(10, 0, 0))
print(box.position) # Prints (0.0, 0.0, 0.0)
print(box.size)     # Prints (10.0, 2.0, 5.0)

box = box.expand(Vector3(-5, 0, 5))
print(box.position) # Prints (-5.0, 0.0, 0.0)
print(box.size)     # Prints (15.0, 2.0, 5.0)
\[/gdscript\]
\[csharp\]
var box = new Aabb(new Vector3(0, 0, 0), new Vector3(5, 2, 5));

box = box.Expand(new Vector3(10, 0, 0));
GD.Print(box.Position); // Prints (0, 0, 0)
GD.Print(box.Size);     // Prints (10, 2, 5)

box = box.Expand(new Vector3(-5, 0, 5));
GD.Print(box.Position); // Prints (-5, 0, 0)
GD.Print(box.Size);     // Prints (15, 2, 5)
\[/csharp\]
\[/codeblocks\] *)
    val expand : 
    (BuiltinClass0.Vector3.t structure ptr -> BuiltinClass0.AABB.t structure ptr -> BuiltinClass0.AABB.t structure ptr)

    (** Returns a copy of this bounding box extended on all sides by the given amount \[param by\]. A negative amount shrinks the box instead.
\[codeblocks\]
\[gdscript\]
var a = AABB(Vector3(4, 4, 4), Vector3(8, 8, 8)).grow(4)
print(a.position) # Prints (0.0, 0.0, 0.0)
print(a.size)     # Prints (16.0, 16.0, 16.0)

var b = AABB(Vector3(0, 0, 0), Vector3(8, 4, 2)).grow(2)
print(b.position) # Prints (-2.0, -2.0, -2.0)
print(b.size)     # Prints (12.0, 8.0, 6.0)
\[/gdscript\]
\[csharp\]
var a = new Aabb(new Vector3(4, 4, 4), new Vector3(8, 8, 8)).Grow(4);
GD.Print(a.Position); // Prints (0, 0, 0)
GD.Print(a.Size);     // Prints (16, 16, 16)

var b = new Aabb(new Vector3(0, 0, 0), new Vector3(8, 4, 2)).Grow(2);
GD.Print(b.Position); // Prints (-2, -2, -2)
GD.Print(b.Size);     // Prints (12, 8, 6)
\[/csharp\]
\[/codeblocks\] *)
    val grow : 
    (BuiltinClass0.Float.t structure ptr -> BuiltinClass0.AABB.t structure ptr -> BuiltinClass0.AABB.t structure ptr)

    (** Returns the vertex''s position of this bounding box that''s the farthest in the given direction. This point is commonly known as the support point in collision detection algorithms. *)
    val get_support : 
    (BuiltinClass0.Vector3.t structure ptr -> BuiltinClass0.AABB.t structure ptr -> BuiltinClass0.Vector3.t structure ptr)

    (** Returns the longest normalized axis of this bounding box''s \[member size\], as a \[Vector3\] (\[constant Vector3.RIGHT\], \[constant Vector3.UP\], or \[constant Vector3.BACK\]).
\[codeblocks\]
\[gdscript\]
var box = AABB(Vector3(0, 0, 0), Vector3(2, 4, 8))

print(box.get_longest_axis())       # Prints (0.0, 0.0, 1.0)
print(box.get_longest_axis_index()) # Prints 2
print(box.get_longest_axis_size())  # Prints 8.0
\[/gdscript\]
\[csharp\]
var box = new Aabb(new Vector3(0, 0, 0), new Vector3(2, 4, 8));

GD.Print(box.GetLongestAxis());      // Prints (0, 0, 1)
GD.Print(box.GetLongestAxisIndex()); // Prints Z
GD.Print(box.GetLongestAxisSize());  // Prints 8
\[/csharp\]
\[/codeblocks\]
See also \[method get_longest_axis_index\] and \[method get_longest_axis_size\]. *)
    val get_longest_axis : 
    (BuiltinClass0.AABB.t structure ptr -> BuiltinClass0.Vector3.t structure ptr)

    (** Returns the index to the longest axis of this bounding box''s \[member size\] (see \[constant Vector3.AXIS_X\], \[constant Vector3.AXIS_Y\], and \[constant Vector3.AXIS_Z\]).
For an example, see \[method get_longest_axis\]. *)
    val get_longest_axis_index : 
    (BuiltinClass0.AABB.t structure ptr -> BuiltinClass0.Int.t structure ptr)

    (** Returns the longest dimension of this bounding box''s \[member size\].
For an example, see \[method get_longest_axis\]. *)
    val get_longest_axis_size : 
    (BuiltinClass0.AABB.t structure ptr -> BuiltinClass0.Float.t structure ptr)

    (** Returns the shortest normalized axis of this bounding box''s \[member size\], as a \[Vector3\] (\[constant Vector3.RIGHT\], \[constant Vector3.UP\], or \[constant Vector3.BACK\]).
\[codeblocks\]
\[gdscript\]
var box = AABB(Vector3(0, 0, 0), Vector3(2, 4, 8))

print(box.get_shortest_axis())       # Prints (1.0, 0.0, 0.0)
print(box.get_shortest_axis_index()) # Prints 0
print(box.get_shortest_axis_size())  # Prints 2.0
\[/gdscript\]
\[csharp\]
var box = new Aabb(new Vector3(0, 0, 0), new Vector3(2, 4, 8));

GD.Print(box.GetShortestAxis());      // Prints (1, 0, 0)
GD.Print(box.GetShortestAxisIndex()); // Prints X
GD.Print(box.GetShortestAxisSize());  // Prints 2
\[/csharp\]
\[/codeblocks\]
See also \[method get_shortest_axis_index\] and \[method get_shortest_axis_size\]. *)
    val get_shortest_axis : 
    (BuiltinClass0.AABB.t structure ptr -> BuiltinClass0.Vector3.t structure ptr)

    (** Returns the index to the shortest axis of this bounding box''s \[member size\] (see \[constant Vector3.AXIS_X\], \[constant Vector3.AXIS_Y\], and \[constant Vector3.AXIS_Z\]).
For an example, see \[method get_shortest_axis\]. *)
    val get_shortest_axis_index : 
    (BuiltinClass0.AABB.t structure ptr -> BuiltinClass0.Int.t structure ptr)

    (** Returns the shortest dimension of this bounding box''s \[member size\].
For an example, see \[method get_shortest_axis\]. *)
    val get_shortest_axis_size : 
    (BuiltinClass0.AABB.t structure ptr -> BuiltinClass0.Float.t structure ptr)

    (** Returns the position of one of the 8 vertices that compose this bounding box. With a \[param idx\] of \[code\]0\[/code\] this is the same as \[member position\], and a \[param idx\] of \[code\]7\[/code\] is the same as \[member end\]. *)
    val get_endpoint : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.AABB.t structure ptr -> BuiltinClass0.Vector3.t structure ptr)

    (** Returns the first point where this bounding box and the given segment intersect, as a \[Vector3\]. If no intersection occurs, returns \[code\]null\[/code\].
The segment begins at \[param from\] and ends at \[param to\]. *)
    val intersects_segment : 
    (BuiltinClass0.Vector3.t structure ptr -> BuiltinClass0.Vector3.t structure ptr -> BuiltinClass0.AABB.t structure ptr -> BuiltinClass0.Variant.t structure ptr)

    (** Returns the first point where this bounding box and the given ray intersect, as a \[Vector3\]. If no intersection occurs, returns \[code\]null\[/code\].
The ray begin at \[param from\], faces \[param dir\] and extends towards infinity. *)
    val intersects_ray : 
    (BuiltinClass0.Vector3.t structure ptr -> BuiltinClass0.Vector3.t structure ptr -> BuiltinClass0.AABB.t structure ptr -> BuiltinClass0.Variant.t structure ptr)






    val not : 
    (AABB.t structure ptr -> AABB.t structure ptr -> Bool.t structure ptr)

    (** Returns \[code\]true\[/code\] if both \[member position\] and \[member size\] of the bounding boxes are exactly equal, respectively.
\[b\]Note:\[/b\] Due to floating-point precision errors, consider using \[method is_equal_approx\] instead, which is more reliable. *)
    val (=) : 
    (AABB.t structure ptr -> AABB.t structure ptr -> Bool.t structure ptr)

    (** Returns \[code\]true\[/code\] if the \[member position\] or \[member size\] of both bounding boxes are not equal.
\[b\]Note:\[/b\] Due to floating-point precision errors, consider using \[method is_equal_approx\] instead, which is more reliable. *)
    val (<>) : 
    (AABB.t structure ptr -> AABB.t structure ptr -> Bool.t structure ptr)




    val mem_Dictionary : 
    (AABB.t structure ptr -> Dictionary.t structure ptr -> Bool.t structure ptr)


    val mem_Array : 
    (AABB.t structure ptr -> Array.t structure ptr -> Bool.t structure ptr)
    end

  module type BASIS = sig
    type t


    include Api_types.API_TYPE with type t := t



    (** Returns the \[url=https://en.wikipedia.org/wiki/Invertible_matrix\]inverse of this basis''s matrix\[/url\]. *)
    val inverse : 
    (BuiltinClass0.Basis.t structure ptr -> BuiltinClass0.Basis.t structure ptr)

    (** Returns the transposed version of this basis. This turns the basis matrix''s columns into rows, and its rows into columns.
\[codeblocks\]
\[gdscript\]
var my_basis = Basis(
    Vector3(1, 2, 3),
    Vector3(4, 5, 6),
    Vector3(7, 8, 9)
)
my_basis = my_basis.transposed()

print(my_basis.x) # Prints (1.0, 4.0, 7.0)
print(my_basis.y) # Prints (2.0, 5.0, 8.0)
print(my_basis.z) # Prints (3.0, 6.0, 9.0)
\[/gdscript\]
\[csharp\]
var myBasis = new Basis(
    new Vector3(1.0f, 2.0f, 3.0f),
    new Vector3(4.0f, 5.0f, 6.0f),
    new Vector3(7.0f, 8.0f, 9.0f)
);
myBasis = myBasis.Transposed();

GD.Print(myBasis.X); // Prints (1, 4, 7)
GD.Print(myBasis.Y); // Prints (2, 5, 8)
GD.Print(myBasis.Z); // Prints (3, 6, 9)
\[/csharp\]
\[/codeblocks\] *)
    val transposed : 
    (BuiltinClass0.Basis.t structure ptr -> BuiltinClass0.Basis.t structure ptr)

    (** Returns the orthonormalized version of this basis. An orthonormal basis is both \[i\]orthogonal\[/i\] (the axes are perpendicular to each other) and \[i\]normalized\[/i\] (the axes have a length of \[code\]1.0\[/code\]), which also means it can only represent a rotation.
It is often useful to call this method to avoid rounding errors on a rotating basis:
\[codeblocks\]
\[gdscript\]
# Rotate this Node3D every frame.
func _process(delta):
    basis = basis.rotated(Vector3.UP, TAU  *  delta)
    basis = basis.rotated(Vector3.RIGHT, TAU  *  delta)

    basis = basis.orthonormalized()
\[/gdscript\]
\[csharp\]
// Rotate this Node3D every frame.
public override void _Process(double delta)
\{!
    Basis = Basis.Rotated(Vector3.Up, Mathf.Tau  *  (float)delta)
                 .Rotated(Vector3.Right, Mathf.Tau  *  (float)delta)
                 .Orthonormalized();
\}
\[/csharp\]
\[/codeblocks\] *)
    val orthonormalized : 
    (BuiltinClass0.Basis.t structure ptr -> BuiltinClass0.Basis.t structure ptr)

    (** Returns the \[url=https://en.wikipedia.org/wiki/Determinant\]determinant\[/url\] of this basis''s matrix. For advanced math, this number can be used to determine a few attributes:
- If the determinant is exactly \[code\]0.0\[/code\], the basis is not invertible (see \[method inverse\]).
- If the determinant is a negative number, the basis represents a negative scale.
\[b\]Note:\[/b\] If the basis''s scale is the same for every axis, its determinant is always that scale by the power of 2. *)
    val determinant : 
    (BuiltinClass0.Basis.t structure ptr -> BuiltinClass0.Float.t structure ptr)

    (** Returns a copy of this basis rotated around the given \[param axis\] by the given \[param angle\] (in radians).
The \[param axis\] must be a normalized vector (see \[method Vector3.normalized\]). If \[param angle\] is positive, the basis is rotated counter-clockwise around the axis.
\[codeblocks\]
\[gdscript\]
var my_basis = Basis.IDENTITY
var angle = TAU / 2

my_basis = my_basis.rotated(Vector3.UP, angle)    # Rotate around the up axis (yaw).
my_basis = my_basis.rotated(Vector3.RIGHT, angle) # Rotate around the right axis (pitch).
my_basis = my_basis.rotated(Vector3.BACK, angle)  # Rotate around the back axis (roll).
\[/gdscript\]
\[csharp\]
var myBasis = Basis.Identity;
var angle = Mathf.Tau / 2.0f;

myBasis = myBasis.Rotated(Vector3.Up, angle);    // Rotate around the up axis (yaw).
myBasis = myBasis.Rotated(Vector3.Right, angle); // Rotate around the right axis (pitch).
myBasis = myBasis.Rotated(Vector3.Back, angle);  // Rotate around the back axis (roll).
\[/csharp\]
\[/codeblocks\] *)
    val rotated : 
    (BuiltinClass0.Vector3.t structure ptr -> BuiltinClass0.Float.t structure ptr -> BuiltinClass0.Basis.t structure ptr -> BuiltinClass0.Basis.t structure ptr)

    (** Returns this basis with each axis''s components scaled by the given \[param scale\]''s components.
The basis matrix''s rows are multiplied by \[param scale\]''s components. This operation is a global scale (relative to the parent).
\[codeblocks\]
\[gdscript\]
var my_basis = Basis(
    Vector3(1, 1, 1),
    Vector3(2, 2, 2),
    Vector3(3, 3, 3)
)
my_basis = my_basis.scaled(Vector3(0, 2, -2))

print(my_basis.x) # Prints (0.0, 2.0, -2.0)
print(my_basis.y) # Prints (0.0, 4.0, -4.0)
print(my_basis.z) # Prints (0.0, 6.0, -6.0)
\[/gdscript\]
\[csharp\]
var myBasis = new Basis(
    new Vector3(1.0f, 1.0f, 1.0f),
    new Vector3(2.0f, 2.0f, 2.0f),
    new Vector3(3.0f, 3.0f, 3.0f)
);
myBasis = myBasis.Scaled(new Vector3(0.0f, 2.0f, -2.0f));

GD.Print(myBasis.X); // Prints (0, 2, -2)
GD.Print(myBasis.Y); // Prints (0, 4, -4)
GD.Print(myBasis.Z); // Prints (0, 6, -6)
\[/csharp\]
\[/codeblocks\] *)
    val scaled : 
    (BuiltinClass0.Vector3.t structure ptr -> BuiltinClass0.Basis.t structure ptr -> BuiltinClass0.Basis.t structure ptr)

    (** Returns the length of each axis of this basis, as a \[Vector3\]. If the basis is not sheared, this value is the scaling factor. It is not affected by rotation.
\[codeblocks\]
\[gdscript\]
var my_basis = Basis(
    Vector3(2, 0, 0),
    Vector3(0, 4, 0),
    Vector3(0, 0, 8)
)
# Rotating the Basis in any way preserves its scale.
my_basis = my_basis.rotated(Vector3.UP, TAU / 2)
my_basis = my_basis.rotated(Vector3.RIGHT, TAU / 4)

print(my_basis.get_scale()) # Prints (2.0, 4.0, 8.0)
\[/gdscript\]
\[csharp\]
var myBasis = new Basis(
    Vector3(2.0f, 0.0f, 0.0f),
    Vector3(0.0f, 4.0f, 0.0f),
    Vector3(0.0f, 0.0f, 8.0f)
);
// Rotating the Basis in any way preserves its scale.
myBasis = myBasis.Rotated(Vector3.Up, Mathf.Tau / 2.0f);
myBasis = myBasis.Rotated(Vector3.Right, Mathf.Tau / 4.0f);

GD.Print(myBasis.Scale); // Prints (2, 4, 8)
\[/csharp\]
\[/codeblocks\]
\[b\]Note:\[/b\] If the value returned by \[method determinant\] is negative, the scale is also negative. *)
    val get_scale : 
    (BuiltinClass0.Basis.t structure ptr -> BuiltinClass0.Vector3.t structure ptr)

    (** Returns this basis''s rotation as a \[Vector3\] of \[url=https://en.wikipedia.org/wiki/Euler_angles\]Euler angles\[/url\], in radians. For the returned value:
- The \[member Vector3.x\] contains the angle around the \[member x\] axis (pitch);
- The \[member Vector3.y\] contains the angle around the \[member y\] axis (yaw);
- The \[member Vector3.z\] contains the angle around the \[member z\] axis (roll).
The order of each consecutive rotation can be changed with \[param order\] (see \[enum EulerOrder\] constants). By default, the YXZ convention is used (\[constant EULER_ORDER_YXZ\]): Z (roll) is calculated first, then X (pitch), and lastly Y (yaw). When using the opposite method \[method from_euler\], this order is reversed.
\[b\]Note:\[/b\] For this method to return correctly, the basis needs to be \[i\]orthonormal\[/i\] (see \[method orthonormalized\]).
\[b\]Note:\[/b\] Euler angles are much more intuitive but are not suitable for 3D math. Because of this, consider using the \[method get_rotation_quaternion\] method instead, which returns a \[Quaternion\].
\[b\]Note:\[/b\] In the Inspector dock, a basis''s rotation is often displayed in Euler angles (in degrees), as is the case with the \[member Node3D.rotation\] property. *)
    val get_euler : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.Basis.t structure ptr -> BuiltinClass0.Vector3.t structure ptr)

    (** Returns the transposed dot product between \[param with\] and the \[member x\] axis (see \[method transposed\]).
This is equivalent to \[code\]basis.x.dot(vector)\[/code\]. *)
    val tdotx : 
    (BuiltinClass0.Vector3.t structure ptr -> BuiltinClass0.Basis.t structure ptr -> BuiltinClass0.Float.t structure ptr)

    (** Returns the transposed dot product between \[param with\] and the \[member y\] axis (see \[method transposed\]).
This is equivalent to \[code\]basis.y.dot(vector)\[/code\]. *)
    val tdoty : 
    (BuiltinClass0.Vector3.t structure ptr -> BuiltinClass0.Basis.t structure ptr -> BuiltinClass0.Float.t structure ptr)

    (** Returns the transposed dot product between \[param with\] and the \[member z\] axis (see \[method transposed\]).
This is equivalent to \[code\]basis.z.dot(vector)\[/code\]. *)
    val tdotz : 
    (BuiltinClass0.Vector3.t structure ptr -> BuiltinClass0.Basis.t structure ptr -> BuiltinClass0.Float.t structure ptr)

    (** Performs a spherical-linear interpolation with the \[param to\] basis, given a \[param weight\]. Both this basis and \[param to\] should represent a rotation.
\[b\]Example:\[/b\] Smoothly rotate a \[Node3D\] to the target basis over time, with a \[Tween\]:
\[codeblock\]
var start_basis = Basis.IDENTITY
var target_basis = Basis.IDENTITY.rotated(Vector3.UP, TAU / 2)

func _ready():
    create_tween().tween_method(interpolate, 0.0, 1.0, 5.0).set_trans(Tween.TRANS_EXPO)

func interpolate(weight):
    basis = start_basis.slerp(target_basis, weight)
\[/codeblock\] *)
    val slerp : 
    (BuiltinClass0.Basis.t structure ptr -> BuiltinClass0.Float.t structure ptr -> BuiltinClass0.Basis.t structure ptr -> BuiltinClass0.Basis.t structure ptr)

    (** Returns \[code\]true\[/code\] if this basis is conformal. A conformal basis is both \[i\]orthogonal\[/i\] (the axes are perpendicular to each other) and \[i\]uniform\[/i\] (the axes share the same length). This method can be especially useful during physics calculations. *)
    val is_conformal : 
    (BuiltinClass0.Basis.t structure ptr -> BuiltinClass0.Bool.t structure ptr)

    (** Returns \[code\]true\[/code\] if this basis and \[param b\] are approximately equal, by calling \[method \@GlobalScope.is_equal_approx\] on all vector components. *)
    val is_equal_approx : 
    (BuiltinClass0.Basis.t structure ptr -> BuiltinClass0.Basis.t structure ptr -> BuiltinClass0.Bool.t structure ptr)

    (** Returns \[code\]true\[/code\] if this basis is finite, by calling \[method \@GlobalScope.is_finite\] on all vector components. *)
    val is_finite : 
    (BuiltinClass0.Basis.t structure ptr -> BuiltinClass0.Bool.t structure ptr)

    (** Returns this basis''s rotation as a \[Quaternion\].
\[b\]Note:\[/b\] Quaternions are much more suitable for 3D math but are less intuitive. For user interfaces, consider using the \[method get_euler\] method, which returns Euler angles. *)
    val get_rotation_quaternion : 
    (BuiltinClass0.Basis.t structure ptr -> BuiltinClass0.Quaternion.t structure ptr)

    (** Creates a new \[Basis\] with a rotation such that the forward axis (-Z) points towards the \[param target\] position.
By default, the -Z axis (camera forward) is treated as forward (implies +X is right). If \[param use_model_front\] is \[code\]true\[/code\], the +Z axis (asset front) is treated as forward (implies +X is left) and points toward the \[param target\] position.
The up axis (+Y) points as close to the \[param up\] vector as possible while staying perpendicular to the forward axis. The returned basis is orthonormalized (see \[method orthonormalized\]).
The \[param target\] and the \[param up\] cannot be \[constant Vector3.ZERO\], and shouldn''t be colinear to avoid unintended rotation around local Z axis. *)
    val looking_at : 
    (BuiltinClass0.Vector3.t structure ptr -> BuiltinClass0.Vector3.t structure ptr -> BuiltinClass0.Bool.t structure ptr -> BuiltinClass0.Basis.t structure ptr)

    (** Constructs a new \[Basis\] that only represents scale, with no rotation or shear, from the given \[param scale\] vector.
\[codeblocks\]
\[gdscript\]
var my_basis = Basis.from_scale(Vector3(2, 4, 8))

print(my_basis.x) # Prints (2.0, 0.0, 0.0)
print(my_basis.y) # Prints (0.0, 4.0, 0.0)
print(my_basis.z) # Prints (0.0, 0.0, 8.0)
\[/gdscript\]
\[csharp\]
var myBasis = Basis.FromScale(new Vector3(2.0f, 4.0f, 8.0f));

GD.Print(myBasis.X); // Prints (2, 0, 0)
GD.Print(myBasis.Y); // Prints (0, 4, 0)
GD.Print(myBasis.Z); // Prints (0, 0, 8)
\[/csharp\]
\[/codeblocks\]
\[b\]Note:\[/b\] In linear algebra, the matrix of this basis is also known as a \[url=https://en.wikipedia.org/wiki/Diagonal_matrix\]diagonal matrix\[/url\]. *)
    val from_scale : 
    (BuiltinClass0.Vector3.t structure ptr -> BuiltinClass0.Basis.t structure ptr)

    (** Constructs a new \[Basis\] that only represents rotation from the given \[Vector3\] of \[url=https://en.wikipedia.org/wiki/Euler_angles\]Euler angles\[/url\], in radians.
- The \[member Vector3.x\] should contain the angle around the \[member x\] axis (pitch);
- The \[member Vector3.y\] should contain the angle around the \[member y\] axis (yaw);
- The \[member Vector3.z\] should contain the angle around the \[member z\] axis (roll).
\[codeblocks\]
\[gdscript\]
# Creates a Basis whose z axis points down.
var my_basis = Basis.from_euler(Vector3(TAU / 4, 0, 0))

print(my_basis.z) # Prints (0.0, -1.0, 0.0)
\[/gdscript\]
\[csharp\]
// Creates a Basis whose z axis points down.
var myBasis = Basis.FromEuler(new Vector3(Mathf.Tau / 4.0f, 0.0f, 0.0f));

GD.Print(myBasis.Z); // Prints (0, -1, 0)
\[/csharp\]
\[/codeblocks\]
The order of each consecutive rotation can be changed with \[param order\] (see \[enum EulerOrder\] constants). By default, the YXZ convention is used (\[constant EULER_ORDER_YXZ\]): the basis rotates first around the Y axis (yaw), then X (pitch), and lastly Z (roll). When using the opposite method \[method get_euler\], this order is reversed. *)
    val from_euler : 
    (BuiltinClass0.Vector3.t structure ptr -> BuiltinClass0.Int.t structure ptr -> BuiltinClass0.Basis.t structure ptr)






    val not : 
    (Basis.t structure ptr -> Basis.t structure ptr -> Bool.t structure ptr)











    (** Returns \[code\]true\[/code\] if the components of both \[Basis\] matrices are exactly equal.
\[b\]Note:\[/b\] Due to floating-point precision errors, consider using \[method is_equal_approx\] instead, which is more reliable. *)
    val (=) : 
    (Basis.t structure ptr -> Basis.t structure ptr -> Bool.t structure ptr)

    (** Returns \[code\]true\[/code\] if the components of both \[Basis\] matrices are not equal.
\[b\]Note:\[/b\] Due to floating-point precision errors, consider using \[method is_equal_approx\] instead, which is more reliable. *)
    val (<>) : 
    (Basis.t structure ptr -> Basis.t structure ptr -> Bool.t structure ptr)

    (** Transforms (multiplies) the \[param right\] basis by this basis.
This is the operation performed between parent and child \[Node3D\]s. *)
    val ( * ) : 
    (Basis.t structure ptr -> Basis.t structure ptr -> Basis.t structure ptr)


    val mem_Dictionary : 
    (Basis.t structure ptr -> Dictionary.t structure ptr -> Bool.t structure ptr)


    val mem_Array : 
    (Basis.t structure ptr -> Array.t structure ptr -> Bool.t structure ptr)
    end

  module type TRANSFORM3D = sig
    type t


    include Api_types.API_TYPE with type t := t



    (** Returns the \[url=https://en.wikipedia.org/wiki/Invertible_matrix\]inverted version of this transform\[/url\]. See also \[method Basis.inverse\].
\[b\]Note:\[/b\] For this method to return correctly, the transform''s \[member basis\] needs to be \[i\]orthonormal\[/i\] (see \[method orthonormalized\]). That means the basis should only represent a rotation. If it does not, use \[method affine_inverse\] instead. *)
    val inverse : 
    (BuiltinClass0.Transform3D.t structure ptr -> BuiltinClass0.Transform3D.t structure ptr)

    (** Returns the inverted version of this transform. Unlike \[method inverse\], this method works with almost any \[member basis\], including non-uniform ones, but is slower. See also \[method Basis.inverse\].
\[b\]Note:\[/b\] For this method to return correctly, the transform''s \[member basis\] needs to have a determinant that is not exactly \[code\]0.0\[/code\] (see \[method Basis.determinant\]). *)
    val affine_inverse : 
    (BuiltinClass0.Transform3D.t structure ptr -> BuiltinClass0.Transform3D.t structure ptr)

    (** Returns a copy of this transform with its \[member basis\] orthonormalized. An orthonormal basis is both \[i\]orthogonal\[/i\] (the axes are perpendicular to each other) and \[i\]normalized\[/i\] (the axes have a length of \[code\]1.0\[/code\]), which also means it can only represent a rotation. See also \[method Basis.orthonormalized\]. *)
    val orthonormalized : 
    (BuiltinClass0.Transform3D.t structure ptr -> BuiltinClass0.Transform3D.t structure ptr)

    (** Returns a copy of this transform rotated around the given \[param axis\] by the given \[param angle\] (in radians).
The \[param axis\] must be a normalized vector (see \[method Vector3.normalized\]). If \[param angle\] is positive, the basis is rotated counter-clockwise around the axis.
This method is an optimized version of multiplying the given transform \[code\]X\[/code\] with a corresponding rotation transform \[code\]R\[/code\] from the left, i.e., \[code\]R  *  X\[/code\].
This can be seen as transforming with respect to the global/parent frame. *)
    val rotated : 
    (BuiltinClass0.Vector3.t structure ptr -> BuiltinClass0.Float.t structure ptr -> BuiltinClass0.Transform3D.t structure ptr -> BuiltinClass0.Transform3D.t structure ptr)

    (** Returns a copy of this transform rotated around the given \[param axis\] by the given \[param angle\] (in radians).
The \[param axis\] must be a normalized vector in the transform''s local coordinate system. For example, to rotate around the local X-axis, use \[constant Vector3.RIGHT\].
This method is an optimized version of multiplying the given transform \[code\]X\[/code\] with a corresponding rotation transform \[code\]R\[/code\] from the right, i.e., \[code\]X  *  R\[/code\].
This can be seen as transforming with respect to the local frame. *)
    val rotated_local : 
    (BuiltinClass0.Vector3.t structure ptr -> BuiltinClass0.Float.t structure ptr -> BuiltinClass0.Transform3D.t structure ptr -> BuiltinClass0.Transform3D.t structure ptr)

    (** Returns a copy of this transform scaled by the given \[param scale\] factor.
This method is an optimized version of multiplying the given transform \[code\]X\[/code\] with a corresponding scaling transform \[code\]S\[/code\] from the left, i.e., \[code\]S  *  X\[/code\].
This can be seen as transforming with respect to the global/parent frame. *)
    val scaled : 
    (BuiltinClass0.Vector3.t structure ptr -> BuiltinClass0.Transform3D.t structure ptr -> BuiltinClass0.Transform3D.t structure ptr)

    (** Returns a copy of this transform scaled by the given \[param scale\] factor.
This method is an optimized version of multiplying the given transform \[code\]X\[/code\] with a corresponding scaling transform \[code\]S\[/code\] from the right, i.e., \[code\]X  *  S\[/code\].
This can be seen as transforming with respect to the local frame. *)
    val scaled_local : 
    (BuiltinClass0.Vector3.t structure ptr -> BuiltinClass0.Transform3D.t structure ptr -> BuiltinClass0.Transform3D.t structure ptr)

    (** Returns a copy of this transform translated by the given \[param offset\].
This method is an optimized version of multiplying the given transform \[code\]X\[/code\] with a corresponding translation transform \[code\]T\[/code\] from the left, i.e., \[code\]T  *  X\[/code\].
This can be seen as transforming with respect to the global/parent frame. *)
    val translated : 
    (BuiltinClass0.Vector3.t structure ptr -> BuiltinClass0.Transform3D.t structure ptr -> BuiltinClass0.Transform3D.t structure ptr)

    (** Returns a copy of this transform translated by the given \[param offset\].
This method is an optimized version of multiplying the given transform \[code\]X\[/code\] with a corresponding translation transform \[code\]T\[/code\] from the right, i.e., \[code\]X  *  T\[/code\].
This can be seen as transforming with respect to the local frame. *)
    val translated_local : 
    (BuiltinClass0.Vector3.t structure ptr -> BuiltinClass0.Transform3D.t structure ptr -> BuiltinClass0.Transform3D.t structure ptr)

    (** Returns a copy of this transform rotated so that the forward axis (-Z) points towards the \[param target\] position.
The up axis (+Y) points as close to the \[param up\] vector as possible while staying perpendicular to the forward axis. The resulting transform is orthonormalized. The existing rotation, scale, and skew information from the original transform is discarded. The \[param target\] and \[param up\] vectors cannot be zero, cannot be parallel to each other, and are defined in global/parent space.
If \[param use_model_front\] is \[code\]true\[/code\], the +Z axis (asset front) is treated as forward (implies +X is left) and points toward the \[param target\] position. By default, the -Z axis (camera forward) is treated as forward (implies +X is right). *)
    val looking_at : 
    (BuiltinClass0.Vector3.t structure ptr -> BuiltinClass0.Vector3.t structure ptr -> BuiltinClass0.Bool.t structure ptr -> BuiltinClass0.Transform3D.t structure ptr -> BuiltinClass0.Transform3D.t structure ptr)

    (** Returns the result of the linear interpolation between this transform and \[param xform\] by the given \[param weight\].
The \[param weight\] should be between \[code\]0.0\[/code\] and \[code\]1.0\[/code\] (inclusive). Values outside this range are allowed and can be used to perform \[i\]extrapolation\[/i\] instead. *)
    val interpolate_with : 
    (BuiltinClass0.Transform3D.t structure ptr -> BuiltinClass0.Float.t structure ptr -> BuiltinClass0.Transform3D.t structure ptr -> BuiltinClass0.Transform3D.t structure ptr)

    (** Returns \[code\]true\[/code\] if this transform and \[param xform\] are approximately equal, by running \[method \@GlobalScope.is_equal_approx\] on each component. *)
    val is_equal_approx : 
    (BuiltinClass0.Transform3D.t structure ptr -> BuiltinClass0.Transform3D.t structure ptr -> BuiltinClass0.Bool.t structure ptr)

    (** Returns \[code\]true\[/code\] if this transform is finite, by calling \[method \@GlobalScope.is_finite\] on each component. *)
    val is_finite : 
    (BuiltinClass0.Transform3D.t structure ptr -> BuiltinClass0.Bool.t structure ptr)






    val not : 
    (Transform3D.t structure ptr -> Transform3D.t structure ptr -> Bool.t structure ptr)















    (** Returns \[code\]true\[/code\] if the components of both transforms are exactly equal.
\[b\]Note:\[/b\] Due to floating-point precision errors, consider using \[method is_equal_approx\] instead, which is more reliable. *)
    val (=) : 
    (Transform3D.t structure ptr -> Transform3D.t structure ptr -> Bool.t structure ptr)

    (** Returns \[code\]true\[/code\] if the components of both transforms are not equal.
\[b\]Note:\[/b\] Due to floating-point precision errors, consider using \[method is_equal_approx\] instead, which is more reliable. *)
    val (<>) : 
    (Transform3D.t structure ptr -> Transform3D.t structure ptr -> Bool.t structure ptr)

    (** Transforms (multiplies) this transform by the \[param right\] transform.
This is the operation performed between parent and child \[Node3D\]s.
\[b\]Note:\[/b\] If you need to only modify one attribute of this transform, consider using one of the following methods, instead:
- For translation, see \[method translated\] or \[method translated_local\].
- For rotation, see \[method rotated\] or \[method rotated_local\].
- For scale, see \[method scaled\] or \[method scaled_local\]. *)
    val ( * ) : 
    (Transform3D.t structure ptr -> Transform3D.t structure ptr -> Transform3D.t structure ptr)


    val mem_Dictionary : 
    (Transform3D.t structure ptr -> Dictionary.t structure ptr -> Bool.t structure ptr)


    val mem_Array : 
    (Transform3D.t structure ptr -> Array.t structure ptr -> Bool.t structure ptr)


    end

  module type PROJECTION = sig
    type t


    include Api_types.API_TYPE with type t := t



    (** Creates a new \[Projection\] that projects positions from a depth range of \[code\]-1\[/code\] to \[code\]1\[/code\] to one that ranges from \[code\]0\[/code\] to \[code\]1\[/code\], and flips the projected positions vertically, according to \[param flip_y\]. *)
    val create_depth_correction : 
    (BuiltinClass0.Bool.t structure ptr -> BuiltinClass0.Projection.t structure ptr)

    (** Creates a new \[Projection\] that projects positions into the given \[Rect2\]. *)
    val create_light_atlas_rect : 
    (BuiltinClass0.Rect2.t structure ptr -> BuiltinClass0.Projection.t structure ptr)

    (** Creates a new \[Projection\] that projects positions using a perspective projection with the given Y-axis field of view (in degrees), X:Y aspect ratio, and clipping planes.
\[param flip_fov\] determines whether the projection''s field of view is flipped over its diagonal. *)
    val create_perspective : 
    (BuiltinClass0.Float.t structure ptr -> BuiltinClass0.Float.t structure ptr -> BuiltinClass0.Float.t structure ptr -> BuiltinClass0.Float.t structure ptr -> BuiltinClass0.Bool.t structure ptr -> BuiltinClass0.Projection.t structure ptr)

    (** Creates a new \[Projection\] that projects positions using a perspective projection with the given Y-axis field of view (in degrees), X:Y aspect ratio, and clipping distances. The projection is adjusted for a head-mounted display with the given distance between eyes and distance to a point that can be focused on.
\[param eye\] creates the projection for the left eye when set to 1, or the right eye when set to 2.
\[param flip_fov\] determines whether the projection''s field of view is flipped over its diagonal. *)
    val create_perspective_hmd : 
    (BuiltinClass0.Float.t structure ptr -> BuiltinClass0.Float.t structure ptr -> BuiltinClass0.Float.t structure ptr -> BuiltinClass0.Float.t structure ptr -> BuiltinClass0.Bool.t structure ptr -> BuiltinClass0.Int.t structure ptr -> BuiltinClass0.Float.t structure ptr -> BuiltinClass0.Float.t structure ptr -> BuiltinClass0.Projection.t structure ptr)

    (** Creates a new \[Projection\] for projecting positions onto a head-mounted display with the given X:Y aspect ratio, distance between eyes, display width, distance to lens, oversampling factor, and depth clipping planes.
\[param eye\] creates the projection for the left eye when set to 1, or the right eye when set to 2. *)
    val create_for_hmd : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.Float.t structure ptr -> BuiltinClass0.Float.t structure ptr -> BuiltinClass0.Float.t structure ptr -> BuiltinClass0.Float.t structure ptr -> BuiltinClass0.Float.t structure ptr -> BuiltinClass0.Float.t structure ptr -> BuiltinClass0.Float.t structure ptr -> BuiltinClass0.Projection.t structure ptr)

    (** Creates a new \[Projection\] that projects positions using an orthogonal projection with the given clipping planes. *)
    val create_orthogonal : 
    (BuiltinClass0.Float.t structure ptr -> BuiltinClass0.Float.t structure ptr -> BuiltinClass0.Float.t structure ptr -> BuiltinClass0.Float.t structure ptr -> BuiltinClass0.Float.t structure ptr -> BuiltinClass0.Float.t structure ptr -> BuiltinClass0.Projection.t structure ptr)

    (** Creates a new \[Projection\] that projects positions using an orthogonal projection with the given size, X:Y aspect ratio, and clipping planes.
\[param flip_fov\] determines whether the projection''s field of view is flipped over its diagonal. *)
    val create_orthogonal_aspect : 
    (BuiltinClass0.Float.t structure ptr -> BuiltinClass0.Float.t structure ptr -> BuiltinClass0.Float.t structure ptr -> BuiltinClass0.Float.t structure ptr -> BuiltinClass0.Bool.t structure ptr -> BuiltinClass0.Projection.t structure ptr)

    (** Creates a new \[Projection\] that projects positions in a frustum with the given clipping planes. *)
    val create_frustum : 
    (BuiltinClass0.Float.t structure ptr -> BuiltinClass0.Float.t structure ptr -> BuiltinClass0.Float.t structure ptr -> BuiltinClass0.Float.t structure ptr -> BuiltinClass0.Float.t structure ptr -> BuiltinClass0.Float.t structure ptr -> BuiltinClass0.Projection.t structure ptr)

    (** Creates a new \[Projection\] that projects positions in a frustum with the given size, X:Y aspect ratio, offset, and clipping planes.
\[param flip_fov\] determines whether the projection''s field of view is flipped over its diagonal. *)
    val create_frustum_aspect : 
    (BuiltinClass0.Float.t structure ptr -> BuiltinClass0.Float.t structure ptr -> BuiltinClass0.Vector2.t structure ptr -> BuiltinClass0.Float.t structure ptr -> BuiltinClass0.Float.t structure ptr -> BuiltinClass0.Bool.t structure ptr -> BuiltinClass0.Projection.t structure ptr)

    (** Creates a new \[Projection\] that scales a given projection to fit around a given \[AABB\] in projection space. *)
    val create_fit_aabb : 
    (BuiltinClass0.AABB.t structure ptr -> BuiltinClass0.Projection.t structure ptr)

    (** Returns a scalar value that is the signed factor by which areas are scaled by this matrix. If the sign is negative, the matrix flips the orientation of the area.
The determinant can be used to calculate the invertibility of a matrix or solve linear systems of equations involving the matrix, among other applications. *)
    val determinant : 
    (BuiltinClass0.Projection.t structure ptr -> BuiltinClass0.Float.t structure ptr)

    (** Returns a \[Projection\] with the near clipping distance adjusted to be \[param new_znear\].
\[b\]Note:\[/b\] The original \[Projection\] must be a perspective projection. *)
    val perspective_znear_adjusted : 
    (BuiltinClass0.Float.t structure ptr -> BuiltinClass0.Projection.t structure ptr -> BuiltinClass0.Projection.t structure ptr)

    (** Returns the clipping plane of this \[Projection\] whose index is given by \[param plane\].
\[param plane\] should be equal to one of \[constant PLANE_NEAR\], \[constant PLANE_FAR\], \[constant PLANE_LEFT\], \[constant PLANE_TOP\], \[constant PLANE_RIGHT\], or \[constant PLANE_BOTTOM\]. *)
    val get_projection_plane : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.Projection.t structure ptr -> BuiltinClass0.Plane.t structure ptr)

    (** Returns a copy of this \[Projection\] with the signs of the values of the Y column flipped. *)
    val flipped_y : 
    (BuiltinClass0.Projection.t structure ptr -> BuiltinClass0.Projection.t structure ptr)

    (** Returns a \[Projection\] with the X and Y values from the given \[Vector2\] added to the first and second values of the final column respectively. *)
    val jitter_offseted : 
    (BuiltinClass0.Vector2.t structure ptr -> BuiltinClass0.Projection.t structure ptr -> BuiltinClass0.Projection.t structure ptr)

    (** Returns the vertical field of view of the projection (in degrees) associated with the given horizontal field of view (in degrees) and aspect ratio.
\[b\]Note:\[/b\] Unlike most methods of \[Projection\], \[param aspect\] is expected to be 1 divided by the X:Y aspect ratio. *)
    val get_fovy : 
    (BuiltinClass0.Float.t structure ptr -> BuiltinClass0.Float.t structure ptr -> BuiltinClass0.Float.t structure ptr)

    (** Returns the distance for this \[Projection\] beyond which positions are clipped. *)
    val get_z_far : 
    (BuiltinClass0.Projection.t structure ptr -> BuiltinClass0.Float.t structure ptr)

    (** Returns the distance for this \[Projection\] before which positions are clipped. *)
    val get_z_near : 
    (BuiltinClass0.Projection.t structure ptr -> BuiltinClass0.Float.t structure ptr)

    (** Returns the X:Y aspect ratio of this \[Projection\]''s viewport. *)
    val get_aspect : 
    (BuiltinClass0.Projection.t structure ptr -> BuiltinClass0.Float.t structure ptr)

    (** Returns the horizontal field of view of the projection (in degrees). *)
    val get_fov : 
    (BuiltinClass0.Projection.t structure ptr -> BuiltinClass0.Float.t structure ptr)

    (** Returns \[code\]true\[/code\] if this \[Projection\] performs an orthogonal projection. *)
    val is_orthogonal : 
    (BuiltinClass0.Projection.t structure ptr -> BuiltinClass0.Bool.t structure ptr)

    (** Returns the dimensions of the viewport plane that this \[Projection\] projects positions onto, divided by two. *)
    val get_viewport_half_extents : 
    (BuiltinClass0.Projection.t structure ptr -> BuiltinClass0.Vector2.t structure ptr)

    (** Returns the dimensions of the far clipping plane of the projection, divided by two. *)
    val get_far_plane_half_extents : 
    (BuiltinClass0.Projection.t structure ptr -> BuiltinClass0.Vector2.t structure ptr)

    (** Returns a \[Projection\] that performs the inverse of this \[Projection\]''s projective transformation. *)
    val inverse : 
    (BuiltinClass0.Projection.t structure ptr -> BuiltinClass0.Projection.t structure ptr)

    (** Returns the number of pixels with the given pixel width displayed per meter, after this \[Projection\] is applied. *)
    val get_pixels_per_meter : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.Projection.t structure ptr -> BuiltinClass0.Int.t structure ptr)

    (** Returns the factor by which the visible level of detail is scaled by this \[Projection\]. *)
    val get_lod_multiplier : 
    (BuiltinClass0.Projection.t structure ptr -> BuiltinClass0.Float.t structure ptr)






    val not : 
    (Projection.t structure ptr -> Projection.t structure ptr -> Bool.t structure ptr)



    (** Returns \[code\]true\[/code\] if the projections are equal.
\[b\]Note:\[/b\] Due to floating-point precision errors, this may return \[code\]false\[/code\], even if the projections are virtually equal. An \[code\]is_equal_approx\[/code\] method may be added in a future version of Godot. *)
    val (=) : 
    (Projection.t structure ptr -> Projection.t structure ptr -> Bool.t structure ptr)

    (** Returns \[code\]true\[/code\] if the projections are not equal.
\[b\]Note:\[/b\] Due to floating-point precision errors, this may return \[code\]true\[/code\], even if the projections are virtually equal. An \[code\]is_equal_approx\[/code\] method may be added in a future version of Godot. *)
    val (<>) : 
    (Projection.t structure ptr -> Projection.t structure ptr -> Bool.t structure ptr)

    (** Returns a \[Projection\] that applies the combined transformations of this \[Projection\] and \[param right\]. *)
    val ( * ) : 
    (Projection.t structure ptr -> Projection.t structure ptr -> Projection.t structure ptr)


    val mem_Dictionary : 
    (Projection.t structure ptr -> Dictionary.t structure ptr -> Bool.t structure ptr)


    val mem_Array : 
    (Projection.t structure ptr -> Array.t structure ptr -> Bool.t structure ptr)

    module PLANES : sig type t

    val typ : 
    Int.t structure ptr typ

    (** The index value of the projection''s near clipping plane. *)
    val _PLANE_NEAR : 
    int

    (** The index value of the projection''s far clipping plane. *)
    val _PLANE_FAR : 
    int

    (** The index value of the projection''s left clipping plane. *)
    val _PLANE_LEFT : 
    int

    (** The index value of the projection''s top clipping plane. *)
    val _PLANE_TOP : 
    int

    (** The index value of the projection''s right clipping plane. *)
    val _PLANE_RIGHT : 
    int

    (** The index value of the projection bottom clipping plane. *)
    val _PLANE_BOTTOM : 
    int

    end
    end

  module type COLOR = sig
    type t


    include Api_types.API_TYPE with type t := t



    (** Returns the color converted to a 32-bit integer in ARGB format (each component is 8 bits). ARGB is more compatible with DirectX.
\[codeblocks\]
\[gdscript\]
var color = Color(1, 0.5, 0.2)
print(color.to_argb32()) # Prints 4294934323
\[/gdscript\]
\[csharp\]
var color = new Color(1.0f, 0.5f, 0.2f);
GD.Print(color.ToArgb32()); // Prints 4294934323
\[/csharp\]
\[/codeblocks\] *)
    val to_argb32 : 
    (BuiltinClass0.Color.t structure ptr -> BuiltinClass0.Int.t structure ptr)

    (** Returns the color converted to a 32-bit integer in ABGR format (each component is 8 bits). ABGR is the reversed version of the default RGBA format.
\[codeblocks\]
\[gdscript\]
var color = Color(1, 0.5, 0.2)
print(color.to_abgr32()) # Prints 4281565439
\[/gdscript\]
\[csharp\]
var color = new Color(1.0f, 0.5f, 0.2f);
GD.Print(color.ToAbgr32()); // Prints 4281565439
\[/csharp\]
\[/codeblocks\] *)
    val to_abgr32 : 
    (BuiltinClass0.Color.t structure ptr -> BuiltinClass0.Int.t structure ptr)

    (** Returns the color converted to a 32-bit integer in RGBA format (each component is 8 bits). RGBA is Godot''s default format. This method is the inverse of \[method hex\].
\[codeblocks\]
\[gdscript\]
var color = Color(1, 0.5, 0.2)
print(color.to_rgba32()) # Prints 4286526463
\[/gdscript\]
\[csharp\]
var color = new Color(1, 0.5f, 0.2f);
GD.Print(color.ToRgba32()); // Prints 4286526463
\[/csharp\]
\[/codeblocks\] *)
    val to_rgba32 : 
    (BuiltinClass0.Color.t structure ptr -> BuiltinClass0.Int.t structure ptr)

    (** Returns the color converted to a 64-bit integer in ARGB format (each component is 16 bits). ARGB is more compatible with DirectX.
\[codeblocks\]
\[gdscript\]
var color = Color(1, 0.5, 0.2)
print(color.to_argb64()) # Prints -2147470541
\[/gdscript\]
\[csharp\]
var color = new Color(1.0f, 0.5f, 0.2f);
GD.Print(color.ToArgb64()); // Prints -2147470541
\[/csharp\]
\[/codeblocks\] *)
    val to_argb64 : 
    (BuiltinClass0.Color.t structure ptr -> BuiltinClass0.Int.t structure ptr)

    (** Returns the color converted to a 64-bit integer in ABGR format (each component is 16 bits). ABGR is the reversed version of the default RGBA format.
\[codeblocks\]
\[gdscript\]
var color = Color(1, 0.5, 0.2)
print(color.to_abgr64()) # Prints -225178692812801
\[/gdscript\]
\[csharp\]
var color = new Color(1.0f, 0.5f, 0.2f);
GD.Print(color.ToAbgr64()); // Prints -225178692812801
\[/csharp\]
\[/codeblocks\] *)
    val to_abgr64 : 
    (BuiltinClass0.Color.t structure ptr -> BuiltinClass0.Int.t structure ptr)

    (** Returns the color converted to a 64-bit integer in RGBA format (each component is 16 bits). RGBA is Godot''s default format. This method is the inverse of \[method hex64\].
\[codeblocks\]
\[gdscript\]
var color = Color(1, 0.5, 0.2)
print(color.to_rgba64()) # Prints -140736629309441
\[/gdscript\]
\[csharp\]
var color = new Color(1, 0.5f, 0.2f);
GD.Print(color.ToRgba64()); // Prints -140736629309441
\[/csharp\]
\[/codeblocks\] *)
    val to_rgba64 : 
    (BuiltinClass0.Color.t structure ptr -> BuiltinClass0.Int.t structure ptr)

    (** Returns the color converted to an HTML hexadecimal color \[String\] in RGBA format, without the hash (\[code\]#\[/code\]) prefix.
Setting \[param with_alpha\] to \[code\]false\[/code\], excludes alpha from the hexadecimal string, using RGB format instead of RGBA format.
\[codeblocks\]
\[gdscript\]
var white = Color(1, 1, 1, 0.5)
var with_alpha = white.to_html() # Returns ""ffffff7f""
var without_alpha = white.to_html(false) # Returns ""ffffff""
\[/gdscript\]
\[csharp\]
var white = new Color(1, 1, 1, 0.5f);
string withAlpha = white.ToHtml(); // Returns ""ffffff7f""
string withoutAlpha = white.ToHtml(false); // Returns ""ffffff""
\[/csharp\]
\[/codeblocks\] *)
    val to_html : 
    (BuiltinClass0.Bool.t structure ptr -> BuiltinClass0.Color.t structure ptr -> BuiltinClass0.String.t structure ptr)

    (** Returns a new color with all components clamped between the components of \[param min\] and \[param max\], by running \[method \@GlobalScope.clamp\] on each component. *)
    val clamp : 
    (BuiltinClass0.Color.t structure ptr -> BuiltinClass0.Color.t structure ptr -> BuiltinClass0.Color.t structure ptr -> BuiltinClass0.Color.t structure ptr)

    (** Returns the color with its \[member r\], \[member g\], and \[member b\] components inverted (\[code\](1 - r, 1 - g, 1 - b, a)\[/code\]).
\[codeblocks\]
\[gdscript\]
var black = Color.WHITE.inverted()
var color = Color(0.3, 0.4, 0.9)
var inverted_color = color.inverted() # Equivalent to `Color(0.7, 0.6, 0.1)`
\[/gdscript\]
\[csharp\]
var black = Colors.White.Inverted();
var color = new Color(0.3f, 0.4f, 0.9f);
Color invertedColor = color.Inverted(); // Equivalent to `new Color(0.7f, 0.6f, 0.1f)`
\[/csharp\]
\[/codeblocks\] *)
    val inverted : 
    (BuiltinClass0.Color.t structure ptr -> BuiltinClass0.Color.t structure ptr)

    (** Returns the linear interpolation between this color''s components and \[param to\]''s components. The interpolation factor \[param weight\] should be between 0.0 and 1.0 (inclusive). See also \[method \@GlobalScope.lerp\].
\[codeblocks\]
\[gdscript\]
var red = Color(1.0, 0.0, 0.0)
var aqua = Color(0.0, 1.0, 0.8)

red.lerp(aqua, 0.2) # Returns Color(0.8, 0.2, 0.16)
red.lerp(aqua, 0.5) # Returns Color(0.5, 0.5, 0.4)
red.lerp(aqua, 1.0) # Returns Color(0.0, 1.0, 0.8)
\[/gdscript\]
\[csharp\]
var red = new Color(1.0f, 0.0f, 0.0f);
var aqua = new Color(0.0f, 1.0f, 0.8f);

red.Lerp(aqua, 0.2f); // Returns Color(0.8f, 0.2f, 0.16f)
red.Lerp(aqua, 0.5f); // Returns Color(0.5f, 0.5f, 0.4f)
red.Lerp(aqua, 1.0f); // Returns Color(0.0f, 1.0f, 0.8f)
\[/csharp\]
\[/codeblocks\] *)
    val lerp : 
    (BuiltinClass0.Color.t structure ptr -> BuiltinClass0.Float.t structure ptr -> BuiltinClass0.Color.t structure ptr -> BuiltinClass0.Color.t structure ptr)

    (** Returns a new color resulting from making this color lighter by the specified \[param amount\], which should be a ratio from 0.0 to 1.0. See also \[method darkened\].
\[codeblocks\]
\[gdscript\]
var green = Color(0.0, 1.0, 0.0)
var light_green = green.lightened(0.2) # 20% lighter than regular green
\[/gdscript\]
\[csharp\]
var green = new Color(0.0f, 1.0f, 0.0f);
Color lightGreen = green.Lightened(0.2f); // 20% lighter than regular green
\[/csharp\]
\[/codeblocks\] *)
    val lightened : 
    (BuiltinClass0.Float.t structure ptr -> BuiltinClass0.Color.t structure ptr -> BuiltinClass0.Color.t structure ptr)

    (** Returns a new color resulting from making this color darker by the specified \[param amount\] (ratio from 0.0 to 1.0). See also \[method lightened\].
\[codeblocks\]
\[gdscript\]
var green = Color(0.0, 1.0, 0.0)
var darkgreen = green.darkened(0.2) # 20% darker than regular green
\[/gdscript\]
\[csharp\]
var green = new Color(0.0f, 1.0f, 0.0f);
Color darkgreen = green.Darkened(0.2f); // 20% darker than regular green
\[/csharp\]
\[/codeblocks\] *)
    val darkened : 
    (BuiltinClass0.Float.t structure ptr -> BuiltinClass0.Color.t structure ptr -> BuiltinClass0.Color.t structure ptr)

    (** Returns a new color resulting from overlaying this color over the given color. In a painting program, you can imagine it as the \[param over\] color painted over this color (including alpha).
\[codeblocks\]
\[gdscript\]
var bg = Color(0.0, 1.0, 0.0, 0.5) # Green with alpha of 50%
var fg = Color(1.0, 0.0, 0.0, 0.5) # Red with alpha of 50%
var blended_color = bg.blend(fg) # Brown with alpha of 75%
\[/gdscript\]
\[csharp\]
var bg = new Color(0.0f, 1.0f, 0.0f, 0.5f); // Green with alpha of 50%
var fg = new Color(1.0f, 0.0f, 0.0f, 0.5f); // Red with alpha of 50%
Color blendedColor = bg.Blend(fg); // Brown with alpha of 75%
\[/csharp\]
\[/codeblocks\] *)
    val blend : 
    (BuiltinClass0.Color.t structure ptr -> BuiltinClass0.Color.t structure ptr -> BuiltinClass0.Color.t structure ptr)

    (** Returns the light intensity of the color, as a value between 0.0 and 1.0 (inclusive). This is useful when determining light or dark color. Colors with a luminance smaller than 0.5 can be generally considered dark.
\[b\]Note:\[/b\] \[method get_luminance\] relies on the color being in the linear color space to return an accurate relative luminance value. If the color is in the sRGB color space, use \[method srgb_to_linear\] to convert it to the linear color space first. *)
    val get_luminance : 
    (BuiltinClass0.Color.t structure ptr -> BuiltinClass0.Float.t structure ptr)

    (** Returns the color converted to the linear color space. This method assumes the original color already is in the sRGB color space. See also \[method linear_to_srgb\] which performs the opposite operation. *)
    val srgb_to_linear : 
    (BuiltinClass0.Color.t structure ptr -> BuiltinClass0.Color.t structure ptr)

    (** Returns the color converted to the \[url=https://en.wikipedia.org/wiki/SRGB\]sRGB\[/url\] color space. This method assumes the original color is in the linear color space. See also \[method srgb_to_linear\] which performs the opposite operation. *)
    val linear_to_srgb : 
    (BuiltinClass0.Color.t structure ptr -> BuiltinClass0.Color.t structure ptr)

    (** Returns \[code\]true\[/code\] if this color and \[param to\] are approximately equal, by running \[method \@GlobalScope.is_equal_approx\] on each component. *)
    val is_equal_approx : 
    (BuiltinClass0.Color.t structure ptr -> BuiltinClass0.Color.t structure ptr -> BuiltinClass0.Bool.t structure ptr)

    (** Returns the \[Color\] associated with the provided \[param hex\] integer in 32-bit RGBA format (8 bits per channel). This method is the inverse of \[method to_rgba32\].
In GDScript and C#, the \[int\] is best visualized with hexadecimal notation (\[code\]""0x""\[/code\] prefix, making it \[code\]""0xRRGGBBAA""\[/code\]).
\[codeblocks\]
\[gdscript\]
var red = Color.hex(0xff0000ff)
var dark_cyan = Color.hex(0x008b8bff)
var my_color = Color.hex(0xbbefd2a4)
\[/gdscript\]
\[csharp\]
var red = new Color(0xff0000ff);
var dark_cyan = new Color(0x008b8bff);
var my_color = new Color(0xbbefd2a4);
\[/csharp\]
\[/codeblocks\]
If you want to use hex notation in a constant expression, use the equivalent constructor instead (i.e. \[code\]Color(0xRRGGBBAA)\[/code\]). *)
    val hex : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.Color.t structure ptr)

    (** Returns the \[Color\] associated with the provided \[param hex\] integer in 64-bit RGBA format (16 bits per channel). This method is the inverse of \[method to_rgba64\].
In GDScript and C#, the \[int\] is best visualized with hexadecimal notation (\[code\]""0x""\[/code\] prefix, making it \[code\]""0xRRRRGGGGBBBBAAAA""\[/code\]). *)
    val hex64 : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.Color.t structure ptr)

    (** Returns a new color from \[param rgba\], an HTML hexadecimal color string. \[param rgba\] is not case-sensitive, and may be prefixed by a hash sign (\[code\]#\[/code\]).
\[param rgba\] must be a valid three-digit or six-digit hexadecimal color string, and may contain an alpha channel value. If \[param rgba\] does not contain an alpha channel value, an alpha channel value of 1.0 is applied. If \[param rgba\] is invalid, returns an empty color.
\[codeblocks\]
\[gdscript\]
var blue = Color.html(""#0000ff"") # blue is Color(0.0, 0.0, 1.0, 1.0)
var green = Color.html(""#0F0"")   # green is Color(0.0, 1.0, 0.0, 1.0)
var col = Color.html(""663399cc"") # col is Color(0.4, 0.2, 0.6, 0.8)
\[/gdscript\]
\[csharp\]
var blue = Color.FromHtml(""#0000ff""); // blue is Color(0.0, 0.0, 1.0, 1.0)
var green = Color.FromHtml(""#0F0"");   // green is Color(0.0, 1.0, 0.0, 1.0)
var col = Color.FromHtml(""663399cc""); // col is Color(0.4, 0.2, 0.6, 0.8)
\[/csharp\]
\[/codeblocks\] *)
    val html : 
    (BuiltinClass0.String.t structure ptr -> BuiltinClass0.Color.t structure ptr)

    (** Returns \[code\]true\[/code\] if \[param color\] is a valid HTML hexadecimal color string. The string must be a hexadecimal value (case-insensitive) of either 3, 4, 6 or 8 digits, and may be prefixed by a hash sign (\[code\]#\[/code\]). This method is identical to \[method String.is_valid_html_color\].
\[codeblocks\]
\[gdscript\]
Color.html_is_valid(""#55aaFF"")   # Returns true
Color.html_is_valid(""#55AAFF20"") # Returns true
Color.html_is_valid(""55AAFF"")    # Returns true
Color.html_is_valid(""#F2C"")      # Returns true

Color.html_is_valid(""#AABBC"")    # Returns false
Color.html_is_valid(""#55aaFF5"")  # Returns false
\[/gdscript\]
\[csharp\]
Color.HtmlIsValid(""#55AAFF"");   // Returns true
Color.HtmlIsValid(""#55AAFF20""); // Returns true
Color.HtmlIsValid(""55AAFF"");    // Returns true
Color.HtmlIsValid(""#F2C"");      // Returns true

Color.HtmlIsValid(""#AABBC"");    // Returns false
Color.HtmlIsValid(""#55aaFF5"");  // Returns false
\[/csharp\]
\[/codeblocks\] *)
    val html_is_valid : 
    (BuiltinClass0.String.t structure ptr -> BuiltinClass0.Bool.t structure ptr)

    (** Creates a \[Color\] from the given string, which can be either an HTML color code or a named color (case-insensitive). Returns \[param default\] if the color cannot be inferred from the string.
If you want to create a color from String in a constant expression, use the equivalent constructor instead (i.e. \[code\]Color(""color string"")\[/code\]). *)
    val from_string : 
    (BuiltinClass0.String.t structure ptr -> BuiltinClass0.Color.t structure ptr -> BuiltinClass0.Color.t structure ptr)

    (** Constructs a color from an \[url=https://en.wikipedia.org/wiki/HSL_and_HSV\]HSV profile\[/url\]. The hue (\[param h\]), saturation (\[param s\]), and value (\[param v\]) are typically between 0.0 and 1.0.
\[codeblocks\]
\[gdscript\]
var color = Color.from_hsv(0.58, 0.5, 0.79, 0.8)
\[/gdscript\]
\[csharp\]
var color = Color.FromHsv(0.58f, 0.5f, 0.79f, 0.8f);
\[/csharp\]
\[/codeblocks\] *)
    val from_hsv : 
    (BuiltinClass0.Float.t structure ptr -> BuiltinClass0.Float.t structure ptr -> BuiltinClass0.Float.t structure ptr -> BuiltinClass0.Float.t structure ptr -> BuiltinClass0.Color.t structure ptr)

    (** Constructs a color from an \[url=https://bottosson.github.io/posts/colorpicker/\]OK HSL profile\[/url\]. The hue (\[param h\]), saturation (\[param s\]), and lightness (\[param l\]) are typically between 0.0 and 1.0.
\[codeblocks\]
\[gdscript\]
var color = Color.from_ok_hsl(0.58, 0.5, 0.79, 0.8)
\[/gdscript\]
\[csharp\]
var color = Color.FromOkHsl(0.58f, 0.5f, 0.79f, 0.8f);
\[/csharp\]
\[/codeblocks\] *)
    val from_ok_hsl : 
    (BuiltinClass0.Float.t structure ptr -> BuiltinClass0.Float.t structure ptr -> BuiltinClass0.Float.t structure ptr -> BuiltinClass0.Float.t structure ptr -> BuiltinClass0.Color.t structure ptr)

    (** Decodes a \[Color\] from an RGBE9995 format integer. See \[constant Image.FORMAT_RGBE9995\]. *)
    val from_rgbe9995 : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.Color.t structure ptr)

    (** Returns a \[Color\] constructed from red (\[param r8\]), green (\[param g8\]), blue (\[param b8\]), and optionally alpha (\[param a8\]) integer channels, each divided by \[code\]255.0\[/code\] for their final value.
\[codeblock\]
var red = Color.from_rgba8(255, 0, 0)             # Same as Color(1, 0, 0).
var dark_blue = Color.from_rgba8(0, 0, 51)        # Same as Color(0, 0, 0.2).
var my_color = Color.from_rgba8(306, 255, 0, 102) # Same as Color(1.2, 1, 0, 0.4).
\[/codeblock\]
\[b\]Note:\[/b\] Due to the lower precision of \[method from_rgba8\] compared to the standard \[Color\] constructor, a color created with \[method from_rgba8\] will generally not be equal to the same color created with the standard \[Color\] constructor. Use \[method is_equal_approx\] for comparisons to avoid issues with floating-point precision error. *)
    val from_rgba8 : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.Int.t structure ptr -> BuiltinClass0.Int.t structure ptr -> BuiltinClass0.Int.t structure ptr -> BuiltinClass0.Color.t structure ptr)





    (** Inverts the given color. This is equivalent to \[code\]Color.WHITE - c\[/code\] or \[code\]Color(1 - c.r, 1 - c.g, 1 - c.b, 1 - c.a)\[/code\]. Unlike with \[method inverted\], the \[member a\] component is inverted, too. *)
    val (~-) : 
    (Color.t structure ptr -> Color.t structure ptr -> Color.t structure ptr)

    (** Returns the same value as if the \[code\]+\[/code\] was not there. Unary \[code\]+\[/code\] does nothing, but sometimes it can make your code more readable. *)
    val (~+) : 
    (Color.t structure ptr -> Color.t structure ptr -> Color.t structure ptr)


    val not : 
    (Color.t structure ptr -> Color.t structure ptr -> Bool.t structure ptr)









    (** Returns \[code\]true\[/code\] if the colors are exactly equal.
\[b\]Note:\[/b\] Due to floating-point precision errors, consider using \[method is_equal_approx\] instead, which is more reliable. *)
    val (=) : 
    (Color.t structure ptr -> Color.t structure ptr -> Bool.t structure ptr)

    (** Returns \[code\]true\[/code\] if the colors are not exactly equal.
\[b\]Note:\[/b\] Due to floating-point precision errors, consider using \[method is_equal_approx\] instead, which is more reliable. *)
    val (<>) : 
    (Color.t structure ptr -> Color.t structure ptr -> Bool.t structure ptr)

    (** Adds each component of the \[Color\] with the components of the given \[Color\]. *)
    val (+) : 
    (Color.t structure ptr -> Color.t structure ptr -> Color.t structure ptr)

    (** Subtracts each component of the \[Color\] by the components of the given \[Color\]. *)
    val (-) : 
    (Color.t structure ptr -> Color.t structure ptr -> Color.t structure ptr)

    (** Multiplies each component of the \[Color\] by the components of the given \[Color\]. *)
    val ( * ) : 
    (Color.t structure ptr -> Color.t structure ptr -> Color.t structure ptr)

    (** Divides each component of the \[Color\] by the components of the given \[Color\]. *)
    val (/) : 
    (Color.t structure ptr -> Color.t structure ptr -> Color.t structure ptr)


    val mem_Dictionary : 
    (Color.t structure ptr -> Dictionary.t structure ptr -> Bool.t structure ptr)


    val mem_Array : 
    (Color.t structure ptr -> Array.t structure ptr -> Bool.t structure ptr)


    val mem_PackedColorArray : 
    (Color.t structure ptr -> PackedColorArray.t structure ptr -> Bool.t structure ptr)
    end

  module type STRINGNAME = sig
    type t


    include Api_types.API_TYPE with type t := t



    (** Performs a case-sensitive comparison to another string. Returns \[code\]-1\[/code\] if less than, \[code\]1\[/code\] if greater than, or \[code\]0\[/code\] if equal. ""Less than"" and ""greater than"" are determined by the \[url=https://en.wikipedia.org/wiki/List_of_Unicode_characters\]Unicode code points\[/url\] of each string, which roughly matches the alphabetical order.
With different string lengths, returns \[code\]1\[/code\] if this string is longer than the \[param to\] string, or \[code\]-1\[/code\] if shorter. Note that the length of empty strings is \[i\]always\[/i\] \[code\]0\[/code\].
To get a \[bool\] result from a string comparison, use the \[code\]==\[/code\] operator instead. See also \[method nocasecmp_to\], \[method filecasecmp_to\], and \[method naturalcasecmp_to\]. *)
    val casecmp_to : 
    (BuiltinClass0.String.t structure ptr -> BuiltinClass0.StringName.t structure ptr -> BuiltinClass0.Int.t structure ptr)

    (** Performs a \[b\]case-insensitive\[/b\] comparison to another string. Returns \[code\]-1\[/code\] if less than, \[code\]1\[/code\] if greater than, or \[code\]0\[/code\] if equal. ""Less than"" or ""greater than"" are determined by the \[url=https://en.wikipedia.org/wiki/List_of_Unicode_characters\]Unicode code points\[/url\] of each string, which roughly matches the alphabetical order. Internally, lowercase characters are converted to uppercase for the comparison.
With different string lengths, returns \[code\]1\[/code\] if this string is longer than the \[param to\] string, or \[code\]-1\[/code\] if shorter. Note that the length of empty strings is \[i\]always\[/i\] \[code\]0\[/code\].
To get a \[bool\] result from a string comparison, use the \[code\]==\[/code\] operator instead. See also \[method casecmp_to\], \[method filenocasecmp_to\], and \[method naturalnocasecmp_to\]. *)
    val nocasecmp_to : 
    (BuiltinClass0.String.t structure ptr -> BuiltinClass0.StringName.t structure ptr -> BuiltinClass0.Int.t structure ptr)

    (** Performs a \[b\]case-sensitive\[/b\], \[i\]natural order\[/i\] comparison to another string. Returns \[code\]-1\[/code\] if less than, \[code\]1\[/code\] if greater than, or \[code\]0\[/code\] if equal. ""Less than"" or ""greater than"" are determined by the \[url=https://en.wikipedia.org/wiki/List_of_Unicode_characters\]Unicode code points\[/url\] of each string, which roughly matches the alphabetical order.
When used for sorting, natural order comparison orders sequences of numbers by the combined value of each digit as is often expected, instead of the single digit''s value. A sorted sequence of numbered strings will be \[code\]\[""1"", ""2"", ""3"", ...\]\[/code\], not \[code\]\[""1"", ""10"", ""2"", ""3"", ...\]\[/code\].
With different string lengths, returns \[code\]1\[/code\] if this string is longer than the \[param to\] string, or \[code\]-1\[/code\] if shorter. Note that the length of empty strings is \[i\]always\[/i\] \[code\]0\[/code\].
To get a \[bool\] result from a string comparison, use the \[code\]==\[/code\] operator instead. See also \[method naturalnocasecmp_to\], \[method filecasecmp_to\], and \[method nocasecmp_to\]. *)
    val naturalcasecmp_to : 
    (BuiltinClass0.String.t structure ptr -> BuiltinClass0.StringName.t structure ptr -> BuiltinClass0.Int.t structure ptr)

    (** Performs a \[b\]case-insensitive\[/b\], \[i\]natural order\[/i\] comparison to another string. Returns \[code\]-1\[/code\] if less than, \[code\]1\[/code\] if greater than, or \[code\]0\[/code\] if equal. ""Less than"" or ""greater than"" are determined by the \[url=https://en.wikipedia.org/wiki/List_of_Unicode_characters\]Unicode code points\[/url\] of each string, which roughly matches the alphabetical order. Internally, lowercase characters are converted to uppercase for the comparison.
When used for sorting, natural order comparison orders sequences of numbers by the combined value of each digit as is often expected, instead of the single digit''s value. A sorted sequence of numbered strings will be \[code\]\[""1"", ""2"", ""3"", ...\]\[/code\], not \[code\]\[""1"", ""10"", ""2"", ""3"", ...\]\[/code\].
With different string lengths, returns \[code\]1\[/code\] if this string is longer than the \[param to\] string, or \[code\]-1\[/code\] if shorter. Note that the length of empty strings is \[i\]always\[/i\] \[code\]0\[/code\].
To get a \[bool\] result from a string comparison, use the \[code\]==\[/code\] operator instead. See also \[method naturalcasecmp_to\], \[method filenocasecmp_to\], and \[method casecmp_to\]. *)
    val naturalnocasecmp_to : 
    (BuiltinClass0.String.t structure ptr -> BuiltinClass0.StringName.t structure ptr -> BuiltinClass0.Int.t structure ptr)

    (** Like \[method naturalcasecmp_to\] but prioritizes strings that begin with periods (\[code\].\[/code\]) and underscores (\[code\]_\[/code\]) before any other character. Useful when sorting folders or file names.
To get a \[bool\] result from a string comparison, use the \[code\]==\[/code\] operator instead. See also \[method filenocasecmp_to\], \[method naturalcasecmp_to\], and \[method casecmp_to\]. *)
    val filecasecmp_to : 
    (BuiltinClass0.String.t structure ptr -> BuiltinClass0.StringName.t structure ptr -> BuiltinClass0.Int.t structure ptr)

    (** Like \[method naturalnocasecmp_to\] but prioritizes strings that begin with periods (\[code\].\[/code\]) and underscores (\[code\]_\[/code\]) before any other character. Useful when sorting folders or file names.
To get a \[bool\] result from a string comparison, use the \[code\]==\[/code\] operator instead. See also \[method filecasecmp_to\], \[method naturalnocasecmp_to\], and \[method nocasecmp_to\]. *)
    val filenocasecmp_to : 
    (BuiltinClass0.String.t structure ptr -> BuiltinClass0.StringName.t structure ptr -> BuiltinClass0.Int.t structure ptr)

    (** Returns the number of characters in the string. Empty strings (\[code\]""""\[/code\]) always return \[code\]0\[/code\]. See also \[method is_empty\]. *)
    val length : 
    (BuiltinClass0.StringName.t structure ptr -> BuiltinClass0.Int.t structure ptr)

    (** Returns part of the string from the position \[param from\] with length \[param len\]. If \[param len\] is \[code\]-1\[/code\] (as by default), returns the rest of the string starting from the given position. *)
    val substr : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.Int.t structure ptr -> BuiltinClass0.StringName.t structure ptr -> BuiltinClass0.String.t structure ptr)

    (** Splits the string using a \[param delimiter\] and returns the substring at index \[param slice\]. Returns the original string if \[param delimiter\] does not occur in the string. Returns an empty string if the \[param slice\] does not exist.
This is faster than \[method split\], if you only need one substring.
\[codeblock\]
print(""i/am/example/hi"".get_slice(""/"", 2)) # Prints ""example""
\[/codeblock\] *)
    val get_slice : 
    (BuiltinClass0.String.t structure ptr -> BuiltinClass0.Int.t structure ptr -> BuiltinClass0.StringName.t structure ptr -> BuiltinClass0.String.t structure ptr)

    (** Splits the string using a Unicode character with code \[param delimiter\] and returns the substring at index \[param slice\]. Returns an empty string if the \[param slice\] does not exist.
This is faster than \[method split\], if you only need one substring. *)
    val get_slicec : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.Int.t structure ptr -> BuiltinClass0.StringName.t structure ptr -> BuiltinClass0.String.t structure ptr)

    (** Returns the total number of slices when the string is split with the given \[param delimiter\] (see \[method split\]). *)
    val get_slice_count : 
    (BuiltinClass0.String.t structure ptr -> BuiltinClass0.StringName.t structure ptr -> BuiltinClass0.Int.t structure ptr)

    (** Returns the index of the \[b\]first\[/b\] occurrence of \[param what\] in this string, or \[code\]-1\[/code\] if there are none. The search''s start can be specified with \[param from\], continuing to the end of the string.
\[codeblocks\]
\[gdscript\]
print(""Team"".find(""I"")) # Prints -1

print(""Potato"".find(""t""))    # Prints 2
print(""Potato"".find(""t"", 3)) # Prints 4
print(""Potato"".find(""t"", 5)) # Prints -1
\[/gdscript\]
\[csharp\]
GD.Print(""Team"".Find(""I"")); // Prints -1

GD.Print(""Potato"".Find(""t""));    // Prints 2
GD.Print(""Potato"".Find(""t"", 3)); // Prints 4
GD.Print(""Potato"".Find(""t"", 5)); // Prints -1
\[/csharp\]
\[/codeblocks\]
\[b\]Note:\[/b\] If you just want to know whether the string contains \[param what\], use \[method contains\]. In GDScript, you may also use the \[code\]in\[/code\] operator. *)
    val find : 
    (BuiltinClass0.String.t structure ptr -> BuiltinClass0.Int.t structure ptr -> BuiltinClass0.StringName.t structure ptr -> BuiltinClass0.Int.t structure ptr)

    (** Returns the index of the \[b\]first\[/b\] \[b\]case-insensitive\[/b\] occurrence of \[param what\] in this string, or \[code\]-1\[/code\] if there are none. The starting search index can be specified with \[param from\], continuing to the end of the string. *)
    val findn : 
    (BuiltinClass0.String.t structure ptr -> BuiltinClass0.Int.t structure ptr -> BuiltinClass0.StringName.t structure ptr -> BuiltinClass0.Int.t structure ptr)

    (** Returns the number of occurrences of the substring \[param what\] between \[param from\] and \[param to\] positions. If \[param to\] is 0, the search continues until the end of the string. *)
    val count : 
    (BuiltinClass0.String.t structure ptr -> BuiltinClass0.Int.t structure ptr -> BuiltinClass0.Int.t structure ptr -> BuiltinClass0.StringName.t structure ptr -> BuiltinClass0.Int.t structure ptr)

    (** Returns the number of occurrences of the substring \[param what\] between \[param from\] and \[param to\] positions, \[b\]ignoring case\[/b\]. If \[param to\] is 0, the search continues until the end of the string. *)
    val countn : 
    (BuiltinClass0.String.t structure ptr -> BuiltinClass0.Int.t structure ptr -> BuiltinClass0.Int.t structure ptr -> BuiltinClass0.StringName.t structure ptr -> BuiltinClass0.Int.t structure ptr)

    (** Returns the index of the \[b\]last\[/b\] occurrence of \[param what\] in this string, or \[code\]-1\[/code\] if there are none. The search''s start can be specified with \[param from\], continuing to the beginning of the string. This method is the reverse of \[method find\]. *)
    val rfind : 
    (BuiltinClass0.String.t structure ptr -> BuiltinClass0.Int.t structure ptr -> BuiltinClass0.StringName.t structure ptr -> BuiltinClass0.Int.t structure ptr)

    (** Returns the index of the \[b\]last\[/b\] \[b\]case-insensitive\[/b\] occurrence of \[param what\] in this string, or \[code\]-1\[/code\] if there are none. The starting search index can be specified with \[param from\], continuing to the beginning of the string. This method is the reverse of \[method findn\]. *)
    val rfindn : 
    (BuiltinClass0.String.t structure ptr -> BuiltinClass0.Int.t structure ptr -> BuiltinClass0.StringName.t structure ptr -> BuiltinClass0.Int.t structure ptr)

    (** Does a simple expression match (also called ""glob"" or ""globbing""), where \[code\] * \[/code\] matches zero or more arbitrary characters and \[code\]?\[/code\] matches any single character except a period (\[code\].\[/code\]). An empty string or empty expression always evaluates to \[code\]false\[/code\]. *)
    val match_ : 
    (BuiltinClass0.String.t structure ptr -> BuiltinClass0.StringName.t structure ptr -> BuiltinClass0.Bool.t structure ptr)

    (** Does a simple \[b\]case-insensitive\[/b\] expression match, where \[code\] * \[/code\] matches zero or more arbitrary characters and \[code\]?\[/code\] matches any single character except a period (\[code\].\[/code\]). An empty string or empty expression always evaluates to \[code\]false\[/code\]. *)
    val matchn : 
    (BuiltinClass0.String.t structure ptr -> BuiltinClass0.StringName.t structure ptr -> BuiltinClass0.Bool.t structure ptr)

    (** Returns \[code\]true\[/code\] if the string begins with the given \[param text\]. See also \[method ends_with\]. *)
    val begins_with : 
    (BuiltinClass0.String.t structure ptr -> BuiltinClass0.StringName.t structure ptr -> BuiltinClass0.Bool.t structure ptr)

    (** Returns \[code\]true\[/code\] if the string ends with the given \[param text\]. See also \[method begins_with\]. *)
    val ends_with : 
    (BuiltinClass0.String.t structure ptr -> BuiltinClass0.StringName.t structure ptr -> BuiltinClass0.Bool.t structure ptr)

    (** Returns \[code\]true\[/code\] if all characters of this string can be found in \[param text\] in their original order.
\[codeblock\]
var text = ""Wow, incredible!""

print(""inedible"".is_subsequence_of(text)) # Prints true
print(""Word!"".is_subsequence_of(text))    # Prints true
print(""Window"".is_subsequence_of(text))   # Prints false
print("""".is_subsequence_of(text))         # Prints true
\[/codeblock\] *)
    val is_subsequence_of : 
    (BuiltinClass0.String.t structure ptr -> BuiltinClass0.StringName.t structure ptr -> BuiltinClass0.Bool.t structure ptr)

    (** Returns \[code\]true\[/code\] if all characters of this string can be found in \[param text\] in their original order, \[b\]ignoring case\[/b\]. *)
    val is_subsequence_ofn : 
    (BuiltinClass0.String.t structure ptr -> BuiltinClass0.StringName.t structure ptr -> BuiltinClass0.Bool.t structure ptr)

    (** Returns an array containing the bigrams (pairs of consecutive characters) of this string.
\[codeblock\]
print(""Get up!"".bigrams()) # Prints \[""Ge"", ""et"", ""t "", "" u"", ""up"", ""p!""\]
\[/codeblock\] *)
    val bigrams : 
    (BuiltinClass0.StringName.t structure ptr -> BuiltinClass0.PackedStringArray.t structure ptr)

    (** Returns the similarity index (\[url=https://en.wikipedia.org/wiki/S%C3%B8rensen%E2%80%93Dice_coefficient\]Srensen-Dice coefficient\[/url\]) of this string compared to another. A result of \[code\]1.0\[/code\] means totally similar, while \[code\]0.0\[/code\] means totally dissimilar.
\[codeblock\]
print(""ABC123"".similarity(""ABC123"")) # Prints 1.0
print(""ABC123"".similarity(""XYZ456"")) # Prints 0.0
print(""ABC123"".similarity(""123ABC"")) # Prints 0.8
print(""ABC123"".similarity(""abc123"")) # Prints 0.4
\[/codeblock\] *)
    val similarity : 
    (BuiltinClass0.String.t structure ptr -> BuiltinClass0.StringName.t structure ptr -> BuiltinClass0.Float.t structure ptr)

    (** Formats the string by replacing all occurrences of \[param placeholder\] with the elements of \[param values\].
\[param values\] can be a \[Dictionary\], an \[Array\], or an \[Object\]. Any underscores in \[param placeholder\] will be replaced with the corresponding keys in advance. Array elements use their index as keys.
\[codeblock\]
# Prints ""Waiting for Godot is a play by Samuel Beckett, and Godot Engine is named after it.""
var use_array_values = ""Waiting for \{!0\} is a play by \{!1\}, and \{!0\} Engine is named after it.""
print(use_array_values.format(\[""Godot"", ""Samuel Beckett""\]))

# Prints ""User 42 is Godot.""
print(""User \{!id\} is \{!name\}."".format(\{!""id"": 42, ""name"": ""Godot""\}))
\[/codeblock\]
Some additional handling is performed when \[param values\] is an \[Array\]. If \[param placeholder\] does not contain an underscore, the elements of the \[param values\] array will be used to replace one occurrence of the placeholder in order; If an element of \[param values\] is another 2-element array, it''ll be interpreted as a key-value pair.
\[codeblock\]
# Prints ""User 42 is Godot.""
print(""User \{!\} is \{!\}."".format(\[42, ""Godot""\], ""\{!\}""))
print(""User \{!id\} is \{!name\}."".format(\[\[""id"", 42\], \[""name"", ""Godot""\]\]))
\[/codeblock\]
When passing an \[Object\], the property names from \[method Object.get_property_list\] are used as keys.
\[codeblock\]
# Prints ""Visible true, position (0, 0)""
var node = Node2D.new()
print(""Visible \{!visible\}, position \{!position\}"".format(node))
\[/codeblock\]
See also the \[url=$DOCS_URL/tutorials/scripting/gdscript/gdscript_format_string.html\]GDScript format string\[/url\] tutorial.
\[b\]Note:\[/b\] Each replacement is done sequentially for each element of \[param values\], \[b\]not\[/b\] all at once. This means that if any element is inserted and it contains another placeholder, it may be changed by the next replacement. While this can be very useful, it often causes unexpected results. If not necessary, make sure \[param values\]''s elements do not contain placeholders.
\[codeblock\]
print(""\{!0\} \{!1\}"".format(\[""\{!1\}"", ""x""\]))           # Prints ""x x""
print(""\{!0\} \{!1\}"".format(\[""x"", ""\{!0\}""\]))           # Prints ""x \{!0\}""
print(""\{!a\} \{!b\}"".format(\{!""a"": ""\{!b\}"", ""b"": ""c""\})) # Prints ""c c""
print(""\{!a\} \{!b\}"".format(\{!""b"": ""c"", ""a"": ""\{!b\}""\})) # Prints ""\{!b\} c""
\[/codeblock\]
\[b\]Note:\[/b\] In C#, it''s recommended to \[url=https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/tokens/interpolated\]interpolate strings with ""$""\[/url\], instead. *)
    val format : 
    (BuiltinClass0.Variant.t structure ptr -> BuiltinClass0.String.t structure ptr -> BuiltinClass0.StringName.t structure ptr -> BuiltinClass0.String.t structure ptr)

    (** Replaces all occurrences of \[param what\] inside the string with the given \[param forwhat\]. *)
    val replace : 
    (BuiltinClass0.String.t structure ptr -> BuiltinClass0.String.t structure ptr -> BuiltinClass0.StringName.t structure ptr -> BuiltinClass0.String.t structure ptr)

    (** Replaces all \[b\]case-insensitive\[/b\] occurrences of \[param what\] inside the string with the given \[param forwhat\]. *)
    val replacen : 
    (BuiltinClass0.String.t structure ptr -> BuiltinClass0.String.t structure ptr -> BuiltinClass0.StringName.t structure ptr -> BuiltinClass0.String.t structure ptr)

    (** Repeats this string a number of times. \[param count\] needs to be greater than \[code\]0\[/code\]. Otherwise, returns an empty string. *)
    val repeat : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.StringName.t structure ptr -> BuiltinClass0.String.t structure ptr)

    (** Returns the copy of this string in reverse order. This operation works on unicode codepoints, rather than sequences of codepoints, and may break things like compound letters or emojis. *)
    val reverse : 
    (BuiltinClass0.StringName.t structure ptr -> BuiltinClass0.String.t structure ptr)

    (** Inserts \[param what\] at the given \[param position\] in the string. *)
    val insert : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.String.t structure ptr -> BuiltinClass0.StringName.t structure ptr -> BuiltinClass0.String.t structure ptr)

    (** Returns a string with \[param chars\] characters erased starting from \[param position\]. If \[param chars\] goes beyond the string''s length given the specified \[param position\], fewer characters will be erased from the returned string. Returns an empty string if either \[param position\] or \[param chars\] is negative. Returns the original string unmodified if \[param chars\] is \[code\]0\[/code\]. *)
    val erase : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.Int.t structure ptr -> BuiltinClass0.StringName.t structure ptr -> BuiltinClass0.String.t structure ptr)

    (** Changes the appearance of the string: replaces underscores (\[code\]_\[/code\]) with spaces, adds spaces before uppercase letters in the middle of a word, converts all letters to lowercase, then converts the first one and each one following a space to uppercase.
\[codeblocks\]
\[gdscript\]
""move_local_x"".capitalize()   # Returns ""Move Local X""
""sceneFile_path"".capitalize() # Returns ""Scene File Path""
""2D, FPS, PNG"".capitalize()   # Returns ""2d, Fps, Png""
\[/gdscript\]
\[csharp\]
""move_local_x"".Capitalize();   // Returns ""Move Local X""
""sceneFile_path"".Capitalize(); // Returns ""Scene File Path""
""2D, FPS, PNG"".Capitalize();   // Returns ""2d, Fps, Png""
\[/csharp\]
\[/codeblocks\] *)
    val capitalize : 
    (BuiltinClass0.StringName.t structure ptr -> BuiltinClass0.String.t structure ptr)

    (** Returns the string converted to \[code\]camelCase\[/code\]. *)
    val to_camel_case : 
    (BuiltinClass0.StringName.t structure ptr -> BuiltinClass0.String.t structure ptr)

    (** Returns the string converted to \[code\]PascalCase\[/code\]. *)
    val to_pascal_case : 
    (BuiltinClass0.StringName.t structure ptr -> BuiltinClass0.String.t structure ptr)

    (** Returns the string converted to \[code\]snake_case\[/code\].
\[b\]Note:\[/b\] Numbers followed by a \[i\]single\[/i\] letter are not separated in the conversion to keep some words (such as ""2D"") together.
\[codeblocks\]
\[gdscript\]
""Node2D"".to_snake_case()               # Returns ""node_2d""
""2nd place"".to_snake_case()            # Returns ""2_nd_place""
""Texture3DAssetFolder"".to_snake_case() # Returns ""texture_3d_asset_folder""
\[/gdscript\]
\[csharp\]
""Node2D"".ToSnakeCase();               // Returns ""node_2d""
""2nd place"".ToSnakeCase();            // Returns ""2_nd_place""
""Texture3DAssetFolder"".ToSnakeCase(); // Returns ""texture_3d_asset_folder""
\[/csharp\]
\[/codeblocks\] *)
    val to_snake_case : 
    (BuiltinClass0.StringName.t structure ptr -> BuiltinClass0.String.t structure ptr)

    (** Splits the string using a \[param delimiter\] and returns an array of the substrings. If \[param delimiter\] is an empty string, each substring will be a single character. This method is the opposite of \[method join\].
If \[param allow_empty\] is \[code\]false\[/code\], empty strings between adjacent delimiters are excluded from the array.
If \[param maxsplit\] is greater than \[code\]0\[/code\], the number of splits may not exceed \[param maxsplit\]. By default, the entire string is split.
\[codeblocks\]
\[gdscript\]
var some_array = ""One,Two,Three,Four"".split("","", true, 2)

print(some_array.size()) # Prints 3
print(some_array\[0\])     # Prints ""One""
print(some_array\[1\])     # Prints ""Two""
print(some_array\[2\])     # Prints ""Three,Four""
\[/gdscript\]
\[csharp\]
// C#''s `Split()` does not support the `maxsplit` parameter.
var someArray = ""One,Two,Three"".Split("","");

GD.Print(someArray\[0\]); // Prints ""One""
GD.Print(someArray\[1\]); // Prints ""Two""
GD.Print(someArray\[2\]); // Prints ""Three""
\[/csharp\]
\[/codeblocks\]
\[b\]Note:\[/b\] If you only need one substring from the array, consider using \[method get_slice\] which is faster. If you need to split strings with more complex rules, use the \[RegEx\] class instead. *)
    val split : 
    (BuiltinClass0.String.t structure ptr -> BuiltinClass0.Bool.t structure ptr -> BuiltinClass0.Int.t structure ptr -> BuiltinClass0.StringName.t structure ptr -> BuiltinClass0.PackedStringArray.t structure ptr)

    (** Splits the string using a \[param delimiter\] and returns an array of the substrings, starting from the end of the string. The splits in the returned array appear in the same order as the original string. If \[param delimiter\] is an empty string, each substring will be a single character.
If \[param allow_empty\] is \[code\]false\[/code\], empty strings between adjacent delimiters are excluded from the array.
If \[param maxsplit\] is greater than \[code\]0\[/code\], the number of splits may not exceed \[param maxsplit\]. By default, the entire string is split, which is mostly identical to \[method split\].
\[codeblocks\]
\[gdscript\]
var some_string = ""One,Two,Three,Four""
var some_array = some_string.rsplit("","", true, 1)

print(some_array.size()) # Prints 2
print(some_array\[0\])     # Prints ""One,Two,Three""
print(some_array\[1\])     # Prints ""Four""
\[/gdscript\]
\[csharp\]
// In C#, there is no String.RSplit() method.
\[/csharp\]
\[/codeblocks\] *)
    val rsplit : 
    (BuiltinClass0.String.t structure ptr -> BuiltinClass0.Bool.t structure ptr -> BuiltinClass0.Int.t structure ptr -> BuiltinClass0.StringName.t structure ptr -> BuiltinClass0.PackedStringArray.t structure ptr)

    (** Splits the string into floats by using a \[param delimiter\] and returns a \[PackedFloat64Array\].
If \[param allow_empty\] is \[code\]false\[/code\], empty or invalid \[float\] conversions between adjacent delimiters are excluded.
\[codeblock\]
var a = ""1,2,4.5"".split_floats("","")         # a is \[1.0, 2.0, 4.5\]
var c = ""1| ||4.5"".split_floats(""|"")        # c is \[1.0, 0.0, 0.0, 4.5\]
var b = ""1| ||4.5"".split_floats(""|"", false) # b is \[1.0, 4.5\]
\[/codeblock\] *)
    val split_floats : 
    (BuiltinClass0.String.t structure ptr -> BuiltinClass0.Bool.t structure ptr -> BuiltinClass0.StringName.t structure ptr -> BuiltinClass0.PackedFloat64Array.t structure ptr)

    (** Returns the concatenation of \[param parts\]'' elements, with each element separated by the string calling this method. This method is the opposite of \[method split\].
\[codeblocks\]
\[gdscript\]
var fruits = \[""Apple"", ""Orange"", ""Pear"", ""Kiwi""\]

print("", "".join(fruits))  # Prints ""Apple, Orange, Pear, Kiwi""
print(""---"".join(fruits)) # Prints ""Apple---Orange---Pear---Kiwi""
\[/gdscript\]
\[csharp\]
string\[\] fruits = \[""Apple"", ""Orange"", ""Pear"", ""Kiwi""\];

// In C#, this method is static.
GD.Print(string.Join("", "", fruits));  // Prints ""Apple, Orange, Pear, Kiwi""
GD.Print(string.Join(""---"", fruits)); // Prints ""Apple---Orange---Pear---Kiwi""
\[/csharp\]
\[/codeblocks\] *)
    val join : 
    (BuiltinClass0.PackedStringArray.t structure ptr -> BuiltinClass0.StringName.t structure ptr -> BuiltinClass0.String.t structure ptr)

    (** Returns the string converted to \[code\]UPPERCASE\[/code\]. *)
    val to_upper : 
    (BuiltinClass0.StringName.t structure ptr -> BuiltinClass0.String.t structure ptr)

    (** Returns the string converted to \[code\]lowercase\[/code\]. *)
    val to_lower : 
    (BuiltinClass0.StringName.t structure ptr -> BuiltinClass0.String.t structure ptr)

    (** Returns the first \[param length\] characters from the beginning of the string. If \[param length\] is negative, strips the last \[param length\] characters from the string''s end.
\[codeblock\]
print(""Hello World!"".left(3))  # Prints ""Hel""
print(""Hello World!"".left(-4)) # Prints ""Hello Wo""
\[/codeblock\] *)
    val left : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.StringName.t structure ptr -> BuiltinClass0.String.t structure ptr)

    (** Returns the last \[param length\] characters from the end of the string. If \[param length\] is negative, strips the first \[param length\] characters from the string''s beginning.
\[codeblock\]
print(""Hello World!"".right(3))  # Prints ""ld!""
print(""Hello World!"".right(-4)) # Prints ""o World!""
\[/codeblock\] *)
    val right : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.StringName.t structure ptr -> BuiltinClass0.String.t structure ptr)

    (** Strips all non-printable characters from the beginning and the end of the string. These include spaces, tabulations (\[code\]\t\[/code\]), and newlines (\[code\]\n\[/code\] \[code\]\r\[/code\]).
If \[param left\] is \[code\]false\[/code\], ignores the string''s beginning. Likewise, if \[param right\] is \[code\]false\[/code\], ignores the string''s end. *)
    val strip_edges : 
    (BuiltinClass0.Bool.t structure ptr -> BuiltinClass0.Bool.t structure ptr -> BuiltinClass0.StringName.t structure ptr -> BuiltinClass0.String.t structure ptr)

    (** Strips all escape characters from the string. These include all non-printable control characters of the first page of the ASCII table (values from 0 to 31), such as tabulation (\[code\]\t\[/code\]) and newline (\[code\]\n\[/code\], \[code\]\r\[/code\]) characters, but \[i\]not\[/i\] spaces. *)
    val strip_escapes : 
    (BuiltinClass0.StringName.t structure ptr -> BuiltinClass0.String.t structure ptr)

    (** Removes a set of characters defined in \[param chars\] from the string''s beginning. See also \[method rstrip\].
\[b\]Note:\[/b\] \[param chars\] is not a prefix. Use \[method trim_prefix\] to remove a single prefix, rather than a set of characters. *)
    val lstrip : 
    (BuiltinClass0.String.t structure ptr -> BuiltinClass0.StringName.t structure ptr -> BuiltinClass0.String.t structure ptr)

    (** Removes a set of characters defined in \[param chars\] from the string''s end. See also \[method lstrip\].
\[b\]Note:\[/b\] \[param chars\] is not a suffix. Use \[method trim_suffix\] to remove a single suffix, rather than a set of characters. *)
    val rstrip : 
    (BuiltinClass0.String.t structure ptr -> BuiltinClass0.StringName.t structure ptr -> BuiltinClass0.String.t structure ptr)

    (** If the string is a valid file name or path, returns the file extension without the leading period (\[code\].\[/code\]). Otherwise, returns an empty string.
\[codeblock\]
var a = ""/path/to/file.txt"".get_extension() # a is ""txt""
var b = ""cool.txt"".get_extension()          # b is ""txt""
var c = ""cool.font.tres"".get_extension()    # c is ""tres""
var d = "".pack1"".get_extension()            # d is ""pack1""

var e = ""file.txt."".get_extension()  # e is """"
var f = ""file.txt.."".get_extension() # f is """"
var g = ""txt"".get_extension()        # g is """"
var h = """".get_extension()           # h is """"
\[/codeblock\] *)
    val get_extension : 
    (BuiltinClass0.StringName.t structure ptr -> BuiltinClass0.String.t structure ptr)

    (** If the string is a valid file path, returns the full file path, without the extension.
\[codeblock\]
var base = ""/path/to/file.txt"".get_basename() # base is ""/path/to/file""
\[/codeblock\] *)
    val get_basename : 
    (BuiltinClass0.StringName.t structure ptr -> BuiltinClass0.String.t structure ptr)

    (** Concatenates \[param file\] at the end of the string as a subpath, adding \[code\]/\[/code\] if necessary.
\[b\]Example:\[/b\] \[code\]""this/is"".path_join(""path"") == ""this/is/path""\[/code\]. *)
    val path_join : 
    (BuiltinClass0.String.t structure ptr -> BuiltinClass0.StringName.t structure ptr -> BuiltinClass0.String.t structure ptr)

    (** Returns the character code at position \[param at\]. *)
    val unicode_at : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.StringName.t structure ptr -> BuiltinClass0.Int.t structure ptr)

    (** Indents every line of the string with the given \[param prefix\]. Empty lines are not indented. See also \[method dedent\] to remove indentation.
For example, the string can be indented with two tabulations using \[code\]""\t\t""\[/code\], or four spaces using \[code\]""    ""\[/code\]. *)
    val indent : 
    (BuiltinClass0.String.t structure ptr -> BuiltinClass0.StringName.t structure ptr -> BuiltinClass0.String.t structure ptr)

    (** Returns a copy of the string with indentation (leading tabs and spaces) removed. See also \[method indent\] to add indentation. *)
    val dedent : 
    (BuiltinClass0.StringName.t structure ptr -> BuiltinClass0.String.t structure ptr)

    (** Returns the \[url=https://en.wikipedia.org/wiki/MD5\]MD5 hash\[/url\] of the string as another \[String\]. *)
    val md5_text : 
    (BuiltinClass0.StringName.t structure ptr -> BuiltinClass0.String.t structure ptr)

    (** Returns the \[url=https://en.wikipedia.org/wiki/SHA-1\]SHA-1\[/url\] hash of the string as another \[String\]. *)
    val sha1_text : 
    (BuiltinClass0.StringName.t structure ptr -> BuiltinClass0.String.t structure ptr)

    (** Returns the \[url=https://en.wikipedia.org/wiki/SHA-2\]SHA-256\[/url\] hash of the string as another \[String\]. *)
    val sha256_text : 
    (BuiltinClass0.StringName.t structure ptr -> BuiltinClass0.String.t structure ptr)

    (** Returns the \[url=https://en.wikipedia.org/wiki/MD5\]MD5 hash\[/url\] of the string as a \[PackedByteArray\]. *)
    val md5_buffer : 
    (BuiltinClass0.StringName.t structure ptr -> BuiltinClass0.PackedByteArray.t structure ptr)

    (** Returns the \[url=https://en.wikipedia.org/wiki/SHA-1\]SHA-1\[/url\] hash of the string as a \[PackedByteArray\]. *)
    val sha1_buffer : 
    (BuiltinClass0.StringName.t structure ptr -> BuiltinClass0.PackedByteArray.t structure ptr)

    (** Returns the \[url=https://en.wikipedia.org/wiki/SHA-2\]SHA-256\[/url\] hash of the string as a \[PackedByteArray\]. *)
    val sha256_buffer : 
    (BuiltinClass0.StringName.t structure ptr -> BuiltinClass0.PackedByteArray.t structure ptr)

    (** Returns \[code\]true\[/code\] if the string''s length is \[code\]0\[/code\] (\[code\]""""\[/code\]). See also \[method length\]. *)
    val is_empty : 
    (BuiltinClass0.StringName.t structure ptr -> BuiltinClass0.Bool.t structure ptr)

    (** Returns \[code\]true\[/code\] if the string contains \[param what\]. In GDScript, this corresponds to the \[code\]in\[/code\] operator.
\[codeblocks\]
\[gdscript\]
print(""Node"".contains(""de"")) # Prints true
print(""team"".contains(""I""))  # Prints false
print(""I"" in ""team"")         # Prints false
\[/gdscript\]
\[csharp\]
GD.Print(""Node"".Contains(""de"")); // Prints True
GD.Print(""team"".Contains(""I""));  // Prints False
\[/csharp\]
\[/codeblocks\]
If you need to know where \[param what\] is within the string, use \[method find\]. See also \[method containsn\]. *)
    val contains : 
    (BuiltinClass0.String.t structure ptr -> BuiltinClass0.StringName.t structure ptr -> BuiltinClass0.Bool.t structure ptr)

    (** Returns \[code\]true\[/code\] if the string contains \[param what\], \[b\]ignoring case\[/b\].
If you need to know where \[param what\] is within the string, use \[method findn\]. See also \[method contains\]. *)
    val containsn : 
    (BuiltinClass0.String.t structure ptr -> BuiltinClass0.StringName.t structure ptr -> BuiltinClass0.Bool.t structure ptr)

    (** Returns \[code\]true\[/code\] if the string is a path to a file or directory, and its starting point is explicitly defined. This method is the opposite of \[method is_relative_path\].
This includes all paths starting with \[code\]""res://""\[/code\], \[code\]""user://""\[/code\], \[code\]""C:\""\[/code\], \[code\]""/""\[/code\], etc. *)
    val is_absolute_path : 
    (BuiltinClass0.StringName.t structure ptr -> BuiltinClass0.Bool.t structure ptr)

    (** Returns \[code\]true\[/code\] if the string is a path, and its starting point is dependent on context. The path could begin from the current directory, or the current \[Node\] (if the string is derived from a \[NodePath\]), and may sometimes be prefixed with \[code\]""./""\[/code\]. This method is the opposite of \[method is_absolute_path\]. *)
    val is_relative_path : 
    (BuiltinClass0.StringName.t structure ptr -> BuiltinClass0.Bool.t structure ptr)

    (** If the string is a valid file path, converts the string into a canonical path. This is the shortest possible path, without \[code\]""./""\[/code\], and all the unnecessary \[code\]""..""\[/code\] and \[code\]""/""\[/code\].
\[codeblock\]
var simple_path = ""./path/to///../file"".simplify_path()
print(simple_path) # Prints ""path/file""
\[/codeblock\] *)
    val simplify_path : 
    (BuiltinClass0.StringName.t structure ptr -> BuiltinClass0.String.t structure ptr)

    (** If the string is a valid file path, returns the base directory name.
\[codeblock\]
var dir_path = ""/path/to/file.txt"".get_base_dir() # dir_path is ""/path/to""
\[/codeblock\] *)
    val get_base_dir : 
    (BuiltinClass0.StringName.t structure ptr -> BuiltinClass0.String.t structure ptr)

    (** If the string is a valid file path, returns the file name, including the extension.
\[codeblock\]
var file = ""/path/to/icon.png"".get_file() # file is ""icon.png""
\[/codeblock\] *)
    val get_file : 
    (BuiltinClass0.StringName.t structure ptr -> BuiltinClass0.String.t structure ptr)

    (** Returns a copy of the string with special characters escaped using the XML standard. If \[param escape_quotes\] is \[code\]true\[/code\], the single quote (\[code\]''\[/code\]) and double quote (\[code\]""\[/code\]) characters are also escaped. *)
    val xml_escape : 
    (BuiltinClass0.Bool.t structure ptr -> BuiltinClass0.StringName.t structure ptr -> BuiltinClass0.String.t structure ptr)

    (** Returns a copy of the string with escaped characters replaced by their meanings according to the XML standard. *)
    val xml_unescape : 
    (BuiltinClass0.StringName.t structure ptr -> BuiltinClass0.String.t structure ptr)

    (** Encodes the string to URL-friendly format. This method is meant to properly encode the parameters in a URL when sending an HTTP request. See also \[method uri_decode\].
\[codeblocks\]
\[gdscript\]
var prefix = ""$DOCS_URL/?highlight=""
var url = prefix + ""Godot Engine:docs"".uri_encode()

print(url) # Prints ""$DOCS_URL/?highlight=Godot%20Engine%3%docs""
\[/gdscript\]
\[csharp\]
var prefix = ""$DOCS_URL/?highlight="";
var url = prefix + ""Godot Engine:docs"".URIEncode();

GD.Print(url); // Prints ""$DOCS_URL/?highlight=Godot%20Engine%3%docs""
\[/csharp\]
\[/codeblocks\] *)
    val uri_encode : 
    (BuiltinClass0.StringName.t structure ptr -> BuiltinClass0.String.t structure ptr)

    (** Decodes the string from its URL-encoded format. This method is meant to properly decode the parameters in a URL when receiving an HTTP request. See also \[method uri_encode\].
\[codeblocks\]
\[gdscript\]
var url = ""$DOCS_URL/?highlight=Godot%20Engine%3%docs""
print(url.uri_decode()) # Prints ""$DOCS_URL/?highlight=Godot Engine:docs""
\[/gdscript\]
\[csharp\]
var url = ""$DOCS_URL/?highlight=Godot%20Engine%3%docs""
GD.Print(url.URIDecode()) // Prints ""$DOCS_URL/?highlight=Godot Engine:docs""
\[/csharp\]
\[/codeblocks\] *)
    val uri_decode : 
    (BuiltinClass0.StringName.t structure ptr -> BuiltinClass0.String.t structure ptr)

    (** Returns a copy of the string with special characters escaped using the C language standard. *)
    val c_escape : 
    (BuiltinClass0.StringName.t structure ptr -> BuiltinClass0.String.t structure ptr)

    (** Returns a copy of the string with escaped characters replaced by their meanings. Supported escape sequences are \[code\]\''\[/code\], \[code\]\""\[/code\], \[code\]\\\[/code\], \[code\]\a\[/code\], \[code\]\b\[/code\], \[code\]\f\[/code\], \[code\]\n\[/code\], \[code\]\r\[/code\], \[code\]\t\[/code\], \[code\]\v\[/code\].
\[b\]Note:\[/b\] Unlike the GDScript parser, this method doesn''t support the \[code\]\uXXXX\[/code\] escape sequence. *)
    val c_unescape : 
    (BuiltinClass0.StringName.t structure ptr -> BuiltinClass0.String.t structure ptr)

    (** Returns a copy of the string with special characters escaped using the JSON standard. Because it closely matches the C standard, it is possible to use \[method c_unescape\] to unescape the string, if necessary. *)
    val json_escape : 
    (BuiltinClass0.StringName.t structure ptr -> BuiltinClass0.String.t structure ptr)

    (** Returns a copy of the string with all characters that are not allowed in \[member Node.name\] (\[code\].\[/code\] \[code\]:\[/code\] \[code\]\@\[/code\] \[code\]/\[/code\] \[code\]""\[/code\] \[code\]%\[/code\]) replaced with underscores. *)
    val validate_node_name : 
    (BuiltinClass0.StringName.t structure ptr -> BuiltinClass0.String.t structure ptr)

    (** Returns a copy of the string with all characters that are not allowed in \[method is_valid_filename\] replaced with underscores. *)
    val validate_filename : 
    (BuiltinClass0.StringName.t structure ptr -> BuiltinClass0.String.t structure ptr)

    (** Returns \[code\]true\[/code\] if this string is a valid ASCII identifier. A valid ASCII identifier may contain only letters, digits, and underscores (\[code\]_\[/code\]), and the first character may not be a digit.
\[codeblock\]
print(""node_2d"".is_valid_ascii_identifier())    # Prints true
print(""TYPE_FLOAT"".is_valid_ascii_identifier()) # Prints true
print(""1st_method"".is_valid_ascii_identifier()) # Prints false
print(""MyMethod#2"".is_valid_ascii_identifier()) # Prints false
\[/codeblock\]
See also \[method is_valid_unicode_identifier\]. *)
    val is_valid_ascii_identifier : 
    (BuiltinClass0.StringName.t structure ptr -> BuiltinClass0.Bool.t structure ptr)

    (** Returns \[code\]true\[/code\] if this string is a valid Unicode identifier.
A valid Unicode identifier must begin with a Unicode character of class \[code\]XID_Start\[/code\] or \[code\]""_""\[/code\], and may contain Unicode characters of class \[code\]XID_Continue\[/code\] in the other positions.
\[codeblock\]
print(""node_2d"".is_valid_unicode_identifier())      # Prints true
print(""1st_method"".is_valid_unicode_identifier())   # Prints false
print(""MyMethod#2"".is_valid_unicode_identifier())   # Prints false
print(""llkpessg"".is_valid_unicode_identifier()) # Prints true
print("""".is_valid_unicode_identifier()) # Prints true
print("""".is_valid_unicode_identifier())         # Prints true
\[/codeblock\]
See also \[method is_valid_ascii_identifier\].
\[b\]Note:\[/b\] This method checks identifiers the same way as GDScript. See \[method TextServer.is_valid_identifier\] for more advanced checks. *)
    val is_valid_unicode_identifier : 
    (BuiltinClass0.StringName.t structure ptr -> BuiltinClass0.Bool.t structure ptr)

    (** Returns \[code\]true\[/code\] if this string is a valid identifier. A valid identifier may contain only letters, digits and underscores (\[code\]_\[/code\]), and the first character may not be a digit.
\[codeblock\]
print(""node_2d"".is_valid_identifier())    # Prints true
print(""TYPE_FLOAT"".is_valid_identifier()) # Prints true
print(""1st_method"".is_valid_identifier()) # Prints false
print(""MyMethod#2"".is_valid_identifier()) # Prints false
\[/codeblock\] *)
    val is_valid_identifier : 
    (BuiltinClass0.StringName.t structure ptr -> BuiltinClass0.Bool.t structure ptr)

    (** Returns \[code\]true\[/code\] if this string represents a valid integer. A valid integer only contains digits, and may be prefixed with a positive (\[code\]+\[/code\]) or negative (\[code\]-\[/code\]) sign. See also \[method to_int\].
\[codeblock\]
print(""7"".is_valid_int())    # Prints true
print(""1.65"".is_valid_int()) # Prints false
print(""Hi"".is_valid_int())   # Prints false
print(""+3"".is_valid_int())   # Prints true
print(""-12"".is_valid_int())  # Prints true
\[/codeblock\] *)
    val is_valid_int : 
    (BuiltinClass0.StringName.t structure ptr -> BuiltinClass0.Bool.t structure ptr)

    (** Returns \[code\]true\[/code\] if this string represents a valid floating-point number. A valid float may contain only digits, one decimal point (\[code\].\[/code\]), and the exponent letter (\[code\]e\[/code\]). It may also be prefixed with a positive (\[code\]+\[/code\]) or negative (\[code\]-\[/code\]) sign. Any valid integer is also a valid float (see \[method is_valid_int\]). See also \[method to_float\].
\[codeblock\]
print(""1.7"".is_valid_float())   # Prints true
print(""24"".is_valid_float())    # Prints true
print(""7e3"".is_valid_float())   # Prints true
print(""Hello"".is_valid_float()) # Prints false
\[/codeblock\] *)
    val is_valid_float : 
    (BuiltinClass0.StringName.t structure ptr -> BuiltinClass0.Bool.t structure ptr)

    (** Returns \[code\]true\[/code\] if this string is a valid hexadecimal number. A valid hexadecimal number only contains digits or letters \[code\]A\[/code\] to \[code\]F\[/code\] (either uppercase or lowercase), and may be prefixed with a positive (\[code\]+\[/code\]) or negative (\[code\]-\[/code\]) sign.
If \[param with_prefix\] is \[code\]true\[/code\], the hexadecimal number needs to prefixed by \[code\]""0x""\[/code\] to be considered valid.
\[codeblock\]
print(""A08E"".is_valid_hex_number())    # Prints true
print(""-AbCdEf"".is_valid_hex_number()) # Prints true
print(""2.5"".is_valid_hex_number())     # Prints false

print(""0xDEADC0DE"".is_valid_hex_number(true)) # Prints true
\[/codeblock\] *)
    val is_valid_hex_number : 
    (BuiltinClass0.Bool.t structure ptr -> BuiltinClass0.StringName.t structure ptr -> BuiltinClass0.Bool.t structure ptr)

    (** Returns \[code\]true\[/code\] if this string is a valid color in hexadecimal HTML notation. The string must be a hexadecimal value (see \[method is_valid_hex_number\]) of either 3, 4, 6 or 8 digits, and may be prefixed by a hash sign (\[code\]#\[/code\]). Other HTML notations for colors, such as names or \[code\]hsl()\[/code\], are not considered valid. See also \[method Color.html\]. *)
    val is_valid_html_color : 
    (BuiltinClass0.StringName.t structure ptr -> BuiltinClass0.Bool.t structure ptr)

    (** Returns \[code\]true\[/code\] if this string represents a well-formatted IPv4 or IPv6 address. This method considers \[url=https://en.wikipedia.org/wiki/Reserved_IP_addresses\]reserved IP addresses\[/url\] such as \[code\]""0.0.0.0""\[/code\] and \[code\]""ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff""\[/code\] as valid. *)
    val is_valid_ip_address : 
    (BuiltinClass0.StringName.t structure ptr -> BuiltinClass0.Bool.t structure ptr)

    (** Returns \[code\]true\[/code\] if this string does not contain characters that are not allowed in file names (\[code\]:\[/code\] \[code\]/\[/code\] \[code\]\\[/code\] \[code\]?\[/code\] \[code\] * \[/code\] \[code\]""\[/code\] \[code\]|\[/code\] \[code\]%\[/code\] \[code\]<\[/code\] \[code\]>\[/code\]). *)
    val is_valid_filename : 
    (BuiltinClass0.StringName.t structure ptr -> BuiltinClass0.Bool.t structure ptr)

    (** Converts the string representing an integer number into an \[int\]. This method removes any non-number character and stops at the first decimal point (\[code\].\[/code\]). See also \[method is_valid_int\].
\[codeblock\]
var a = ""123"".to_int()    # a is 123
var b = ""x1y2z3"".to_int() # b is 123
var c = ""-1.2.3"".to_int() # c is -1
var d = ""Hello!"".to_int() # d is 0
\[/codeblock\] *)
    val to_int : 
    (BuiltinClass0.StringName.t structure ptr -> BuiltinClass0.Int.t structure ptr)

    (** Converts the string representing a decimal number into a \[float\]. This method stops on the first non-number character, except the first decimal point (\[code\].\[/code\]) and the exponent letter (\[code\]e\[/code\]). See also \[method is_valid_float\].
\[codeblock\]
var a = ""12.35"".to_float()  # a is 12.35
var b = ""1.2.3"".to_float()  # b is 1.2
var c = ""12xy3"".to_float()  # c is 12.0
var d = ""1e3"".to_float()    # d is 1000.0
var e = ""Hello!"".to_float() # e is 0.0
\[/codeblock\] *)
    val to_float : 
    (BuiltinClass0.StringName.t structure ptr -> BuiltinClass0.Float.t structure ptr)

    (** Converts the string representing a hexadecimal number into an \[int\]. The string may be optionally prefixed with \[code\]""0x""\[/code\], and an additional \[code\]-\[/code\] prefix for negative numbers.
\[codeblocks\]
\[gdscript\]
print(""0xff"".hex_to_int()) # Prints 255
print(""ab"".hex_to_int())   # Prints 171
\[/gdscript\]
\[csharp\]
GD.Print(""0xff"".HexToInt()); // Prints 255
GD.Print(""ab"".HexToInt());   // Prints 171
\[/csharp\]
\[/codeblocks\] *)
    val hex_to_int : 
    (BuiltinClass0.StringName.t structure ptr -> BuiltinClass0.Int.t structure ptr)

    (** Converts the string representing a binary number into an \[int\]. The string may optionally be prefixed with \[code\]""0b""\[/code\], and an additional \[code\]-\[/code\] prefix for negative numbers.
\[codeblocks\]
\[gdscript\]
print(""101"".bin_to_int())   # Prints 5
print(""0b101"".bin_to_int()) # Prints 5
print(""-0b10"".bin_to_int()) # Prints -2
\[/gdscript\]
\[csharp\]
GD.Print(""101"".BinToInt());   // Prints 5
GD.Print(""0b101"".BinToInt()); // Prints 5
GD.Print(""-0b10"".BinToInt()); // Prints -2
\[/csharp\]
\[/codeblocks\] *)
    val bin_to_int : 
    (BuiltinClass0.StringName.t structure ptr -> BuiltinClass0.Int.t structure ptr)

    (** Formats the string to be at least \[param min_length\] long by adding \[param character\]s to the left of the string, if necessary. See also \[method rpad\]. *)
    val lpad : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.String.t structure ptr -> BuiltinClass0.StringName.t structure ptr -> BuiltinClass0.String.t structure ptr)

    (** Formats the string to be at least \[param min_length\] long, by adding \[param character\]s to the right of the string, if necessary. See also \[method lpad\]. *)
    val rpad : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.String.t structure ptr -> BuiltinClass0.StringName.t structure ptr -> BuiltinClass0.String.t structure ptr)

    (** Formats the string representing a number to have an exact number of \[param digits\] \[i\]after\[/i\] the decimal point. *)
    val pad_decimals : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.StringName.t structure ptr -> BuiltinClass0.String.t structure ptr)

    (** Formats the string representing a number to have an exact number of \[param digits\] \[i\]before\[/i\] the decimal point. *)
    val pad_zeros : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.StringName.t structure ptr -> BuiltinClass0.String.t structure ptr)

    (** Removes the given \[param prefix\] from the start of the string, or returns the string unchanged. *)
    val trim_prefix : 
    (BuiltinClass0.String.t structure ptr -> BuiltinClass0.StringName.t structure ptr -> BuiltinClass0.String.t structure ptr)

    (** Removes the given \[param suffix\] from the end of the string, or returns the string unchanged. *)
    val trim_suffix : 
    (BuiltinClass0.String.t structure ptr -> BuiltinClass0.StringName.t structure ptr -> BuiltinClass0.String.t structure ptr)

    (** Converts the string to an \[url=https://en.wikipedia.org/wiki/ASCII\]ASCII\[/url\]/Latin-1 encoded \[PackedByteArray\]. This method is slightly faster than \[method to_utf8_buffer\], but replaces all unsupported characters with spaces. This is the inverse of \[method PackedByteArray.get_string_from_ascii\]. *)
    val to_ascii_buffer : 
    (BuiltinClass0.StringName.t structure ptr -> BuiltinClass0.PackedByteArray.t structure ptr)

    (** Converts the string to a \[url=https://en.wikipedia.org/wiki/UTF-8\]UTF-8\[/url\] encoded \[PackedByteArray\]. This method is slightly slower than \[method to_ascii_buffer\], but supports all UTF-8 characters. For most cases, prefer using this method. This is the inverse of \[method PackedByteArray.get_string_from_utf8\]. *)
    val to_utf8_buffer : 
    (BuiltinClass0.StringName.t structure ptr -> BuiltinClass0.PackedByteArray.t structure ptr)

    (** Converts the string to a \[url=https://en.wikipedia.org/wiki/UTF-16\]UTF-16\[/url\] encoded \[PackedByteArray\]. This is the inverse of \[method PackedByteArray.get_string_from_utf16\]. *)
    val to_utf16_buffer : 
    (BuiltinClass0.StringName.t structure ptr -> BuiltinClass0.PackedByteArray.t structure ptr)

    (** Converts the string to a \[url=https://en.wikipedia.org/wiki/UTF-32\]UTF-32\[/url\] encoded \[PackedByteArray\]. This is the inverse of \[method PackedByteArray.get_string_from_utf32\]. *)
    val to_utf32_buffer : 
    (BuiltinClass0.StringName.t structure ptr -> BuiltinClass0.PackedByteArray.t structure ptr)

    (** Decodes a hexadecimal string as a \[PackedByteArray\].
\[codeblocks\]
\[gdscript\]
var text = ""hello world""
var encoded = text.to_utf8_buffer().hex_encode() # outputs ""68656c6c6f20776f726c64""
print(buf.hex_decode().get_string_from_utf8())
\[/gdscript\]
\[csharp\]
var text = ""hello world"";
var encoded = text.ToUtf8Buffer().HexEncode(); // outputs ""68656c6c6f20776f726c64""
GD.Print(buf.HexDecode().GetStringFromUtf8());
\[/csharp\]
\[/codeblocks\] *)
    val hex_decode : 
    (BuiltinClass0.StringName.t structure ptr -> BuiltinClass0.PackedByteArray.t structure ptr)

    (** Converts the string to a \[url=https://en.wikipedia.org/wiki/Wide_character\]wide character\[/url\] (\[code\]wchar_t\[/code\], UTF-16 on Windows, UTF-32 on other platforms) encoded \[PackedByteArray\]. This is the inverse of \[method PackedByteArray.get_string_from_wchar\]. *)
    val to_wchar_buffer : 
    (BuiltinClass0.StringName.t structure ptr -> BuiltinClass0.PackedByteArray.t structure ptr)

    (** Returns the 32-bit hash value representing the string''s contents.
\[b\]Note:\[/b\] Strings with equal hash values are \[i\]not\[/i\] guaranteed to be the same, as a result of hash collisions. On the contrary, strings with different hash values are guaranteed to be different. *)
    val hash : 
    (BuiltinClass0.StringName.t structure ptr -> BuiltinClass0.Int.t structure ptr)








    val not : 
    (StringName.t structure ptr -> StringName.t structure ptr -> Bool.t structure ptr)
















    val mem_String : 
    (StringName.t structure ptr -> String.t structure ptr -> Bool.t structure ptr)

































    (** Returns \[code\]true\[/code\] if the \[StringName\] and \[param right\] refer to the same name. Comparisons between \[StringName\]s are much faster than regular \[String\] comparisons. *)
    val (=) : 
    (StringName.t structure ptr -> StringName.t structure ptr -> Bool.t structure ptr)

    (** Returns \[code\]true\[/code\] if the \[StringName\] and \[param right\] do not refer to the same name. Comparisons between \[StringName\]s are much faster than regular \[String\] comparisons. *)
    val (<>) : 
    (StringName.t structure ptr -> StringName.t structure ptr -> Bool.t structure ptr)

    (** Returns \[code\]true\[/code\] if the left \[StringName\]''s pointer comes before \[param right\]. Note that this will not match their \[url=https://en.wikipedia.org/wiki/List_of_Unicode_characters\]Unicode order\[/url\]. *)
    val (<) : 
    (StringName.t structure ptr -> StringName.t structure ptr -> Bool.t structure ptr)

    (** Returns \[code\]true\[/code\] if the left \[StringName\]''s pointer comes before \[param right\] or if they are the same. Note that this will not match their \[url=https://en.wikipedia.org/wiki/List_of_Unicode_characters\]Unicode order\[/url\]. *)
    val (<=) : 
    (StringName.t structure ptr -> StringName.t structure ptr -> Bool.t structure ptr)

    (** Returns \[code\]true\[/code\] if the left \[StringName\]''s pointer comes after \[param right\]. Note that this will not match their \[url=https://en.wikipedia.org/wiki/List_of_Unicode_characters\]Unicode order\[/url\]. *)
    val (>) : 
    (StringName.t structure ptr -> StringName.t structure ptr -> Bool.t structure ptr)

    (** Returns \[code\]true\[/code\] if the left \[StringName\]''s pointer comes after \[param right\] or if they are the same. Note that this will not match their \[url=https://en.wikipedia.org/wiki/List_of_Unicode_characters\]Unicode order\[/url\]. *)
    val (>=) : 
    (StringName.t structure ptr -> StringName.t structure ptr -> Bool.t structure ptr)

    (** Appends \[param right\] at the end of this \[StringName\], returning a \[String\]. This is also known as a string concatenation. *)
    val (+) : 
    (StringName.t structure ptr -> StringName.t structure ptr -> String.t structure ptr)


    val (%) : 
    (StringName.t structure ptr -> StringName.t structure ptr -> String.t structure ptr)


    val mem_StringName : 
    (StringName.t structure ptr -> StringName.t structure ptr -> Bool.t structure ptr)






    val mem_Object : 
    (StringName.t structure ptr -> Object.t structure ptr -> Bool.t structure ptr)








    val mem_Dictionary : 
    (StringName.t structure ptr -> Dictionary.t structure ptr -> Bool.t structure ptr)




    val mem_Array : 
    (StringName.t structure ptr -> Array.t structure ptr -> Bool.t structure ptr)














    val mem_PackedStringArray : 
    (StringName.t structure ptr -> PackedStringArray.t structure ptr -> Bool.t structure ptr)








    end

  module type NODEPATH = sig
    type t


    include Api_types.API_TYPE with type t := t



    (** Returns \[code\]true\[/code\] if the node path is absolute. Unlike a relative path, an absolute path is represented by a leading slash character (\[code\]/\[/code\]) and always begins from the \[SceneTree\]. It can be used to reliably access nodes from the root node (e.g. \[code\]""/root/Global""\[/code\] if an autoload named ""Global"" exists). *)
    val is_absolute : 
    (BuiltinClass0.NodePath.t structure ptr -> BuiltinClass0.Bool.t structure ptr)

    (** Returns the number of node names in the path. Property subnames are not included.
For example, \[code\]""../RigidBody2D/Sprite2D:texture""\[/code\] contains 3 node names. *)
    val get_name_count : 
    (BuiltinClass0.NodePath.t structure ptr -> BuiltinClass0.Int.t structure ptr)

    (** Returns the node name indicated by \[param idx\], starting from 0. If \[param idx\] is out of bounds, an error is generated. See also \[method get_subname_count\] and \[method get_name_count\].
\[codeblocks\]
\[gdscript\]
var sprite_path = NodePath(""../RigidBody2D/Sprite2D"")
print(sprite_path.get_name(0)) # Prints ""..""
print(sprite_path.get_name(1)) # Prints ""RigidBody2D""
print(sprite_path.get_name(2)) # Prints ""Sprite""
\[/gdscript\]
\[csharp\]
var spritePath = new NodePath(""../RigidBody2D/Sprite2D"");
GD.Print(spritePath.GetName(0)); // Prints ""..""
GD.Print(spritePath.GetName(1)); // Prints ""PathFollow2D""
GD.Print(spritePath.GetName(2)); // Prints ""Sprite""
\[/csharp\]
\[/codeblocks\] *)
    val get_name : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.NodePath.t structure ptr -> BuiltinClass0.StringName.t structure ptr)

    (** Returns the number of property names (""subnames"") in the path. Each subname in the node path is listed after a colon character (\[code\]:\[/code\]).
For example, \[code\]""Level/RigidBody2D/Sprite2D:texture:resource_name""\[/code\] contains 2 subnames. *)
    val get_subname_count : 
    (BuiltinClass0.NodePath.t structure ptr -> BuiltinClass0.Int.t structure ptr)

    (** Returns the 32-bit hash value representing the node path''s contents.
\[b\]Note:\[/b\] Node paths with equal hash values are \[i\]not\[/i\] guaranteed to be the same, as a result of hash collisions. Node paths with different hash values are guaranteed to be different. *)
    val hash : 
    (BuiltinClass0.NodePath.t structure ptr -> BuiltinClass0.Int.t structure ptr)

    (** Returns the property name indicated by \[param idx\], starting from 0. If \[param idx\] is out of bounds, an error is generated. See also \[method get_subname_count\].
\[codeblocks\]
\[gdscript\]
var path_to_name = NodePath(""Sprite2D:texture:resource_name"")
print(path_to_name.get_subname(0)) # Prints ""texture""
print(path_to_name.get_subname(1)) # Prints ""resource_name""
\[/gdscript\]
\[csharp\]
var pathToName = new NodePath(""Sprite2D:texture:resource_name"");
GD.Print(pathToName.GetSubname(0)); // Prints ""texture""
GD.Print(pathToName.GetSubname(1)); // Prints ""resource_name""
\[/csharp\]
\[/codeblocks\] *)
    val get_subname : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.NodePath.t structure ptr -> BuiltinClass0.StringName.t structure ptr)

    (** Returns all node names concatenated with a slash character (\[code\]/\[/code\]) as a single \[StringName\]. *)
    val get_concatenated_names : 
    (BuiltinClass0.NodePath.t structure ptr -> BuiltinClass0.StringName.t structure ptr)

    (** Returns all property subnames concatenated with a colon character (\[code\]:\[/code\]) as a single \[StringName\].
\[codeblocks\]
\[gdscript\]
var node_path = ^""Sprite2D:texture:resource_name""
print(node_path.get_concatenated_subnames()) # Prints ""texture:resource_name""
\[/gdscript\]
\[csharp\]
var nodePath = new NodePath(""Sprite2D:texture:resource_name"");
GD.Print(nodePath.GetConcatenatedSubnames()); // Prints ""texture:resource_name""
\[/csharp\]
\[/codeblocks\] *)
    val get_concatenated_subnames : 
    (BuiltinClass0.NodePath.t structure ptr -> BuiltinClass0.StringName.t structure ptr)

    (** Returns the slice of the \[NodePath\], from \[param begin\] (inclusive) to \[param end\] (exclusive), as a new \[NodePath\].
The absolute value of \[param begin\] and \[param end\] will be clamped to the sum of \[method get_name_count\] and \[method get_subname_count\], so the default value for \[param end\] makes it slice to the end of the \[NodePath\] by default (i.e. \[code\]path.slice(1)\[/code\] is a shorthand for \[code\]path.slice(1, path.get_name_count() + path.get_subname_count())\[/code\]).
If either \[param begin\] or \[param end\] are negative, they will be relative to the end of the \[NodePath\] (i.e. \[code\]path.slice(0, -2)\[/code\] is a shorthand for \[code\]path.slice(0, path.get_name_count() + path.get_subname_count() - 2)\[/code\]). *)
    val slice : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.Int.t structure ptr -> BuiltinClass0.NodePath.t structure ptr -> BuiltinClass0.NodePath.t structure ptr)

    (** Returns a copy of this node path with a colon character (\[code\]:\[/code\]) prefixed, transforming it to a pure property path with no node names (relative to the current node).
\[codeblocks\]
\[gdscript\]
# node_path points to the ""x"" property of the child node named ""position"".
var node_path = ^""position:x""

# property_path points to the ""position"" in the ""x"" axis of this node.
var property_path = node_path.get_as_property_path()
print(property_path) # Prints "":position:x""
\[/gdscript\]
\[csharp\]
// nodePath points to the ""x"" property of the child node named ""position"".
var nodePath = new NodePath(""position:x"");

// propertyPath points to the ""position"" in the ""x"" axis of this node.
NodePath propertyPath = nodePath.GetAsPropertyPath();
GD.Print(propertyPath); // Prints "":position:x""
\[/csharp\]
\[/codeblocks\] *)
    val get_as_property_path : 
    (BuiltinClass0.NodePath.t structure ptr -> BuiltinClass0.NodePath.t structure ptr)

    (** Returns \[code\]true\[/code\] if the node path has been constructed from an empty \[String\] (\[code\]""""\[/code\]). *)
    val is_empty : 
    (BuiltinClass0.NodePath.t structure ptr -> BuiltinClass0.Bool.t structure ptr)






    val not : 
    (NodePath.t structure ptr -> NodePath.t structure ptr -> Bool.t structure ptr)

    (** Returns \[code\]true\[/code\] if two node paths are equal, that is, they are composed of the same node names and subnames in the same order. *)
    val (=) : 
    (NodePath.t structure ptr -> NodePath.t structure ptr -> Bool.t structure ptr)

    (** Returns \[code\]true\[/code\] if two node paths are not equal. *)
    val (<>) : 
    (NodePath.t structure ptr -> NodePath.t structure ptr -> Bool.t structure ptr)


    val mem_Dictionary : 
    (NodePath.t structure ptr -> Dictionary.t structure ptr -> Bool.t structure ptr)


    val mem_Array : 
    (NodePath.t structure ptr -> Array.t structure ptr -> Bool.t structure ptr)
    end

  module type RID = sig
    type t


    include Api_types.API_TYPE with type t := t



    (** Returns \[code\]true\[/code\] if the \[RID\] is not \[code\]0\[/code\]. *)
    val is_valid : 
    (BuiltinClass0.RID.t structure ptr -> BuiltinClass0.Bool.t structure ptr)

    (** Returns the ID of the referenced low-level resource. *)
    val get_id : 
    (BuiltinClass0.RID.t structure ptr -> BuiltinClass0.Int.t structure ptr)






    val not : 
    (RID.t structure ptr -> RID.t structure ptr -> Bool.t structure ptr)

    (** Returns \[code\]true\[/code\] if both \[RID\]s are equal, which means they both refer to the same low-level resource. *)
    val (=) : 
    (RID.t structure ptr -> RID.t structure ptr -> Bool.t structure ptr)

    (** Returns \[code\]true\[/code\] if the \[RID\]s are not equal. *)
    val (<>) : 
    (RID.t structure ptr -> RID.t structure ptr -> Bool.t structure ptr)

    (** Returns \[code\]true\[/code\] if the \[RID\]''s ID is less than \[param right\]''s ID. *)
    val (<) : 
    (RID.t structure ptr -> RID.t structure ptr -> Bool.t structure ptr)

    (** Returns \[code\]true\[/code\] if the \[RID\]''s ID is less than or equal to \[param right\]''s ID. *)
    val (<=) : 
    (RID.t structure ptr -> RID.t structure ptr -> Bool.t structure ptr)

    (** Returns \[code\]true\[/code\] if the \[RID\]''s ID is greater than \[param right\]''s ID. *)
    val (>) : 
    (RID.t structure ptr -> RID.t structure ptr -> Bool.t structure ptr)

    (** Returns \[code\]true\[/code\] if the \[RID\]''s ID is greater than or equal to \[param right\]''s ID. *)
    val (>=) : 
    (RID.t structure ptr -> RID.t structure ptr -> Bool.t structure ptr)


    val mem_Dictionary : 
    (RID.t structure ptr -> Dictionary.t structure ptr -> Bool.t structure ptr)


    val mem_Array : 
    (RID.t structure ptr -> Array.t structure ptr -> Bool.t structure ptr)
    end

  module type CALLABLE = sig
    type t


    include Api_types.API_TYPE with type t := t



    (** Creates a new \[Callable\] for the method named \[param method\] in the specified \[param variant\]. To represent a method of a built-in \[Variant\] type, a custom callable is used (see \[method is_custom\]). If \[param variant\] is \[Object\], then a standard callable will be created instead.
\[b\]Note:\[/b\] This method is always necessary for the \[Dictionary\] type, as property syntax is used to access its entries. You may also use this method when \[param variant\]''s type is not known in advance (for polymorphism). *)
    val create : 
    (BuiltinClass0.Variant.t structure ptr -> BuiltinClass0.StringName.t structure ptr -> BuiltinClass0.Callable.t structure ptr)

    (** Calls the method represented by this \[Callable\]. Unlike \[method call\], this method expects all arguments to be contained inside the \[param arguments\] \[Array\]. *)
    val callv : 
    (BuiltinClass0.Array.t structure ptr -> BuiltinClass0.Callable.t structure ptr -> BuiltinClass0.Variant.t structure ptr)

    (** Returns \[code\]true\[/code\] if this \[Callable\] has no target to call the method on. Equivalent to \[code\]callable == Callable()\[/code\].
\[b\]Note:\[/b\] This is \[i\]not\[/i\] the same as \[code\]not is_valid()\[/code\] and using \[code\]not is_null()\[/code\] will \[i\]not\[/i\] guarantee that this callable can be called. Use \[method is_valid\] instead. *)
    val is_null : 
    (BuiltinClass0.Callable.t structure ptr -> BuiltinClass0.Bool.t structure ptr)

    (** Returns \[code\]true\[/code\] if this \[Callable\] is a custom callable. Custom callables are used:
- for binding/unbinding arguments (see \[method bind\] and \[method unbind\]);
- for representing methods of built-in \[Variant\] types (see \[method create\]);
- for representing global, lambda, and RPC functions in GDScript;
- for other purposes in the core, GDExtension, and C#. *)
    val is_custom : 
    (BuiltinClass0.Callable.t structure ptr -> BuiltinClass0.Bool.t structure ptr)

    (** Returns \[code\]true\[/code\] if this \[Callable\] is a standard callable. This method is the opposite of \[method is_custom\]. Returns \[code\]false\[/code\] if this callable is a lambda function. *)
    val is_standard : 
    (BuiltinClass0.Callable.t structure ptr -> BuiltinClass0.Bool.t structure ptr)

    (** Returns \[code\]true\[/code\] if the callable''s object exists and has a valid method name assigned, or is a custom callable. *)
    val is_valid : 
    (BuiltinClass0.Callable.t structure ptr -> BuiltinClass0.Bool.t structure ptr)

    (** Returns the object on which this \[Callable\] is called. *)
    val get_object : 
    (BuiltinClass0.Callable.t structure ptr -> BuiltinClass0.Object.t structure ptr)

    (** Returns the ID of this \[Callable\]''s object (see \[method Object.get_instance_id\]). *)
    val get_object_id : 
    (BuiltinClass0.Callable.t structure ptr -> BuiltinClass0.Int.t structure ptr)

    (** Returns the name of the method represented by this \[Callable\]. If the callable is a GDScript lambda function, returns the function''s name or \[code\]""<anonymous lambda>""\[/code\]. *)
    val get_method : 
    (BuiltinClass0.Callable.t structure ptr -> BuiltinClass0.StringName.t structure ptr)

    (** Returns the total number of arguments this \[Callable\] should take, including optional arguments. This means that any arguments bound with \[method bind\] are \[i\]subtracted\[/i\] from the result, and any arguments unbound with \[method unbind\] are \[i\]added\[/i\] to the result. *)
    val get_argument_count : 
    (BuiltinClass0.Callable.t structure ptr -> BuiltinClass0.Int.t structure ptr)

    (** Returns the total amount of arguments bound via successive \[method bind\] or \[method unbind\] calls. This is the same as the size of the array returned by \[method get_bound_arguments\]. See \[method get_bound_arguments\] for details.
\[b\]Note:\[/b\] The \[method get_bound_arguments_count\] and \[method get_unbound_arguments_count\] methods can both return positive values. *)
    val get_bound_arguments_count : 
    (BuiltinClass0.Callable.t structure ptr -> BuiltinClass0.Int.t structure ptr)

    (** Returns the array of arguments bound via successive \[method bind\] or \[method unbind\] calls. These arguments will be added \[i\]after\[/i\] the arguments passed to the call, from which \[method get_unbound_arguments_count\] arguments on the right have been previously excluded.
\[codeblock\]
func get_effective_arguments(callable, call_args):
    assert(call_args.size() - callable.get_unbound_arguments_count() >= 0)
    var result = call_args.slice(0, call_args.size() - callable.get_unbound_arguments_count())
    result.append_array(callable.get_bound_arguments())
    return result
\[/codeblock\] *)
    val get_bound_arguments : 
    (BuiltinClass0.Callable.t structure ptr -> BuiltinClass0.Array.t structure ptr)

    (** Returns the total amount of arguments unbound via successive \[method bind\] or \[method unbind\] calls. See \[method get_bound_arguments\] for details.
\[b\]Note:\[/b\] The \[method get_bound_arguments_count\] and \[method get_unbound_arguments_count\] methods can both return positive values. *)
    val get_unbound_arguments_count : 
    (BuiltinClass0.Callable.t structure ptr -> BuiltinClass0.Int.t structure ptr)

    (** Returns the 32-bit hash value of this \[Callable\]''s object.
\[b\]Note:\[/b\] \[Callable\]s with equal content will always produce identical hash values. However, the reverse is not true. Returning identical hash values does \[i\]not\[/i\] imply the callables are equal, because different callables can have identical hash values due to hash collisions. The engine uses a 32-bit hash algorithm for \[method hash\]. *)
    val hash : 
    (BuiltinClass0.Callable.t structure ptr -> BuiltinClass0.Int.t structure ptr)

    (** Returns a copy of this \[Callable\] with one or more arguments bound, reading them from an array. When called, the bound arguments are passed \[i\]after\[/i\] the arguments supplied by \[method call\]. See also \[method unbind\].
\[b\]Note:\[/b\] When this method is chained with other similar methods, the order in which the argument list is modified is read from right to left. *)
    val bindv : 
    (BuiltinClass0.Array.t structure ptr -> BuiltinClass0.Callable.t structure ptr -> BuiltinClass0.Callable.t structure ptr)

    (** Returns a copy of this \[Callable\] with a number of arguments unbound. In other words, when the new callable is called the last few arguments supplied by the user are ignored, according to \[param argcount\]. The remaining arguments are passed to the callable. This allows to use the original callable in a context that attempts to pass more arguments than this callable can handle, e.g. a signal with a fixed number of arguments. See also \[method bind\].
\[b\]Note:\[/b\] When this method is chained with other similar methods, the order in which the argument list is modified is read from right to left.
\[codeblock\]
func _ready():
    foo.unbind(1).call(1, 2) # Calls foo(1).
    foo.bind(3, 4).unbind(1).call(1, 2) # Calls foo(1, 3, 4), note that it does not change the arguments from bind.
\[/codeblock\] *)
    val unbind : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.Callable.t structure ptr -> BuiltinClass0.Callable.t structure ptr)

    (** Calls the method represented by this \[Callable\]. Arguments can be passed and should match the method''s signature. *)
    val call : 
    (Variadic.t structure ptr -> BuiltinClass0.Callable.t structure ptr -> BuiltinClass0.Variant.t structure ptr)

    (** Calls the method represented by this \[Callable\] in deferred mode, i.e. at the end of the current frame. Arguments can be passed and should match the method''s signature.
\[codeblocks\]
\[gdscript\]
func _ready():
    grab_focus.call_deferred()
\[/gdscript\]
\[csharp\]
public override void _Ready()
\{!
    Callable.From(GrabFocus).CallDeferred();
\}
\[/csharp\]
\[/codeblocks\]
\[b\]Note:\[/b\] Deferred calls are processed at idle time. Idle time happens mainly at the end of process and physics frames. In it, deferred calls will be run until there are none left, which means you can defer calls from other deferred calls and they''ll still be run in the current idle time cycle. This means you should not call a method deferred from itself (or from a method called by it), as this causes infinite recursion the same way as if you had called the method directly.
See also \[method Object.call_deferred\]. *)
    val call_deferred : 
    (Variadic.t structure ptr -> BuiltinClass0.Callable.t structure ptr -> unit)

    (** Perform an RPC (Remote Procedure Call) on all connected peers. This is used for multiplayer and is normally not available, unless the function being called has been marked as \[i\]RPC\[/i\] (using \[annotation \@GDScript.\@rpc\] or \[method Node.rpc_config\]). Calling this method on unsupported functions will result in an error. See \[method Node.rpc\]. *)
    val rpc : 
    (Variadic.t structure ptr -> BuiltinClass0.Callable.t structure ptr -> unit)

    (** Perform an RPC (Remote Procedure Call) on a specific peer ID (see multiplayer documentation for reference). This is used for multiplayer and is normally not available unless the function being called has been marked as \[i\]RPC\[/i\] (using \[annotation \@GDScript.\@rpc\] or \[method Node.rpc_config\]). Calling this method on unsupported functions will result in an error. See \[method Node.rpc_id\]. *)
    val rpc_id : 
    (BuiltinClass0.Int.t structure ptr -> Variadic.t structure ptr -> BuiltinClass0.Callable.t structure ptr -> unit)

    (** Returns a copy of this \[Callable\] with one or more arguments bound. When called, the bound arguments are passed \[i\]after\[/i\] the arguments supplied by \[method call\]. See also \[method unbind\].
\[b\]Note:\[/b\] When this method is chained with other similar methods, the order in which the argument list is modified is read from right to left. *)
    val bind : 
    (Variadic.t structure ptr -> BuiltinClass0.Callable.t structure ptr -> BuiltinClass0.Callable.t structure ptr)






    val not : 
    (Callable.t structure ptr -> Callable.t structure ptr -> Bool.t structure ptr)

    (** Returns \[code\]true\[/code\] if both \[Callable\]s invoke the same custom target. *)
    val (=) : 
    (Callable.t structure ptr -> Callable.t structure ptr -> Bool.t structure ptr)

    (** Returns \[code\]true\[/code\] if both \[Callable\]s invoke different targets. *)
    val (<>) : 
    (Callable.t structure ptr -> Callable.t structure ptr -> Bool.t structure ptr)


    val mem_Dictionary : 
    (Callable.t structure ptr -> Dictionary.t structure ptr -> Bool.t structure ptr)


    val mem_Array : 
    (Callable.t structure ptr -> Array.t structure ptr -> Bool.t structure ptr)
    end

  module type SIGNAL = sig
    type t


    include Api_types.API_TYPE with type t := t



    (** Returns \[code\]true\[/code\] if this \[Signal\] has no object and the signal name is empty. Equivalent to \[code\]signal == Signal()\[/code\]. *)
    val is_null : 
    (BuiltinClass0.Signal.t structure ptr -> BuiltinClass0.Bool.t structure ptr)

    (** Returns the object emitting this signal. *)
    val get_object : 
    (BuiltinClass0.Signal.t structure ptr -> BuiltinClass0.Object.t structure ptr)

    (** Returns the ID of the object emitting this signal (see \[method Object.get_instance_id\]). *)
    val get_object_id : 
    (BuiltinClass0.Signal.t structure ptr -> BuiltinClass0.Int.t structure ptr)

    (** Returns the name of this signal. *)
    val get_name : 
    (BuiltinClass0.Signal.t structure ptr -> BuiltinClass0.StringName.t structure ptr)

    (** Connects this signal to the specified \[param callable\]. Optional \[param flags\] can be also added to configure the connection''s behavior (see \[enum Object.ConnectFlags\] constants). You can provide additional arguments to the connected \[param callable\] by using \[method Callable.bind\].
A signal can only be connected once to the same \[Callable\]. If the signal is already connected, returns \[constant ERR_INVALID_PARAMETER\] and pushes an error message, unless the signal is connected with \[constant Object.CONNECT_REFERENCE_COUNTED\]. To prevent this, use \[method is_connected\] first to check for existing connections.
\[codeblock\]
for button in $Buttons.get_children():
    button.pressed.connect(_on_pressed.bind(button))

func _on_pressed(button):
    print(button.name, "" was pressed"")
\[/codeblock\] *)
    val connect : 
    (BuiltinClass0.Callable.t structure ptr -> BuiltinClass0.Int.t structure ptr -> BuiltinClass0.Signal.t structure ptr -> BuiltinClass0.Int.t structure ptr)

    (** Disconnects this signal from the specified \[Callable\]. If the connection does not exist, generates an error. Use \[method is_connected\] to make sure that the connection exists. *)
    val disconnect : 
    (BuiltinClass0.Callable.t structure ptr -> BuiltinClass0.Signal.t structure ptr -> unit)

    (** Returns \[code\]true\[/code\] if the specified \[Callable\] is connected to this signal. *)
    val is_connected : 
    (BuiltinClass0.Callable.t structure ptr -> BuiltinClass0.Signal.t structure ptr -> BuiltinClass0.Bool.t structure ptr)

    (** Returns an \[Array\] of connections for this signal. Each connection is represented as a \[Dictionary\] that contains three entries:
- \[code\]signal\[/code\] is a reference to this signal;
- \[code\]callable\[/code\] is a reference to the connected \[Callable\];
- \[code\]flags\[/code\] is a combination of \[enum Object.ConnectFlags\]. *)
    val get_connections : 
    (BuiltinClass0.Signal.t structure ptr -> BuiltinClass0.Array.t structure ptr)

    (** Returns \[code\]true\[/code\] if any \[Callable\] is connected to this signal. *)
    val has_connections : 
    (BuiltinClass0.Signal.t structure ptr -> BuiltinClass0.Bool.t structure ptr)

    (** Emits this signal. All \[Callable\]s connected to this signal will be triggered. This method supports a variable number of arguments, so parameters can be passed as a comma separated list. *)
    val emit : 
    (Variadic.t structure ptr -> BuiltinClass0.Signal.t structure ptr -> unit)






    val not : 
    (Signal.t structure ptr -> Signal.t structure ptr -> Bool.t structure ptr)

    (** Returns \[code\]true\[/code\] if both signals share the same object and name. *)
    val (=) : 
    (Signal.t structure ptr -> Signal.t structure ptr -> Bool.t structure ptr)

    (** Returns \[code\]true\[/code\] if the signals do not share the same object and name. *)
    val (<>) : 
    (Signal.t structure ptr -> Signal.t structure ptr -> Bool.t structure ptr)


    val mem_Dictionary : 
    (Signal.t structure ptr -> Dictionary.t structure ptr -> Bool.t structure ptr)


    val mem_Array : 
    (Signal.t structure ptr -> Array.t structure ptr -> Bool.t structure ptr)
    end

  module type DICTIONARY = sig
    type t


    include Api_types.API_TYPE with type t := t



    (** Returns the number of entries in the dictionary. Empty dictionaries (\[code\]\{! \}\[/code\]) always return \[code\]0\[/code\]. See also \[method is_empty\]. *)
    val size : 
    (BuiltinClass0.Dictionary.t structure ptr -> BuiltinClass0.Int.t structure ptr)

    (** Returns \[code\]true\[/code\] if the dictionary is empty (its size is \[code\]0\[/code\]). See also \[method size\]. *)
    val is_empty : 
    (BuiltinClass0.Dictionary.t structure ptr -> BuiltinClass0.Bool.t structure ptr)

    (** Clears the dictionary, removing all entries from it. *)
    val clear : 
    (BuiltinClass0.Dictionary.t structure ptr -> unit)

    (** Assigns elements of another \[param dictionary\] into the dictionary. Resizes the dictionary to match \[param dictionary\]. Performs type conversions if the dictionary is typed. *)
    val assign : 
    (BuiltinClass0.Dictionary.t structure ptr -> BuiltinClass0.Dictionary.t structure ptr -> unit)

    (** Sorts the dictionary in-place by key. This can be used to ensure dictionaries with the same contents produce equivalent results when getting the \[method keys\], getting the \[method values\], and converting to a string. This is also useful when wanting a JSON representation consistent with what is in memory, and useful for storing on a database that requires dictionaries to be sorted. *)
    val sort : 
    (BuiltinClass0.Dictionary.t structure ptr -> unit)

    (** Adds entries from \[param dictionary\] to this dictionary. By default, duplicate keys are not copied over, unless \[param overwrite\] is \[code\]true\[/code\].
\[codeblocks\]
\[gdscript\]
var dict = \{! ""item"": ""sword"", ""quantity"": 2 \}
var other_dict = \{! ""quantity"": 15, ""color"": ""silver"" \}

# Overwriting of existing keys is disabled by default.
dict.merge(other_dict)
print(dict)  # \{! ""item"": ""sword"", ""quantity"": 2, ""color"": ""silver"" \}

# With overwriting of existing keys enabled.
dict.merge(other_dict, true)
print(dict)  # \{! ""item"": ""sword"", ""quantity"": 15, ""color"": ""silver"" \}
\[/gdscript\]
\[csharp\]
var dict = new Godot.Collections.Dictionary
\{!
    \[""item""\] = ""sword"",
    \[""quantity""\] = 2,
\};

var otherDict = new Godot.Collections.Dictionary
\{!
    \[""quantity""\] = 15,
    \[""color""\] = ""silver"",
\};

// Overwriting of existing keys is disabled by default.
dict.Merge(otherDict);
GD.Print(dict); // \{! ""item"": ""sword"", ""quantity"": 2, ""color"": ""silver"" \}

// With overwriting of existing keys enabled.
dict.Merge(otherDict, true);
GD.Print(dict); // \{! ""item"": ""sword"", ""quantity"": 15, ""color"": ""silver"" \}
\[/csharp\]
\[/codeblocks\]
\[b\]Note:\[/b\] \[method merge\] is \[i\]not\[/i\] recursive. Nested dictionaries are considered as keys that can be overwritten or not depending on the value of \[param overwrite\], but they will never be merged together. *)
    val merge : 
    (BuiltinClass0.Dictionary.t structure ptr -> BuiltinClass0.Bool.t structure ptr -> BuiltinClass0.Dictionary.t structure ptr -> unit)

    (** Returns a copy of this dictionary merged with the other \[param dictionary\]. By default, duplicate keys are not copied over, unless \[param overwrite\] is \[code\]true\[/code\]. See also \[method merge\].
This method is useful for quickly making dictionaries with default values:
\[codeblock\]
var base = \{! ""fruit"": ""apple"", ""vegetable"": ""potato"" \}
var extra = \{! ""fruit"": ""orange"", ""dressing"": ""vinegar"" \}
# Prints \{! ""fruit"": ""orange"", ""vegetable"": ""potato"", ""dressing"": ""vinegar"" \}
print(extra.merged(base))
# Prints \{! ""fruit"": ""apple"", ""vegetable"": ""potato"", ""dressing"": ""vinegar"" \}
print(extra.merged(base, true))
\[/codeblock\] *)
    val merged : 
    (BuiltinClass0.Dictionary.t structure ptr -> BuiltinClass0.Bool.t structure ptr -> BuiltinClass0.Dictionary.t structure ptr -> BuiltinClass0.Dictionary.t structure ptr)

    (** Returns \[code\]true\[/code\] if the dictionary contains an entry with the given \[param key\].
\[codeblocks\]
\[gdscript\]
var my_dict = \{!
    ""Godot"" : 4,
    210 : null,
\}

print(my_dict.has(""Godot"")) # Prints true
print(my_dict.has(210))     # Prints true
print(my_dict.has(4))       # Prints false
\[/gdscript\]
\[csharp\]
var myDict = new Godot.Collections.Dictionary
\{!
    \{! ""Godot"", 4 \},
    \{! 210, default \},
\};

GD.Print(myDict.ContainsKey(""Godot"")); // Prints True
GD.Print(myDict.ContainsKey(210));     // Prints True
GD.Print(myDict.ContainsKey(4));       // Prints False
\[/csharp\]
\[/codeblocks\]
In GDScript, this is equivalent to the \[code\]in\[/code\] operator:
\[codeblock\]
if ""Godot"" in \{!""Godot"": 4\}:
    print(""The key is here!"") # Will be printed.
\[/codeblock\]
\[b\]Note:\[/b\] This method returns \[code\]true\[/code\] as long as the \[param key\] exists, even if its corresponding value is \[code\]null\[/code\]. *)
    val has : 
    (BuiltinClass0.Variant.t structure ptr -> BuiltinClass0.Dictionary.t structure ptr -> BuiltinClass0.Bool.t structure ptr)

    (** Returns \[code\]true\[/code\] if the dictionary contains all keys in the given \[param keys\] array.
\[codeblock\]
var data = \{!""width"" : 10, ""height"" : 20\}
data.has_all(\[""height"", ""width""\]) # Returns true
\[/codeblock\] *)
    val has_all : 
    (BuiltinClass0.Array.t structure ptr -> BuiltinClass0.Dictionary.t structure ptr -> BuiltinClass0.Bool.t structure ptr)

    (** Finds and returns the first key whose associated value is equal to \[param value\], or \[code\]null\[/code\] if it is not found.
\[b\]Note:\[/b\] \[code\]null\[/code\] is also a valid key. If inside the dictionary, \[method find_key\] may give misleading results. *)
    val find_key : 
    (BuiltinClass0.Variant.t structure ptr -> BuiltinClass0.Dictionary.t structure ptr -> BuiltinClass0.Variant.t structure ptr)

    (** Removes the dictionary entry by key, if it exists. Returns \[code\]true\[/code\] if the given \[param key\] existed in the dictionary, otherwise \[code\]false\[/code\].
\[b\]Note:\[/b\] Do not erase entries while iterating over the dictionary. You can iterate over the \[method keys\] array instead. *)
    val erase : 
    (BuiltinClass0.Variant.t structure ptr -> BuiltinClass0.Dictionary.t structure ptr -> BuiltinClass0.Bool.t structure ptr)

    (** Returns a hashed 32-bit integer value representing the dictionary contents.
\[codeblocks\]
\[gdscript\]
var dict1 = \{!""A"": 10, ""B"": 2\}
var dict2 = \{!""A"": 10, ""B"": 2\}

print(dict1.hash() == dict2.hash()) # Prints true
\[/gdscript\]
\[csharp\]
var dict1 = new Godot.Collections.Dictionary\{!\{!""A"", 10\}, \{!""B"", 2\}\};
var dict2 = new Godot.Collections.Dictionary\{!\{!""A"", 10\}, \{!""B"", 2\}\};

// Godot.Collections.Dictionary has no Hash() method. Use GD.Hash() instead.
GD.Print(GD.Hash(dict1) == GD.Hash(dict2)); // Prints True
\[/csharp\]
\[/codeblocks\]
\[b\]Note:\[/b\] Dictionaries with the same entries but in a different order will not have the same hash.
\[b\]Note:\[/b\] Dictionaries with equal hash values are \[i\]not\[/i\] guaranteed to be the same, because of hash collisions. On the contrary, dictionaries with different hash values are guaranteed to be different. *)
    val hash : 
    (BuiltinClass0.Dictionary.t structure ptr -> BuiltinClass0.Int.t structure ptr)

    (** Returns the list of keys in the dictionary. *)
    val keys : 
    (BuiltinClass0.Dictionary.t structure ptr -> BuiltinClass0.Array.t structure ptr)

    (** Returns the list of values in this dictionary. *)
    val values : 
    (BuiltinClass0.Dictionary.t structure ptr -> BuiltinClass0.Array.t structure ptr)

    (** Creates and returns a new copy of the dictionary. If \[param deep\] is \[code\]true\[/code\], inner \[Dictionary\] and \[Array\] keys and values are also copied, recursively. *)
    val duplicate : 
    (BuiltinClass0.Bool.t structure ptr -> BuiltinClass0.Dictionary.t structure ptr -> BuiltinClass0.Dictionary.t structure ptr)

    (** Returns the corresponding value for the given \[param key\] in the dictionary. If the \[param key\] does not exist, returns \[param default\], or \[code\]null\[/code\] if the parameter is omitted. *)
    val get : 
    (BuiltinClass0.Variant.t structure ptr -> BuiltinClass0.Variant.t structure ptr -> BuiltinClass0.Dictionary.t structure ptr -> BuiltinClass0.Variant.t structure ptr)

    (** Gets a value and ensures the key is set. If the \[param key\] exists in the dictionary, this behaves like \[method get\]. Otherwise, the \[param default\] value is inserted into the dictionary and returned. *)
    val get_or_add : 
    (BuiltinClass0.Variant.t structure ptr -> BuiltinClass0.Variant.t structure ptr -> BuiltinClass0.Dictionary.t structure ptr -> BuiltinClass0.Variant.t structure ptr)

    (** Sets the value of the element at the given \[param key\] to the given \[param value\]. This is the same as using the \[code\]\[\]\[/code\] operator (\[code\]array\[index\] = value\[/code\]). *)
    val set : 
    (BuiltinClass0.Variant.t structure ptr -> BuiltinClass0.Variant.t structure ptr -> BuiltinClass0.Dictionary.t structure ptr -> BuiltinClass0.Bool.t structure ptr)

    (** Returns \[code\]true\[/code\] if the dictionary is typed. Typed dictionaries can only store keys/values of their associated type and provide type safety for the \[code\]\[\]\[/code\] operator. Methods of typed dictionary still return \[Variant\]. *)
    val is_typed : 
    (BuiltinClass0.Dictionary.t structure ptr -> BuiltinClass0.Bool.t structure ptr)

    (** Returns \[code\]true\[/code\] if the dictionary''s keys are typed. *)
    val is_typed_key : 
    (BuiltinClass0.Dictionary.t structure ptr -> BuiltinClass0.Bool.t structure ptr)

    (** Returns \[code\]true\[/code\] if the dictionary''s values are typed. *)
    val is_typed_value : 
    (BuiltinClass0.Dictionary.t structure ptr -> BuiltinClass0.Bool.t structure ptr)

    (** Returns \[code\]true\[/code\] if the dictionary is typed the same as \[param dictionary\]. *)
    val is_same_typed : 
    (BuiltinClass0.Dictionary.t structure ptr -> BuiltinClass0.Dictionary.t structure ptr -> BuiltinClass0.Bool.t structure ptr)

    (** Returns \[code\]true\[/code\] if the dictionary''s keys are typed the same as \[param dictionary\]''s keys. *)
    val is_same_typed_key : 
    (BuiltinClass0.Dictionary.t structure ptr -> BuiltinClass0.Dictionary.t structure ptr -> BuiltinClass0.Bool.t structure ptr)

    (** Returns \[code\]true\[/code\] if the dictionary''s values are typed the same as \[param dictionary\]''s values. *)
    val is_same_typed_value : 
    (BuiltinClass0.Dictionary.t structure ptr -> BuiltinClass0.Dictionary.t structure ptr -> BuiltinClass0.Bool.t structure ptr)

    (** Returns the built-in \[Variant\] type of the typed dictionary''s keys as a \[enum Variant.Type\] constant. If the keys are not typed, returns \[constant TYPE_NIL\]. See also \[method is_typed_key\]. *)
    val get_typed_key_builtin : 
    (BuiltinClass0.Dictionary.t structure ptr -> BuiltinClass0.Int.t structure ptr)

    (** Returns the built-in \[Variant\] type of the typed dictionary''s values as a \[enum Variant.Type\] constant. If the values are not typed, returns \[constant TYPE_NIL\]. See also \[method is_typed_value\]. *)
    val get_typed_value_builtin : 
    (BuiltinClass0.Dictionary.t structure ptr -> BuiltinClass0.Int.t structure ptr)

    (** Returns the \[b\]built-in\[/b\] class name of the typed dictionary''s keys, if the built-in \[Variant\] type is \[constant TYPE_OBJECT\]. Otherwise, returns an empty \[StringName\]. See also \[method is_typed_key\] and \[method Object.get_class\]. *)
    val get_typed_key_class_name : 
    (BuiltinClass0.Dictionary.t structure ptr -> BuiltinClass0.StringName.t structure ptr)

    (** Returns the \[b\]built-in\[/b\] class name of the typed dictionary''s values, if the built-in \[Variant\] type is \[constant TYPE_OBJECT\]. Otherwise, returns an empty \[StringName\]. See also \[method is_typed_value\] and \[method Object.get_class\]. *)
    val get_typed_value_class_name : 
    (BuiltinClass0.Dictionary.t structure ptr -> BuiltinClass0.StringName.t structure ptr)

    (** Returns the \[Script\] instance associated with this typed dictionary''s keys, or \[code\]null\[/code\] if it does not exist. See also \[method is_typed_key\]. *)
    val get_typed_key_script : 
    (BuiltinClass0.Dictionary.t structure ptr -> BuiltinClass0.Variant.t structure ptr)

    (** Returns the \[Script\] instance associated with this typed dictionary''s values, or \[code\]null\[/code\] if it does not exist. See also \[method is_typed_value\]. *)
    val get_typed_value_script : 
    (BuiltinClass0.Dictionary.t structure ptr -> BuiltinClass0.Variant.t structure ptr)

    (** Makes the dictionary read-only, i.e. disables modification of the dictionary''s contents. Does not apply to nested content, e.g. content of nested dictionaries. *)
    val make_read_only : 
    (BuiltinClass0.Dictionary.t structure ptr -> unit)

    (** Returns \[code\]true\[/code\] if the dictionary is read-only. See \[method make_read_only\]. Dictionaries are automatically read-only if declared with \[code\]const\[/code\] keyword. *)
    val is_read_only : 
    (BuiltinClass0.Dictionary.t structure ptr -> BuiltinClass0.Bool.t structure ptr)

    (** Returns \[code\]true\[/code\] if the two dictionaries contain the same keys and values, inner \[Dictionary\] and \[Array\] keys and values are compared recursively. *)
    val recursive_equal : 
    (BuiltinClass0.Dictionary.t structure ptr -> BuiltinClass0.Int.t structure ptr -> BuiltinClass0.Dictionary.t structure ptr -> BuiltinClass0.Bool.t structure ptr)






    val not : 
    (Dictionary.t structure ptr -> Dictionary.t structure ptr -> Bool.t structure ptr)

    (** Returns \[code\]true\[/code\] if the two dictionaries contain the same keys and values. The order of the entries does not matter.
\[b\]Note:\[/b\] In C#, by convention, this operator compares by \[b\]reference\[/b\]. If you need to compare by value, iterate over both dictionaries. *)
    val (=) : 
    (Dictionary.t structure ptr -> Dictionary.t structure ptr -> Bool.t structure ptr)

    (** Returns \[code\]true\[/code\] if the two dictionaries do not contain the same keys and values. *)
    val (<>) : 
    (Dictionary.t structure ptr -> Dictionary.t structure ptr -> Bool.t structure ptr)


    val mem_Dictionary : 
    (Dictionary.t structure ptr -> Dictionary.t structure ptr -> Bool.t structure ptr)


    val mem_Array : 
    (Dictionary.t structure ptr -> Array.t structure ptr -> Bool.t structure ptr)
    end

  module type ARRAY = sig
    type t


    include Api_types.API_TYPE with type t := t



    (** Returns the number of elements in the array. Empty arrays (\[code\]\[\]\[/code\]) always return \[code\]0\[/code\]. See also \[method is_empty\]. *)
    val size : 
    (BuiltinClass0.Array.t structure ptr -> BuiltinClass0.Int.t structure ptr)

    (** Returns \[code\]true\[/code\] if the array is empty (\[code\]\[\]\[/code\]). See also \[method size\]. *)
    val is_empty : 
    (BuiltinClass0.Array.t structure ptr -> BuiltinClass0.Bool.t structure ptr)

    (** Removes all elements from the array. This is equivalent to using \[method resize\] with a size of \[code\]0\[/code\]. *)
    val clear : 
    (BuiltinClass0.Array.t structure ptr -> unit)

    (** Returns a hashed 32-bit integer value representing the array and its contents.
\[b\]Note:\[/b\] Arrays with equal hash values are \[i\]not\[/i\] guaranteed to be the same, as a result of hash collisions. On the countrary, arrays with different hash values are guaranteed to be different. *)
    val hash : 
    (BuiltinClass0.Array.t structure ptr -> BuiltinClass0.Int.t structure ptr)

    (** Assigns elements of another \[param array\] into the array. Resizes the array to match \[param array\]. Performs type conversions if the array is typed. *)
    val assign : 
    (BuiltinClass0.Array.t structure ptr -> BuiltinClass0.Array.t structure ptr -> unit)

    (** Returns the element at the given \[param index\] in the array. This is the same as using the \[code\]\[\]\[/code\] operator (\[code\]array\[index\]\[/code\]). *)
    val get : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.Array.t structure ptr -> BuiltinClass0.Variant.t structure ptr)

    (** Sets the value of the element at the given \[param index\] to the given \[param value\]. This will not change the size of the array, it only changes the value at an index already in the array. This is the same as using the \[code\]\[\]\[/code\] operator (\[code\]array\[index\] = value\[/code\]). *)
    val set : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.Variant.t structure ptr -> BuiltinClass0.Array.t structure ptr -> unit)

    (** Appends an element at the end of the array. See also \[method push_front\]. *)
    val push_back : 
    (BuiltinClass0.Variant.t structure ptr -> BuiltinClass0.Array.t structure ptr -> unit)

    (** Adds an element at the beginning of the array. See also \[method push_back\].
\[b\]Note:\[/b\] This method shifts every other element''s index forward, which may have a noticeable performance cost, especially on larger arrays. *)
    val push_front : 
    (BuiltinClass0.Variant.t structure ptr -> BuiltinClass0.Array.t structure ptr -> unit)

    (** Appends \[param value\] at the end of the array (alias of \[method push_back\]). *)
    val append : 
    (BuiltinClass0.Variant.t structure ptr -> BuiltinClass0.Array.t structure ptr -> unit)

    (** Appends another \[param array\] at the end of this array.
\[codeblock\]
var numbers = \[1, 2, 3\]
var extra = \[4, 5, 6\]
numbers.append_array(extra)
print(numbers) # Prints \[1, 2, 3, 4, 5, 6\]
\[/codeblock\] *)
    val append_array : 
    (BuiltinClass0.Array.t structure ptr -> BuiltinClass0.Array.t structure ptr -> unit)

    (** Sets the array''s number of elements to \[param size\]. If \[param size\] is smaller than the array''s current size, the elements at the end are removed. If \[param size\] is greater, new default elements (usually \[code\]null\[/code\]) are added, depending on the array''s type.
Returns \[constant OK\] on success, or one of the other \[enum Error\] constants if this method fails.
\[b\]Note:\[/b\] Calling this method once and assigning the new values is faster than calling \[method append\] for every new element. *)
    val resize : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.Array.t structure ptr -> BuiltinClass0.Int.t structure ptr)

    (** Inserts a new element (\[param value\]) at a given index (\[param position\]) in the array. \[param position\] should be between \[code\]0\[/code\] and the array''s \[method size\].
Returns \[constant OK\] on success, or one of the other \[enum Error\] constants if this method fails.
\[b\]Note:\[/b\] Every element''s index after \[param position\] needs to be shifted forward, which may have a noticeable performance cost, especially on larger arrays. *)
    val insert : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.Variant.t structure ptr -> BuiltinClass0.Array.t structure ptr -> BuiltinClass0.Int.t structure ptr)

    (** Removes the element from the array at the given index (\[param position\]). If the index is out of bounds, this method fails.
If you need to return the removed element, use \[method pop_at\]. To remove an element by value, use \[method erase\] instead.
\[b\]Note:\[/b\] This method shifts every element''s index after \[param position\] back, which may have a noticeable performance cost, especially on larger arrays.
\[b\]Note:\[/b\] The \[param position\] cannot be negative. To remove an element relative to the end of the array, use \[code\]arr.remove_at(arr.size() - (i + 1))\[/code\]. To remove the last element from the array, use \[code\]arr.resize(arr.size() - 1)\[/code\]. *)
    val remove_at : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.Array.t structure ptr -> unit)

    (** Assigns the given \[param value\] to all elements in the array.
This method can often be combined with \[method resize\] to create an array with a given size and initialized elements:
\[codeblocks\]
\[gdscript\]
var array = \[\]
array.resize(5)
array.fill(2)
print(array) # Prints \[2, 2, 2, 2, 2\]
\[/gdscript\]
\[csharp\]
Godot.Collections.Array array = \[\];
array.Resize(5);
array.Fill(2);
GD.Print(array); // Prints \[2, 2, 2, 2, 2\]
\[/csharp\]
\[/codeblocks\]
\[b\]Note:\[/b\] If \[param value\] is a \[Variant\] passed by reference (\[Object\]-derived, \[Array\], \[Dictionary\], etc.), the array will be filled with references to the same \[param value\], which are not duplicates. *)
    val fill : 
    (BuiltinClass0.Variant.t structure ptr -> BuiltinClass0.Array.t structure ptr -> unit)

    (** Finds and removes the first occurrence of \[param value\] from the array. If \[param value\] does not exist in the array, nothing happens. To remove an element by index, use \[method remove_at\] instead.
\[b\]Note:\[/b\] This method shifts every element''s index after the removed \[param value\] back, which may have a noticeable performance cost, especially on larger arrays.
\[b\]Note:\[/b\] Erasing elements while iterating over arrays is \[b\]not\[/b\] supported and will result in unpredictable behavior. *)
    val erase : 
    (BuiltinClass0.Variant.t structure ptr -> BuiltinClass0.Array.t structure ptr -> unit)

    (** Returns the first element of the array. If the array is empty, fails and returns \[code\]null\[/code\]. See also \[method back\].
\[b\]Note:\[/b\] Unlike with the \[code\]\[\]\[/code\] operator (\[code\]array\[0\]\[/code\]), an error is generated without stopping project execution. *)
    val front : 
    (BuiltinClass0.Array.t structure ptr -> BuiltinClass0.Variant.t structure ptr)

    (** Returns the last element of the array. If the array is empty, fails and returns \[code\]null\[/code\]. See also \[method front\].
\[b\]Note:\[/b\] Unlike with the \[code\]\[\]\[/code\] operator (\[code\]array\[-1\]\[/code\]), an error is generated without stopping project execution. *)
    val back : 
    (BuiltinClass0.Array.t structure ptr -> BuiltinClass0.Variant.t structure ptr)

    (** Returns a random element from the array. Generates an error and returns \[code\]null\[/code\] if the array is empty.
\[codeblocks\]
\[gdscript\]
# May print 1, 2, 3.25, or ""Hi"".
print(\[1, 2, 3.25, ""Hi""\].pick_random())
\[/gdscript\]
\[csharp\]
Godot.Collections.Array array = \[1, 2, 3.25f, ""Hi""\];
GD.Print(array.PickRandom()); // May print 1, 2, 3.25, or ""Hi"".
\[/csharp\]
\[/codeblocks\]
\[b\]Note:\[/b\] Like many similar functions in the engine (such as \[method \@GlobalScope.randi\] or \[method shuffle\]), this method uses a common, global random seed. To get a predictable outcome from this method, see \[method \@GlobalScope.seed\]. *)
    val pick_random : 
    (BuiltinClass0.Array.t structure ptr -> BuiltinClass0.Variant.t structure ptr)

    (** Returns the index of the \[b\]first\[/b\] occurrence of \[param what\] in this array, or \[code\]-1\[/code\] if there are none. The search''s start can be specified with \[param from\], continuing to the end of the array.
\[b\]Note:\[/b\] If you just want to know whether the array contains \[param what\], use \[method has\] (\[code\]Contains\[/code\] in C#). In GDScript, you may also use the \[code\]in\[/code\] operator.
\[b\]Note:\[/b\] For performance reasons, the search is affected by \[param what\]''s \[enum Variant.Type\]. For example, \[code\]7\[/code\] (\[int\]) and \[code\]7.0\[/code\] (\[float\]) are not considered equal for this method. *)
    val find : 
    (BuiltinClass0.Variant.t structure ptr -> BuiltinClass0.Int.t structure ptr -> BuiltinClass0.Array.t structure ptr -> BuiltinClass0.Int.t structure ptr)

    (** Returns the index of the \[b\]first\[/b\] element in the array that causes \[param method\] to return \[code\]true\[/code\], or \[code\]-1\[/code\] if there are none. The search''s start can be specified with \[param from\], continuing to the end of the array.
\[param method\] is a callable that takes an element of the array, and returns a \[bool\].
\[b\]Note:\[/b\] If you just want to know whether the array contains \[i\]anything\[/i\] that satisfies \[param method\], use \[method any\].
\[codeblocks\]
\[gdscript\]
func is_even(number):
    return number % 2 == 0

func _ready():
    print(\[1, 3, 4, 7\].find_custom(is_even.bind())) # Prints 2
\[/gdscript\]
\[/codeblocks\] *)
    val find_custom : 
    (BuiltinClass0.Callable.t structure ptr -> BuiltinClass0.Int.t structure ptr -> BuiltinClass0.Array.t structure ptr -> BuiltinClass0.Int.t structure ptr)

    (** Returns the index of the \[b\]last\[/b\] occurrence of \[param what\] in this array, or \[code\]-1\[/code\] if there are none. The search''s start can be specified with \[param from\], continuing to the beginning of the array. This method is the reverse of \[method find\]. *)
    val rfind : 
    (BuiltinClass0.Variant.t structure ptr -> BuiltinClass0.Int.t structure ptr -> BuiltinClass0.Array.t structure ptr -> BuiltinClass0.Int.t structure ptr)

    (** Returns the index of the \[b\]last\[/b\] element of the array that causes \[param method\] to return \[code\]true\[/code\], or \[code\]-1\[/code\] if there are none. The search''s start can be specified with \[param from\], continuing to the beginning of the array. This method is the reverse of \[method find_custom\]. *)
    val rfind_custom : 
    (BuiltinClass0.Callable.t structure ptr -> BuiltinClass0.Int.t structure ptr -> BuiltinClass0.Array.t structure ptr -> BuiltinClass0.Int.t structure ptr)

    (** Returns the number of times an element is in the array.
To count how many elements in an array satisfy a condition, see \[method reduce\]. *)
    val count : 
    (BuiltinClass0.Variant.t structure ptr -> BuiltinClass0.Array.t structure ptr -> BuiltinClass0.Int.t structure ptr)

    (** Returns \[code\]true\[/code\] if the array contains the given \[param value\].
\[codeblocks\]
\[gdscript\]
print(\[""inside"", 7\].has(""inside""))  # Prints true
print(\[""inside"", 7\].has(""outside"")) # Prints false
print(\[""inside"", 7\].has(7))         # Prints true
print(\[""inside"", 7\].has(""7""))       # Prints false
\[/gdscript\]
\[csharp\]
Godot.Collections.Array arr = \[""inside"", 7\];
// By C# convention, this method is renamed to `Contains`.
GD.Print(arr.Contains(""inside""));  // Prints True
GD.Print(arr.Contains(""outside"")); // Prints False
GD.Print(arr.Contains(7));         // Prints True
GD.Print(arr.Contains(""7""));       // Prints False
\[/csharp\]
\[/codeblocks\]
In GDScript, this is equivalent to the \[code\]in\[/code\] operator:
\[codeblock\]
if 4 in \[2, 4, 6, 8\]:
    print(""4 is here!"") # Will be printed.
\[/codeblock\]
\[b\]Note:\[/b\] For performance reasons, the search is affected by the \[param value\]''s \[enum Variant.Type\]. For example, \[code\]7\[/code\] (\[int\]) and \[code\]7.0\[/code\] (\[float\]) are not considered equal for this method. *)
    val has : 
    (BuiltinClass0.Variant.t structure ptr -> BuiltinClass0.Array.t structure ptr -> BuiltinClass0.Bool.t structure ptr)

    (** Removes and returns the last element of the array. Returns \[code\]null\[/code\] if the array is empty, without generating an error. See also \[method pop_front\]. *)
    val pop_back : 
    (BuiltinClass0.Array.t structure ptr -> BuiltinClass0.Variant.t structure ptr)

    (** Removes and returns the first element of the array. Returns \[code\]null\[/code\] if the array is empty, without generating an error. See also \[method pop_back\].
\[b\]Note:\[/b\] This method shifts every other element''s index back, which may have a noticeable performance cost, especially on larger arrays. *)
    val pop_front : 
    (BuiltinClass0.Array.t structure ptr -> BuiltinClass0.Variant.t structure ptr)

    (** Removes and returns the element of the array at index \[param position\]. If negative, \[param position\] is considered relative to the end of the array. Returns \[code\]null\[/code\] if the array is empty. If \[param position\] is out of bounds, an error message is also generated.
\[b\]Note:\[/b\] This method shifts every element''s index after \[param position\] back, which may have a noticeable performance cost, especially on larger arrays. *)
    val pop_at : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.Array.t structure ptr -> BuiltinClass0.Variant.t structure ptr)

    (** Sorts the array in ascending order. The final order is dependent on the ""less than"" (\[code\]<\[/code\]) comparison between elements.
\[codeblocks\]
\[gdscript\]
var numbers = \[10, 5, 2.5, 8\]
numbers.sort()
print(numbers) # Prints \[2.5, 5, 8, 10\]
\[/gdscript\]
\[csharp\]
Godot.Collections.Array numbers = \[10, 5, 2.5, 8\];
numbers.Sort();
GD.Print(numbers); // Prints \[2.5, 5, 8, 10\]
\[/csharp\]
\[/codeblocks\]
\[b\]Note:\[/b\] The sorting algorithm used is not \[url=https://en.wikipedia.org/wiki/Sorting_algorithm#Stability\]stable\[/url\]. This means that equivalent elements (such as \[code\]2\[/code\] and \[code\]2.0\[/code\]) may have their order changed when calling \[method sort\]. *)
    val sort : 
    (BuiltinClass0.Array.t structure ptr -> unit)

    (** Sorts the array using a custom \[Callable\].
\[param func\] is called as many times as necessary, receiving two array elements as arguments. The function should return \[code\]true\[/code\] if the first element should be moved \[i\]before\[/i\] the second one, otherwise it should return \[code\]false\[/code\].
\[codeblock\]
func sort_ascending(a, b):
    if a\[1\] < b\[1\]:
        return true
    return false

func _ready():
    var my_items = \[\[""Tomato"", 5\], \[""Apple"", 9\], \[""Rice"", 4\]\]
    my_items.sort_custom(sort_ascending)
    print(my_items) # Prints \[\[""Rice"", 4\], \[""Tomato"", 5\], \[""Apple"", 9\]\]

    # Sort descending, using a lambda function.
    my_items.sort_custom(func(a, b): return a\[1\] > b\[1\])
    print(my_items) # Prints \[\[""Apple"", 9\], \[""Tomato"", 5\], \[""Rice"", 4\]\]
\[/codeblock\]
It may also be necessary to use this method to sort strings by natural order, with \[method String.naturalnocasecmp_to\], as in the following example:
\[codeblock\]
var files = \[""newfile1"", ""newfile2"", ""newfile10"", ""newfile11""\]
files.sort_custom(func(a, b): return a.naturalnocasecmp_to(b) < 0)
print(files) # Prints \[""newfile1"", ""newfile2"", ""newfile10"", ""newfile11""\]
\[/codeblock\]
\[b\]Note:\[/b\] In C#, this method is not supported.
\[b\]Note:\[/b\] The sorting algorithm used is not \[url=https://en.wikipedia.org/wiki/Sorting_algorithm#Stability\]stable\[/url\]. This means that values considered equal may have their order changed when calling this method.
\[b\]Note:\[/b\] You should not randomize the return value of \[param func\], as the heapsort algorithm expects a consistent result. Randomizing the return value will result in unexpected behavior. *)
    val sort_custom : 
    (BuiltinClass0.Callable.t structure ptr -> BuiltinClass0.Array.t structure ptr -> unit)

    (** Shuffles all elements of the array in a random order.
\[b\]Note:\[/b\] Like many similar functions in the engine (such as \[method \@GlobalScope.randi\] or \[method pick_random\]), this method uses a common, global random seed. To get a predictable outcome from this method, see \[method \@GlobalScope.seed\]. *)
    val shuffle : 
    (BuiltinClass0.Array.t structure ptr -> unit)

    (** Returns the index of \[param value\] in the sorted array. If it cannot be found, returns where \[param value\] should be inserted to keep the array sorted. The algorithm used is \[url=https://en.wikipedia.org/wiki/Binary_search_algorithm\]binary search\[/url\].
If \[param before\] is \[code\]true\[/code\] (as by default), the returned index comes before all existing elements equal to \[param value\] in the array.
\[codeblock\]
var numbers = \[2, 4, 8, 10\]
var idx = numbers.bsearch(7)

numbers.insert(idx, 7)
print(numbers) # Prints \[2, 4, 7, 8, 10\]

var fruits = \[""Apple"", ""Lemon"", ""Lemon"", ""Orange""\]
print(fruits.bsearch(""Lemon"", true))  # Prints 1, points at the first ""Lemon"".
print(fruits.bsearch(""Lemon"", false)) # Prints 3, points at ""Orange"".
\[/codeblock\]
\[b\]Note:\[/b\] Calling \[method bsearch\] on an \[i\]unsorted\[/i\] array will result in unexpected behavior. Use \[method sort\] before calling this method. *)
    val bsearch : 
    (BuiltinClass0.Variant.t structure ptr -> BuiltinClass0.Bool.t structure ptr -> BuiltinClass0.Array.t structure ptr -> BuiltinClass0.Int.t structure ptr)

    (** Returns the index of \[param value\] in the sorted array. If it cannot be found, returns where \[param value\] should be inserted to keep the array sorted (using \[param func\] for the comparisons). The algorithm used is \[url=https://en.wikipedia.org/wiki/Binary_search_algorithm\]binary search\[/url\].
Similar to \[method sort_custom\], \[param func\] is called as many times as necessary, receiving one array element and \[param value\] as arguments. The function should return \[code\]true\[/code\] if the array element should be \[i\]behind\[/i\] \[param value\], otherwise it should return \[code\]false\[/code\].
If \[param before\] is \[code\]true\[/code\] (as by default), the returned index comes before all existing elements equal to \[param value\] in the array.
\[codeblock\]
func sort_by_amount(a, b):
    if a\[1\] < b\[1\]:
        return true
    return false

func _ready():
    var my_items = \[\[""Tomato"", 2\], \[""Kiwi"", 5\], \[""Rice"", 9\]\]

    var apple = \[""Apple"", 5\]
    # ""Apple"" is inserted before ""Kiwi"".
    my_items.insert(my_items.bsearch_custom(apple, sort_by_amount, true), apple)

    var banana = \[""Banana"", 5\]
    # ""Banana"" is inserted after ""Kiwi"".
    my_items.insert(my_items.bsearch_custom(banana, sort_by_amount, false), banana)

    # Prints \[\[""Tomato"", 2\], \[""Apple"", 5\], \[""Kiwi"", 5\], \[""Banana"", 5\], \[""Rice"", 9\]\]
    print(my_items)
\[/codeblock\]
\[b\]Note:\[/b\] Calling \[method bsearch_custom\] on an \[i\]unsorted\[/i\] array will result in unexpected behavior. Use \[method sort_custom\] with \[param func\] before calling this method. *)
    val bsearch_custom : 
    (BuiltinClass0.Variant.t structure ptr -> BuiltinClass0.Callable.t structure ptr -> BuiltinClass0.Bool.t structure ptr -> BuiltinClass0.Array.t structure ptr -> BuiltinClass0.Int.t structure ptr)

    (** Reverses the order of all elements in the array. *)
    val reverse : 
    (BuiltinClass0.Array.t structure ptr -> unit)

    (** Returns a new copy of the array.
By default, a \[b\]shallow\[/b\] copy is returned: all nested \[Array\] and \[Dictionary\] elements are shared with the original array. Modifying them in one array will also affect them in the other.\[br\]If \[param deep\] is \[code\]true\[/code\], a \[b\]deep\[/b\] copy is returned: all nested arrays and dictionaries are also duplicated (recursively). *)
    val duplicate : 
    (BuiltinClass0.Bool.t structure ptr -> BuiltinClass0.Array.t structure ptr -> BuiltinClass0.Array.t structure ptr)

    (** Returns a new \[Array\] containing this array''s elements, from index \[param begin\] (inclusive) to \[param end\] (exclusive), every \[param step\] elements.
If either \[param begin\] or \[param end\] are negative, their value is relative to the end of the array.
If \[param step\] is negative, this method iterates through the array in reverse, returning a slice ordered backwards. For this to work, \[param begin\] must be greater than \[param end\].
If \[param deep\] is \[code\]true\[/code\], all nested \[Array\] and \[Dictionary\] elements in the slice are duplicated from the original, recursively. See also \[method duplicate\]).
\[codeblock\]
var letters = \[""A"", ""B"", ""C"", ""D"", ""E"", ""F""\]

print(letters.slice(0, 2))  # Prints \[""A"", ""B""\]
print(letters.slice(2, -2)) # Prints \[""C"", ""D""\]
print(letters.slice(-2, 6)) # Prints \[""E"", ""F""\]

print(letters.slice(0, 6, 2))  # Prints \[""A"", ""C"", ""E""\]
print(letters.slice(4, 1, -1)) # Prints \[""E"", ""D"", ""C""\]
\[/codeblock\] *)
    val slice : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.Int.t structure ptr -> BuiltinClass0.Int.t structure ptr -> BuiltinClass0.Bool.t structure ptr -> BuiltinClass0.Array.t structure ptr -> BuiltinClass0.Array.t structure ptr)

    (** Calls the given \[Callable\] on each element in the array and returns a new, filtered \[Array\].
The \[param method\] receives one of the array elements as an argument, and should return \[code\]true\[/code\] to add the element to the filtered array, or \[code\]false\[/code\] to exclude it.
\[codeblock\]
func is_even(number):
    return number % 2 == 0

func _ready():
    print(\[1, 4, 5, 8\].filter(is_even)) # Prints \[4, 8\]

    # Same as above, but using a lambda function.
    print(\[1, 4, 5, 8\].filter(func(number): return number % 2 == 0))
\[/codeblock\]
See also \[method any\], \[method all\], \[method map\] and \[method reduce\]. *)
    val filter : 
    (BuiltinClass0.Callable.t structure ptr -> BuiltinClass0.Array.t structure ptr -> BuiltinClass0.Array.t structure ptr)

    (** Calls the given \[Callable\] for each element in the array and returns a new array filled with values returned by the \[param method\].
The \[param method\] should take one \[Variant\] parameter (the current array element) and can return any \[Variant\].
\[codeblock\]
func double(number):
    return number  *  2

func _ready():
    print(\[1, 2, 3\].map(double)) # Prints \[2, 4, 6\]

    # Same as above, but using a lambda function.
    print(\[1, 2, 3\].map(func(element): return element  *  2))
\[/codeblock\]
See also \[method filter\], \[method reduce\], \[method any\] and \[method all\]. *)
    val map : 
    (BuiltinClass0.Callable.t structure ptr -> BuiltinClass0.Array.t structure ptr -> BuiltinClass0.Array.t structure ptr)

    (** Calls the given \[Callable\] for each element in array, accumulates the result in \[param accum\], then returns it.
The \[param method\] takes two arguments: the current value of \[param accum\] and the current array element. If \[param accum\] is \[code\]null\[/code\] (as by default), the iteration will start from the second element, with the first one used as initial value of \[param accum\].
\[codeblock\]
func sum(accum, number):
    return accum + number

func _ready():
    print(\[1, 2, 3\].reduce(sum, 0))  # Prints 6
    print(\[1, 2, 3\].reduce(sum, 10)) # Prints 16

    # Same as above, but using a lambda function.
    print(\[1, 2, 3\].reduce(func(accum, number): return accum + number, 10))
\[/codeblock\]
If \[method max\] is not desirable, this method may also be used to implement a custom comparator:
\[codeblock\]
func _ready():
    var arr = \[Vector2i(5, 0), Vector2i(3, 4), Vector2i(1, 2)\]

    var longest_vec = arr.reduce(func(max, vec): return vec if is_length_greater(vec, max) else max)
    print(longest_vec) # Prints (3, 4)

func is_length_greater(a, b):
    return a.length() > b.length()
\[/codeblock\]
This method can also be used to count how many elements in an array satisfy a certain condition, similar to \[method count\]:
\[codeblock\]
func is_even(number):
    return number % 2 == 0

func _ready():
    var arr = \[1, 2, 3, 4, 5\]
    # If the current element is even, increment count, otherwise leave count the same.
    var even_count = arr.reduce(func(count, next): return count + 1 if is_even(next) else count, 0)
    print(even_count) # Prints 2
\[/codeblock\]
See also \[method map\], \[method filter\], \[method any\], and \[method all\]. *)
    val reduce : 
    (BuiltinClass0.Callable.t structure ptr -> BuiltinClass0.Variant.t structure ptr -> BuiltinClass0.Array.t structure ptr -> BuiltinClass0.Variant.t structure ptr)

    (** Calls the given \[Callable\] on each element in the array and returns \[code\]true\[/code\] if the \[Callable\] returns \[code\]true\[/code\] for \[i\]one or more\[/i\] elements in the array. If the \[Callable\] returns \[code\]false\[/code\] for all elements in the array, this method returns \[code\]false\[/code\].
The \[param method\] should take one \[Variant\] parameter (the current array element) and return a \[bool\].
\[codeblock\]
func greater_than_5(number):
    return number > 5

func _ready():
    print(\[6, 10, 6\].any(greater_than_5)) # Prints true (3 elements evaluate to true).
    print(\[4, 10, 4\].any(greater_than_5)) # Prints true (1 elements evaluate to true).
    print(\[4, 4, 4\].any(greater_than_5))  # Prints false (0 elements evaluate to true).
    print(\[\].any(greater_than_5))         # Prints false (0 elements evaluate to true).

    # Same as the first line above, but using a lambda function.
    print(\[6, 10, 6\].any(func(number): return number > 5)) # Prints true
\[/codeblock\]
See also \[method all\], \[method filter\], \[method map\] and \[method reduce\].
\[b\]Note:\[/b\] Unlike relying on the size of an array returned by \[method filter\], this method will return as early as possible to improve performance (especially with large arrays).
\[b\]Note:\[/b\] For an empty array, this method always returns \[code\]false\[/code\]. *)
    val any : 
    (BuiltinClass0.Callable.t structure ptr -> BuiltinClass0.Array.t structure ptr -> BuiltinClass0.Bool.t structure ptr)

    (** Calls the given \[Callable\] on each element in the array and returns \[code\]true\[/code\] if the \[Callable\] returns \[code\]true\[/code\] for \[i\]all\[/i\] elements in the array. If the \[Callable\] returns \[code\]false\[/code\] for one array element or more, this method returns \[code\]false\[/code\].
The \[param method\] should take one \[Variant\] parameter (the current array element) and return a \[bool\].
\[codeblocks\]
\[gdscript\]
func greater_than_5(number):
    return number > 5

func _ready():
    print(\[6, 10, 6\].all(greater_than_5)) # Prints true (3/3 elements evaluate to true).
    print(\[4, 10, 4\].all(greater_than_5)) # Prints false (1/3 elements evaluate to true).
    print(\[4, 4, 4\].all(greater_than_5))  # Prints false (0/3 elements evaluate to true).
    print(\[\].all(greater_than_5))         # Prints true (0/0 elements evaluate to true).

    # Same as the first line above, but using a lambda function.
    print(\[6, 10, 6\].all(func(element): return element > 5)) # Prints true
\[/gdscript\]
\[csharp\]
private static bool GreaterThan5(int number)
\{!
    return number > 5;
\}

public override void _Ready()
\{!
    // Prints True (3/3 elements evaluate to true).
    GD.Print(new Godot.Collections.Array>int< \{! 6, 10, 6 \}.All(GreaterThan5));
    // Prints False (1/3 elements evaluate to true).
    GD.Print(new Godot.Collections.Array>int< \{! 4, 10, 4 \}.All(GreaterThan5));
    // Prints False (0/3 elements evaluate to true).
    GD.Print(new Godot.Collections.Array>int< \{! 4, 4, 4 \}.All(GreaterThan5));
    // Prints True (0/0 elements evaluate to true).
    GD.Print(new Godot.Collections.Array>int< \{! \}.All(GreaterThan5));

    // Same as the first line above, but using a lambda function.
    GD.Print(new Godot.Collections.Array>int< \{! 6, 10, 6 \}.All(element => element > 5)); // Prints True
\}
\[/csharp\]
\[/codeblocks\]
See also \[method any\], \[method filter\], \[method map\] and \[method reduce\].
\[b\]Note:\[/b\] Unlike relying on the size of an array returned by \[method filter\], this method will return as early as possible to improve performance (especially with large arrays).
\[b\]Note:\[/b\] For an empty array, this method \[url=https://en.wikipedia.org/wiki/Vacuous_truth\]always\[/url\] returns \[code\]true\[/code\]. *)
    val all : 
    (BuiltinClass0.Callable.t structure ptr -> BuiltinClass0.Array.t structure ptr -> BuiltinClass0.Bool.t structure ptr)

    (** Returns the maximum value contained in the array, if all elements can be compared. Otherwise, returns \[code\]null\[/code\]. See also \[method min\].
To find the maximum value using a custom comparator, you can use \[method reduce\]. *)
    val max : 
    (BuiltinClass0.Array.t structure ptr -> BuiltinClass0.Variant.t structure ptr)

    (** Returns the minimum value contained in the array, if all elements can be compared. Otherwise, returns \[code\]null\[/code\]. See also \[method max\]. *)
    val min : 
    (BuiltinClass0.Array.t structure ptr -> BuiltinClass0.Variant.t structure ptr)

    (** Returns \[code\]true\[/code\] if the array is typed. Typed arrays can only contain elements of a specific type, as defined by the typed array constructor. The methods of a typed array are still expected to return a generic \[Variant\].
In GDScript, it is possible to define a typed array with static typing:
\[codeblock\]
var numbers: Array\[float\] = \[0.2, 4.2, -2.0\]
print(numbers.is_typed()) # Prints true
\[/codeblock\] *)
    val is_typed : 
    (BuiltinClass0.Array.t structure ptr -> BuiltinClass0.Bool.t structure ptr)

    (** Returns \[code\]true\[/code\] if this array is typed the same as the given \[param array\]. See also \[method is_typed\]. *)
    val is_same_typed : 
    (BuiltinClass0.Array.t structure ptr -> BuiltinClass0.Array.t structure ptr -> BuiltinClass0.Bool.t structure ptr)

    (** Returns the built-in \[Variant\] type of the typed array as a \[enum Variant.Type\] constant. If the array is not typed, returns \[constant TYPE_NIL\]. See also \[method is_typed\]. *)
    val get_typed_builtin : 
    (BuiltinClass0.Array.t structure ptr -> BuiltinClass0.Int.t structure ptr)

    (** Returns the \[b\]built-in\[/b\] class name of the typed array, if the built-in \[Variant\] type \[constant TYPE_OBJECT\]. Otherwise, returns an empty \[StringName\]. See also \[method is_typed\] and \[method Object.get_class\]. *)
    val get_typed_class_name : 
    (BuiltinClass0.Array.t structure ptr -> BuiltinClass0.StringName.t structure ptr)

    (** Returns the \[Script\] instance associated with this typed array, or \[code\]null\[/code\] if it does not exist. See also \[method is_typed\]. *)
    val get_typed_script : 
    (BuiltinClass0.Array.t structure ptr -> BuiltinClass0.Variant.t structure ptr)

    (** Makes the array read-only. The array''s elements cannot be overridden with different values, and their order cannot change. Does not apply to nested elements, such as dictionaries.
In GDScript, arrays are automatically read-only if declared with the \[code\]const\[/code\] keyword. *)
    val make_read_only : 
    (BuiltinClass0.Array.t structure ptr -> unit)

    (** Returns \[code\]true\[/code\] if the array is read-only. See \[method make_read_only\].
In GDScript, arrays are automatically read-only if declared with the \[code\]const\[/code\] keyword. *)
    val is_read_only : 
    (BuiltinClass0.Array.t structure ptr -> BuiltinClass0.Bool.t structure ptr)






    val not : 
    (Array.t structure ptr -> Array.t structure ptr -> Bool.t structure ptr)


    val mem_Dictionary : 
    (Array.t structure ptr -> Dictionary.t structure ptr -> Bool.t structure ptr)

    (** Compares the left operand \[Array\] against the \[param right\] \[Array\]. Returns \[code\]true\[/code\] if the sizes and contents of the arrays are equal, \[code\]false\[/code\] otherwise. *)
    val (=) : 
    (Array.t structure ptr -> Array.t structure ptr -> Bool.t structure ptr)

    (** Returns \[code\]true\[/code\] if the array''s size or its elements are different than \[param right\]''s. *)
    val (<>) : 
    (Array.t structure ptr -> Array.t structure ptr -> Bool.t structure ptr)

    (** Compares the elements of both arrays in order, starting from index \[code\]0\[/code\] and ending on the last index in common between both arrays. For each pair of elements, returns \[code\]true\[/code\] if this array''s element is less than \[param right\]''s, \[code\]false\[/code\] if this element is greater. Otherwise, continues to the next pair.
If all searched elements are equal, returns \[code\]true\[/code\] if this array''s size is less than \[param right\]''s, otherwise returns \[code\]false\[/code\]. *)
    val (<) : 
    (Array.t structure ptr -> Array.t structure ptr -> Bool.t structure ptr)

    (** Compares the elements of both arrays in order, starting from index \[code\]0\[/code\] and ending on the last index in common between both arrays. For each pair of elements, returns \[code\]true\[/code\] if this array''s element is less than \[param right\]''s, \[code\]false\[/code\] if this element is greater. Otherwise, continues to the next pair.
If all searched elements are equal, returns \[code\]true\[/code\] if this array''s size is less or equal to \[param right\]''s, otherwise returns \[code\]false\[/code\]. *)
    val (<=) : 
    (Array.t structure ptr -> Array.t structure ptr -> Bool.t structure ptr)

    (** Compares the elements of both arrays in order, starting from index \[code\]0\[/code\] and ending on the last index in common between both arrays. For each pair of elements, returns \[code\]true\[/code\] if this array''s element is greater than \[param right\]''s, \[code\]false\[/code\] if this element is less. Otherwise, continues to the next pair.
If all searched elements are equal, returns \[code\]true\[/code\] if this array''s size is greater than \[param right\]''s, otherwise returns \[code\]false\[/code\]. *)
    val (>) : 
    (Array.t structure ptr -> Array.t structure ptr -> Bool.t structure ptr)

    (** Compares the elements of both arrays in order, starting from index \[code\]0\[/code\] and ending on the last index in common between both arrays. For each pair of elements, returns \[code\]true\[/code\] if this array''s element is greater than \[param right\]''s, \[code\]false\[/code\] if this element is less. Otherwise, continues to the next pair.
If all searched elements are equal, returns \[code\]true\[/code\] if this array''s size is greater or equal to \[param right\]''s, otherwise returns \[code\]false\[/code\]. *)
    val (>=) : 
    (Array.t structure ptr -> Array.t structure ptr -> Bool.t structure ptr)

    (** Appends the \[param right\] array to the left operand, creating a new \[Array\]. This is also known as an array concatenation.
\[codeblocks\]
\[gdscript\]
var array1 = \[""One"", 2\]
var array2 = \[3, ""Four""\]
print(array1 + array2) # Prints \[""One"", 2, 3, ""Four""\]
\[/gdscript\]
\[csharp\]
// Note that concatenation is not possible with C#''s native Array type.
Godot.Collections.Array array1 = \[""One"", 2\];
Godot.Collections.Array array2 = \[3, ""Four""\];
GD.Print(array1 + array2); // Prints \[""One"", 2, 3, ""Four""\]
\[/csharp\]
\[/codeblocks\]
\[b\]Note:\[/b\] For existing arrays, \[method append_array\] is much more efficient than concatenation and assignment with the \[code\]+=\[/code\] operator. *)
    val (+) : 
    (Array.t structure ptr -> Array.t structure ptr -> Array.t structure ptr)


    val mem_Array : 
    (Array.t structure ptr -> Array.t structure ptr -> Bool.t structure ptr)
    end

  module type PACKEDBYTEARRAY = sig
    type t


    include Api_types.API_TYPE with type t := t



    (** Returns the byte at the given \[param index\] in the array. This is the same as using the \[code\]\[\]\[/code\] operator (\[code\]array\[index\]\[/code\]). *)
    val get : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.PackedByteArray.t structure ptr -> BuiltinClass0.Int.t structure ptr)

    (** Changes the byte at the given index. *)
    val set : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.Int.t structure ptr -> BuiltinClass0.PackedByteArray.t structure ptr -> unit)

    (** Returns the number of elements in the array. *)
    val size : 
    (BuiltinClass0.PackedByteArray.t structure ptr -> BuiltinClass0.Int.t structure ptr)

    (** Returns \[code\]true\[/code\] if the array is empty. *)
    val is_empty : 
    (BuiltinClass0.PackedByteArray.t structure ptr -> BuiltinClass0.Bool.t structure ptr)

    (** Appends an element at the end of the array. *)
    val push_back : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.PackedByteArray.t structure ptr -> BuiltinClass0.Bool.t structure ptr)

    (** Appends an element at the end of the array (alias of \[method push_back\]). *)
    val append : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.PackedByteArray.t structure ptr -> BuiltinClass0.Bool.t structure ptr)

    (** Appends a \[PackedByteArray\] at the end of this array. *)
    val append_array : 
    (BuiltinClass0.PackedByteArray.t structure ptr -> BuiltinClass0.PackedByteArray.t structure ptr -> unit)

    (** Removes an element from the array by index. *)
    val remove_at : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.PackedByteArray.t structure ptr -> unit)

    (** Inserts a new element at a given position in the array. The position must be valid, or at the end of the array (\[code\]idx == size()\[/code\]). *)
    val insert : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.Int.t structure ptr -> BuiltinClass0.PackedByteArray.t structure ptr -> BuiltinClass0.Int.t structure ptr)

    (** Assigns the given value to all elements in the array. This can typically be used together with \[method resize\] to create an array with a given size and initialized elements. *)
    val fill : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.PackedByteArray.t structure ptr -> unit)

    (** Sets the size of the array. If the array is grown, reserves elements at the end of the array. If the array is shrunk, truncates the array to the new size. Calling \[method resize\] once and assigning the new values is faster than adding new elements one by one. *)
    val resize : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.PackedByteArray.t structure ptr -> BuiltinClass0.Int.t structure ptr)

    (** Clears the array. This is equivalent to using \[method resize\] with a size of \[code\]0\[/code\]. *)
    val clear : 
    (BuiltinClass0.PackedByteArray.t structure ptr -> unit)

    (** Returns \[code\]true\[/code\] if the array contains \[param value\]. *)
    val has : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.PackedByteArray.t structure ptr -> BuiltinClass0.Bool.t structure ptr)

    (** Reverses the order of the elements in the array. *)
    val reverse : 
    (BuiltinClass0.PackedByteArray.t structure ptr -> unit)

    (** Returns the slice of the \[PackedByteArray\], from \[param begin\] (inclusive) to \[param end\] (exclusive), as a new \[PackedByteArray\].
The absolute value of \[param begin\] and \[param end\] will be clamped to the array size, so the default value for \[param end\] makes it slice to the size of the array by default (i.e. \[code\]arr.slice(1)\[/code\] is a shorthand for \[code\]arr.slice(1, arr.size())\[/code\]).
If either \[param begin\] or \[param end\] are negative, they will be relative to the end of the array (i.e. \[code\]arr.slice(0, -2)\[/code\] is a shorthand for \[code\]arr.slice(0, arr.size() - 2)\[/code\]). *)
    val slice : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.Int.t structure ptr -> BuiltinClass0.PackedByteArray.t structure ptr -> BuiltinClass0.PackedByteArray.t structure ptr)

    (** Sorts the elements of the array in ascending order. *)
    val sort : 
    (BuiltinClass0.PackedByteArray.t structure ptr -> unit)

    (** Finds the index of an existing value (or the insertion index that maintains sorting order, if the value is not yet present in the array) using binary search. Optionally, a \[param before\] specifier can be passed. If \[code\]false\[/code\], the returned index comes after all existing entries of the value in the array.
\[b\]Note:\[/b\] Calling \[method bsearch\] on an unsorted array results in unexpected behavior. *)
    val bsearch : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.Bool.t structure ptr -> BuiltinClass0.PackedByteArray.t structure ptr -> BuiltinClass0.Int.t structure ptr)

    (** Creates a copy of the array, and returns it. *)
    val duplicate : 
    (BuiltinClass0.PackedByteArray.t structure ptr -> BuiltinClass0.PackedByteArray.t structure ptr)

    (** Searches the array for a value and returns its index or \[code\]-1\[/code\] if not found. Optionally, the initial search index can be passed. *)
    val find : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.Int.t structure ptr -> BuiltinClass0.PackedByteArray.t structure ptr -> BuiltinClass0.Int.t structure ptr)

    (** Searches the array in reverse order. Optionally, a start search index can be passed. If negative, the start index is considered relative to the end of the array. *)
    val rfind : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.Int.t structure ptr -> BuiltinClass0.PackedByteArray.t structure ptr -> BuiltinClass0.Int.t structure ptr)

    (** Returns the number of times an element is in the array. *)
    val count : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.PackedByteArray.t structure ptr -> BuiltinClass0.Int.t structure ptr)

    (** Converts ASCII/Latin-1 encoded array to \[String\]. Fast alternative to \[method get_string_from_utf8\] if the content is ASCII/Latin-1 only. Unlike the UTF-8 function this function maps every byte to a character in the array. Multibyte sequences will not be interpreted correctly. For parsing user input always use \[method get_string_from_utf8\]. This is the inverse of \[method String.to_ascii_buffer\]. *)
    val get_string_from_ascii : 
    (BuiltinClass0.PackedByteArray.t structure ptr -> BuiltinClass0.String.t structure ptr)

    (** Converts UTF-8 encoded array to \[String\]. Slower than \[method get_string_from_ascii\] but supports UTF-8 encoded data. Use this function if you are unsure about the source of the data. For user input this function should always be preferred. Returns empty string if source array is not valid UTF-8 string. This is the inverse of \[method String.to_utf8_buffer\]. *)
    val get_string_from_utf8 : 
    (BuiltinClass0.PackedByteArray.t structure ptr -> BuiltinClass0.String.t structure ptr)

    (** Converts UTF-16 encoded array to \[String\]. If the BOM is missing, system endianness is assumed. Returns empty string if source array is not valid UTF-16 string. This is the inverse of \[method String.to_utf16_buffer\]. *)
    val get_string_from_utf16 : 
    (BuiltinClass0.PackedByteArray.t structure ptr -> BuiltinClass0.String.t structure ptr)

    (** Converts UTF-32 encoded array to \[String\]. System endianness is assumed. Returns empty string if source array is not valid UTF-32 string. This is the inverse of \[method String.to_utf32_buffer\]. *)
    val get_string_from_utf32 : 
    (BuiltinClass0.PackedByteArray.t structure ptr -> BuiltinClass0.String.t structure ptr)

    (** Converts wide character (\[code\]wchar_t\[/code\], UTF-16 on Windows, UTF-32 on other platforms) encoded array to \[String\]. Returns empty string if source array is not valid wide string. This is the inverse of \[method String.to_wchar_buffer\]. *)
    val get_string_from_wchar : 
    (BuiltinClass0.PackedByteArray.t structure ptr -> BuiltinClass0.String.t structure ptr)

    (** Returns a hexadecimal representation of this array as a \[String\].
\[codeblocks\]
\[gdscript\]
var array = PackedByteArray(\[11, 46, 255\])
print(array.hex_encode()) # Prints ""0b2eff""
\[/gdscript\]
\[csharp\]
byte\[\] array = \[11, 46, 255\];
GD.Print(array.HexEncode()); // Prints ""0b2eff""
\[/csharp\]
\[/codeblocks\] *)
    val hex_encode : 
    (BuiltinClass0.PackedByteArray.t structure ptr -> BuiltinClass0.String.t structure ptr)

    (** Returns a new \[PackedByteArray\] with the data compressed. Set the compression mode using one of \[enum FileAccess.CompressionMode\]''s constants. *)
    val compress : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.PackedByteArray.t structure ptr -> BuiltinClass0.PackedByteArray.t structure ptr)

    (** Returns a new \[PackedByteArray\] with the data decompressed. Set \[param buffer_size\] to the size of the uncompressed data. Set the compression mode using one of \[enum FileAccess.CompressionMode\]''s constants.
\[b\]Note:\[/b\] Decompression is not guaranteed to work with data not compressed by Godot, for example if data compressed with the deflate compression mode lacks a checksum or header. *)
    val decompress : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.Int.t structure ptr -> BuiltinClass0.PackedByteArray.t structure ptr -> BuiltinClass0.PackedByteArray.t structure ptr)

    (** Returns a new \[PackedByteArray\] with the data decompressed. Set the compression mode using one of \[enum FileAccess.CompressionMode\]''s constants. \[b\]This method only accepts brotli, gzip, and deflate compression modes.\[/b\]
This method is potentially slower than \[method decompress\], as it may have to re-allocate its output buffer multiple times while decompressing, whereas \[method decompress\] knows it''s output buffer size from the beginning.
GZIP has a maximal compression ratio of 1032:1, meaning it''s very possible for a small compressed payload to decompress to a potentially very large output. To guard against this, you may provide a maximum size this function is allowed to allocate in bytes via \[param max_output_size\]. Passing -1 will allow for unbounded output. If any positive value is passed, and the decompression exceeds that amount in bytes, then an error will be returned.
\[b\]Note:\[/b\] Decompression is not guaranteed to work with data not compressed by Godot, for example if data compressed with the deflate compression mode lacks a checksum or header. *)
    val decompress_dynamic : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.Int.t structure ptr -> BuiltinClass0.PackedByteArray.t structure ptr -> BuiltinClass0.PackedByteArray.t structure ptr)

    (** Decodes a 8-bit unsigned integer number from the bytes starting at \[param byte_offset\]. Fails if the byte count is insufficient. Returns \[code\]0\[/code\] if a valid number can''t be decoded. *)
    val decode_u8 : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.PackedByteArray.t structure ptr -> BuiltinClass0.Int.t structure ptr)

    (** Decodes a 8-bit signed integer number from the bytes starting at \[param byte_offset\]. Fails if the byte count is insufficient. Returns \[code\]0\[/code\] if a valid number can''t be decoded. *)
    val decode_s8 : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.PackedByteArray.t structure ptr -> BuiltinClass0.Int.t structure ptr)

    (** Decodes a 16-bit unsigned integer number from the bytes starting at \[param byte_offset\]. Fails if the byte count is insufficient. Returns \[code\]0\[/code\] if a valid number can''t be decoded. *)
    val decode_u16 : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.PackedByteArray.t structure ptr -> BuiltinClass0.Int.t structure ptr)

    (** Decodes a 16-bit signed integer number from the bytes starting at \[param byte_offset\]. Fails if the byte count is insufficient. Returns \[code\]0\[/code\] if a valid number can''t be decoded. *)
    val decode_s16 : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.PackedByteArray.t structure ptr -> BuiltinClass0.Int.t structure ptr)

    (** Decodes a 32-bit unsigned integer number from the bytes starting at \[param byte_offset\]. Fails if the byte count is insufficient. Returns \[code\]0\[/code\] if a valid number can''t be decoded. *)
    val decode_u32 : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.PackedByteArray.t structure ptr -> BuiltinClass0.Int.t structure ptr)

    (** Decodes a 32-bit signed integer number from the bytes starting at \[param byte_offset\]. Fails if the byte count is insufficient. Returns \[code\]0\[/code\] if a valid number can''t be decoded. *)
    val decode_s32 : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.PackedByteArray.t structure ptr -> BuiltinClass0.Int.t structure ptr)

    (** Decodes a 64-bit unsigned integer number from the bytes starting at \[param byte_offset\]. Fails if the byte count is insufficient. Returns \[code\]0\[/code\] if a valid number can''t be decoded. *)
    val decode_u64 : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.PackedByteArray.t structure ptr -> BuiltinClass0.Int.t structure ptr)

    (** Decodes a 64-bit signed integer number from the bytes starting at \[param byte_offset\]. Fails if the byte count is insufficient. Returns \[code\]0\[/code\] if a valid number can''t be decoded. *)
    val decode_s64 : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.PackedByteArray.t structure ptr -> BuiltinClass0.Int.t structure ptr)

    (** Decodes a 16-bit floating-point number from the bytes starting at \[param byte_offset\]. Fails if the byte count is insufficient. Returns \[code\]0.0\[/code\] if a valid number can''t be decoded. *)
    val decode_half : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.PackedByteArray.t structure ptr -> BuiltinClass0.Float.t structure ptr)

    (** Decodes a 32-bit floating-point number from the bytes starting at \[param byte_offset\]. Fails if the byte count is insufficient. Returns \[code\]0.0\[/code\] if a valid number can''t be decoded. *)
    val decode_float : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.PackedByteArray.t structure ptr -> BuiltinClass0.Float.t structure ptr)

    (** Decodes a 64-bit floating-point number from the bytes starting at \[param byte_offset\]. Fails if the byte count is insufficient. Returns \[code\]0.0\[/code\] if a valid number can''t be decoded. *)
    val decode_double : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.PackedByteArray.t structure ptr -> BuiltinClass0.Float.t structure ptr)

    (** Returns \[code\]true\[/code\] if a valid \[Variant\] value can be decoded at the \[param byte_offset\]. Returns \[code\]false\[/code\] otherwise or when the value is \[Object\]-derived and \[param allow_objects\] is \[code\]false\[/code\]. *)
    val has_encoded_var : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.Bool.t structure ptr -> BuiltinClass0.PackedByteArray.t structure ptr -> BuiltinClass0.Bool.t structure ptr)

    (** Decodes a \[Variant\] from the bytes starting at \[param byte_offset\]. Returns \[code\]null\[/code\] if a valid variant can''t be decoded or the value is \[Object\]-derived and \[param allow_objects\] is \[code\]false\[/code\]. *)
    val decode_var : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.Bool.t structure ptr -> BuiltinClass0.PackedByteArray.t structure ptr -> BuiltinClass0.Variant.t structure ptr)

    (** Decodes a size of a \[Variant\] from the bytes starting at \[param byte_offset\]. Requires at least 4 bytes of data starting at the offset, otherwise fails. *)
    val decode_var_size : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.Bool.t structure ptr -> BuiltinClass0.PackedByteArray.t structure ptr -> BuiltinClass0.Int.t structure ptr)

    (** Returns a copy of the data converted to a \[PackedInt32Array\], where each block of 4 bytes has been converted to a signed 32-bit integer (C++ \[code\]int32_t\[/code\]).
The size of the input array must be a multiple of 4 (size of 32-bit integer). The size of the new array will be \[code\]byte_array.size() / 4\[/code\].
If the original data can''t be converted to signed 32-bit integers, the resulting data is undefined. *)
    val to_int32_array : 
    (BuiltinClass0.PackedByteArray.t structure ptr -> BuiltinClass0.PackedInt32Array.t structure ptr)

    (** Returns a copy of the data converted to a \[PackedInt64Array\], where each block of 8 bytes has been converted to a signed 64-bit integer (C++ \[code\]int64_t\[/code\], Godot \[int\]).
The size of the input array must be a multiple of 8 (size of 64-bit integer). The size of the new array will be \[code\]byte_array.size() / 8\[/code\].
If the original data can''t be converted to signed 64-bit integers, the resulting data is undefined. *)
    val to_int64_array : 
    (BuiltinClass0.PackedByteArray.t structure ptr -> BuiltinClass0.PackedInt64Array.t structure ptr)

    (** Returns a copy of the data converted to a \[PackedFloat32Array\], where each block of 4 bytes has been converted to a 32-bit float (C++ \[code skip-lint\]float\[/code\]).
The size of the input array must be a multiple of 4 (size of 32-bit float). The size of the new array will be \[code\]byte_array.size() / 4\[/code\].
If the original data can''t be converted to 32-bit floats, the resulting data is undefined. *)
    val to_float32_array : 
    (BuiltinClass0.PackedByteArray.t structure ptr -> BuiltinClass0.PackedFloat32Array.t structure ptr)

    (** Returns a copy of the data converted to a \[PackedFloat64Array\], where each block of 8 bytes has been converted to a 64-bit float (C++ \[code\]double\[/code\], Godot \[float\]).
The size of the input array must be a multiple of 8 (size of 64-bit double). The size of the new array will be \[code\]byte_array.size() / 8\[/code\].
If the original data can''t be converted to 64-bit floats, the resulting data is undefined. *)
    val to_float64_array : 
    (BuiltinClass0.PackedByteArray.t structure ptr -> BuiltinClass0.PackedFloat64Array.t structure ptr)

    (** Encodes a 8-bit unsigned integer number (byte) at the index of \[param byte_offset\] bytes. The array must have at least 1 byte of space, starting at the offset. *)
    val encode_u8 : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.Int.t structure ptr -> BuiltinClass0.PackedByteArray.t structure ptr -> unit)

    (** Encodes a 8-bit signed integer number (signed byte) at the index of \[param byte_offset\] bytes. The array must have at least 1 byte of space, starting at the offset. *)
    val encode_s8 : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.Int.t structure ptr -> BuiltinClass0.PackedByteArray.t structure ptr -> unit)

    (** Encodes a 16-bit unsigned integer number as bytes at the index of \[param byte_offset\] bytes. The array must have at least 2 bytes of space, starting at the offset. *)
    val encode_u16 : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.Int.t structure ptr -> BuiltinClass0.PackedByteArray.t structure ptr -> unit)

    (** Encodes a 16-bit signed integer number as bytes at the index of \[param byte_offset\] bytes. The array must have at least 2 bytes of space, starting at the offset. *)
    val encode_s16 : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.Int.t structure ptr -> BuiltinClass0.PackedByteArray.t structure ptr -> unit)

    (** Encodes a 32-bit unsigned integer number as bytes at the index of \[param byte_offset\] bytes. The array must have at least 4 bytes of space, starting at the offset. *)
    val encode_u32 : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.Int.t structure ptr -> BuiltinClass0.PackedByteArray.t structure ptr -> unit)

    (** Encodes a 32-bit signed integer number as bytes at the index of \[param byte_offset\] bytes. The array must have at least 4 bytes of space, starting at the offset. *)
    val encode_s32 : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.Int.t structure ptr -> BuiltinClass0.PackedByteArray.t structure ptr -> unit)

    (** Encodes a 64-bit unsigned integer number as bytes at the index of \[param byte_offset\] bytes. The array must have at least 8 bytes of space, starting at the offset. *)
    val encode_u64 : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.Int.t structure ptr -> BuiltinClass0.PackedByteArray.t structure ptr -> unit)

    (** Encodes a 64-bit signed integer number as bytes at the index of \[param byte_offset\] bytes. The array must have at least 8 bytes of space, starting at the offset. *)
    val encode_s64 : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.Int.t structure ptr -> BuiltinClass0.PackedByteArray.t structure ptr -> unit)

    (** Encodes a 16-bit floating-point number as bytes at the index of \[param byte_offset\] bytes. The array must have at least 2 bytes of space, starting at the offset. *)
    val encode_half : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.Float.t structure ptr -> BuiltinClass0.PackedByteArray.t structure ptr -> unit)

    (** Encodes a 32-bit floating-point number as bytes at the index of \[param byte_offset\] bytes. The array must have at least 4 bytes of space, starting at the offset. *)
    val encode_float : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.Float.t structure ptr -> BuiltinClass0.PackedByteArray.t structure ptr -> unit)

    (** Encodes a 64-bit floating-point number as bytes at the index of \[param byte_offset\] bytes. The array must have at least 8 bytes of allocated space, starting at the offset. *)
    val encode_double : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.Float.t structure ptr -> BuiltinClass0.PackedByteArray.t structure ptr -> unit)

    (** Encodes a \[Variant\] at the index of \[param byte_offset\] bytes. A sufficient space must be allocated, depending on the encoded variant''s size. If \[param allow_objects\] is \[code\]false\[/code\], \[Object\]-derived values are not permitted and will instead be serialized as ID-only. *)
    val encode_var : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.Variant.t structure ptr -> BuiltinClass0.Bool.t structure ptr -> BuiltinClass0.PackedByteArray.t structure ptr -> BuiltinClass0.Int.t structure ptr)






    val not : 
    (PackedByteArray.t structure ptr -> PackedByteArray.t structure ptr -> Bool.t structure ptr)


    val mem_Dictionary : 
    (PackedByteArray.t structure ptr -> Dictionary.t structure ptr -> Bool.t structure ptr)


    val mem_Array : 
    (PackedByteArray.t structure ptr -> Array.t structure ptr -> Bool.t structure ptr)

    (** Returns \[code\]true\[/code\] if contents of both arrays are the same, i.e. they have all equal bytes at the corresponding indices. *)
    val (=) : 
    (PackedByteArray.t structure ptr -> PackedByteArray.t structure ptr -> Bool.t structure ptr)

    (** Returns \[code\]true\[/code\] if contents of the arrays differ. *)
    val (<>) : 
    (PackedByteArray.t structure ptr -> PackedByteArray.t structure ptr -> Bool.t structure ptr)

    (** Returns a new \[PackedByteArray\] with contents of \[param right\] added at the end of this array. For better performance, consider using \[method append_array\] instead. *)
    val (+) : 
    (PackedByteArray.t structure ptr -> PackedByteArray.t structure ptr -> PackedByteArray.t structure ptr)
    end

  module type PACKEDINT32ARRAY = sig
    type t


    include Api_types.API_TYPE with type t := t



    (** Returns the 32-bit integer at the given \[param index\] in the array. This is the same as using the \[code\]\[\]\[/code\] operator (\[code\]array\[index\]\[/code\]). *)
    val get : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.PackedInt32Array.t structure ptr -> BuiltinClass0.Int.t structure ptr)

    (** Changes the integer at the given index. *)
    val set : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.Int.t structure ptr -> BuiltinClass0.PackedInt32Array.t structure ptr -> unit)

    (** Returns the number of elements in the array. *)
    val size : 
    (BuiltinClass0.PackedInt32Array.t structure ptr -> BuiltinClass0.Int.t structure ptr)

    (** Returns \[code\]true\[/code\] if the array is empty. *)
    val is_empty : 
    (BuiltinClass0.PackedInt32Array.t structure ptr -> BuiltinClass0.Bool.t structure ptr)

    (** Appends a value to the array. *)
    val push_back : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.PackedInt32Array.t structure ptr -> BuiltinClass0.Bool.t structure ptr)

    (** Appends an element at the end of the array (alias of \[method push_back\]). *)
    val append : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.PackedInt32Array.t structure ptr -> BuiltinClass0.Bool.t structure ptr)

    (** Appends a \[PackedInt32Array\] at the end of this array. *)
    val append_array : 
    (BuiltinClass0.PackedInt32Array.t structure ptr -> BuiltinClass0.PackedInt32Array.t structure ptr -> unit)

    (** Removes an element from the array by index. *)
    val remove_at : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.PackedInt32Array.t structure ptr -> unit)

    (** Inserts a new integer at a given position in the array. The position must be valid, or at the end of the array (\[code\]idx == size()\[/code\]). *)
    val insert : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.Int.t structure ptr -> BuiltinClass0.PackedInt32Array.t structure ptr -> BuiltinClass0.Int.t structure ptr)

    (** Assigns the given value to all elements in the array. This can typically be used together with \[method resize\] to create an array with a given size and initialized elements. *)
    val fill : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.PackedInt32Array.t structure ptr -> unit)

    (** Sets the size of the array. If the array is grown, reserves elements at the end of the array. If the array is shrunk, truncates the array to the new size. Calling \[method resize\] once and assigning the new values is faster than adding new elements one by one. *)
    val resize : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.PackedInt32Array.t structure ptr -> BuiltinClass0.Int.t structure ptr)

    (** Clears the array. This is equivalent to using \[method resize\] with a size of \[code\]0\[/code\]. *)
    val clear : 
    (BuiltinClass0.PackedInt32Array.t structure ptr -> unit)

    (** Returns \[code\]true\[/code\] if the array contains \[param value\]. *)
    val has : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.PackedInt32Array.t structure ptr -> BuiltinClass0.Bool.t structure ptr)

    (** Reverses the order of the elements in the array. *)
    val reverse : 
    (BuiltinClass0.PackedInt32Array.t structure ptr -> unit)

    (** Returns the slice of the \[PackedInt32Array\], from \[param begin\] (inclusive) to \[param end\] (exclusive), as a new \[PackedInt32Array\].
The absolute value of \[param begin\] and \[param end\] will be clamped to the array size, so the default value for \[param end\] makes it slice to the size of the array by default (i.e. \[code\]arr.slice(1)\[/code\] is a shorthand for \[code\]arr.slice(1, arr.size())\[/code\]).
If either \[param begin\] or \[param end\] are negative, they will be relative to the end of the array (i.e. \[code\]arr.slice(0, -2)\[/code\] is a shorthand for \[code\]arr.slice(0, arr.size() - 2)\[/code\]). *)
    val slice : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.Int.t structure ptr -> BuiltinClass0.PackedInt32Array.t structure ptr -> BuiltinClass0.PackedInt32Array.t structure ptr)

    (** Returns a copy of the data converted to a \[PackedByteArray\], where each element has been encoded as 4 bytes.
The size of the new array will be \[code\]int32_array.size()  *  4\[/code\]. *)
    val to_byte_array : 
    (BuiltinClass0.PackedInt32Array.t structure ptr -> BuiltinClass0.PackedByteArray.t structure ptr)

    (** Sorts the elements of the array in ascending order. *)
    val sort : 
    (BuiltinClass0.PackedInt32Array.t structure ptr -> unit)

    (** Finds the index of an existing value (or the insertion index that maintains sorting order, if the value is not yet present in the array) using binary search. Optionally, a \[param before\] specifier can be passed. If \[code\]false\[/code\], the returned index comes after all existing entries of the value in the array.
\[b\]Note:\[/b\] Calling \[method bsearch\] on an unsorted array results in unexpected behavior. *)
    val bsearch : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.Bool.t structure ptr -> BuiltinClass0.PackedInt32Array.t structure ptr -> BuiltinClass0.Int.t structure ptr)

    (** Creates a copy of the array, and returns it. *)
    val duplicate : 
    (BuiltinClass0.PackedInt32Array.t structure ptr -> BuiltinClass0.PackedInt32Array.t structure ptr)

    (** Searches the array for a value and returns its index or \[code\]-1\[/code\] if not found. Optionally, the initial search index can be passed. *)
    val find : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.Int.t structure ptr -> BuiltinClass0.PackedInt32Array.t structure ptr -> BuiltinClass0.Int.t structure ptr)

    (** Searches the array in reverse order. Optionally, a start search index can be passed. If negative, the start index is considered relative to the end of the array. *)
    val rfind : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.Int.t structure ptr -> BuiltinClass0.PackedInt32Array.t structure ptr -> BuiltinClass0.Int.t structure ptr)

    (** Returns the number of times an element is in the array. *)
    val count : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.PackedInt32Array.t structure ptr -> BuiltinClass0.Int.t structure ptr)






    val not : 
    (PackedInt32Array.t structure ptr -> PackedInt32Array.t structure ptr -> Bool.t structure ptr)


    val mem_Dictionary : 
    (PackedInt32Array.t structure ptr -> Dictionary.t structure ptr -> Bool.t structure ptr)


    val mem_Array : 
    (PackedInt32Array.t structure ptr -> Array.t structure ptr -> Bool.t structure ptr)

    (** Returns \[code\]true\[/code\] if contents of both arrays are the same, i.e. they have all equal ints at the corresponding indices. *)
    val (=) : 
    (PackedInt32Array.t structure ptr -> PackedInt32Array.t structure ptr -> Bool.t structure ptr)

    (** Returns \[code\]true\[/code\] if contents of the arrays differ. *)
    val (<>) : 
    (PackedInt32Array.t structure ptr -> PackedInt32Array.t structure ptr -> Bool.t structure ptr)

    (** Returns a new \[PackedInt32Array\] with contents of \[param right\] added at the end of this array. For better performance, consider using \[method append_array\] instead. *)
    val (+) : 
    (PackedInt32Array.t structure ptr -> PackedInt32Array.t structure ptr -> PackedInt32Array.t structure ptr)
    end

  module type PACKEDINT64ARRAY = sig
    type t


    include Api_types.API_TYPE with type t := t



    (** Returns the 64-bit integer at the given \[param index\] in the array. This is the same as using the \[code\]\[\]\[/code\] operator (\[code\]array\[index\]\[/code\]). *)
    val get : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.PackedInt64Array.t structure ptr -> BuiltinClass0.Int.t structure ptr)

    (** Changes the integer at the given index. *)
    val set : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.Int.t structure ptr -> BuiltinClass0.PackedInt64Array.t structure ptr -> unit)

    (** Returns the number of elements in the array. *)
    val size : 
    (BuiltinClass0.PackedInt64Array.t structure ptr -> BuiltinClass0.Int.t structure ptr)

    (** Returns \[code\]true\[/code\] if the array is empty. *)
    val is_empty : 
    (BuiltinClass0.PackedInt64Array.t structure ptr -> BuiltinClass0.Bool.t structure ptr)

    (** Appends a value to the array. *)
    val push_back : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.PackedInt64Array.t structure ptr -> BuiltinClass0.Bool.t structure ptr)

    (** Appends an element at the end of the array (alias of \[method push_back\]). *)
    val append : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.PackedInt64Array.t structure ptr -> BuiltinClass0.Bool.t structure ptr)

    (** Appends a \[PackedInt64Array\] at the end of this array. *)
    val append_array : 
    (BuiltinClass0.PackedInt64Array.t structure ptr -> BuiltinClass0.PackedInt64Array.t structure ptr -> unit)

    (** Removes an element from the array by index. *)
    val remove_at : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.PackedInt64Array.t structure ptr -> unit)

    (** Inserts a new integer at a given position in the array. The position must be valid, or at the end of the array (\[code\]idx == size()\[/code\]). *)
    val insert : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.Int.t structure ptr -> BuiltinClass0.PackedInt64Array.t structure ptr -> BuiltinClass0.Int.t structure ptr)

    (** Assigns the given value to all elements in the array. This can typically be used together with \[method resize\] to create an array with a given size and initialized elements. *)
    val fill : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.PackedInt64Array.t structure ptr -> unit)

    (** Sets the size of the array. If the array is grown, reserves elements at the end of the array. If the array is shrunk, truncates the array to the new size. Calling \[method resize\] once and assigning the new values is faster than adding new elements one by one. *)
    val resize : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.PackedInt64Array.t structure ptr -> BuiltinClass0.Int.t structure ptr)

    (** Clears the array. This is equivalent to using \[method resize\] with a size of \[code\]0\[/code\]. *)
    val clear : 
    (BuiltinClass0.PackedInt64Array.t structure ptr -> unit)

    (** Returns \[code\]true\[/code\] if the array contains \[param value\]. *)
    val has : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.PackedInt64Array.t structure ptr -> BuiltinClass0.Bool.t structure ptr)

    (** Reverses the order of the elements in the array. *)
    val reverse : 
    (BuiltinClass0.PackedInt64Array.t structure ptr -> unit)

    (** Returns the slice of the \[PackedInt64Array\], from \[param begin\] (inclusive) to \[param end\] (exclusive), as a new \[PackedInt64Array\].
The absolute value of \[param begin\] and \[param end\] will be clamped to the array size, so the default value for \[param end\] makes it slice to the size of the array by default (i.e. \[code\]arr.slice(1)\[/code\] is a shorthand for \[code\]arr.slice(1, arr.size())\[/code\]).
If either \[param begin\] or \[param end\] are negative, they will be relative to the end of the array (i.e. \[code\]arr.slice(0, -2)\[/code\] is a shorthand for \[code\]arr.slice(0, arr.size() - 2)\[/code\]). *)
    val slice : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.Int.t structure ptr -> BuiltinClass0.PackedInt64Array.t structure ptr -> BuiltinClass0.PackedInt64Array.t structure ptr)

    (** Returns a copy of the data converted to a \[PackedByteArray\], where each element has been encoded as 8 bytes.
The size of the new array will be \[code\]int64_array.size()  *  8\[/code\]. *)
    val to_byte_array : 
    (BuiltinClass0.PackedInt64Array.t structure ptr -> BuiltinClass0.PackedByteArray.t structure ptr)

    (** Sorts the elements of the array in ascending order. *)
    val sort : 
    (BuiltinClass0.PackedInt64Array.t structure ptr -> unit)

    (** Finds the index of an existing value (or the insertion index that maintains sorting order, if the value is not yet present in the array) using binary search. Optionally, a \[param before\] specifier can be passed. If \[code\]false\[/code\], the returned index comes after all existing entries of the value in the array.
\[b\]Note:\[/b\] Calling \[method bsearch\] on an unsorted array results in unexpected behavior. *)
    val bsearch : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.Bool.t structure ptr -> BuiltinClass0.PackedInt64Array.t structure ptr -> BuiltinClass0.Int.t structure ptr)

    (** Creates a copy of the array, and returns it. *)
    val duplicate : 
    (BuiltinClass0.PackedInt64Array.t structure ptr -> BuiltinClass0.PackedInt64Array.t structure ptr)

    (** Searches the array for a value and returns its index or \[code\]-1\[/code\] if not found. Optionally, the initial search index can be passed. *)
    val find : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.Int.t structure ptr -> BuiltinClass0.PackedInt64Array.t structure ptr -> BuiltinClass0.Int.t structure ptr)

    (** Searches the array in reverse order. Optionally, a start search index can be passed. If negative, the start index is considered relative to the end of the array. *)
    val rfind : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.Int.t structure ptr -> BuiltinClass0.PackedInt64Array.t structure ptr -> BuiltinClass0.Int.t structure ptr)

    (** Returns the number of times an element is in the array. *)
    val count : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.PackedInt64Array.t structure ptr -> BuiltinClass0.Int.t structure ptr)






    val not : 
    (PackedInt64Array.t structure ptr -> PackedInt64Array.t structure ptr -> Bool.t structure ptr)


    val mem_Dictionary : 
    (PackedInt64Array.t structure ptr -> Dictionary.t structure ptr -> Bool.t structure ptr)


    val mem_Array : 
    (PackedInt64Array.t structure ptr -> Array.t structure ptr -> Bool.t structure ptr)

    (** Returns \[code\]true\[/code\] if contents of both arrays are the same, i.e. they have all equal ints at the corresponding indices. *)
    val (=) : 
    (PackedInt64Array.t structure ptr -> PackedInt64Array.t structure ptr -> Bool.t structure ptr)

    (** Returns \[code\]true\[/code\] if contents of the arrays differ. *)
    val (<>) : 
    (PackedInt64Array.t structure ptr -> PackedInt64Array.t structure ptr -> Bool.t structure ptr)

    (** Returns a new \[PackedInt64Array\] with contents of \[param right\] added at the end of this array. For better performance, consider using \[method append_array\] instead. *)
    val (+) : 
    (PackedInt64Array.t structure ptr -> PackedInt64Array.t structure ptr -> PackedInt64Array.t structure ptr)
    end

  module type PACKEDFLOAT32ARRAY = sig
    type t


    include Api_types.API_TYPE with type t := t



    (** Returns the 32-bit float at the given \[param index\] in the array. This is the same as using the \[code\]\[\]\[/code\] operator (\[code\]array\[index\]\[/code\]). *)
    val get : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.PackedFloat32Array.t structure ptr -> BuiltinClass0.Float.t structure ptr)

    (** Changes the float at the given index. *)
    val set : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.Float.t structure ptr -> BuiltinClass0.PackedFloat32Array.t structure ptr -> unit)

    (** Returns the number of elements in the array. *)
    val size : 
    (BuiltinClass0.PackedFloat32Array.t structure ptr -> BuiltinClass0.Int.t structure ptr)

    (** Returns \[code\]true\[/code\] if the array is empty. *)
    val is_empty : 
    (BuiltinClass0.PackedFloat32Array.t structure ptr -> BuiltinClass0.Bool.t structure ptr)

    (** Appends an element at the end of the array. *)
    val push_back : 
    (BuiltinClass0.Float.t structure ptr -> BuiltinClass0.PackedFloat32Array.t structure ptr -> BuiltinClass0.Bool.t structure ptr)

    (** Appends an element at the end of the array (alias of \[method push_back\]). *)
    val append : 
    (BuiltinClass0.Float.t structure ptr -> BuiltinClass0.PackedFloat32Array.t structure ptr -> BuiltinClass0.Bool.t structure ptr)

    (** Appends a \[PackedFloat32Array\] at the end of this array. *)
    val append_array : 
    (BuiltinClass0.PackedFloat32Array.t structure ptr -> BuiltinClass0.PackedFloat32Array.t structure ptr -> unit)

    (** Removes an element from the array by index. *)
    val remove_at : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.PackedFloat32Array.t structure ptr -> unit)

    (** Inserts a new element at a given position in the array. The position must be valid, or at the end of the array (\[code\]idx == size()\[/code\]). *)
    val insert : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.Float.t structure ptr -> BuiltinClass0.PackedFloat32Array.t structure ptr -> BuiltinClass0.Int.t structure ptr)

    (** Assigns the given value to all elements in the array. This can typically be used together with \[method resize\] to create an array with a given size and initialized elements. *)
    val fill : 
    (BuiltinClass0.Float.t structure ptr -> BuiltinClass0.PackedFloat32Array.t structure ptr -> unit)

    (** Sets the size of the array. If the array is grown, reserves elements at the end of the array. If the array is shrunk, truncates the array to the new size. Calling \[method resize\] once and assigning the new values is faster than adding new elements one by one. *)
    val resize : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.PackedFloat32Array.t structure ptr -> BuiltinClass0.Int.t structure ptr)

    (** Clears the array. This is equivalent to using \[method resize\] with a size of \[code\]0\[/code\]. *)
    val clear : 
    (BuiltinClass0.PackedFloat32Array.t structure ptr -> unit)

    (** Returns \[code\]true\[/code\] if the array contains \[param value\].
\[b\]Note:\[/b\] \[constant \@GDScript.NAN\] doesn''t behave the same as other numbers. Therefore, the results from this method may not be accurate if NaNs are included. *)
    val has : 
    (BuiltinClass0.Float.t structure ptr -> BuiltinClass0.PackedFloat32Array.t structure ptr -> BuiltinClass0.Bool.t structure ptr)

    (** Reverses the order of the elements in the array. *)
    val reverse : 
    (BuiltinClass0.PackedFloat32Array.t structure ptr -> unit)

    (** Returns the slice of the \[PackedFloat32Array\], from \[param begin\] (inclusive) to \[param end\] (exclusive), as a new \[PackedFloat32Array\].
The absolute value of \[param begin\] and \[param end\] will be clamped to the array size, so the default value for \[param end\] makes it slice to the size of the array by default (i.e. \[code\]arr.slice(1)\[/code\] is a shorthand for \[code\]arr.slice(1, arr.size())\[/code\]).
If either \[param begin\] or \[param end\] are negative, they will be relative to the end of the array (i.e. \[code\]arr.slice(0, -2)\[/code\] is a shorthand for \[code\]arr.slice(0, arr.size() - 2)\[/code\]). *)
    val slice : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.Int.t structure ptr -> BuiltinClass0.PackedFloat32Array.t structure ptr -> BuiltinClass0.PackedFloat32Array.t structure ptr)

    (** Returns a copy of the data converted to a \[PackedByteArray\], where each element has been encoded as 4 bytes.
The size of the new array will be \[code\]float32_array.size()  *  4\[/code\]. *)
    val to_byte_array : 
    (BuiltinClass0.PackedFloat32Array.t structure ptr -> BuiltinClass0.PackedByteArray.t structure ptr)

    (** Sorts the elements of the array in ascending order.
\[b\]Note:\[/b\] \[constant \@GDScript.NAN\] doesn''t behave the same as other numbers. Therefore, the results from this method may not be accurate if NaNs are included. *)
    val sort : 
    (BuiltinClass0.PackedFloat32Array.t structure ptr -> unit)

    (** Finds the index of an existing value (or the insertion index that maintains sorting order, if the value is not yet present in the array) using binary search. Optionally, a \[param before\] specifier can be passed. If \[code\]false\[/code\], the returned index comes after all existing entries of the value in the array.
\[b\]Note:\[/b\] Calling \[method bsearch\] on an unsorted array results in unexpected behavior.
\[b\]Note:\[/b\] \[constant \@GDScript.NAN\] doesn''t behave the same as other numbers. Therefore, the results from this method may not be accurate if NaNs are included. *)
    val bsearch : 
    (BuiltinClass0.Float.t structure ptr -> BuiltinClass0.Bool.t structure ptr -> BuiltinClass0.PackedFloat32Array.t structure ptr -> BuiltinClass0.Int.t structure ptr)

    (** Creates a copy of the array, and returns it. *)
    val duplicate : 
    (BuiltinClass0.PackedFloat32Array.t structure ptr -> BuiltinClass0.PackedFloat32Array.t structure ptr)

    (** Searches the array for a value and returns its index or \[code\]-1\[/code\] if not found. Optionally, the initial search index can be passed.
\[b\]Note:\[/b\] \[constant \@GDScript.NAN\] doesn''t behave the same as other numbers. Therefore, the results from this method may not be accurate if NaNs are included. *)
    val find : 
    (BuiltinClass0.Float.t structure ptr -> BuiltinClass0.Int.t structure ptr -> BuiltinClass0.PackedFloat32Array.t structure ptr -> BuiltinClass0.Int.t structure ptr)

    (** Searches the array in reverse order. Optionally, a start search index can be passed. If negative, the start index is considered relative to the end of the array.
\[b\]Note:\[/b\] \[constant \@GDScript.NAN\] doesn''t behave the same as other numbers. Therefore, the results from this method may not be accurate if NaNs are included. *)
    val rfind : 
    (BuiltinClass0.Float.t structure ptr -> BuiltinClass0.Int.t structure ptr -> BuiltinClass0.PackedFloat32Array.t structure ptr -> BuiltinClass0.Int.t structure ptr)

    (** Returns the number of times an element is in the array.
\[b\]Note:\[/b\] \[constant \@GDScript.NAN\] doesn''t behave the same as other numbers. Therefore, the results from this method may not be accurate if NaNs are included. *)
    val count : 
    (BuiltinClass0.Float.t structure ptr -> BuiltinClass0.PackedFloat32Array.t structure ptr -> BuiltinClass0.Int.t structure ptr)






    val not : 
    (PackedFloat32Array.t structure ptr -> PackedFloat32Array.t structure ptr -> Bool.t structure ptr)


    val mem_Dictionary : 
    (PackedFloat32Array.t structure ptr -> Dictionary.t structure ptr -> Bool.t structure ptr)


    val mem_Array : 
    (PackedFloat32Array.t structure ptr -> Array.t structure ptr -> Bool.t structure ptr)

    (** Returns \[code\]true\[/code\] if contents of both arrays are the same, i.e. they have all equal floats at the corresponding indices. *)
    val (=) : 
    (PackedFloat32Array.t structure ptr -> PackedFloat32Array.t structure ptr -> Bool.t structure ptr)

    (** Returns \[code\]true\[/code\] if contents of the arrays differ. *)
    val (<>) : 
    (PackedFloat32Array.t structure ptr -> PackedFloat32Array.t structure ptr -> Bool.t structure ptr)

    (** Returns a new \[PackedFloat32Array\] with contents of \[param right\] added at the end of this array. For better performance, consider using \[method append_array\] instead. *)
    val (+) : 
    (PackedFloat32Array.t structure ptr -> PackedFloat32Array.t structure ptr -> PackedFloat32Array.t structure ptr)
    end

  module type PACKEDFLOAT64ARRAY = sig
    type t


    include Api_types.API_TYPE with type t := t



    (** Returns the 64-bit float at the given \[param index\] in the array. This is the same as using the \[code\]\[\]\[/code\] operator (\[code\]array\[index\]\[/code\]). *)
    val get : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.PackedFloat64Array.t structure ptr -> BuiltinClass0.Float.t structure ptr)

    (** Changes the float at the given index. *)
    val set : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.Float.t structure ptr -> BuiltinClass0.PackedFloat64Array.t structure ptr -> unit)

    (** Returns the number of elements in the array. *)
    val size : 
    (BuiltinClass0.PackedFloat64Array.t structure ptr -> BuiltinClass0.Int.t structure ptr)

    (** Returns \[code\]true\[/code\] if the array is empty. *)
    val is_empty : 
    (BuiltinClass0.PackedFloat64Array.t structure ptr -> BuiltinClass0.Bool.t structure ptr)

    (** Appends an element at the end of the array. *)
    val push_back : 
    (BuiltinClass0.Float.t structure ptr -> BuiltinClass0.PackedFloat64Array.t structure ptr -> BuiltinClass0.Bool.t structure ptr)

    (** Appends an element at the end of the array (alias of \[method push_back\]). *)
    val append : 
    (BuiltinClass0.Float.t structure ptr -> BuiltinClass0.PackedFloat64Array.t structure ptr -> BuiltinClass0.Bool.t structure ptr)

    (** Appends a \[PackedFloat64Array\] at the end of this array. *)
    val append_array : 
    (BuiltinClass0.PackedFloat64Array.t structure ptr -> BuiltinClass0.PackedFloat64Array.t structure ptr -> unit)

    (** Removes an element from the array by index. *)
    val remove_at : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.PackedFloat64Array.t structure ptr -> unit)

    (** Inserts a new element at a given position in the array. The position must be valid, or at the end of the array (\[code\]idx == size()\[/code\]). *)
    val insert : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.Float.t structure ptr -> BuiltinClass0.PackedFloat64Array.t structure ptr -> BuiltinClass0.Int.t structure ptr)

    (** Assigns the given value to all elements in the array. This can typically be used together with \[method resize\] to create an array with a given size and initialized elements. *)
    val fill : 
    (BuiltinClass0.Float.t structure ptr -> BuiltinClass0.PackedFloat64Array.t structure ptr -> unit)

    (** Sets the size of the array. If the array is grown, reserves elements at the end of the array. If the array is shrunk, truncates the array to the new size. Calling \[method resize\] once and assigning the new values is faster than adding new elements one by one. *)
    val resize : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.PackedFloat64Array.t structure ptr -> BuiltinClass0.Int.t structure ptr)

    (** Clears the array. This is equivalent to using \[method resize\] with a size of \[code\]0\[/code\]. *)
    val clear : 
    (BuiltinClass0.PackedFloat64Array.t structure ptr -> unit)

    (** Returns \[code\]true\[/code\] if the array contains \[param value\].
\[b\]Note:\[/b\] \[constant \@GDScript.NAN\] doesn''t behave the same as other numbers. Therefore, the results from this method may not be accurate if NaNs are included. *)
    val has : 
    (BuiltinClass0.Float.t structure ptr -> BuiltinClass0.PackedFloat64Array.t structure ptr -> BuiltinClass0.Bool.t structure ptr)

    (** Reverses the order of the elements in the array. *)
    val reverse : 
    (BuiltinClass0.PackedFloat64Array.t structure ptr -> unit)

    (** Returns the slice of the \[PackedFloat64Array\], from \[param begin\] (inclusive) to \[param end\] (exclusive), as a new \[PackedFloat64Array\].
The absolute value of \[param begin\] and \[param end\] will be clamped to the array size, so the default value for \[param end\] makes it slice to the size of the array by default (i.e. \[code\]arr.slice(1)\[/code\] is a shorthand for \[code\]arr.slice(1, arr.size())\[/code\]).
If either \[param begin\] or \[param end\] are negative, they will be relative to the end of the array (i.e. \[code\]arr.slice(0, -2)\[/code\] is a shorthand for \[code\]arr.slice(0, arr.size() - 2)\[/code\]). *)
    val slice : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.Int.t structure ptr -> BuiltinClass0.PackedFloat64Array.t structure ptr -> BuiltinClass0.PackedFloat64Array.t structure ptr)

    (** Returns a copy of the data converted to a \[PackedByteArray\], where each element has been encoded as 8 bytes.
The size of the new array will be \[code\]float64_array.size()  *  8\[/code\]. *)
    val to_byte_array : 
    (BuiltinClass0.PackedFloat64Array.t structure ptr -> BuiltinClass0.PackedByteArray.t structure ptr)

    (** Sorts the elements of the array in ascending order.
\[b\]Note:\[/b\] \[constant \@GDScript.NAN\] doesn''t behave the same as other numbers. Therefore, the results from this method may not be accurate if NaNs are included. *)
    val sort : 
    (BuiltinClass0.PackedFloat64Array.t structure ptr -> unit)

    (** Finds the index of an existing value (or the insertion index that maintains sorting order, if the value is not yet present in the array) using binary search. Optionally, a \[param before\] specifier can be passed. If \[code\]false\[/code\], the returned index comes after all existing entries of the value in the array.
\[b\]Note:\[/b\] Calling \[method bsearch\] on an unsorted array results in unexpected behavior.
\[b\]Note:\[/b\] \[constant \@GDScript.NAN\] doesn''t behave the same as other numbers. Therefore, the results from this method may not be accurate if NaNs are included. *)
    val bsearch : 
    (BuiltinClass0.Float.t structure ptr -> BuiltinClass0.Bool.t structure ptr -> BuiltinClass0.PackedFloat64Array.t structure ptr -> BuiltinClass0.Int.t structure ptr)

    (** Creates a copy of the array, and returns it. *)
    val duplicate : 
    (BuiltinClass0.PackedFloat64Array.t structure ptr -> BuiltinClass0.PackedFloat64Array.t structure ptr)

    (** Searches the array for a value and returns its index or \[code\]-1\[/code\] if not found. Optionally, the initial search index can be passed.
\[b\]Note:\[/b\] \[constant \@GDScript.NAN\] doesn''t behave the same as other numbers. Therefore, the results from this method may not be accurate if NaNs are included. *)
    val find : 
    (BuiltinClass0.Float.t structure ptr -> BuiltinClass0.Int.t structure ptr -> BuiltinClass0.PackedFloat64Array.t structure ptr -> BuiltinClass0.Int.t structure ptr)

    (** Searches the array in reverse order. Optionally, a start search index can be passed. If negative, the start index is considered relative to the end of the array.
\[b\]Note:\[/b\] \[constant \@GDScript.NAN\] doesn''t behave the same as other numbers. Therefore, the results from this method may not be accurate if NaNs are included. *)
    val rfind : 
    (BuiltinClass0.Float.t structure ptr -> BuiltinClass0.Int.t structure ptr -> BuiltinClass0.PackedFloat64Array.t structure ptr -> BuiltinClass0.Int.t structure ptr)

    (** Returns the number of times an element is in the array.
\[b\]Note:\[/b\] \[constant \@GDScript.NAN\] doesn''t behave the same as other numbers. Therefore, the results from this method may not be accurate if NaNs are included. *)
    val count : 
    (BuiltinClass0.Float.t structure ptr -> BuiltinClass0.PackedFloat64Array.t structure ptr -> BuiltinClass0.Int.t structure ptr)






    val not : 
    (PackedFloat64Array.t structure ptr -> PackedFloat64Array.t structure ptr -> Bool.t structure ptr)


    val mem_Dictionary : 
    (PackedFloat64Array.t structure ptr -> Dictionary.t structure ptr -> Bool.t structure ptr)


    val mem_Array : 
    (PackedFloat64Array.t structure ptr -> Array.t structure ptr -> Bool.t structure ptr)

    (** Returns \[code\]true\[/code\] if contents of both arrays are the same, i.e. they have all equal doubles at the corresponding indices. *)
    val (=) : 
    (PackedFloat64Array.t structure ptr -> PackedFloat64Array.t structure ptr -> Bool.t structure ptr)

    (** Returns \[code\]true\[/code\] if contents of the arrays differ. *)
    val (<>) : 
    (PackedFloat64Array.t structure ptr -> PackedFloat64Array.t structure ptr -> Bool.t structure ptr)

    (** Returns a new \[PackedFloat64Array\] with contents of \[param right\] added at the end of this array. For better performance, consider using \[method append_array\] instead. *)
    val (+) : 
    (PackedFloat64Array.t structure ptr -> PackedFloat64Array.t structure ptr -> PackedFloat64Array.t structure ptr)
    end

  module type PACKEDSTRINGARRAY = sig
    type t


    include Api_types.API_TYPE with type t := t



    (** Returns the \[String\] at the given \[param index\] in the array. This is the same as using the \[code\]\[\]\[/code\] operator (\[code\]array\[index\]\[/code\]). *)
    val get : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.PackedStringArray.t structure ptr -> BuiltinClass0.String.t structure ptr)

    (** Changes the \[String\] at the given index. *)
    val set : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.String.t structure ptr -> BuiltinClass0.PackedStringArray.t structure ptr -> unit)

    (** Returns the number of elements in the array. *)
    val size : 
    (BuiltinClass0.PackedStringArray.t structure ptr -> BuiltinClass0.Int.t structure ptr)

    (** Returns \[code\]true\[/code\] if the array is empty. *)
    val is_empty : 
    (BuiltinClass0.PackedStringArray.t structure ptr -> BuiltinClass0.Bool.t structure ptr)

    (** Appends a string element at end of the array. *)
    val push_back : 
    (BuiltinClass0.String.t structure ptr -> BuiltinClass0.PackedStringArray.t structure ptr -> BuiltinClass0.Bool.t structure ptr)

    (** Appends an element at the end of the array (alias of \[method push_back\]). *)
    val append : 
    (BuiltinClass0.String.t structure ptr -> BuiltinClass0.PackedStringArray.t structure ptr -> BuiltinClass0.Bool.t structure ptr)

    (** Appends a \[PackedStringArray\] at the end of this array. *)
    val append_array : 
    (BuiltinClass0.PackedStringArray.t structure ptr -> BuiltinClass0.PackedStringArray.t structure ptr -> unit)

    (** Removes an element from the array by index. *)
    val remove_at : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.PackedStringArray.t structure ptr -> unit)

    (** Inserts a new element at a given position in the array. The position must be valid, or at the end of the array (\[code\]idx == size()\[/code\]). *)
    val insert : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.String.t structure ptr -> BuiltinClass0.PackedStringArray.t structure ptr -> BuiltinClass0.Int.t structure ptr)

    (** Assigns the given value to all elements in the array. This can typically be used together with \[method resize\] to create an array with a given size and initialized elements. *)
    val fill : 
    (BuiltinClass0.String.t structure ptr -> BuiltinClass0.PackedStringArray.t structure ptr -> unit)

    (** Sets the size of the array. If the array is grown, reserves elements at the end of the array. If the array is shrunk, truncates the array to the new size. Calling \[method resize\] once and assigning the new values is faster than adding new elements one by one. *)
    val resize : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.PackedStringArray.t structure ptr -> BuiltinClass0.Int.t structure ptr)

    (** Clears the array. This is equivalent to using \[method resize\] with a size of \[code\]0\[/code\]. *)
    val clear : 
    (BuiltinClass0.PackedStringArray.t structure ptr -> unit)

    (** Returns \[code\]true\[/code\] if the array contains \[param value\]. *)
    val has : 
    (BuiltinClass0.String.t structure ptr -> BuiltinClass0.PackedStringArray.t structure ptr -> BuiltinClass0.Bool.t structure ptr)

    (** Reverses the order of the elements in the array. *)
    val reverse : 
    (BuiltinClass0.PackedStringArray.t structure ptr -> unit)

    (** Returns the slice of the \[PackedStringArray\], from \[param begin\] (inclusive) to \[param end\] (exclusive), as a new \[PackedStringArray\].
The absolute value of \[param begin\] and \[param end\] will be clamped to the array size, so the default value for \[param end\] makes it slice to the size of the array by default (i.e. \[code\]arr.slice(1)\[/code\] is a shorthand for \[code\]arr.slice(1, arr.size())\[/code\]).
If either \[param begin\] or \[param end\] are negative, they will be relative to the end of the array (i.e. \[code\]arr.slice(0, -2)\[/code\] is a shorthand for \[code\]arr.slice(0, arr.size() - 2)\[/code\]). *)
    val slice : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.Int.t structure ptr -> BuiltinClass0.PackedStringArray.t structure ptr -> BuiltinClass0.PackedStringArray.t structure ptr)

    (** Returns a \[PackedByteArray\] with each string encoded as UTF-8. Strings are \[code\]null\[/code\] terminated. *)
    val to_byte_array : 
    (BuiltinClass0.PackedStringArray.t structure ptr -> BuiltinClass0.PackedByteArray.t structure ptr)

    (** Sorts the elements of the array in ascending order. *)
    val sort : 
    (BuiltinClass0.PackedStringArray.t structure ptr -> unit)

    (** Finds the index of an existing value (or the insertion index that maintains sorting order, if the value is not yet present in the array) using binary search. Optionally, a \[param before\] specifier can be passed. If \[code\]false\[/code\], the returned index comes after all existing entries of the value in the array.
\[b\]Note:\[/b\] Calling \[method bsearch\] on an unsorted array results in unexpected behavior. *)
    val bsearch : 
    (BuiltinClass0.String.t structure ptr -> BuiltinClass0.Bool.t structure ptr -> BuiltinClass0.PackedStringArray.t structure ptr -> BuiltinClass0.Int.t structure ptr)

    (** Creates a copy of the array, and returns it. *)
    val duplicate : 
    (BuiltinClass0.PackedStringArray.t structure ptr -> BuiltinClass0.PackedStringArray.t structure ptr)

    (** Searches the array for a value and returns its index or \[code\]-1\[/code\] if not found. Optionally, the initial search index can be passed. *)
    val find : 
    (BuiltinClass0.String.t structure ptr -> BuiltinClass0.Int.t structure ptr -> BuiltinClass0.PackedStringArray.t structure ptr -> BuiltinClass0.Int.t structure ptr)

    (** Searches the array in reverse order. Optionally, a start search index can be passed. If negative, the start index is considered relative to the end of the array. *)
    val rfind : 
    (BuiltinClass0.String.t structure ptr -> BuiltinClass0.Int.t structure ptr -> BuiltinClass0.PackedStringArray.t structure ptr -> BuiltinClass0.Int.t structure ptr)

    (** Returns the number of times an element is in the array. *)
    val count : 
    (BuiltinClass0.String.t structure ptr -> BuiltinClass0.PackedStringArray.t structure ptr -> BuiltinClass0.Int.t structure ptr)






    val not : 
    (PackedStringArray.t structure ptr -> PackedStringArray.t structure ptr -> Bool.t structure ptr)


    val mem_Dictionary : 
    (PackedStringArray.t structure ptr -> Dictionary.t structure ptr -> Bool.t structure ptr)


    val mem_Array : 
    (PackedStringArray.t structure ptr -> Array.t structure ptr -> Bool.t structure ptr)

    (** Returns \[code\]true\[/code\] if contents of both arrays are the same, i.e. they have all equal \[String\]s at the corresponding indices. *)
    val (=) : 
    (PackedStringArray.t structure ptr -> PackedStringArray.t structure ptr -> Bool.t structure ptr)

    (** Returns \[code\]true\[/code\] if contents of the arrays differ. *)
    val (<>) : 
    (PackedStringArray.t structure ptr -> PackedStringArray.t structure ptr -> Bool.t structure ptr)

    (** Returns a new \[PackedStringArray\] with contents of \[param right\] added at the end of this array. For better performance, consider using \[method append_array\] instead. *)
    val (+) : 
    (PackedStringArray.t structure ptr -> PackedStringArray.t structure ptr -> PackedStringArray.t structure ptr)
    end

  module type PACKEDVECTOR2ARRAY = sig
    type t


    include Api_types.API_TYPE with type t := t



    (** Returns the \[Vector2\] at the given \[param index\] in the array. This is the same as using the \[code\]\[\]\[/code\] operator (\[code\]array\[index\]\[/code\]). *)
    val get : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.PackedVector2Array.t structure ptr -> BuiltinClass0.Vector2.t structure ptr)

    (** Changes the \[Vector2\] at the given index. *)
    val set : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.Vector2.t structure ptr -> BuiltinClass0.PackedVector2Array.t structure ptr -> unit)

    (** Returns the number of elements in the array. *)
    val size : 
    (BuiltinClass0.PackedVector2Array.t structure ptr -> BuiltinClass0.Int.t structure ptr)

    (** Returns \[code\]true\[/code\] if the array is empty. *)
    val is_empty : 
    (BuiltinClass0.PackedVector2Array.t structure ptr -> BuiltinClass0.Bool.t structure ptr)

    (** Inserts a \[Vector2\] at the end. *)
    val push_back : 
    (BuiltinClass0.Vector2.t structure ptr -> BuiltinClass0.PackedVector2Array.t structure ptr -> BuiltinClass0.Bool.t structure ptr)

    (** Appends an element at the end of the array (alias of \[method push_back\]). *)
    val append : 
    (BuiltinClass0.Vector2.t structure ptr -> BuiltinClass0.PackedVector2Array.t structure ptr -> BuiltinClass0.Bool.t structure ptr)

    (** Appends a \[PackedVector2Array\] at the end of this array. *)
    val append_array : 
    (BuiltinClass0.PackedVector2Array.t structure ptr -> BuiltinClass0.PackedVector2Array.t structure ptr -> unit)

    (** Removes an element from the array by index. *)
    val remove_at : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.PackedVector2Array.t structure ptr -> unit)

    (** Inserts a new element at a given position in the array. The position must be valid, or at the end of the array (\[code\]idx == size()\[/code\]). *)
    val insert : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.Vector2.t structure ptr -> BuiltinClass0.PackedVector2Array.t structure ptr -> BuiltinClass0.Int.t structure ptr)

    (** Assigns the given value to all elements in the array. This can typically be used together with \[method resize\] to create an array with a given size and initialized elements. *)
    val fill : 
    (BuiltinClass0.Vector2.t structure ptr -> BuiltinClass0.PackedVector2Array.t structure ptr -> unit)

    (** Sets the size of the array. If the array is grown, reserves elements at the end of the array. If the array is shrunk, truncates the array to the new size. Calling \[method resize\] once and assigning the new values is faster than adding new elements one by one. *)
    val resize : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.PackedVector2Array.t structure ptr -> BuiltinClass0.Int.t structure ptr)

    (** Clears the array. This is equivalent to using \[method resize\] with a size of \[code\]0\[/code\]. *)
    val clear : 
    (BuiltinClass0.PackedVector2Array.t structure ptr -> unit)

    (** Returns \[code\]true\[/code\] if the array contains \[param value\].
\[b\]Note:\[/b\] Vectors with \[constant \@GDScript.NAN\] elements don''t behave the same as other vectors. Therefore, the results from this method may not be accurate if NaNs are included. *)
    val has : 
    (BuiltinClass0.Vector2.t structure ptr -> BuiltinClass0.PackedVector2Array.t structure ptr -> BuiltinClass0.Bool.t structure ptr)

    (** Reverses the order of the elements in the array. *)
    val reverse : 
    (BuiltinClass0.PackedVector2Array.t structure ptr -> unit)

    (** Returns the slice of the \[PackedVector2Array\], from \[param begin\] (inclusive) to \[param end\] (exclusive), as a new \[PackedVector2Array\].
The absolute value of \[param begin\] and \[param end\] will be clamped to the array size, so the default value for \[param end\] makes it slice to the size of the array by default (i.e. \[code\]arr.slice(1)\[/code\] is a shorthand for \[code\]arr.slice(1, arr.size())\[/code\]).
If either \[param begin\] or \[param end\] are negative, they will be relative to the end of the array (i.e. \[code\]arr.slice(0, -2)\[/code\] is a shorthand for \[code\]arr.slice(0, arr.size() - 2)\[/code\]). *)
    val slice : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.Int.t structure ptr -> BuiltinClass0.PackedVector2Array.t structure ptr -> BuiltinClass0.PackedVector2Array.t structure ptr)

    (** Returns a \[PackedByteArray\] with each vector encoded as bytes. *)
    val to_byte_array : 
    (BuiltinClass0.PackedVector2Array.t structure ptr -> BuiltinClass0.PackedByteArray.t structure ptr)

    (** Sorts the elements of the array in ascending order.
\[b\]Note:\[/b\] Vectors with \[constant \@GDScript.NAN\] elements don''t behave the same as other vectors. Therefore, the results from this method may not be accurate if NaNs are included. *)
    val sort : 
    (BuiltinClass0.PackedVector2Array.t structure ptr -> unit)

    (** Finds the index of an existing value (or the insertion index that maintains sorting order, if the value is not yet present in the array) using binary search. Optionally, a \[param before\] specifier can be passed. If \[code\]false\[/code\], the returned index comes after all existing entries of the value in the array.
\[b\]Note:\[/b\] Calling \[method bsearch\] on an unsorted array results in unexpected behavior.
\[b\]Note:\[/b\] Vectors with \[constant \@GDScript.NAN\] elements don''t behave the same as other vectors. Therefore, the results from this method may not be accurate if NaNs are included. *)
    val bsearch : 
    (BuiltinClass0.Vector2.t structure ptr -> BuiltinClass0.Bool.t structure ptr -> BuiltinClass0.PackedVector2Array.t structure ptr -> BuiltinClass0.Int.t structure ptr)

    (** Creates a copy of the array, and returns it. *)
    val duplicate : 
    (BuiltinClass0.PackedVector2Array.t structure ptr -> BuiltinClass0.PackedVector2Array.t structure ptr)

    (** Searches the array for a value and returns its index or \[code\]-1\[/code\] if not found. Optionally, the initial search index can be passed.
\[b\]Note:\[/b\] Vectors with \[constant \@GDScript.NAN\] elements don''t behave the same as other vectors. Therefore, the results from this method may not be accurate if NaNs are included. *)
    val find : 
    (BuiltinClass0.Vector2.t structure ptr -> BuiltinClass0.Int.t structure ptr -> BuiltinClass0.PackedVector2Array.t structure ptr -> BuiltinClass0.Int.t structure ptr)

    (** Searches the array in reverse order. Optionally, a start search index can be passed. If negative, the start index is considered relative to the end of the array.
\[b\]Note:\[/b\] Vectors with \[constant \@GDScript.NAN\] elements don''t behave the same as other vectors. Therefore, the results from this method may not be accurate if NaNs are included. *)
    val rfind : 
    (BuiltinClass0.Vector2.t structure ptr -> BuiltinClass0.Int.t structure ptr -> BuiltinClass0.PackedVector2Array.t structure ptr -> BuiltinClass0.Int.t structure ptr)

    (** Returns the number of times an element is in the array.
\[b\]Note:\[/b\] Vectors with \[constant \@GDScript.NAN\] elements don''t behave the same as other vectors. Therefore, the results from this method may not be accurate if NaNs are included. *)
    val count : 
    (BuiltinClass0.Vector2.t structure ptr -> BuiltinClass0.PackedVector2Array.t structure ptr -> BuiltinClass0.Int.t structure ptr)






    val not : 
    (PackedVector2Array.t structure ptr -> PackedVector2Array.t structure ptr -> Bool.t structure ptr)




    val mem_Dictionary : 
    (PackedVector2Array.t structure ptr -> Dictionary.t structure ptr -> Bool.t structure ptr)


    val mem_Array : 
    (PackedVector2Array.t structure ptr -> Array.t structure ptr -> Bool.t structure ptr)

    (** Returns \[code\]true\[/code\] if contents of both arrays are the same, i.e. they have all equal \[Vector2\]s at the corresponding indices. *)
    val (=) : 
    (PackedVector2Array.t structure ptr -> PackedVector2Array.t structure ptr -> Bool.t structure ptr)

    (** Returns \[code\]true\[/code\] if contents of the arrays differ. *)
    val (<>) : 
    (PackedVector2Array.t structure ptr -> PackedVector2Array.t structure ptr -> Bool.t structure ptr)

    (** Returns a new \[PackedVector2Array\] with contents of \[param right\] added at the end of this array. For better performance, consider using \[method append_array\] instead. *)
    val (+) : 
    (PackedVector2Array.t structure ptr -> PackedVector2Array.t structure ptr -> PackedVector2Array.t structure ptr)
    end

  module type PACKEDVECTOR3ARRAY = sig
    type t


    include Api_types.API_TYPE with type t := t



    (** Returns the \[Vector3\] at the given \[param index\] in the array. This is the same as using the \[code\]\[\]\[/code\] operator (\[code\]array\[index\]\[/code\]). *)
    val get : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.PackedVector3Array.t structure ptr -> BuiltinClass0.Vector3.t structure ptr)

    (** Changes the \[Vector3\] at the given index. *)
    val set : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.Vector3.t structure ptr -> BuiltinClass0.PackedVector3Array.t structure ptr -> unit)

    (** Returns the number of elements in the array. *)
    val size : 
    (BuiltinClass0.PackedVector3Array.t structure ptr -> BuiltinClass0.Int.t structure ptr)

    (** Returns \[code\]true\[/code\] if the array is empty. *)
    val is_empty : 
    (BuiltinClass0.PackedVector3Array.t structure ptr -> BuiltinClass0.Bool.t structure ptr)

    (** Inserts a \[Vector3\] at the end. *)
    val push_back : 
    (BuiltinClass0.Vector3.t structure ptr -> BuiltinClass0.PackedVector3Array.t structure ptr -> BuiltinClass0.Bool.t structure ptr)

    (** Appends an element at the end of the array (alias of \[method push_back\]). *)
    val append : 
    (BuiltinClass0.Vector3.t structure ptr -> BuiltinClass0.PackedVector3Array.t structure ptr -> BuiltinClass0.Bool.t structure ptr)

    (** Appends a \[PackedVector3Array\] at the end of this array. *)
    val append_array : 
    (BuiltinClass0.PackedVector3Array.t structure ptr -> BuiltinClass0.PackedVector3Array.t structure ptr -> unit)

    (** Removes an element from the array by index. *)
    val remove_at : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.PackedVector3Array.t structure ptr -> unit)

    (** Inserts a new element at a given position in the array. The position must be valid, or at the end of the array (\[code\]idx == size()\[/code\]). *)
    val insert : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.Vector3.t structure ptr -> BuiltinClass0.PackedVector3Array.t structure ptr -> BuiltinClass0.Int.t structure ptr)

    (** Assigns the given value to all elements in the array. This can typically be used together with \[method resize\] to create an array with a given size and initialized elements. *)
    val fill : 
    (BuiltinClass0.Vector3.t structure ptr -> BuiltinClass0.PackedVector3Array.t structure ptr -> unit)

    (** Sets the size of the array. If the array is grown, reserves elements at the end of the array. If the array is shrunk, truncates the array to the new size. Calling \[method resize\] once and assigning the new values is faster than adding new elements one by one. *)
    val resize : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.PackedVector3Array.t structure ptr -> BuiltinClass0.Int.t structure ptr)

    (** Clears the array. This is equivalent to using \[method resize\] with a size of \[code\]0\[/code\]. *)
    val clear : 
    (BuiltinClass0.PackedVector3Array.t structure ptr -> unit)

    (** Returns \[code\]true\[/code\] if the array contains \[param value\].
\[b\]Note:\[/b\] Vectors with \[constant \@GDScript.NAN\] elements don''t behave the same as other vectors. Therefore, the results from this method may not be accurate if NaNs are included. *)
    val has : 
    (BuiltinClass0.Vector3.t structure ptr -> BuiltinClass0.PackedVector3Array.t structure ptr -> BuiltinClass0.Bool.t structure ptr)

    (** Reverses the order of the elements in the array. *)
    val reverse : 
    (BuiltinClass0.PackedVector3Array.t structure ptr -> unit)

    (** Returns the slice of the \[PackedVector3Array\], from \[param begin\] (inclusive) to \[param end\] (exclusive), as a new \[PackedVector3Array\].
The absolute value of \[param begin\] and \[param end\] will be clamped to the array size, so the default value for \[param end\] makes it slice to the size of the array by default (i.e. \[code\]arr.slice(1)\[/code\] is a shorthand for \[code\]arr.slice(1, arr.size())\[/code\]).
If either \[param begin\] or \[param end\] are negative, they will be relative to the end of the array (i.e. \[code\]arr.slice(0, -2)\[/code\] is a shorthand for \[code\]arr.slice(0, arr.size() - 2)\[/code\]). *)
    val slice : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.Int.t structure ptr -> BuiltinClass0.PackedVector3Array.t structure ptr -> BuiltinClass0.PackedVector3Array.t structure ptr)

    (** Returns a \[PackedByteArray\] with each vector encoded as bytes. *)
    val to_byte_array : 
    (BuiltinClass0.PackedVector3Array.t structure ptr -> BuiltinClass0.PackedByteArray.t structure ptr)

    (** Sorts the elements of the array in ascending order.
\[b\]Note:\[/b\] Vectors with \[constant \@GDScript.NAN\] elements don''t behave the same as other vectors. Therefore, the results from this method may not be accurate if NaNs are included. *)
    val sort : 
    (BuiltinClass0.PackedVector3Array.t structure ptr -> unit)

    (** Finds the index of an existing value (or the insertion index that maintains sorting order, if the value is not yet present in the array) using binary search. Optionally, a \[param before\] specifier can be passed. If \[code\]false\[/code\], the returned index comes after all existing entries of the value in the array.
\[b\]Note:\[/b\] Calling \[method bsearch\] on an unsorted array results in unexpected behavior.
\[b\]Note:\[/b\] Vectors with \[constant \@GDScript.NAN\] elements don''t behave the same as other vectors. Therefore, the results from this method may not be accurate if NaNs are included. *)
    val bsearch : 
    (BuiltinClass0.Vector3.t structure ptr -> BuiltinClass0.Bool.t structure ptr -> BuiltinClass0.PackedVector3Array.t structure ptr -> BuiltinClass0.Int.t structure ptr)

    (** Creates a copy of the array, and returns it. *)
    val duplicate : 
    (BuiltinClass0.PackedVector3Array.t structure ptr -> BuiltinClass0.PackedVector3Array.t structure ptr)

    (** Searches the array for a value and returns its index or \[code\]-1\[/code\] if not found. Optionally, the initial search index can be passed.
\[b\]Note:\[/b\] Vectors with \[constant \@GDScript.NAN\] elements don''t behave the same as other vectors. Therefore, the results from this method may not be accurate if NaNs are included. *)
    val find : 
    (BuiltinClass0.Vector3.t structure ptr -> BuiltinClass0.Int.t structure ptr -> BuiltinClass0.PackedVector3Array.t structure ptr -> BuiltinClass0.Int.t structure ptr)

    (** Searches the array in reverse order. Optionally, a start search index can be passed. If negative, the start index is considered relative to the end of the array.
\[b\]Note:\[/b\] Vectors with \[constant \@GDScript.NAN\] elements don''t behave the same as other vectors. Therefore, the results from this method may not be accurate if NaNs are included. *)
    val rfind : 
    (BuiltinClass0.Vector3.t structure ptr -> BuiltinClass0.Int.t structure ptr -> BuiltinClass0.PackedVector3Array.t structure ptr -> BuiltinClass0.Int.t structure ptr)

    (** Returns the number of times an element is in the array.
\[b\]Note:\[/b\] Vectors with \[constant \@GDScript.NAN\] elements don''t behave the same as other vectors. Therefore, the results from this method may not be accurate if NaNs are included. *)
    val count : 
    (BuiltinClass0.Vector3.t structure ptr -> BuiltinClass0.PackedVector3Array.t structure ptr -> BuiltinClass0.Int.t structure ptr)






    val not : 
    (PackedVector3Array.t structure ptr -> PackedVector3Array.t structure ptr -> Bool.t structure ptr)




    val mem_Dictionary : 
    (PackedVector3Array.t structure ptr -> Dictionary.t structure ptr -> Bool.t structure ptr)


    val mem_Array : 
    (PackedVector3Array.t structure ptr -> Array.t structure ptr -> Bool.t structure ptr)

    (** Returns \[code\]true\[/code\] if contents of both arrays are the same, i.e. they have all equal \[Vector3\]s at the corresponding indices. *)
    val (=) : 
    (PackedVector3Array.t structure ptr -> PackedVector3Array.t structure ptr -> Bool.t structure ptr)

    (** Returns \[code\]true\[/code\] if contents of the arrays differ. *)
    val (<>) : 
    (PackedVector3Array.t structure ptr -> PackedVector3Array.t structure ptr -> Bool.t structure ptr)

    (** Returns a new \[PackedVector3Array\] with contents of \[param right\] added at the end of this array. For better performance, consider using \[method append_array\] instead. *)
    val (+) : 
    (PackedVector3Array.t structure ptr -> PackedVector3Array.t structure ptr -> PackedVector3Array.t structure ptr)
    end

  module type PACKEDCOLORARRAY = sig
    type t


    include Api_types.API_TYPE with type t := t



    (** Returns the \[Color\] at the given \[param index\] in the array. This is the same as using the \[code\]\[\]\[/code\] operator (\[code\]array\[index\]\[/code\]). *)
    val get : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.PackedColorArray.t structure ptr -> BuiltinClass0.Color.t structure ptr)

    (** Changes the \[Color\] at the given index. *)
    val set : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.Color.t structure ptr -> BuiltinClass0.PackedColorArray.t structure ptr -> unit)

    (** Returns the number of elements in the array. *)
    val size : 
    (BuiltinClass0.PackedColorArray.t structure ptr -> BuiltinClass0.Int.t structure ptr)

    (** Returns \[code\]true\[/code\] if the array is empty. *)
    val is_empty : 
    (BuiltinClass0.PackedColorArray.t structure ptr -> BuiltinClass0.Bool.t structure ptr)

    (** Appends a value to the array. *)
    val push_back : 
    (BuiltinClass0.Color.t structure ptr -> BuiltinClass0.PackedColorArray.t structure ptr -> BuiltinClass0.Bool.t structure ptr)

    (** Appends an element at the end of the array (alias of \[method push_back\]). *)
    val append : 
    (BuiltinClass0.Color.t structure ptr -> BuiltinClass0.PackedColorArray.t structure ptr -> BuiltinClass0.Bool.t structure ptr)

    (** Appends a \[PackedColorArray\] at the end of this array. *)
    val append_array : 
    (BuiltinClass0.PackedColorArray.t structure ptr -> BuiltinClass0.PackedColorArray.t structure ptr -> unit)

    (** Removes an element from the array by index. *)
    val remove_at : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.PackedColorArray.t structure ptr -> unit)

    (** Inserts a new element at a given position in the array. The position must be valid, or at the end of the array (\[code\]idx == size()\[/code\]). *)
    val insert : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.Color.t structure ptr -> BuiltinClass0.PackedColorArray.t structure ptr -> BuiltinClass0.Int.t structure ptr)

    (** Assigns the given value to all elements in the array. This can typically be used together with \[method resize\] to create an array with a given size and initialized elements. *)
    val fill : 
    (BuiltinClass0.Color.t structure ptr -> BuiltinClass0.PackedColorArray.t structure ptr -> unit)

    (** Sets the size of the array. If the array is grown, reserves elements at the end of the array. If the array is shrunk, truncates the array to the new size. Calling \[method resize\] once and assigning the new values is faster than adding new elements one by one. *)
    val resize : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.PackedColorArray.t structure ptr -> BuiltinClass0.Int.t structure ptr)

    (** Clears the array. This is equivalent to using \[method resize\] with a size of \[code\]0\[/code\]. *)
    val clear : 
    (BuiltinClass0.PackedColorArray.t structure ptr -> unit)

    (** Returns \[code\]true\[/code\] if the array contains \[param value\]. *)
    val has : 
    (BuiltinClass0.Color.t structure ptr -> BuiltinClass0.PackedColorArray.t structure ptr -> BuiltinClass0.Bool.t structure ptr)

    (** Reverses the order of the elements in the array. *)
    val reverse : 
    (BuiltinClass0.PackedColorArray.t structure ptr -> unit)

    (** Returns the slice of the \[PackedColorArray\], from \[param begin\] (inclusive) to \[param end\] (exclusive), as a new \[PackedColorArray\].
The absolute value of \[param begin\] and \[param end\] will be clamped to the array size, so the default value for \[param end\] makes it slice to the size of the array by default (i.e. \[code\]arr.slice(1)\[/code\] is a shorthand for \[code\]arr.slice(1, arr.size())\[/code\]).
If either \[param begin\] or \[param end\] are negative, they will be relative to the end of the array (i.e. \[code\]arr.slice(0, -2)\[/code\] is a shorthand for \[code\]arr.slice(0, arr.size() - 2)\[/code\]). *)
    val slice : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.Int.t structure ptr -> BuiltinClass0.PackedColorArray.t structure ptr -> BuiltinClass0.PackedColorArray.t structure ptr)

    (** Returns a \[PackedByteArray\] with each color encoded as bytes. *)
    val to_byte_array : 
    (BuiltinClass0.PackedColorArray.t structure ptr -> BuiltinClass0.PackedByteArray.t structure ptr)

    (** Sorts the elements of the array in ascending order. *)
    val sort : 
    (BuiltinClass0.PackedColorArray.t structure ptr -> unit)

    (** Finds the index of an existing value (or the insertion index that maintains sorting order, if the value is not yet present in the array) using binary search. Optionally, a \[param before\] specifier can be passed. If \[code\]false\[/code\], the returned index comes after all existing entries of the value in the array.
\[b\]Note:\[/b\] Calling \[method bsearch\] on an unsorted array results in unexpected behavior. *)
    val bsearch : 
    (BuiltinClass0.Color.t structure ptr -> BuiltinClass0.Bool.t structure ptr -> BuiltinClass0.PackedColorArray.t structure ptr -> BuiltinClass0.Int.t structure ptr)

    (** Creates a copy of the array, and returns it. *)
    val duplicate : 
    (BuiltinClass0.PackedColorArray.t structure ptr -> BuiltinClass0.PackedColorArray.t structure ptr)

    (** Searches the array for a value and returns its index or \[code\]-1\[/code\] if not found. Optionally, the initial search index can be passed. *)
    val find : 
    (BuiltinClass0.Color.t structure ptr -> BuiltinClass0.Int.t structure ptr -> BuiltinClass0.PackedColorArray.t structure ptr -> BuiltinClass0.Int.t structure ptr)

    (** Searches the array in reverse order. Optionally, a start search index can be passed. If negative, the start index is considered relative to the end of the array. *)
    val rfind : 
    (BuiltinClass0.Color.t structure ptr -> BuiltinClass0.Int.t structure ptr -> BuiltinClass0.PackedColorArray.t structure ptr -> BuiltinClass0.Int.t structure ptr)

    (** Returns the number of times an element is in the array. *)
    val count : 
    (BuiltinClass0.Color.t structure ptr -> BuiltinClass0.PackedColorArray.t structure ptr -> BuiltinClass0.Int.t structure ptr)






    val not : 
    (PackedColorArray.t structure ptr -> PackedColorArray.t structure ptr -> Bool.t structure ptr)


    val mem_Dictionary : 
    (PackedColorArray.t structure ptr -> Dictionary.t structure ptr -> Bool.t structure ptr)


    val mem_Array : 
    (PackedColorArray.t structure ptr -> Array.t structure ptr -> Bool.t structure ptr)

    (** Returns \[code\]true\[/code\] if contents of both arrays are the same, i.e. they have all equal \[Color\]s at the corresponding indices. *)
    val (=) : 
    (PackedColorArray.t structure ptr -> PackedColorArray.t structure ptr -> Bool.t structure ptr)

    (** Returns \[code\]true\[/code\] if contents of the arrays differ. *)
    val (<>) : 
    (PackedColorArray.t structure ptr -> PackedColorArray.t structure ptr -> Bool.t structure ptr)

    (** Returns a new \[PackedColorArray\] with contents of \[param right\] added at the end of this array. For better performance, consider using \[method append_array\] instead. *)
    val (+) : 
    (PackedColorArray.t structure ptr -> PackedColorArray.t structure ptr -> PackedColorArray.t structure ptr)
    end

  module type PACKEDVECTOR4ARRAY = sig
    type t


    include Api_types.API_TYPE with type t := t



    (** Returns the \[Vector4\] at the given \[param index\] in the array. This is the same as using the \[code\]\[\]\[/code\] operator (\[code\]array\[index\]\[/code\]). *)
    val get : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.PackedVector4Array.t structure ptr -> BuiltinClass0.Vector4.t structure ptr)

    (** Changes the \[Vector4\] at the given index. *)
    val set : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.Vector4.t structure ptr -> BuiltinClass0.PackedVector4Array.t structure ptr -> unit)

    (** Returns the number of elements in the array. *)
    val size : 
    (BuiltinClass0.PackedVector4Array.t structure ptr -> BuiltinClass0.Int.t structure ptr)

    (** Returns \[code\]true\[/code\] if the array is empty. *)
    val is_empty : 
    (BuiltinClass0.PackedVector4Array.t structure ptr -> BuiltinClass0.Bool.t structure ptr)

    (** Inserts a \[Vector4\] at the end. *)
    val push_back : 
    (BuiltinClass0.Vector4.t structure ptr -> BuiltinClass0.PackedVector4Array.t structure ptr -> BuiltinClass0.Bool.t structure ptr)

    (** Appends an element at the end of the array (alias of \[method push_back\]). *)
    val append : 
    (BuiltinClass0.Vector4.t structure ptr -> BuiltinClass0.PackedVector4Array.t structure ptr -> BuiltinClass0.Bool.t structure ptr)

    (** Appends a \[PackedVector4Array\] at the end of this array. *)
    val append_array : 
    (BuiltinClass0.PackedVector4Array.t structure ptr -> BuiltinClass0.PackedVector4Array.t structure ptr -> unit)

    (** Removes an element from the array by index. *)
    val remove_at : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.PackedVector4Array.t structure ptr -> unit)

    (** Inserts a new element at a given position in the array. The position must be valid, or at the end of the array (\[code\]idx == size()\[/code\]). *)
    val insert : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.Vector4.t structure ptr -> BuiltinClass0.PackedVector4Array.t structure ptr -> BuiltinClass0.Int.t structure ptr)

    (** Assigns the given value to all elements in the array. This can typically be used together with \[method resize\] to create an array with a given size and initialized elements. *)
    val fill : 
    (BuiltinClass0.Vector4.t structure ptr -> BuiltinClass0.PackedVector4Array.t structure ptr -> unit)

    (** Sets the size of the array. If the array is grown, reserves elements at the end of the array. If the array is shrunk, truncates the array to the new size. *)
    val resize : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.PackedVector4Array.t structure ptr -> BuiltinClass0.Int.t structure ptr)

    (** Clears the array. This is equivalent to using \[method resize\] with a size of \[code\]0\[/code\]. *)
    val clear : 
    (BuiltinClass0.PackedVector4Array.t structure ptr -> unit)

    (** Returns \[code\]true\[/code\] if the array contains \[param value\].
\[b\]Note:\[/b\] Vectors with \[constant \@GDScript.NAN\] elements don''t behave the same as other vectors. Therefore, the results from this method may not be accurate if NaNs are included. *)
    val has : 
    (BuiltinClass0.Vector4.t structure ptr -> BuiltinClass0.PackedVector4Array.t structure ptr -> BuiltinClass0.Bool.t structure ptr)

    (** Reverses the order of the elements in the array. *)
    val reverse : 
    (BuiltinClass0.PackedVector4Array.t structure ptr -> unit)

    (** Returns the slice of the \[PackedVector4Array\], from \[param begin\] (inclusive) to \[param end\] (exclusive), as a new \[PackedVector4Array\].
The absolute value of \[param begin\] and \[param end\] will be clamped to the array size, so the default value for \[param end\] makes it slice to the size of the array by default (i.e. \[code\]arr.slice(1)\[/code\] is a shorthand for \[code\]arr.slice(1, arr.size())\[/code\]).
If either \[param begin\] or \[param end\] are negative, they will be relative to the end of the array (i.e. \[code\]arr.slice(0, -2)\[/code\] is a shorthand for \[code\]arr.slice(0, arr.size() - 2)\[/code\]). *)
    val slice : 
    (BuiltinClass0.Int.t structure ptr -> BuiltinClass0.Int.t structure ptr -> BuiltinClass0.PackedVector4Array.t structure ptr -> BuiltinClass0.PackedVector4Array.t structure ptr)

    (** Returns a \[PackedByteArray\] with each vector encoded as bytes. *)
    val to_byte_array : 
    (BuiltinClass0.PackedVector4Array.t structure ptr -> BuiltinClass0.PackedByteArray.t structure ptr)

    (** Sorts the elements of the array in ascending order.
\[b\]Note:\[/b\] Vectors with \[constant \@GDScript.NAN\] elements don''t behave the same as other vectors. Therefore, the results from this method may not be accurate if NaNs are included. *)
    val sort : 
    (BuiltinClass0.PackedVector4Array.t structure ptr -> unit)

    (** Finds the index of an existing value (or the insertion index that maintains sorting order, if the value is not yet present in the array) using binary search. Optionally, a \[param before\] specifier can be passed. If \[code\]false\[/code\], the returned index comes after all existing entries of the value in the array.
\[b\]Note:\[/b\] Calling \[method bsearch\] on an unsorted array results in unexpected behavior.
\[b\]Note:\[/b\] Vectors with \[constant \@GDScript.NAN\] elements don''t behave the same as other vectors. Therefore, the results from this method may not be accurate if NaNs are included. *)
    val bsearch : 
    (BuiltinClass0.Vector4.t structure ptr -> BuiltinClass0.Bool.t structure ptr -> BuiltinClass0.PackedVector4Array.t structure ptr -> BuiltinClass0.Int.t structure ptr)

    (** Creates a copy of the array, and returns it. *)
    val duplicate : 
    (BuiltinClass0.PackedVector4Array.t structure ptr -> BuiltinClass0.PackedVector4Array.t structure ptr)

    (** Searches the array for a value and returns its index or \[code\]-1\[/code\] if not found. Optionally, the initial search index can be passed.
\[b\]Note:\[/b\] Vectors with \[constant \@GDScript.NAN\] elements don''t behave the same as other vectors. Therefore, the results from this method may not be accurate if NaNs are included. *)
    val find : 
    (BuiltinClass0.Vector4.t structure ptr -> BuiltinClass0.Int.t structure ptr -> BuiltinClass0.PackedVector4Array.t structure ptr -> BuiltinClass0.Int.t structure ptr)

    (** Searches the array in reverse order. Optionally, a start search index can be passed. If negative, the start index is considered relative to the end of the array.
\[b\]Note:\[/b\] Vectors with \[constant \@GDScript.NAN\] elements don''t behave the same as other vectors. Therefore, the results from this method may not be accurate if NaNs are included. *)
    val rfind : 
    (BuiltinClass0.Vector4.t structure ptr -> BuiltinClass0.Int.t structure ptr -> BuiltinClass0.PackedVector4Array.t structure ptr -> BuiltinClass0.Int.t structure ptr)

    (** Returns the number of times an element is in the array.
\[b\]Note:\[/b\] Vectors with \[constant \@GDScript.NAN\] elements don''t behave the same as other vectors. Therefore, the results from this method may not be accurate if NaNs are included. *)
    val count : 
    (BuiltinClass0.Vector4.t structure ptr -> BuiltinClass0.PackedVector4Array.t structure ptr -> BuiltinClass0.Int.t structure ptr)






    val not : 
    (PackedVector4Array.t structure ptr -> PackedVector4Array.t structure ptr -> Bool.t structure ptr)


    val mem_Dictionary : 
    (PackedVector4Array.t structure ptr -> Dictionary.t structure ptr -> Bool.t structure ptr)


    val mem_Array : 
    (PackedVector4Array.t structure ptr -> Array.t structure ptr -> Bool.t structure ptr)

    (** Returns \[code\]true\[/code\] if contents of both arrays are the same, i.e. they have all equal \[Vector4\]s at the corresponding indices. *)
    val (=) : 
    (PackedVector4Array.t structure ptr -> PackedVector4Array.t structure ptr -> Bool.t structure ptr)

    (** Returns \[code\]true\[/code\] if contents of the arrays differ. *)
    val (<>) : 
    (PackedVector4Array.t structure ptr -> PackedVector4Array.t structure ptr -> Bool.t structure ptr)

    (** Returns a new \[PackedVector4Array\] with contents of \[param right\] added at the end of this array. For better performance, consider using \[method append_array\] instead. *)
    val (+) : 
    (PackedVector4Array.t structure ptr -> PackedVector4Array.t structure ptr -> PackedVector4Array.t structure ptr)
    end

  module Nil = struct
    include M.Nil
include BuiltinClass0.Nil








    let not x0  = 
    foreign_builtin_operator1 GlobalEnum.VariantType._TYPE_NIL None  GlobalEnum.VariantOperator._OP_NOT
      (funptr (Nil.typ @-> Bool.typ @-> returning void))
      Bool.s x0 






































































































































    let mem_Dictionary x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_NIL (Some GlobalEnum.VariantType._TYPE_DICTIONARY) GlobalEnum.VariantOperator._OP_IN
      (funptr (Nil.typ @-> Dictionary.typ @-> Bool.typ @-> returning void))
      Bool.s x0  x1 






    let mem_Array x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_NIL (Some GlobalEnum.VariantType._TYPE_ARRAY) GlobalEnum.VariantOperator._OP_IN
      (funptr (Nil.typ @-> Array.typ @-> Bool.typ @-> returning void))
      Bool.s x0  x1 








































    end

  module Bool = struct
    include M.Bool
include BuiltinClass0.Bool












    let not x0  = 
    foreign_builtin_operator1 GlobalEnum.VariantType._TYPE_BOOL None  GlobalEnum.VariantOperator._OP_NOT
      (funptr (Bool.typ @-> Bool.typ @-> returning void))
      Bool.s x0 

    (** Returns \[code\]true\[/code\] if the two booleans are equal. That is, both are \[code\]true\[/code\] or both are \[code\]false\[/code\]. This operation can be seen as a logical EQ or XNOR. *)
    let (=) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_BOOL (Some GlobalEnum.VariantType._TYPE_BOOL) GlobalEnum.VariantOperator._OP_EQUAL
      (funptr (Bool.typ @-> Bool.typ @-> Bool.typ @-> returning void))
      Bool.s
      Conv.Bool.of_ocaml
      Conv.Bool.of_ocaml
      Conv.Bool.to_ocaml x0  x1 

    (** Returns \[code\]true\[/code\] if the two booleans are not equal. That is, one is \[code\]true\[/code\] and the other is \[code\]false\[/code\]. This operation can be seen as a logical XOR. *)
    let (<>) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_BOOL (Some GlobalEnum.VariantType._TYPE_BOOL) GlobalEnum.VariantOperator._OP_NOT_EQUAL
      (funptr (Bool.typ @-> Bool.typ @-> Bool.typ @-> returning void))
      Bool.s
      Conv.Bool.of_ocaml
      Conv.Bool.of_ocaml
      Conv.Bool.to_ocaml x0  x1 

    (** Returns \[code\]true\[/code\] if the left operand is \[code\]false\[/code\] and the right operand is \[code\]true\[/code\]. *)
    let (<) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_BOOL (Some GlobalEnum.VariantType._TYPE_BOOL) GlobalEnum.VariantOperator._OP_LESS
      (funptr (Bool.typ @-> Bool.typ @-> Bool.typ @-> returning void))
      Bool.s
      Conv.Bool.of_ocaml
      Conv.Bool.of_ocaml
      Conv.Bool.to_ocaml x0  x1 

    (** Returns \[code\]true\[/code\] if the left operand is \[code\]true\[/code\] and the right operand is \[code\]false\[/code\]. *)
    let (>) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_BOOL (Some GlobalEnum.VariantType._TYPE_BOOL) GlobalEnum.VariantOperator._OP_GREATER
      (funptr (Bool.typ @-> Bool.typ @-> Bool.typ @-> returning void))
      Bool.s
      Conv.Bool.of_ocaml
      Conv.Bool.of_ocaml
      Conv.Bool.to_ocaml x0  x1 


    let (&&) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_BOOL (Some GlobalEnum.VariantType._TYPE_BOOL) GlobalEnum.VariantOperator._OP_AND
      (funptr (Bool.typ @-> Bool.typ @-> Bool.typ @-> returning void))
      Bool.s
      Conv.Bool.of_ocaml
      Conv.Bool.of_ocaml
      Conv.Bool.to_ocaml x0  x1 


    let (||) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_BOOL (Some GlobalEnum.VariantType._TYPE_BOOL) GlobalEnum.VariantOperator._OP_OR
      (funptr (Bool.typ @-> Bool.typ @-> Bool.typ @-> returning void))
      Bool.s
      Conv.Bool.of_ocaml
      Conv.Bool.of_ocaml
      Conv.Bool.to_ocaml x0  x1 


    let xor x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_BOOL (Some GlobalEnum.VariantType._TYPE_BOOL) GlobalEnum.VariantOperator._OP_XOR
      (funptr (Bool.typ @-> Bool.typ @-> Bool.typ @-> returning void))
      Bool.s
      Conv.Bool.of_ocaml
      Conv.Bool.of_ocaml
      Conv.Bool.to_ocaml x0  x1 




















    let mem_Dictionary x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_BOOL (Some GlobalEnum.VariantType._TYPE_DICTIONARY) GlobalEnum.VariantOperator._OP_IN
      (funptr (Bool.typ @-> Dictionary.typ @-> Bool.typ @-> returning void))
      Bool.s x0  x1 


    let mem_Array x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_BOOL (Some GlobalEnum.VariantType._TYPE_ARRAY) GlobalEnum.VariantOperator._OP_IN
      (funptr (Bool.typ @-> Array.typ @-> Bool.typ @-> returning void))
      Bool.s x0  x1 
    end

  module Int = struct
    include M.Int
include BuiltinClass0.Int





    (** Returns the negated value of the \[int\]. If positive, turns the number negative. If negative, turns the number positive. If zero, does nothing. *)
    let (~-) x0  = 
    foreign_builtin_operator1 GlobalEnum.VariantType._TYPE_INT None  GlobalEnum.VariantOperator._OP_NEGATE
      (funptr (Int.typ @-> Int.typ @-> returning void))
      Int.s x0 

    (** Returns the same value as if the \[code\]+\[/code\] was not there. Unary \[code\]+\[/code\] does nothing, but sometimes it can make your code more readable. *)
    let (~+) x0  = 
    foreign_builtin_operator1 GlobalEnum.VariantType._TYPE_INT None  GlobalEnum.VariantOperator._OP_POSITIVE
      (funptr (Int.typ @-> Int.typ @-> returning void))
      Int.s x0 

    (** Performs the bitwise \[code\]NOT\[/code\] operation on the \[int\]. Due to \[url=https://en.wikipedia.org/wiki/Two%27s_complement\]2''s complement\[/url\], it''s effectively equal to \[code\]-(int + 1)\[/code\].
\[codeblock\]
print(~4) # Prints -5
print(~(-7)) # Prints 6
\[/codeblock\] *)
    let (~~~) x0  = 
    foreign_builtin_operator1 GlobalEnum.VariantType._TYPE_INT None  GlobalEnum.VariantOperator._OP_BIT_NEGATE
      (funptr (Int.typ @-> Int.typ @-> returning void))
      Int.s x0 








    let not x0  = 
    foreign_builtin_operator1 GlobalEnum.VariantType._TYPE_INT None  GlobalEnum.VariantOperator._OP_NOT
      (funptr (Int.typ @-> Bool.typ @-> returning void))
      Bool.s x0 







    (** Returns \[code\]true\[/code\] if the two \[int\]s are equal. *)
    let (=) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_INT (Some GlobalEnum.VariantType._TYPE_INT) GlobalEnum.VariantOperator._OP_EQUAL
      (funptr (Int.typ @-> Int.typ @-> Bool.typ @-> returning void))
      Bool.s
      Conv.Int.of_ocaml
      Conv.Int.of_ocaml
      Conv.Bool.to_ocaml x0  x1 

    (** Returns \[code\]true\[/code\] if the \[int\]s are not equal. *)
    let (<>) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_INT (Some GlobalEnum.VariantType._TYPE_INT) GlobalEnum.VariantOperator._OP_NOT_EQUAL
      (funptr (Int.typ @-> Int.typ @-> Bool.typ @-> returning void))
      Bool.s
      Conv.Int.of_ocaml
      Conv.Int.of_ocaml
      Conv.Bool.to_ocaml x0  x1 

    (** Returns \[code\]true\[/code\] if the left \[int\] is less than the right \[int\]. *)
    let (<) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_INT (Some GlobalEnum.VariantType._TYPE_INT) GlobalEnum.VariantOperator._OP_LESS
      (funptr (Int.typ @-> Int.typ @-> Bool.typ @-> returning void))
      Bool.s
      Conv.Int.of_ocaml
      Conv.Int.of_ocaml
      Conv.Bool.to_ocaml x0  x1 

    (** Returns \[code\]true\[/code\] if the left \[int\] is less than or equal to the right \[int\]. *)
    let (<=) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_INT (Some GlobalEnum.VariantType._TYPE_INT) GlobalEnum.VariantOperator._OP_LESS_EQUAL
      (funptr (Int.typ @-> Int.typ @-> Bool.typ @-> returning void))
      Bool.s
      Conv.Int.of_ocaml
      Conv.Int.of_ocaml
      Conv.Bool.to_ocaml x0  x1 

    (** Returns \[code\]true\[/code\] if the left \[int\] is greater than the right \[int\]. *)
    let (>) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_INT (Some GlobalEnum.VariantType._TYPE_INT) GlobalEnum.VariantOperator._OP_GREATER
      (funptr (Int.typ @-> Int.typ @-> Bool.typ @-> returning void))
      Bool.s
      Conv.Int.of_ocaml
      Conv.Int.of_ocaml
      Conv.Bool.to_ocaml x0  x1 

    (** Returns \[code\]true\[/code\] if the left \[int\] is greater than or equal to the right \[int\]. *)
    let (>=) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_INT (Some GlobalEnum.VariantType._TYPE_INT) GlobalEnum.VariantOperator._OP_GREATER_EQUAL
      (funptr (Int.typ @-> Int.typ @-> Bool.typ @-> returning void))
      Bool.s
      Conv.Int.of_ocaml
      Conv.Int.of_ocaml
      Conv.Bool.to_ocaml x0  x1 

    (** Adds the two \[int\]s. *)
    let (+) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_INT (Some GlobalEnum.VariantType._TYPE_INT) GlobalEnum.VariantOperator._OP_ADD
      (funptr (Int.typ @-> Int.typ @-> Int.typ @-> returning void))
      Int.s
      Conv.Int.of_ocaml
      Conv.Int.of_ocaml
      Conv.Int.to_ocaml x0  x1 

    (** Subtracts the two \[int\]s. *)
    let (-) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_INT (Some GlobalEnum.VariantType._TYPE_INT) GlobalEnum.VariantOperator._OP_SUBTRACT
      (funptr (Int.typ @-> Int.typ @-> Int.typ @-> returning void))
      Int.s
      Conv.Int.of_ocaml
      Conv.Int.of_ocaml
      Conv.Int.to_ocaml x0  x1 

    (** Multiplies the two \[int\]s. *)
    let ( * ) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_INT (Some GlobalEnum.VariantType._TYPE_INT) GlobalEnum.VariantOperator._OP_MULTIPLY
      (funptr (Int.typ @-> Int.typ @-> Int.typ @-> returning void))
      Int.s
      Conv.Int.of_ocaml
      Conv.Int.of_ocaml
      Conv.Int.to_ocaml x0  x1 

    (** Divides the two \[int\]s. The result is an \[int\]. This will truncate the \[float\], discarding anything after the floating point.
\[codeblock\]
print(6 / 2) # Prints 3
print(5 / 3) # Prints 1
\[/codeblock\] *)
    let (/) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_INT (Some GlobalEnum.VariantType._TYPE_INT) GlobalEnum.VariantOperator._OP_DIVIDE
      (funptr (Int.typ @-> Int.typ @-> Int.typ @-> returning void))
      Int.s
      Conv.Int.of_ocaml
      Conv.Int.of_ocaml
      Conv.Int.to_ocaml x0  x1 

    (** Returns the remainder after dividing two \[int\]s. Uses truncated division, which returns a negative number if the dividend is negative. If this is not desired, consider using \[method \@GlobalScope.posmod\].
\[codeblock\]
print(6 % 2) # Prints 0
print(11 % 4) # Prints 3
print(-5 % 3) # Prints -2
\[/codeblock\] *)
    let (%) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_INT (Some GlobalEnum.VariantType._TYPE_INT) GlobalEnum.VariantOperator._OP_MODULE
      (funptr (Int.typ @-> Int.typ @-> Int.typ @-> returning void))
      Int.s
      Conv.Int.of_ocaml
      Conv.Int.of_ocaml
      Conv.Int.to_ocaml x0  x1 

    (** Raises the left \[int\] to a power of the right \[int\].
\[codeblock\]
print(3  *  *  4) # Prints 81
\[/codeblock\] *)
    let ( ** ) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_INT (Some GlobalEnum.VariantType._TYPE_INT) GlobalEnum.VariantOperator._OP_POWER
      (funptr (Int.typ @-> Int.typ @-> Int.typ @-> returning void))
      Int.s
      Conv.Int.of_ocaml
      Conv.Int.of_ocaml
      Conv.Int.to_ocaml x0  x1 

    (** Performs the bitwise shift left operation. Effectively the same as multiplying by a power of 2.
\[codeblock\]
print(0b1010 << 1) # Prints 20 (binary 10100)
print(0b1010 << 3) # Prints 80 (binary 1010000)
\[/codeblock\] *)
    let (<<<) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_INT (Some GlobalEnum.VariantType._TYPE_INT) GlobalEnum.VariantOperator._OP_SHIFT_LEFT
      (funptr (Int.typ @-> Int.typ @-> Int.typ @-> returning void))
      Int.s
      Conv.Int.of_ocaml
      Conv.Int.of_ocaml
      Conv.Int.to_ocaml x0  x1 

    (** Performs the bitwise shift right operation. Effectively the same as dividing by a power of 2.
\[codeblock\]
print(0b1010 >> 1) # Prints 5 (binary 101)
print(0b1010 >> 2) # Prints 2 (binary 10)
\[/codeblock\] *)
    let (>>>) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_INT (Some GlobalEnum.VariantType._TYPE_INT) GlobalEnum.VariantOperator._OP_SHIFT_RIGHT
      (funptr (Int.typ @-> Int.typ @-> Int.typ @-> returning void))
      Int.s
      Conv.Int.of_ocaml
      Conv.Int.of_ocaml
      Conv.Int.to_ocaml x0  x1 

    (** Performs the bitwise \[code\]AND\[/code\] operation.
\[codeblock\]
print(0b1100 & 0b1010) # Prints 8 (binary 1000)
\[/codeblock\]
This is useful for retrieving binary flags from a variable.
\[codeblock\]
var flags = 0b101
# Check if the first or second bit are enabled.
if flags & 0b011:
    do_stuff() # This line will run.
\[/codeblock\] *)
    let (&&&) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_INT (Some GlobalEnum.VariantType._TYPE_INT) GlobalEnum.VariantOperator._OP_BIT_AND
      (funptr (Int.typ @-> Int.typ @-> Int.typ @-> returning void))
      Int.s
      Conv.Int.of_ocaml
      Conv.Int.of_ocaml
      Conv.Int.to_ocaml x0  x1 

    (** Performs the bitwise \[code\]OR\[/code\] operation.
\[codeblock\]
print(0b1100 | 0b1010) # Prints 14 (binary 1110)
\[/codeblock\]
This is useful for storing binary flags in a variable.
\[codeblock\]
var flags = 0
flags |= 0b101 # Turn the first and third bits on.
\[/codeblock\] *)
    let (|||) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_INT (Some GlobalEnum.VariantType._TYPE_INT) GlobalEnum.VariantOperator._OP_BIT_OR
      (funptr (Int.typ @-> Int.typ @-> Int.typ @-> returning void))
      Int.s
      Conv.Int.of_ocaml
      Conv.Int.of_ocaml
      Conv.Int.to_ocaml x0  x1 

    (** Performs the bitwise \[code\]XOR\[/code\] operation.
\[codeblock\]
print(0b1100 ^ 0b1010) # Prints 6 (binary 110)
\[/codeblock\] *)
    let (^^^) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_INT (Some GlobalEnum.VariantType._TYPE_INT) GlobalEnum.VariantOperator._OP_BIT_XOR
      (funptr (Int.typ @-> Int.typ @-> Int.typ @-> returning void))
      Int.s
      Conv.Int.of_ocaml
      Conv.Int.of_ocaml
      Conv.Int.to_ocaml x0  x1 


    let (&&) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_INT (Some GlobalEnum.VariantType._TYPE_INT) GlobalEnum.VariantOperator._OP_AND
      (funptr (Int.typ @-> Int.typ @-> Bool.typ @-> returning void))
      Bool.s
      Conv.Int.of_ocaml
      Conv.Int.of_ocaml
      Conv.Bool.to_ocaml x0  x1 


    let (||) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_INT (Some GlobalEnum.VariantType._TYPE_INT) GlobalEnum.VariantOperator._OP_OR
      (funptr (Int.typ @-> Int.typ @-> Bool.typ @-> returning void))
      Bool.s
      Conv.Int.of_ocaml
      Conv.Int.of_ocaml
      Conv.Bool.to_ocaml x0  x1 


    let xor x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_INT (Some GlobalEnum.VariantType._TYPE_INT) GlobalEnum.VariantOperator._OP_XOR
      (funptr (Int.typ @-> Int.typ @-> Bool.typ @-> returning void))
      Bool.s
      Conv.Int.of_ocaml
      Conv.Int.of_ocaml
      Conv.Bool.to_ocaml x0  x1 




















































    let mem_Dictionary x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_INT (Some GlobalEnum.VariantType._TYPE_DICTIONARY) GlobalEnum.VariantOperator._OP_IN
      (funptr (Int.typ @-> Dictionary.typ @-> Bool.typ @-> returning void))
      Bool.s x0  x1 


    let mem_Array x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_INT (Some GlobalEnum.VariantType._TYPE_ARRAY) GlobalEnum.VariantOperator._OP_IN
      (funptr (Int.typ @-> Array.typ @-> Bool.typ @-> returning void))
      Bool.s x0  x1 


    let mem_PackedByteArray x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_INT (Some GlobalEnum.VariantType._TYPE_PACKED_BYTE_ARRAY) GlobalEnum.VariantOperator._OP_IN
      (funptr (Int.typ @-> PackedByteArray.typ @-> Bool.typ @-> returning void))
      Bool.s x0  x1 


    let mem_PackedInt32Array x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_INT (Some GlobalEnum.VariantType._TYPE_PACKED_INT32_ARRAY) GlobalEnum.VariantOperator._OP_IN
      (funptr (Int.typ @-> PackedInt32Array.typ @-> Bool.typ @-> returning void))
      Bool.s x0  x1 


    let mem_PackedInt64Array x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_INT (Some GlobalEnum.VariantType._TYPE_PACKED_INT64_ARRAY) GlobalEnum.VariantOperator._OP_IN
      (funptr (Int.typ @-> PackedInt64Array.typ @-> Bool.typ @-> returning void))
      Bool.s x0  x1 


    let mem_PackedFloat32Array x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_INT (Some GlobalEnum.VariantType._TYPE_PACKED_FLOAT32_ARRAY) GlobalEnum.VariantOperator._OP_IN
      (funptr (Int.typ @-> PackedFloat32Array.typ @-> Bool.typ @-> returning void))
      Bool.s x0  x1 


    let mem_PackedFloat64Array x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_INT (Some GlobalEnum.VariantType._TYPE_PACKED_FLOAT64_ARRAY) GlobalEnum.VariantOperator._OP_IN
      (funptr (Int.typ @-> PackedFloat64Array.typ @-> Bool.typ @-> returning void))
      Bool.s x0  x1 
    end

  module Float = struct
    include M.Float
include BuiltinClass0.Float





    (** Returns the negative value of the \[float\]. If positive, turns the number negative. If negative, turns the number positive. With floats, the number zero can be either positive or negative. *)
    let (~-) x0  = 
    foreign_builtin_operator1 GlobalEnum.VariantType._TYPE_FLOAT None  GlobalEnum.VariantOperator._OP_NEGATE
      (funptr (Float.typ @-> Float.typ @-> returning void))
      Float.s x0 

    (** Returns the same value as if the \[code\]+\[/code\] was not there. Unary \[code\]+\[/code\] does nothing, but sometimes it can make your code more readable. *)
    let (~+) x0  = 
    foreign_builtin_operator1 GlobalEnum.VariantType._TYPE_FLOAT None  GlobalEnum.VariantOperator._OP_POSITIVE
      (funptr (Float.typ @-> Float.typ @-> returning void))
      Float.s x0 








    let not x0  = 
    foreign_builtin_operator1 GlobalEnum.VariantType._TYPE_FLOAT None  GlobalEnum.VariantOperator._OP_NOT
      (funptr (Float.typ @-> Bool.typ @-> returning void))
      Bool.s x0 



































    (** Returns \[code\]true\[/code\] if both floats are exactly equal.
\[b\]Note:\[/b\] Due to floating-point precision errors, consider using \[method \@GlobalScope.is_equal_approx\] or \[method \@GlobalScope.is_zero_approx\] instead, which are more reliable.
\[b\]Note:\[/b\] \[constant \@GDScript.NAN\] doesn''t behave the same as other numbers. Therefore, the results from this operator may not be accurate if NaNs are included. *)
    let (=) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_FLOAT (Some GlobalEnum.VariantType._TYPE_FLOAT) GlobalEnum.VariantOperator._OP_EQUAL
      (funptr (Float.typ @-> Float.typ @-> Bool.typ @-> returning void))
      Bool.s
      Conv.Float.of_ocaml
      Conv.Float.of_ocaml
      Conv.Bool.to_ocaml x0  x1 

    (** Returns \[code\]true\[/code\] if two floats are different from each other.
\[b\]Note:\[/b\] \[constant \@GDScript.NAN\] doesn''t behave the same as other numbers. Therefore, the results from this operator may not be accurate if NaNs are included. *)
    let (<>) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_FLOAT (Some GlobalEnum.VariantType._TYPE_FLOAT) GlobalEnum.VariantOperator._OP_NOT_EQUAL
      (funptr (Float.typ @-> Float.typ @-> Bool.typ @-> returning void))
      Bool.s
      Conv.Float.of_ocaml
      Conv.Float.of_ocaml
      Conv.Bool.to_ocaml x0  x1 

    (** Returns \[code\]true\[/code\] if the left float is less than the right one.
\[b\]Note:\[/b\] \[constant \@GDScript.NAN\] doesn''t behave the same as other numbers. Therefore, the results from this operator may not be accurate if NaNs are included. *)
    let (<) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_FLOAT (Some GlobalEnum.VariantType._TYPE_FLOAT) GlobalEnum.VariantOperator._OP_LESS
      (funptr (Float.typ @-> Float.typ @-> Bool.typ @-> returning void))
      Bool.s
      Conv.Float.of_ocaml
      Conv.Float.of_ocaml
      Conv.Bool.to_ocaml x0  x1 

    (** Returns \[code\]true\[/code\] if the left float is less than or equal to the right one.
\[b\]Note:\[/b\] \[constant \@GDScript.NAN\] doesn''t behave the same as other numbers. Therefore, the results from this operator may not be accurate if NaNs are included. *)
    let (<=) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_FLOAT (Some GlobalEnum.VariantType._TYPE_FLOAT) GlobalEnum.VariantOperator._OP_LESS_EQUAL
      (funptr (Float.typ @-> Float.typ @-> Bool.typ @-> returning void))
      Bool.s
      Conv.Float.of_ocaml
      Conv.Float.of_ocaml
      Conv.Bool.to_ocaml x0  x1 

    (** Returns \[code\]true\[/code\] if the left float is greater than the right one.
\[b\]Note:\[/b\] \[constant \@GDScript.NAN\] doesn''t behave the same as other numbers. Therefore, the results from this operator may not be accurate if NaNs are included. *)
    let (>) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_FLOAT (Some GlobalEnum.VariantType._TYPE_FLOAT) GlobalEnum.VariantOperator._OP_GREATER
      (funptr (Float.typ @-> Float.typ @-> Bool.typ @-> returning void))
      Bool.s
      Conv.Float.of_ocaml
      Conv.Float.of_ocaml
      Conv.Bool.to_ocaml x0  x1 

    (** Returns \[code\]true\[/code\] if the left float is greater than or equal to the right one.
\[b\]Note:\[/b\] \[constant \@GDScript.NAN\] doesn''t behave the same as other numbers. Therefore, the results from this operator may not be accurate if NaNs are included. *)
    let (>=) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_FLOAT (Some GlobalEnum.VariantType._TYPE_FLOAT) GlobalEnum.VariantOperator._OP_GREATER_EQUAL
      (funptr (Float.typ @-> Float.typ @-> Bool.typ @-> returning void))
      Bool.s
      Conv.Float.of_ocaml
      Conv.Float.of_ocaml
      Conv.Bool.to_ocaml x0  x1 

    (** Adds two floats. *)
    let (+) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_FLOAT (Some GlobalEnum.VariantType._TYPE_FLOAT) GlobalEnum.VariantOperator._OP_ADD
      (funptr (Float.typ @-> Float.typ @-> Float.typ @-> returning void))
      Float.s
      Conv.Float.of_ocaml
      Conv.Float.of_ocaml
      Conv.Float.to_ocaml x0  x1 

    (** Subtracts a float from a float. *)
    let (-) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_FLOAT (Some GlobalEnum.VariantType._TYPE_FLOAT) GlobalEnum.VariantOperator._OP_SUBTRACT
      (funptr (Float.typ @-> Float.typ @-> Float.typ @-> returning void))
      Float.s
      Conv.Float.of_ocaml
      Conv.Float.of_ocaml
      Conv.Float.to_ocaml x0  x1 

    (** Multiplies two \[float\]s. *)
    let ( * ) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_FLOAT (Some GlobalEnum.VariantType._TYPE_FLOAT) GlobalEnum.VariantOperator._OP_MULTIPLY
      (funptr (Float.typ @-> Float.typ @-> Float.typ @-> returning void))
      Float.s
      Conv.Float.of_ocaml
      Conv.Float.of_ocaml
      Conv.Float.to_ocaml x0  x1 

    (** Divides two floats. *)
    let (/) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_FLOAT (Some GlobalEnum.VariantType._TYPE_FLOAT) GlobalEnum.VariantOperator._OP_DIVIDE
      (funptr (Float.typ @-> Float.typ @-> Float.typ @-> returning void))
      Float.s
      Conv.Float.of_ocaml
      Conv.Float.of_ocaml
      Conv.Float.to_ocaml x0  x1 

    (** Raises a \[float\] to a power of a \[float\].
\[codeblock\]
print(39.0625 *  * 0.25) # 2.5
\[/codeblock\] *)
    let ( ** ) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_FLOAT (Some GlobalEnum.VariantType._TYPE_FLOAT) GlobalEnum.VariantOperator._OP_POWER
      (funptr (Float.typ @-> Float.typ @-> Float.typ @-> returning void))
      Float.s
      Conv.Float.of_ocaml
      Conv.Float.of_ocaml
      Conv.Float.to_ocaml x0  x1 


    let (&&) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_FLOAT (Some GlobalEnum.VariantType._TYPE_FLOAT) GlobalEnum.VariantOperator._OP_AND
      (funptr (Float.typ @-> Float.typ @-> Bool.typ @-> returning void))
      Bool.s
      Conv.Float.of_ocaml
      Conv.Float.of_ocaml
      Conv.Bool.to_ocaml x0  x1 


    let (||) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_FLOAT (Some GlobalEnum.VariantType._TYPE_FLOAT) GlobalEnum.VariantOperator._OP_OR
      (funptr (Float.typ @-> Float.typ @-> Bool.typ @-> returning void))
      Bool.s
      Conv.Float.of_ocaml
      Conv.Float.of_ocaml
      Conv.Bool.to_ocaml x0  x1 


    let xor x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_FLOAT (Some GlobalEnum.VariantType._TYPE_FLOAT) GlobalEnum.VariantOperator._OP_XOR
      (funptr (Float.typ @-> Float.typ @-> Bool.typ @-> returning void))
      Bool.s
      Conv.Float.of_ocaml
      Conv.Float.of_ocaml
      Conv.Bool.to_ocaml x0  x1 
























    let mem_Dictionary x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_FLOAT (Some GlobalEnum.VariantType._TYPE_DICTIONARY) GlobalEnum.VariantOperator._OP_IN
      (funptr (Float.typ @-> Dictionary.typ @-> Bool.typ @-> returning void))
      Bool.s x0  x1 


    let mem_Array x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_FLOAT (Some GlobalEnum.VariantType._TYPE_ARRAY) GlobalEnum.VariantOperator._OP_IN
      (funptr (Float.typ @-> Array.typ @-> Bool.typ @-> returning void))
      Bool.s x0  x1 


    let mem_PackedByteArray x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_FLOAT (Some GlobalEnum.VariantType._TYPE_PACKED_BYTE_ARRAY) GlobalEnum.VariantOperator._OP_IN
      (funptr (Float.typ @-> PackedByteArray.typ @-> Bool.typ @-> returning void))
      Bool.s x0  x1 


    let mem_PackedInt32Array x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_FLOAT (Some GlobalEnum.VariantType._TYPE_PACKED_INT32_ARRAY) GlobalEnum.VariantOperator._OP_IN
      (funptr (Float.typ @-> PackedInt32Array.typ @-> Bool.typ @-> returning void))
      Bool.s x0  x1 


    let mem_PackedInt64Array x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_FLOAT (Some GlobalEnum.VariantType._TYPE_PACKED_INT64_ARRAY) GlobalEnum.VariantOperator._OP_IN
      (funptr (Float.typ @-> PackedInt64Array.typ @-> Bool.typ @-> returning void))
      Bool.s x0  x1 


    let mem_PackedFloat32Array x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_FLOAT (Some GlobalEnum.VariantType._TYPE_PACKED_FLOAT32_ARRAY) GlobalEnum.VariantOperator._OP_IN
      (funptr (Float.typ @-> PackedFloat32Array.typ @-> Bool.typ @-> returning void))
      Bool.s x0  x1 


    let mem_PackedFloat64Array x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_FLOAT (Some GlobalEnum.VariantType._TYPE_PACKED_FLOAT64_ARRAY) GlobalEnum.VariantOperator._OP_IN
      (funptr (Float.typ @-> PackedFloat64Array.typ @-> Bool.typ @-> returning void))
      Bool.s x0  x1 
    end

  module String = struct
    include M.String
include BuiltinClass0.String

    (** Performs a case-sensitive comparison to another string. Returns \[code\]-1\[/code\] if less than, \[code\]1\[/code\] if greater than, or \[code\]0\[/code\] if equal. ""Less than"" and ""greater than"" are determined by the \[url=https://en.wikipedia.org/wiki/List_of_Unicode_characters\]Unicode code points\[/url\] of each string, which roughly matches the alphabetical order.
With different string lengths, returns \[code\]1\[/code\] if this string is longer than the \[param to\] string, or \[code\]-1\[/code\] if shorter. Note that the length of empty strings is \[i\]always\[/i\] \[code\]0\[/code\].
To get a \[bool\] result from a string comparison, use the \[code\]==\[/code\] operator instead. See also \[method nocasecmp_to\], \[method filecasecmp_to\], and \[method naturalcasecmp_to\]. *)
    let casecmp_to x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_STRING
      "casecmp_to"
      2920860731L
      (String.typ @-> String.typ @-> returning Int.typ)
      Int.s x0  x1 

    (** Performs a \[b\]case-insensitive\[/b\] comparison to another string. Returns \[code\]-1\[/code\] if less than, \[code\]1\[/code\] if greater than, or \[code\]0\[/code\] if equal. ""Less than"" or ""greater than"" are determined by the \[url=https://en.wikipedia.org/wiki/List_of_Unicode_characters\]Unicode code points\[/url\] of each string, which roughly matches the alphabetical order. Internally, lowercase characters are converted to uppercase for the comparison.
With different string lengths, returns \[code\]1\[/code\] if this string is longer than the \[param to\] string, or \[code\]-1\[/code\] if shorter. Note that the length of empty strings is \[i\]always\[/i\] \[code\]0\[/code\].
To get a \[bool\] result from a string comparison, use the \[code\]==\[/code\] operator instead. See also \[method casecmp_to\], \[method filenocasecmp_to\], and \[method naturalnocasecmp_to\]. *)
    let nocasecmp_to x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_STRING
      "nocasecmp_to"
      2920860731L
      (String.typ @-> String.typ @-> returning Int.typ)
      Int.s x0  x1 

    (** Performs a \[b\]case-sensitive\[/b\], \[i\]natural order\[/i\] comparison to another string. Returns \[code\]-1\[/code\] if less than, \[code\]1\[/code\] if greater than, or \[code\]0\[/code\] if equal. ""Less than"" or ""greater than"" are determined by the \[url=https://en.wikipedia.org/wiki/List_of_Unicode_characters\]Unicode code points\[/url\] of each string, which roughly matches the alphabetical order.
When used for sorting, natural order comparison orders sequences of numbers by the combined value of each digit as is often expected, instead of the single digit''s value. A sorted sequence of numbered strings will be \[code\]\[""1"", ""2"", ""3"", ...\]\[/code\], not \[code\]\[""1"", ""10"", ""2"", ""3"", ...\]\[/code\].
With different string lengths, returns \[code\]1\[/code\] if this string is longer than the \[param to\] string, or \[code\]-1\[/code\] if shorter. Note that the length of empty strings is \[i\]always\[/i\] \[code\]0\[/code\].
To get a \[bool\] result from a string comparison, use the \[code\]==\[/code\] operator instead. See also \[method naturalnocasecmp_to\], \[method filecasecmp_to\], and \[method nocasecmp_to\]. *)
    let naturalcasecmp_to x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_STRING
      "naturalcasecmp_to"
      2920860731L
      (String.typ @-> String.typ @-> returning Int.typ)
      Int.s x0  x1 

    (** Performs a \[b\]case-insensitive\[/b\], \[i\]natural order\[/i\] comparison to another string. Returns \[code\]-1\[/code\] if less than, \[code\]1\[/code\] if greater than, or \[code\]0\[/code\] if equal. ""Less than"" or ""greater than"" are determined by the \[url=https://en.wikipedia.org/wiki/List_of_Unicode_characters\]Unicode code points\[/url\] of each string, which roughly matches the alphabetical order. Internally, lowercase characters are converted to uppercase for the comparison.
When used for sorting, natural order comparison orders sequences of numbers by the combined value of each digit as is often expected, instead of the single digit''s value. A sorted sequence of numbered strings will be \[code\]\[""1"", ""2"", ""3"", ...\]\[/code\], not \[code\]\[""1"", ""10"", ""2"", ""3"", ...\]\[/code\].
With different string lengths, returns \[code\]1\[/code\] if this string is longer than the \[param to\] string, or \[code\]-1\[/code\] if shorter. Note that the length of empty strings is \[i\]always\[/i\] \[code\]0\[/code\].
To get a \[bool\] result from a string comparison, use the \[code\]==\[/code\] operator instead. See also \[method naturalcasecmp_to\], \[method filenocasecmp_to\], and \[method casecmp_to\]. *)
    let naturalnocasecmp_to x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_STRING
      "naturalnocasecmp_to"
      2920860731L
      (String.typ @-> String.typ @-> returning Int.typ)
      Int.s x0  x1 

    (** Like \[method naturalcasecmp_to\] but prioritizes strings that begin with periods (\[code\].\[/code\]) and underscores (\[code\]_\[/code\]) before any other character. Useful when sorting folders or file names.
To get a \[bool\] result from a string comparison, use the \[code\]==\[/code\] operator instead. See also \[method filenocasecmp_to\], \[method naturalcasecmp_to\], and \[method casecmp_to\]. *)
    let filecasecmp_to x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_STRING
      "filecasecmp_to"
      2920860731L
      (String.typ @-> String.typ @-> returning Int.typ)
      Int.s x0  x1 

    (** Like \[method naturalnocasecmp_to\] but prioritizes strings that begin with periods (\[code\].\[/code\]) and underscores (\[code\]_\[/code\]) before any other character. Useful when sorting folders or file names.
To get a \[bool\] result from a string comparison, use the \[code\]==\[/code\] operator instead. See also \[method filecasecmp_to\], \[method naturalnocasecmp_to\], and \[method nocasecmp_to\]. *)
    let filenocasecmp_to x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_STRING
      "filenocasecmp_to"
      2920860731L
      (String.typ @-> String.typ @-> returning Int.typ)
      Int.s x0  x1 

    (** Returns the number of characters in the string. Empty strings (\[code\]""""\[/code\]) always return \[code\]0\[/code\]. See also \[method is_empty\]. *)
    let length x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_STRING
      "length"
      3173160232L
      (String.typ @-> returning Int.typ)
      Int.s x0 

    (** Returns part of the string from the position \[param from\] with length \[param len\]. If \[param len\] is \[code\]-1\[/code\] (as by default), returns the rest of the string starting from the given position. *)
    let substr x0  x1  x2  = 
    foreign_builtin_method2
      GlobalEnum.VariantType._TYPE_STRING
      "substr"
      787537301L
      (Int.typ @-> Int.typ @-> String.typ @-> returning String.typ)
      String.s x0  x1  x2 

    (** Splits the string using a \[param delimiter\] and returns the substring at index \[param slice\]. Returns the original string if \[param delimiter\] does not occur in the string. Returns an empty string if the \[param slice\] does not exist.
This is faster than \[method split\], if you only need one substring.
\[codeblock\]
print(""i/am/example/hi"".get_slice(""/"", 2)) # Prints ""example""
\[/codeblock\] *)
    let get_slice x0  x1  x2  = 
    foreign_builtin_method2
      GlobalEnum.VariantType._TYPE_STRING
      "get_slice"
      3535100402L
      (String.typ @-> Int.typ @-> String.typ @-> returning String.typ)
      String.s x0  x1  x2 

    (** Splits the string using a Unicode character with code \[param delimiter\] and returns the substring at index \[param slice\]. Returns an empty string if the \[param slice\] does not exist.
This is faster than \[method split\], if you only need one substring. *)
    let get_slicec x0  x1  x2  = 
    foreign_builtin_method2
      GlobalEnum.VariantType._TYPE_STRING
      "get_slicec"
      787537301L
      (Int.typ @-> Int.typ @-> String.typ @-> returning String.typ)
      String.s x0  x1  x2 

    (** Returns the total number of slices when the string is split with the given \[param delimiter\] (see \[method split\]). *)
    let get_slice_count x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_STRING
      "get_slice_count"
      2920860731L
      (String.typ @-> String.typ @-> returning Int.typ)
      Int.s x0  x1 

    (** Returns the index of the \[b\]first\[/b\] occurrence of \[param what\] in this string, or \[code\]-1\[/code\] if there are none. The search''s start can be specified with \[param from\], continuing to the end of the string.
\[codeblocks\]
\[gdscript\]
print(""Team"".find(""I"")) # Prints -1

print(""Potato"".find(""t""))    # Prints 2
print(""Potato"".find(""t"", 3)) # Prints 4
print(""Potato"".find(""t"", 5)) # Prints -1
\[/gdscript\]
\[csharp\]
GD.Print(""Team"".Find(""I"")); // Prints -1

GD.Print(""Potato"".Find(""t""));    // Prints 2
GD.Print(""Potato"".Find(""t"", 3)); // Prints 4
GD.Print(""Potato"".Find(""t"", 5)); // Prints -1
\[/csharp\]
\[/codeblocks\]
\[b\]Note:\[/b\] If you just want to know whether the string contains \[param what\], use \[method contains\]. In GDScript, you may also use the \[code\]in\[/code\] operator. *)
    let find x0  x1  x2  = 
    foreign_builtin_method2
      GlobalEnum.VariantType._TYPE_STRING
      "find"
      1760645412L
      (String.typ @-> Int.typ @-> String.typ @-> returning Int.typ)
      Int.s x0  x1  x2 

    (** Returns the index of the \[b\]first\[/b\] \[b\]case-insensitive\[/b\] occurrence of \[param what\] in this string, or \[code\]-1\[/code\] if there are none. The starting search index can be specified with \[param from\], continuing to the end of the string. *)
    let findn x0  x1  x2  = 
    foreign_builtin_method2
      GlobalEnum.VariantType._TYPE_STRING
      "findn"
      1760645412L
      (String.typ @-> Int.typ @-> String.typ @-> returning Int.typ)
      Int.s x0  x1  x2 

    (** Returns the number of occurrences of the substring \[param what\] between \[param from\] and \[param to\] positions. If \[param to\] is 0, the search continues until the end of the string. *)
    let count x0  x1  x2  x3  = 
    foreign_builtin_method3
      GlobalEnum.VariantType._TYPE_STRING
      "count"
      2343087891L
      (String.typ @-> Int.typ @-> Int.typ @-> String.typ @-> returning Int.typ)
      Int.s x0  x1  x2  x3 

    (** Returns the number of occurrences of the substring \[param what\] between \[param from\] and \[param to\] positions, \[b\]ignoring case\[/b\]. If \[param to\] is 0, the search continues until the end of the string. *)
    let countn x0  x1  x2  x3  = 
    foreign_builtin_method3
      GlobalEnum.VariantType._TYPE_STRING
      "countn"
      2343087891L
      (String.typ @-> Int.typ @-> Int.typ @-> String.typ @-> returning Int.typ)
      Int.s x0  x1  x2  x3 

    (** Returns the index of the \[b\]last\[/b\] occurrence of \[param what\] in this string, or \[code\]-1\[/code\] if there are none. The search''s start can be specified with \[param from\], continuing to the beginning of the string. This method is the reverse of \[method find\]. *)
    let rfind x0  x1  x2  = 
    foreign_builtin_method2
      GlobalEnum.VariantType._TYPE_STRING
      "rfind"
      1760645412L
      (String.typ @-> Int.typ @-> String.typ @-> returning Int.typ)
      Int.s x0  x1  x2 

    (** Returns the index of the \[b\]last\[/b\] \[b\]case-insensitive\[/b\] occurrence of \[param what\] in this string, or \[code\]-1\[/code\] if there are none. The starting search index can be specified with \[param from\], continuing to the beginning of the string. This method is the reverse of \[method findn\]. *)
    let rfindn x0  x1  x2  = 
    foreign_builtin_method2
      GlobalEnum.VariantType._TYPE_STRING
      "rfindn"
      1760645412L
      (String.typ @-> Int.typ @-> String.typ @-> returning Int.typ)
      Int.s x0  x1  x2 

    (** Does a simple expression match (also called ""glob"" or ""globbing""), where \[code\] * \[/code\] matches zero or more arbitrary characters and \[code\]?\[/code\] matches any single character except a period (\[code\].\[/code\]). An empty string or empty expression always evaluates to \[code\]false\[/code\]. *)
    let match_ x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_STRING
      "match_"
      2566493496L
      (String.typ @-> String.typ @-> returning Bool.typ)
      Bool.s x0  x1 

    (** Does a simple \[b\]case-insensitive\[/b\] expression match, where \[code\] * \[/code\] matches zero or more arbitrary characters and \[code\]?\[/code\] matches any single character except a period (\[code\].\[/code\]). An empty string or empty expression always evaluates to \[code\]false\[/code\]. *)
    let matchn x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_STRING
      "matchn"
      2566493496L
      (String.typ @-> String.typ @-> returning Bool.typ)
      Bool.s x0  x1 

    (** Returns \[code\]true\[/code\] if the string begins with the given \[param text\]. See also \[method ends_with\]. *)
    let begins_with x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_STRING
      "begins_with"
      2566493496L
      (String.typ @-> String.typ @-> returning Bool.typ)
      Bool.s x0  x1 

    (** Returns \[code\]true\[/code\] if the string ends with the given \[param text\]. See also \[method begins_with\]. *)
    let ends_with x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_STRING
      "ends_with"
      2566493496L
      (String.typ @-> String.typ @-> returning Bool.typ)
      Bool.s x0  x1 

    (** Returns \[code\]true\[/code\] if all characters of this string can be found in \[param text\] in their original order.
\[codeblock\]
var text = ""Wow, incredible!""

print(""inedible"".is_subsequence_of(text)) # Prints true
print(""Word!"".is_subsequence_of(text))    # Prints true
print(""Window"".is_subsequence_of(text))   # Prints false
print("""".is_subsequence_of(text))         # Prints true
\[/codeblock\] *)
    let is_subsequence_of x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_STRING
      "is_subsequence_of"
      2566493496L
      (String.typ @-> String.typ @-> returning Bool.typ)
      Bool.s x0  x1 

    (** Returns \[code\]true\[/code\] if all characters of this string can be found in \[param text\] in their original order, \[b\]ignoring case\[/b\]. *)
    let is_subsequence_ofn x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_STRING
      "is_subsequence_ofn"
      2566493496L
      (String.typ @-> String.typ @-> returning Bool.typ)
      Bool.s x0  x1 

    (** Returns an array containing the bigrams (pairs of consecutive characters) of this string.
\[codeblock\]
print(""Get up!"".bigrams()) # Prints \[""Ge"", ""et"", ""t "", "" u"", ""up"", ""p!""\]
\[/codeblock\] *)
    let bigrams x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_STRING
      "bigrams"
      747180633L
      (String.typ @-> returning PackedStringArray.typ)
      PackedStringArray.s x0 

    (** Returns the similarity index (\[url=https://en.wikipedia.org/wiki/S%C3%B8rensen%E2%80%93Dice_coefficient\]Srensen-Dice coefficient\[/url\]) of this string compared to another. A result of \[code\]1.0\[/code\] means totally similar, while \[code\]0.0\[/code\] means totally dissimilar.
\[codeblock\]
print(""ABC123"".similarity(""ABC123"")) # Prints 1.0
print(""ABC123"".similarity(""XYZ456"")) # Prints 0.0
print(""ABC123"".similarity(""123ABC"")) # Prints 0.8
print(""ABC123"".similarity(""abc123"")) # Prints 0.4
\[/codeblock\] *)
    let similarity x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_STRING
      "similarity"
      2697460964L
      (String.typ @-> String.typ @-> returning Float.typ)
      Float.s x0  x1 

    (** Formats the string by replacing all occurrences of \[param placeholder\] with the elements of \[param values\].
\[param values\] can be a \[Dictionary\], an \[Array\], or an \[Object\]. Any underscores in \[param placeholder\] will be replaced with the corresponding keys in advance. Array elements use their index as keys.
\[codeblock\]
# Prints ""Waiting for Godot is a play by Samuel Beckett, and Godot Engine is named after it.""
var use_array_values = ""Waiting for \{!0\} is a play by \{!1\}, and \{!0\} Engine is named after it.""
print(use_array_values.format(\[""Godot"", ""Samuel Beckett""\]))

# Prints ""User 42 is Godot.""
print(""User \{!id\} is \{!name\}."".format(\{!""id"": 42, ""name"": ""Godot""\}))
\[/codeblock\]
Some additional handling is performed when \[param values\] is an \[Array\]. If \[param placeholder\] does not contain an underscore, the elements of the \[param values\] array will be used to replace one occurrence of the placeholder in order; If an element of \[param values\] is another 2-element array, it''ll be interpreted as a key-value pair.
\[codeblock\]
# Prints ""User 42 is Godot.""
print(""User \{!\} is \{!\}."".format(\[42, ""Godot""\], ""\{!\}""))
print(""User \{!id\} is \{!name\}."".format(\[\[""id"", 42\], \[""name"", ""Godot""\]\]))
\[/codeblock\]
When passing an \[Object\], the property names from \[method Object.get_property_list\] are used as keys.
\[codeblock\]
# Prints ""Visible true, position (0, 0)""
var node = Node2D.new()
print(""Visible \{!visible\}, position \{!position\}"".format(node))
\[/codeblock\]
See also the \[url=$DOCS_URL/tutorials/scripting/gdscript/gdscript_format_string.html\]GDScript format string\[/url\] tutorial.
\[b\]Note:\[/b\] Each replacement is done sequentially for each element of \[param values\], \[b\]not\[/b\] all at once. This means that if any element is inserted and it contains another placeholder, it may be changed by the next replacement. While this can be very useful, it often causes unexpected results. If not necessary, make sure \[param values\]''s elements do not contain placeholders.
\[codeblock\]
print(""\{!0\} \{!1\}"".format(\[""\{!1\}"", ""x""\]))           # Prints ""x x""
print(""\{!0\} \{!1\}"".format(\[""x"", ""\{!0\}""\]))           # Prints ""x \{!0\}""
print(""\{!a\} \{!b\}"".format(\{!""a"": ""\{!b\}"", ""b"": ""c""\})) # Prints ""c c""
print(""\{!a\} \{!b\}"".format(\{!""b"": ""c"", ""a"": ""\{!b\}""\})) # Prints ""\{!b\} c""
\[/codeblock\]
\[b\]Note:\[/b\] In C#, it''s recommended to \[url=https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/tokens/interpolated\]interpolate strings with ""$""\[/url\], instead. *)
    let format x0  x1  x2  = 
    foreign_builtin_method2
      GlobalEnum.VariantType._TYPE_STRING
      "format"
      3212199029L
      (Variant.typ @-> String.typ @-> String.typ @-> returning String.typ)
      String.s x0  x1  x2 

    (** Replaces all occurrences of \[param what\] inside the string with the given \[param forwhat\]. *)
    let replace x0  x1  x2  = 
    foreign_builtin_method2
      GlobalEnum.VariantType._TYPE_STRING
      "replace"
      1340436205L
      (String.typ @-> String.typ @-> String.typ @-> returning String.typ)
      String.s x0  x1  x2 

    (** Replaces all \[b\]case-insensitive\[/b\] occurrences of \[param what\] inside the string with the given \[param forwhat\]. *)
    let replacen x0  x1  x2  = 
    foreign_builtin_method2
      GlobalEnum.VariantType._TYPE_STRING
      "replacen"
      1340436205L
      (String.typ @-> String.typ @-> String.typ @-> returning String.typ)
      String.s x0  x1  x2 

    (** Repeats this string a number of times. \[param count\] needs to be greater than \[code\]0\[/code\]. Otherwise, returns an empty string. *)
    let repeat x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_STRING
      "repeat"
      2162347432L
      (Int.typ @-> String.typ @-> returning String.typ)
      String.s x0  x1 

    (** Returns the copy of this string in reverse order. This operation works on unicode codepoints, rather than sequences of codepoints, and may break things like compound letters or emojis. *)
    let reverse x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_STRING
      "reverse"
      3942272618L
      (String.typ @-> returning String.typ)
      String.s x0 

    (** Inserts \[param what\] at the given \[param position\] in the string. *)
    let insert x0  x1  x2  = 
    foreign_builtin_method2
      GlobalEnum.VariantType._TYPE_STRING
      "insert"
      248737229L
      (Int.typ @-> String.typ @-> String.typ @-> returning String.typ)
      String.s x0  x1  x2 

    (** Returns a string with \[param chars\] characters erased starting from \[param position\]. If \[param chars\] goes beyond the string''s length given the specified \[param position\], fewer characters will be erased from the returned string. Returns an empty string if either \[param position\] or \[param chars\] is negative. Returns the original string unmodified if \[param chars\] is \[code\]0\[/code\]. *)
    let erase x0  x1  x2  = 
    foreign_builtin_method2
      GlobalEnum.VariantType._TYPE_STRING
      "erase"
      787537301L
      (Int.typ @-> Int.typ @-> String.typ @-> returning String.typ)
      String.s x0  x1  x2 

    (** Changes the appearance of the string: replaces underscores (\[code\]_\[/code\]) with spaces, adds spaces before uppercase letters in the middle of a word, converts all letters to lowercase, then converts the first one and each one following a space to uppercase.
\[codeblocks\]
\[gdscript\]
""move_local_x"".capitalize()   # Returns ""Move Local X""
""sceneFile_path"".capitalize() # Returns ""Scene File Path""
""2D, FPS, PNG"".capitalize()   # Returns ""2d, Fps, Png""
\[/gdscript\]
\[csharp\]
""move_local_x"".Capitalize();   // Returns ""Move Local X""
""sceneFile_path"".Capitalize(); // Returns ""Scene File Path""
""2D, FPS, PNG"".Capitalize();   // Returns ""2d, Fps, Png""
\[/csharp\]
\[/codeblocks\] *)
    let capitalize x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_STRING
      "capitalize"
      3942272618L
      (String.typ @-> returning String.typ)
      String.s x0 

    (** Returns the string converted to \[code\]camelCase\[/code\]. *)
    let to_camel_case x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_STRING
      "to_camel_case"
      3942272618L
      (String.typ @-> returning String.typ)
      String.s x0 

    (** Returns the string converted to \[code\]PascalCase\[/code\]. *)
    let to_pascal_case x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_STRING
      "to_pascal_case"
      3942272618L
      (String.typ @-> returning String.typ)
      String.s x0 

    (** Returns the string converted to \[code\]snake_case\[/code\].
\[b\]Note:\[/b\] Numbers followed by a \[i\]single\[/i\] letter are not separated in the conversion to keep some words (such as ""2D"") together.
\[codeblocks\]
\[gdscript\]
""Node2D"".to_snake_case()               # Returns ""node_2d""
""2nd place"".to_snake_case()            # Returns ""2_nd_place""
""Texture3DAssetFolder"".to_snake_case() # Returns ""texture_3d_asset_folder""
\[/gdscript\]
\[csharp\]
""Node2D"".ToSnakeCase();               // Returns ""node_2d""
""2nd place"".ToSnakeCase();            // Returns ""2_nd_place""
""Texture3DAssetFolder"".ToSnakeCase(); // Returns ""texture_3d_asset_folder""
\[/csharp\]
\[/codeblocks\] *)
    let to_snake_case x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_STRING
      "to_snake_case"
      3942272618L
      (String.typ @-> returning String.typ)
      String.s x0 

    (** Splits the string using a \[param delimiter\] and returns an array of the substrings. If \[param delimiter\] is an empty string, each substring will be a single character. This method is the opposite of \[method join\].
If \[param allow_empty\] is \[code\]false\[/code\], empty strings between adjacent delimiters are excluded from the array.
If \[param maxsplit\] is greater than \[code\]0\[/code\], the number of splits may not exceed \[param maxsplit\]. By default, the entire string is split.
\[codeblocks\]
\[gdscript\]
var some_array = ""One,Two,Three,Four"".split("","", true, 2)

print(some_array.size()) # Prints 3
print(some_array\[0\])     # Prints ""One""
print(some_array\[1\])     # Prints ""Two""
print(some_array\[2\])     # Prints ""Three,Four""
\[/gdscript\]
\[csharp\]
// C#''s `Split()` does not support the `maxsplit` parameter.
var someArray = ""One,Two,Three"".Split("","");

GD.Print(someArray\[0\]); // Prints ""One""
GD.Print(someArray\[1\]); // Prints ""Two""
GD.Print(someArray\[2\]); // Prints ""Three""
\[/csharp\]
\[/codeblocks\]
\[b\]Note:\[/b\] If you only need one substring from the array, consider using \[method get_slice\] which is faster. If you need to split strings with more complex rules, use the \[RegEx\] class instead. *)
    let split x0  x1  x2  x3  = 
    foreign_builtin_method3
      GlobalEnum.VariantType._TYPE_STRING
      "split"
      1252735785L
      (String.typ @-> Bool.typ @-> Int.typ @-> String.typ @-> returning PackedStringArray.typ)
      PackedStringArray.s x0  x1  x2  x3 

    (** Splits the string using a \[param delimiter\] and returns an array of the substrings, starting from the end of the string. The splits in the returned array appear in the same order as the original string. If \[param delimiter\] is an empty string, each substring will be a single character.
If \[param allow_empty\] is \[code\]false\[/code\], empty strings between adjacent delimiters are excluded from the array.
If \[param maxsplit\] is greater than \[code\]0\[/code\], the number of splits may not exceed \[param maxsplit\]. By default, the entire string is split, which is mostly identical to \[method split\].
\[codeblocks\]
\[gdscript\]
var some_string = ""One,Two,Three,Four""
var some_array = some_string.rsplit("","", true, 1)

print(some_array.size()) # Prints 2
print(some_array\[0\])     # Prints ""One,Two,Three""
print(some_array\[1\])     # Prints ""Four""
\[/gdscript\]
\[csharp\]
// In C#, there is no String.RSplit() method.
\[/csharp\]
\[/codeblocks\] *)
    let rsplit x0  x1  x2  x3  = 
    foreign_builtin_method3
      GlobalEnum.VariantType._TYPE_STRING
      "rsplit"
      1252735785L
      (String.typ @-> Bool.typ @-> Int.typ @-> String.typ @-> returning PackedStringArray.typ)
      PackedStringArray.s x0  x1  x2  x3 

    (** Splits the string into floats by using a \[param delimiter\] and returns a \[PackedFloat64Array\].
If \[param allow_empty\] is \[code\]false\[/code\], empty or invalid \[float\] conversions between adjacent delimiters are excluded.
\[codeblock\]
var a = ""1,2,4.5"".split_floats("","")         # a is \[1.0, 2.0, 4.5\]
var c = ""1| ||4.5"".split_floats(""|"")        # c is \[1.0, 0.0, 0.0, 4.5\]
var b = ""1| ||4.5"".split_floats(""|"", false) # b is \[1.0, 4.5\]
\[/codeblock\] *)
    let split_floats x0  x1  x2  = 
    foreign_builtin_method2
      GlobalEnum.VariantType._TYPE_STRING
      "split_floats"
      2092079095L
      (String.typ @-> Bool.typ @-> String.typ @-> returning PackedFloat64Array.typ)
      PackedFloat64Array.s x0  x1  x2 

    (** Returns the concatenation of \[param parts\]'' elements, with each element separated by the string calling this method. This method is the opposite of \[method split\].
\[codeblocks\]
\[gdscript\]
var fruits = \[""Apple"", ""Orange"", ""Pear"", ""Kiwi""\]

print("", "".join(fruits))  # Prints ""Apple, Orange, Pear, Kiwi""
print(""---"".join(fruits)) # Prints ""Apple---Orange---Pear---Kiwi""
\[/gdscript\]
\[csharp\]
string\[\] fruits = \[""Apple"", ""Orange"", ""Pear"", ""Kiwi""\];

// In C#, this method is static.
GD.Print(string.Join("", "", fruits));  // Prints ""Apple, Orange, Pear, Kiwi""
GD.Print(string.Join(""---"", fruits)); // Prints ""Apple---Orange---Pear---Kiwi""
\[/csharp\]
\[/codeblocks\] *)
    let join x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_STRING
      "join"
      3595973238L
      (PackedStringArray.typ @-> String.typ @-> returning String.typ)
      String.s x0  x1 

    (** Returns the string converted to \[code\]UPPERCASE\[/code\]. *)
    let to_upper x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_STRING
      "to_upper"
      3942272618L
      (String.typ @-> returning String.typ)
      String.s x0 

    (** Returns the string converted to \[code\]lowercase\[/code\]. *)
    let to_lower x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_STRING
      "to_lower"
      3942272618L
      (String.typ @-> returning String.typ)
      String.s x0 

    (** Returns the first \[param length\] characters from the beginning of the string. If \[param length\] is negative, strips the last \[param length\] characters from the string''s end.
\[codeblock\]
print(""Hello World!"".left(3))  # Prints ""Hel""
print(""Hello World!"".left(-4)) # Prints ""Hello Wo""
\[/codeblock\] *)
    let left x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_STRING
      "left"
      2162347432L
      (Int.typ @-> String.typ @-> returning String.typ)
      String.s x0  x1 

    (** Returns the last \[param length\] characters from the end of the string. If \[param length\] is negative, strips the first \[param length\] characters from the string''s beginning.
\[codeblock\]
print(""Hello World!"".right(3))  # Prints ""ld!""
print(""Hello World!"".right(-4)) # Prints ""o World!""
\[/codeblock\] *)
    let right x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_STRING
      "right"
      2162347432L
      (Int.typ @-> String.typ @-> returning String.typ)
      String.s x0  x1 

    (** Strips all non-printable characters from the beginning and the end of the string. These include spaces, tabulations (\[code\]\t\[/code\]), and newlines (\[code\]\n\[/code\] \[code\]\r\[/code\]).
If \[param left\] is \[code\]false\[/code\], ignores the string''s beginning. Likewise, if \[param right\] is \[code\]false\[/code\], ignores the string''s end. *)
    let strip_edges x0  x1  x2  = 
    foreign_builtin_method2
      GlobalEnum.VariantType._TYPE_STRING
      "strip_edges"
      907855311L
      (Bool.typ @-> Bool.typ @-> String.typ @-> returning String.typ)
      String.s x0  x1  x2 

    (** Strips all escape characters from the string. These include all non-printable control characters of the first page of the ASCII table (values from 0 to 31), such as tabulation (\[code\]\t\[/code\]) and newline (\[code\]\n\[/code\], \[code\]\r\[/code\]) characters, but \[i\]not\[/i\] spaces. *)
    let strip_escapes x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_STRING
      "strip_escapes"
      3942272618L
      (String.typ @-> returning String.typ)
      String.s x0 

    (** Removes a set of characters defined in \[param chars\] from the string''s beginning. See also \[method rstrip\].
\[b\]Note:\[/b\] \[param chars\] is not a prefix. Use \[method trim_prefix\] to remove a single prefix, rather than a set of characters. *)
    let lstrip x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_STRING
      "lstrip"
      3134094431L
      (String.typ @-> String.typ @-> returning String.typ)
      String.s x0  x1 

    (** Removes a set of characters defined in \[param chars\] from the string''s end. See also \[method lstrip\].
\[b\]Note:\[/b\] \[param chars\] is not a suffix. Use \[method trim_suffix\] to remove a single suffix, rather than a set of characters. *)
    let rstrip x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_STRING
      "rstrip"
      3134094431L
      (String.typ @-> String.typ @-> returning String.typ)
      String.s x0  x1 

    (** If the string is a valid file name or path, returns the file extension without the leading period (\[code\].\[/code\]). Otherwise, returns an empty string.
\[codeblock\]
var a = ""/path/to/file.txt"".get_extension() # a is ""txt""
var b = ""cool.txt"".get_extension()          # b is ""txt""
var c = ""cool.font.tres"".get_extension()    # c is ""tres""
var d = "".pack1"".get_extension()            # d is ""pack1""

var e = ""file.txt."".get_extension()  # e is """"
var f = ""file.txt.."".get_extension() # f is """"
var g = ""txt"".get_extension()        # g is """"
var h = """".get_extension()           # h is """"
\[/codeblock\] *)
    let get_extension x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_STRING
      "get_extension"
      3942272618L
      (String.typ @-> returning String.typ)
      String.s x0 

    (** If the string is a valid file path, returns the full file path, without the extension.
\[codeblock\]
var base = ""/path/to/file.txt"".get_basename() # base is ""/path/to/file""
\[/codeblock\] *)
    let get_basename x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_STRING
      "get_basename"
      3942272618L
      (String.typ @-> returning String.typ)
      String.s x0 

    (** Concatenates \[param file\] at the end of the string as a subpath, adding \[code\]/\[/code\] if necessary.
\[b\]Example:\[/b\] \[code\]""this/is"".path_join(""path"") == ""this/is/path""\[/code\]. *)
    let path_join x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_STRING
      "path_join"
      3134094431L
      (String.typ @-> String.typ @-> returning String.typ)
      String.s x0  x1 

    (** Returns the character code at position \[param at\]. *)
    let unicode_at x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_STRING
      "unicode_at"
      4103005248L
      (Int.typ @-> String.typ @-> returning Int.typ)
      Int.s x0  x1 

    (** Indents every line of the string with the given \[param prefix\]. Empty lines are not indented. See also \[method dedent\] to remove indentation.
For example, the string can be indented with two tabulations using \[code\]""\t\t""\[/code\], or four spaces using \[code\]""    ""\[/code\]. *)
    let indent x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_STRING
      "indent"
      3134094431L
      (String.typ @-> String.typ @-> returning String.typ)
      String.s x0  x1 

    (** Returns a copy of the string with indentation (leading tabs and spaces) removed. See also \[method indent\] to add indentation. *)
    let dedent x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_STRING
      "dedent"
      3942272618L
      (String.typ @-> returning String.typ)
      String.s x0 

    (** Returns the 32-bit hash value representing the string''s contents.
\[b\]Note:\[/b\] Strings with equal hash values are \[i\]not\[/i\] guaranteed to be the same, as a result of hash collisions. On the contrary, strings with different hash values are guaranteed to be different. *)
    let hash x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_STRING
      "hash"
      3173160232L
      (String.typ @-> returning Int.typ)
      Int.s x0 

    (** Returns the \[url=https://en.wikipedia.org/wiki/MD5\]MD5 hash\[/url\] of the string as another \[String\]. *)
    let md5_text x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_STRING
      "md5_text"
      3942272618L
      (String.typ @-> returning String.typ)
      String.s x0 

    (** Returns the \[url=https://en.wikipedia.org/wiki/SHA-1\]SHA-1\[/url\] hash of the string as another \[String\]. *)
    let sha1_text x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_STRING
      "sha1_text"
      3942272618L
      (String.typ @-> returning String.typ)
      String.s x0 

    (** Returns the \[url=https://en.wikipedia.org/wiki/SHA-2\]SHA-256\[/url\] hash of the string as another \[String\]. *)
    let sha256_text x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_STRING
      "sha256_text"
      3942272618L
      (String.typ @-> returning String.typ)
      String.s x0 

    (** Returns the \[url=https://en.wikipedia.org/wiki/MD5\]MD5 hash\[/url\] of the string as a \[PackedByteArray\]. *)
    let md5_buffer x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_STRING
      "md5_buffer"
      247621236L
      (String.typ @-> returning PackedByteArray.typ)
      PackedByteArray.s x0 

    (** Returns the \[url=https://en.wikipedia.org/wiki/SHA-1\]SHA-1\[/url\] hash of the string as a \[PackedByteArray\]. *)
    let sha1_buffer x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_STRING
      "sha1_buffer"
      247621236L
      (String.typ @-> returning PackedByteArray.typ)
      PackedByteArray.s x0 

    (** Returns the \[url=https://en.wikipedia.org/wiki/SHA-2\]SHA-256\[/url\] hash of the string as a \[PackedByteArray\]. *)
    let sha256_buffer x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_STRING
      "sha256_buffer"
      247621236L
      (String.typ @-> returning PackedByteArray.typ)
      PackedByteArray.s x0 

    (** Returns \[code\]true\[/code\] if the string''s length is \[code\]0\[/code\] (\[code\]""""\[/code\]). See also \[method length\]. *)
    let is_empty x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_STRING
      "is_empty"
      3918633141L
      (String.typ @-> returning Bool.typ)
      Bool.s x0 

    (** Returns \[code\]true\[/code\] if the string contains \[param what\]. In GDScript, this corresponds to the \[code\]in\[/code\] operator.
\[codeblocks\]
\[gdscript\]
print(""Node"".contains(""de"")) # Prints true
print(""team"".contains(""I""))  # Prints false
print(""I"" in ""team"")         # Prints false
\[/gdscript\]
\[csharp\]
GD.Print(""Node"".Contains(""de"")); // Prints True
GD.Print(""team"".Contains(""I""));  // Prints False
\[/csharp\]
\[/codeblocks\]
If you need to know where \[param what\] is within the string, use \[method find\]. See also \[method containsn\]. *)
    let contains x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_STRING
      "contains"
      2566493496L
      (String.typ @-> String.typ @-> returning Bool.typ)
      Bool.s x0  x1 

    (** Returns \[code\]true\[/code\] if the string contains \[param what\], \[b\]ignoring case\[/b\].
If you need to know where \[param what\] is within the string, use \[method findn\]. See also \[method contains\]. *)
    let containsn x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_STRING
      "containsn"
      2566493496L
      (String.typ @-> String.typ @-> returning Bool.typ)
      Bool.s x0  x1 

    (** Returns \[code\]true\[/code\] if the string is a path to a file or directory, and its starting point is explicitly defined. This method is the opposite of \[method is_relative_path\].
This includes all paths starting with \[code\]""res://""\[/code\], \[code\]""user://""\[/code\], \[code\]""C:\""\[/code\], \[code\]""/""\[/code\], etc. *)
    let is_absolute_path x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_STRING
      "is_absolute_path"
      3918633141L
      (String.typ @-> returning Bool.typ)
      Bool.s x0 

    (** Returns \[code\]true\[/code\] if the string is a path, and its starting point is dependent on context. The path could begin from the current directory, or the current \[Node\] (if the string is derived from a \[NodePath\]), and may sometimes be prefixed with \[code\]""./""\[/code\]. This method is the opposite of \[method is_absolute_path\]. *)
    let is_relative_path x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_STRING
      "is_relative_path"
      3918633141L
      (String.typ @-> returning Bool.typ)
      Bool.s x0 

    (** If the string is a valid file path, converts the string into a canonical path. This is the shortest possible path, without \[code\]""./""\[/code\], and all the unnecessary \[code\]""..""\[/code\] and \[code\]""/""\[/code\].
\[codeblock\]
var simple_path = ""./path/to///../file"".simplify_path()
print(simple_path) # Prints ""path/file""
\[/codeblock\] *)
    let simplify_path x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_STRING
      "simplify_path"
      3942272618L
      (String.typ @-> returning String.typ)
      String.s x0 

    (** If the string is a valid file path, returns the base directory name.
\[codeblock\]
var dir_path = ""/path/to/file.txt"".get_base_dir() # dir_path is ""/path/to""
\[/codeblock\] *)
    let get_base_dir x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_STRING
      "get_base_dir"
      3942272618L
      (String.typ @-> returning String.typ)
      String.s x0 

    (** If the string is a valid file path, returns the file name, including the extension.
\[codeblock\]
var file = ""/path/to/icon.png"".get_file() # file is ""icon.png""
\[/codeblock\] *)
    let get_file x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_STRING
      "get_file"
      3942272618L
      (String.typ @-> returning String.typ)
      String.s x0 

    (** Returns a copy of the string with special characters escaped using the XML standard. If \[param escape_quotes\] is \[code\]true\[/code\], the single quote (\[code\]''\[/code\]) and double quote (\[code\]""\[/code\]) characters are also escaped. *)
    let xml_escape x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_STRING
      "xml_escape"
      3429816538L
      (Bool.typ @-> String.typ @-> returning String.typ)
      String.s x0  x1 

    (** Returns a copy of the string with escaped characters replaced by their meanings according to the XML standard. *)
    let xml_unescape x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_STRING
      "xml_unescape"
      3942272618L
      (String.typ @-> returning String.typ)
      String.s x0 

    (** Encodes the string to URL-friendly format. This method is meant to properly encode the parameters in a URL when sending an HTTP request. See also \[method uri_decode\].
\[codeblocks\]
\[gdscript\]
var prefix = ""$DOCS_URL/?highlight=""
var url = prefix + ""Godot Engine:docs"".uri_encode()

print(url) # Prints ""$DOCS_URL/?highlight=Godot%20Engine%3%docs""
\[/gdscript\]
\[csharp\]
var prefix = ""$DOCS_URL/?highlight="";
var url = prefix + ""Godot Engine:docs"".URIEncode();

GD.Print(url); // Prints ""$DOCS_URL/?highlight=Godot%20Engine%3%docs""
\[/csharp\]
\[/codeblocks\] *)
    let uri_encode x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_STRING
      "uri_encode"
      3942272618L
      (String.typ @-> returning String.typ)
      String.s x0 

    (** Decodes the string from its URL-encoded format. This method is meant to properly decode the parameters in a URL when receiving an HTTP request. See also \[method uri_encode\].
\[codeblocks\]
\[gdscript\]
var url = ""$DOCS_URL/?highlight=Godot%20Engine%3%docs""
print(url.uri_decode()) # Prints ""$DOCS_URL/?highlight=Godot Engine:docs""
\[/gdscript\]
\[csharp\]
var url = ""$DOCS_URL/?highlight=Godot%20Engine%3%docs""
GD.Print(url.URIDecode()) // Prints ""$DOCS_URL/?highlight=Godot Engine:docs""
\[/csharp\]
\[/codeblocks\] *)
    let uri_decode x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_STRING
      "uri_decode"
      3942272618L
      (String.typ @-> returning String.typ)
      String.s x0 

    (** Returns a copy of the string with special characters escaped using the C language standard. *)
    let c_escape x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_STRING
      "c_escape"
      3942272618L
      (String.typ @-> returning String.typ)
      String.s x0 

    (** Returns a copy of the string with escaped characters replaced by their meanings. Supported escape sequences are \[code\]\''\[/code\], \[code\]\""\[/code\], \[code\]\\\[/code\], \[code\]\a\[/code\], \[code\]\b\[/code\], \[code\]\f\[/code\], \[code\]\n\[/code\], \[code\]\r\[/code\], \[code\]\t\[/code\], \[code\]\v\[/code\].
\[b\]Note:\[/b\] Unlike the GDScript parser, this method doesn''t support the \[code\]\uXXXX\[/code\] escape sequence. *)
    let c_unescape x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_STRING
      "c_unescape"
      3942272618L
      (String.typ @-> returning String.typ)
      String.s x0 

    (** Returns a copy of the string with special characters escaped using the JSON standard. Because it closely matches the C standard, it is possible to use \[method c_unescape\] to unescape the string, if necessary. *)
    let json_escape x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_STRING
      "json_escape"
      3942272618L
      (String.typ @-> returning String.typ)
      String.s x0 

    (** Returns a copy of the string with all characters that are not allowed in \[member Node.name\] (\[code\].\[/code\] \[code\]:\[/code\] \[code\]\@\[/code\] \[code\]/\[/code\] \[code\]""\[/code\] \[code\]%\[/code\]) replaced with underscores. *)
    let validate_node_name x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_STRING
      "validate_node_name"
      3942272618L
      (String.typ @-> returning String.typ)
      String.s x0 

    (** Returns a copy of the string with all characters that are not allowed in \[method is_valid_filename\] replaced with underscores. *)
    let validate_filename x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_STRING
      "validate_filename"
      3942272618L
      (String.typ @-> returning String.typ)
      String.s x0 

    (** Returns \[code\]true\[/code\] if this string is a valid ASCII identifier. A valid ASCII identifier may contain only letters, digits, and underscores (\[code\]_\[/code\]), and the first character may not be a digit.
\[codeblock\]
print(""node_2d"".is_valid_ascii_identifier())    # Prints true
print(""TYPE_FLOAT"".is_valid_ascii_identifier()) # Prints true
print(""1st_method"".is_valid_ascii_identifier()) # Prints false
print(""MyMethod#2"".is_valid_ascii_identifier()) # Prints false
\[/codeblock\]
See also \[method is_valid_unicode_identifier\]. *)
    let is_valid_ascii_identifier x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_STRING
      "is_valid_ascii_identifier"
      3918633141L
      (String.typ @-> returning Bool.typ)
      Bool.s x0 

    (** Returns \[code\]true\[/code\] if this string is a valid Unicode identifier.
A valid Unicode identifier must begin with a Unicode character of class \[code\]XID_Start\[/code\] or \[code\]""_""\[/code\], and may contain Unicode characters of class \[code\]XID_Continue\[/code\] in the other positions.
\[codeblock\]
print(""node_2d"".is_valid_unicode_identifier())      # Prints true
print(""1st_method"".is_valid_unicode_identifier())   # Prints false
print(""MyMethod#2"".is_valid_unicode_identifier())   # Prints false
print(""llkpessg"".is_valid_unicode_identifier()) # Prints true
print("""".is_valid_unicode_identifier()) # Prints true
print("""".is_valid_unicode_identifier())         # Prints true
\[/codeblock\]
See also \[method is_valid_ascii_identifier\].
\[b\]Note:\[/b\] This method checks identifiers the same way as GDScript. See \[method TextServer.is_valid_identifier\] for more advanced checks. *)
    let is_valid_unicode_identifier x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_STRING
      "is_valid_unicode_identifier"
      3918633141L
      (String.typ @-> returning Bool.typ)
      Bool.s x0 

    (** Returns \[code\]true\[/code\] if this string is a valid identifier. A valid identifier may contain only letters, digits and underscores (\[code\]_\[/code\]), and the first character may not be a digit.
\[codeblock\]
print(""node_2d"".is_valid_identifier())    # Prints true
print(""TYPE_FLOAT"".is_valid_identifier()) # Prints true
print(""1st_method"".is_valid_identifier()) # Prints false
print(""MyMethod#2"".is_valid_identifier()) # Prints false
\[/codeblock\] *)
    let is_valid_identifier x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_STRING
      "is_valid_identifier"
      3918633141L
      (String.typ @-> returning Bool.typ)
      Bool.s x0 

    (** Returns \[code\]true\[/code\] if this string represents a valid integer. A valid integer only contains digits, and may be prefixed with a positive (\[code\]+\[/code\]) or negative (\[code\]-\[/code\]) sign. See also \[method to_int\].
\[codeblock\]
print(""7"".is_valid_int())    # Prints true
print(""1.65"".is_valid_int()) # Prints false
print(""Hi"".is_valid_int())   # Prints false
print(""+3"".is_valid_int())   # Prints true
print(""-12"".is_valid_int())  # Prints true
\[/codeblock\] *)
    let is_valid_int x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_STRING
      "is_valid_int"
      3918633141L
      (String.typ @-> returning Bool.typ)
      Bool.s x0 

    (** Returns \[code\]true\[/code\] if this string represents a valid floating-point number. A valid float may contain only digits, one decimal point (\[code\].\[/code\]), and the exponent letter (\[code\]e\[/code\]). It may also be prefixed with a positive (\[code\]+\[/code\]) or negative (\[code\]-\[/code\]) sign. Any valid integer is also a valid float (see \[method is_valid_int\]). See also \[method to_float\].
\[codeblock\]
print(""1.7"".is_valid_float())   # Prints true
print(""24"".is_valid_float())    # Prints true
print(""7e3"".is_valid_float())   # Prints true
print(""Hello"".is_valid_float()) # Prints false
\[/codeblock\] *)
    let is_valid_float x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_STRING
      "is_valid_float"
      3918633141L
      (String.typ @-> returning Bool.typ)
      Bool.s x0 

    (** Returns \[code\]true\[/code\] if this string is a valid hexadecimal number. A valid hexadecimal number only contains digits or letters \[code\]A\[/code\] to \[code\]F\[/code\] (either uppercase or lowercase), and may be prefixed with a positive (\[code\]+\[/code\]) or negative (\[code\]-\[/code\]) sign.
If \[param with_prefix\] is \[code\]true\[/code\], the hexadecimal number needs to prefixed by \[code\]""0x""\[/code\] to be considered valid.
\[codeblock\]
print(""A08E"".is_valid_hex_number())    # Prints true
print(""-AbCdEf"".is_valid_hex_number()) # Prints true
print(""2.5"".is_valid_hex_number())     # Prints false

print(""0xDEADC0DE"".is_valid_hex_number(true)) # Prints true
\[/codeblock\] *)
    let is_valid_hex_number x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_STRING
      "is_valid_hex_number"
      593672999L
      (Bool.typ @-> String.typ @-> returning Bool.typ)
      Bool.s x0  x1 

    (** Returns \[code\]true\[/code\] if this string is a valid color in hexadecimal HTML notation. The string must be a hexadecimal value (see \[method is_valid_hex_number\]) of either 3, 4, 6 or 8 digits, and may be prefixed by a hash sign (\[code\]#\[/code\]). Other HTML notations for colors, such as names or \[code\]hsl()\[/code\], are not considered valid. See also \[method Color.html\]. *)
    let is_valid_html_color x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_STRING
      "is_valid_html_color"
      3918633141L
      (String.typ @-> returning Bool.typ)
      Bool.s x0 

    (** Returns \[code\]true\[/code\] if this string represents a well-formatted IPv4 or IPv6 address. This method considers \[url=https://en.wikipedia.org/wiki/Reserved_IP_addresses\]reserved IP addresses\[/url\] such as \[code\]""0.0.0.0""\[/code\] and \[code\]""ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff""\[/code\] as valid. *)
    let is_valid_ip_address x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_STRING
      "is_valid_ip_address"
      3918633141L
      (String.typ @-> returning Bool.typ)
      Bool.s x0 

    (** Returns \[code\]true\[/code\] if this string does not contain characters that are not allowed in file names (\[code\]:\[/code\] \[code\]/\[/code\] \[code\]\\[/code\] \[code\]?\[/code\] \[code\] * \[/code\] \[code\]""\[/code\] \[code\]|\[/code\] \[code\]%\[/code\] \[code\]<\[/code\] \[code\]>\[/code\]). *)
    let is_valid_filename x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_STRING
      "is_valid_filename"
      3918633141L
      (String.typ @-> returning Bool.typ)
      Bool.s x0 

    (** Converts the string representing an integer number into an \[int\]. This method removes any non-number character and stops at the first decimal point (\[code\].\[/code\]). See also \[method is_valid_int\].
\[codeblock\]
var a = ""123"".to_int()    # a is 123
var b = ""x1y2z3"".to_int() # b is 123
var c = ""-1.2.3"".to_int() # c is -1
var d = ""Hello!"".to_int() # d is 0
\[/codeblock\] *)
    let to_int x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_STRING
      "to_int"
      3173160232L
      (String.typ @-> returning Int.typ)
      Int.s x0 

    (** Converts the string representing a decimal number into a \[float\]. This method stops on the first non-number character, except the first decimal point (\[code\].\[/code\]) and the exponent letter (\[code\]e\[/code\]). See also \[method is_valid_float\].
\[codeblock\]
var a = ""12.35"".to_float()  # a is 12.35
var b = ""1.2.3"".to_float()  # b is 1.2
var c = ""12xy3"".to_float()  # c is 12.0
var d = ""1e3"".to_float()    # d is 1000.0
var e = ""Hello!"".to_float() # e is 0.0
\[/codeblock\] *)
    let to_float x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_STRING
      "to_float"
      466405837L
      (String.typ @-> returning Float.typ)
      Float.s x0 

    (** Converts the string representing a hexadecimal number into an \[int\]. The string may be optionally prefixed with \[code\]""0x""\[/code\], and an additional \[code\]-\[/code\] prefix for negative numbers.
\[codeblocks\]
\[gdscript\]
print(""0xff"".hex_to_int()) # Prints 255
print(""ab"".hex_to_int())   # Prints 171
\[/gdscript\]
\[csharp\]
GD.Print(""0xff"".HexToInt()); // Prints 255
GD.Print(""ab"".HexToInt());   // Prints 171
\[/csharp\]
\[/codeblocks\] *)
    let hex_to_int x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_STRING
      "hex_to_int"
      3173160232L
      (String.typ @-> returning Int.typ)
      Int.s x0 

    (** Converts the string representing a binary number into an \[int\]. The string may optionally be prefixed with \[code\]""0b""\[/code\], and an additional \[code\]-\[/code\] prefix for negative numbers.
\[codeblocks\]
\[gdscript\]
print(""101"".bin_to_int())   # Prints 5
print(""0b101"".bin_to_int()) # Prints 5
print(""-0b10"".bin_to_int()) # Prints -2
\[/gdscript\]
\[csharp\]
GD.Print(""101"".BinToInt());   // Prints 5
GD.Print(""0b101"".BinToInt()); // Prints 5
GD.Print(""-0b10"".BinToInt()); // Prints -2
\[/csharp\]
\[/codeblocks\] *)
    let bin_to_int x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_STRING
      "bin_to_int"
      3173160232L
      (String.typ @-> returning Int.typ)
      Int.s x0 

    (** Formats the string to be at least \[param min_length\] long by adding \[param character\]s to the left of the string, if necessary. See also \[method rpad\]. *)
    let lpad x0  x1  x2  = 
    foreign_builtin_method2
      GlobalEnum.VariantType._TYPE_STRING
      "lpad"
      248737229L
      (Int.typ @-> String.typ @-> String.typ @-> returning String.typ)
      String.s x0  x1  x2 

    (** Formats the string to be at least \[param min_length\] long, by adding \[param character\]s to the right of the string, if necessary. See also \[method lpad\]. *)
    let rpad x0  x1  x2  = 
    foreign_builtin_method2
      GlobalEnum.VariantType._TYPE_STRING
      "rpad"
      248737229L
      (Int.typ @-> String.typ @-> String.typ @-> returning String.typ)
      String.s x0  x1  x2 

    (** Formats the string representing a number to have an exact number of \[param digits\] \[i\]after\[/i\] the decimal point. *)
    let pad_decimals x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_STRING
      "pad_decimals"
      2162347432L
      (Int.typ @-> String.typ @-> returning String.typ)
      String.s x0  x1 

    (** Formats the string representing a number to have an exact number of \[param digits\] \[i\]before\[/i\] the decimal point. *)
    let pad_zeros x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_STRING
      "pad_zeros"
      2162347432L
      (Int.typ @-> String.typ @-> returning String.typ)
      String.s x0  x1 

    (** Removes the given \[param prefix\] from the start of the string, or returns the string unchanged. *)
    let trim_prefix x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_STRING
      "trim_prefix"
      3134094431L
      (String.typ @-> String.typ @-> returning String.typ)
      String.s x0  x1 

    (** Removes the given \[param suffix\] from the end of the string, or returns the string unchanged. *)
    let trim_suffix x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_STRING
      "trim_suffix"
      3134094431L
      (String.typ @-> String.typ @-> returning String.typ)
      String.s x0  x1 

    (** Converts the string to an \[url=https://en.wikipedia.org/wiki/ASCII\]ASCII\[/url\]/Latin-1 encoded \[PackedByteArray\]. This method is slightly faster than \[method to_utf8_buffer\], but replaces all unsupported characters with spaces. This is the inverse of \[method PackedByteArray.get_string_from_ascii\]. *)
    let to_ascii_buffer x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_STRING
      "to_ascii_buffer"
      247621236L
      (String.typ @-> returning PackedByteArray.typ)
      PackedByteArray.s x0 

    (** Converts the string to a \[url=https://en.wikipedia.org/wiki/UTF-8\]UTF-8\[/url\] encoded \[PackedByteArray\]. This method is slightly slower than \[method to_ascii_buffer\], but supports all UTF-8 characters. For most cases, prefer using this method. This is the inverse of \[method PackedByteArray.get_string_from_utf8\]. *)
    let to_utf8_buffer x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_STRING
      "to_utf8_buffer"
      247621236L
      (String.typ @-> returning PackedByteArray.typ)
      PackedByteArray.s x0 

    (** Converts the string to a \[url=https://en.wikipedia.org/wiki/UTF-16\]UTF-16\[/url\] encoded \[PackedByteArray\]. This is the inverse of \[method PackedByteArray.get_string_from_utf16\]. *)
    let to_utf16_buffer x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_STRING
      "to_utf16_buffer"
      247621236L
      (String.typ @-> returning PackedByteArray.typ)
      PackedByteArray.s x0 

    (** Converts the string to a \[url=https://en.wikipedia.org/wiki/UTF-32\]UTF-32\[/url\] encoded \[PackedByteArray\]. This is the inverse of \[method PackedByteArray.get_string_from_utf32\]. *)
    let to_utf32_buffer x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_STRING
      "to_utf32_buffer"
      247621236L
      (String.typ @-> returning PackedByteArray.typ)
      PackedByteArray.s x0 

    (** Decodes a hexadecimal string as a \[PackedByteArray\].
\[codeblocks\]
\[gdscript\]
var text = ""hello world""
var encoded = text.to_utf8_buffer().hex_encode() # outputs ""68656c6c6f20776f726c64""
print(buf.hex_decode().get_string_from_utf8())
\[/gdscript\]
\[csharp\]
var text = ""hello world"";
var encoded = text.ToUtf8Buffer().HexEncode(); // outputs ""68656c6c6f20776f726c64""
GD.Print(buf.HexDecode().GetStringFromUtf8());
\[/csharp\]
\[/codeblocks\] *)
    let hex_decode x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_STRING
      "hex_decode"
      247621236L
      (String.typ @-> returning PackedByteArray.typ)
      PackedByteArray.s x0 

    (** Converts the string to a \[url=https://en.wikipedia.org/wiki/Wide_character\]wide character\[/url\] (\[code\]wchar_t\[/code\], UTF-16 on Windows, UTF-32 on other platforms) encoded \[PackedByteArray\]. This is the inverse of \[method PackedByteArray.get_string_from_wchar\]. *)
    let to_wchar_buffer x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_STRING
      "to_wchar_buffer"
      247621236L
      (String.typ @-> returning PackedByteArray.typ)
      PackedByteArray.s x0 

    (** Converts the given \[param number\] to a string representation, in scientific notation.
\[codeblocks\]
\[gdscript\]
var n = -5.2e8
print(n)                        # Prints -520000000
print(String.num_scientific(n)) # Prints -5.2e+08
\[/gdscript\]
\[csharp\]
// This method is not implemented in C#.
// Use `string.ToString()` with ""e"" to achieve similar results.
var n = -5.2e8f;
GD.Print(n);                // Prints -520000000
GD.Print(n.ToString(""e1"")); // Prints -5.2e+008
\[/csharp\]
\[/codeblocks\]
\[b\]Note:\[/b\] In C#, this method is not implemented. To achieve similar results, see C#''s \[url=https://learn.microsoft.com/en-us/dotnet/standard/base-types/standard-numeric-format-strings\]Standard numeric format strings\[/url\] *)
    let num_scientific x0  = 
    foreign_builtin_method1_static
      GlobalEnum.VariantType._TYPE_STRING
      "num_scientific"
      2710373411L
      (Float.typ @-> returning String.typ)
      String.s x0 

    (** Converts a \[float\] to a string representation of a decimal number, with the number of decimal places specified in \[param decimals\].
If \[param decimals\] is \[code\]-1\[/code\] as by default, the string representation may only have up to 14 significant digits, with digits before the decimal point having priority over digits after.
Trailing zeros are not included in the string. The last digit is rounded, not truncated.
\[codeblock\]
String.num(3.141593)     # Returns ""3.141593""
String.num(3.141593, 3)  # Returns ""3.142""
String.num(3.14159300)   # Returns ""3.141593""

# Here, the last digit will be rounded up,
# which reduces the total digit count, since trailing zeros are removed:
String.num(42.129999, 5) # Returns ""42.13""

# If `decimals` is not specified, the maximum number of significant digits is 14:
String.num(-0.0000012345432123454321)     # Returns ""-0.00000123454321""
String.num(-10000.0000012345432123454321) # Returns ""-10000.0000012345""
\[/codeblock\] *)
    let num x0  x1  = 
    foreign_builtin_method2_static
      GlobalEnum.VariantType._TYPE_STRING
      "num"
      1555901022L
      (Float.typ @-> Int.typ @-> returning String.typ)
      String.s x0  x1 

    (** Converts the given \[param number\] to a string representation, with the given \[param base\].
By default, \[param base\] is set to decimal (\[code\]10\[/code\]). Other common bases in programming include binary (\[code\]2\[/code\]), \[url=https://en.wikipedia.org/wiki/Octal\]octal\[/url\] (\[code\]8\[/code\]), hexadecimal (\[code\]16\[/code\]).
If \[param capitalize_hex\] is \[code\]true\[/code\], digits higher than 9 are represented in uppercase. *)
    let num_int64 x0  x1  x2  = 
    foreign_builtin_method3_static
      GlobalEnum.VariantType._TYPE_STRING
      "num_int64"
      2111271071L
      (Int.typ @-> Int.typ @-> Bool.typ @-> returning String.typ)
      String.s x0  x1  x2 

    (** Converts the given unsigned \[int\] to a string representation, with the given \[param base\].
By default, \[param base\] is set to decimal (\[code\]10\[/code\]). Other common bases in programming include binary (\[code\]2\[/code\]), \[url=https://en.wikipedia.org/wiki/Octal\]octal\[/url\] (\[code\]8\[/code\]), hexadecimal (\[code\]16\[/code\]).
If \[param capitalize_hex\] is \[code\]true\[/code\], digits higher than 9 are represented in uppercase. *)
    let num_uint64 x0  x1  x2  = 
    foreign_builtin_method3_static
      GlobalEnum.VariantType._TYPE_STRING
      "num_uint64"
      2111271071L
      (Int.typ @-> Int.typ @-> Bool.typ @-> returning String.typ)
      String.s x0  x1  x2 

    (** Returns a single Unicode character from the decimal \[param char\]. You may use \[url=https://unicodelookup.com/\]unicodelookup.com\[/url\] or \[url=https://www.unicode.org/charts/\]unicode.org\[/url\] as points of reference.
\[codeblock\]
print(String.chr(65))     # Prints ""A""
print(String.chr(129302)) # Prints """" (robot face emoji)
\[/codeblock\] *)
    let chr x0  = 
    foreign_builtin_method1_static
      GlobalEnum.VariantType._TYPE_STRING
      "chr"
      897497541L
      (Int.typ @-> returning String.typ)
      String.s x0 

    (** Converts \[param size\] which represents a number of bytes into a human-readable form.
The result is in \[url=https://en.wikipedia.org/wiki/Binary_prefix#IEC_prefixes\]IEC prefix format\[/url\], which may end in either \[code\]""B""\[/code\], \[code\]""KiB""\[/code\], \[code\]""MiB""\[/code\], \[code\]""GiB""\[/code\], \[code\]""TiB""\[/code\], \[code\]""PiB""\[/code\], or \[code\]""EiB""\[/code\]. *)
    let humanize_size x0  = 
    foreign_builtin_method1_static
      GlobalEnum.VariantType._TYPE_STRING
      "humanize_size"
      897497541L
      (Int.typ @-> returning String.typ)
      String.s x0 








    let not x0  = 
    foreign_builtin_operator1 GlobalEnum.VariantType._TYPE_STRING None  GlobalEnum.VariantOperator._OP_NOT
      (funptr (String.typ @-> Bool.typ @-> returning void))
      Bool.s x0 







    (** Returns \[code\]true\[/code\] if both strings contain the same sequence of characters. *)
    let (=) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_STRING (Some GlobalEnum.VariantType._TYPE_STRING) GlobalEnum.VariantOperator._OP_EQUAL
      (funptr (String.typ @-> String.typ @-> Bool.typ @-> returning void))
      Bool.s
      Conv.String.of_ocaml
      Conv.String.of_ocaml
      Conv.Bool.to_ocaml x0  x1 

    (** Returns \[code\]true\[/code\] if both strings do not contain the same sequence of characters. *)
    let (<>) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_STRING (Some GlobalEnum.VariantType._TYPE_STRING) GlobalEnum.VariantOperator._OP_NOT_EQUAL
      (funptr (String.typ @-> String.typ @-> Bool.typ @-> returning void))
      Bool.s
      Conv.String.of_ocaml
      Conv.String.of_ocaml
      Conv.Bool.to_ocaml x0  x1 

    (** Returns \[code\]true\[/code\] if the left \[String\] comes before \[param right\] in \[url=https://en.wikipedia.org/wiki/List_of_Unicode_characters\]Unicode order\[/url\], which roughly matches the alphabetical order. Useful for sorting. *)
    let (<) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_STRING (Some GlobalEnum.VariantType._TYPE_STRING) GlobalEnum.VariantOperator._OP_LESS
      (funptr (String.typ @-> String.typ @-> Bool.typ @-> returning void))
      Bool.s
      Conv.String.of_ocaml
      Conv.String.of_ocaml
      Conv.Bool.to_ocaml x0  x1 

    (** Returns \[code\]true\[/code\] if the left \[String\] comes before \[param right\] in \[url=https://en.wikipedia.org/wiki/List_of_Unicode_characters\]Unicode order\[/url\], which roughly matches the alphabetical order, or if both are equal. *)
    let (<=) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_STRING (Some GlobalEnum.VariantType._TYPE_STRING) GlobalEnum.VariantOperator._OP_LESS_EQUAL
      (funptr (String.typ @-> String.typ @-> Bool.typ @-> returning void))
      Bool.s
      Conv.String.of_ocaml
      Conv.String.of_ocaml
      Conv.Bool.to_ocaml x0  x1 

    (** Returns \[code\]true\[/code\] if the left \[String\] comes after \[param right\] in \[url=https://en.wikipedia.org/wiki/List_of_Unicode_characters\]Unicode order\[/url\], which roughly matches the alphabetical order. Useful for sorting. *)
    let (>) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_STRING (Some GlobalEnum.VariantType._TYPE_STRING) GlobalEnum.VariantOperator._OP_GREATER
      (funptr (String.typ @-> String.typ @-> Bool.typ @-> returning void))
      Bool.s
      Conv.String.of_ocaml
      Conv.String.of_ocaml
      Conv.Bool.to_ocaml x0  x1 

    (** Returns \[code\]true\[/code\] if the left \[String\] comes after \[param right\] in \[url=https://en.wikipedia.org/wiki/List_of_Unicode_characters\]Unicode order\[/url\], which roughly matches the alphabetical order, or if both are equal. *)
    let (>=) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_STRING (Some GlobalEnum.VariantType._TYPE_STRING) GlobalEnum.VariantOperator._OP_GREATER_EQUAL
      (funptr (String.typ @-> String.typ @-> Bool.typ @-> returning void))
      Bool.s
      Conv.String.of_ocaml
      Conv.String.of_ocaml
      Conv.Bool.to_ocaml x0  x1 

    (** Appends \[param right\] at the end of this \[String\], also known as a string concatenation. *)
    let (+) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_STRING (Some GlobalEnum.VariantType._TYPE_STRING) GlobalEnum.VariantOperator._OP_ADD
      (funptr (String.typ @-> String.typ @-> String.typ @-> returning void))
      String.s
      Conv.String.of_ocaml
      Conv.String.of_ocaml
      Conv.String.to_ocaml x0  x1 


    let (%) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_STRING (Some GlobalEnum.VariantType._TYPE_STRING) GlobalEnum.VariantOperator._OP_MODULE
      (funptr (String.typ @-> String.typ @-> String.typ @-> returning void))
      String.s
      Conv.String.of_ocaml
      Conv.String.of_ocaml
      Conv.String.to_ocaml x0  x1 


    let mem_String x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_STRING (Some GlobalEnum.VariantType._TYPE_STRING) GlobalEnum.VariantOperator._OP_IN
      (funptr (String.typ @-> String.typ @-> Bool.typ @-> returning void))
      Bool.s x0  x1 










































    let mem_StringName x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_STRING (Some GlobalEnum.VariantType._TYPE_STRING_NAME) GlobalEnum.VariantOperator._OP_IN
      (funptr (String.typ @-> StringName.typ @-> Bool.typ @-> returning void))
      Bool.s x0  x1 






    let mem_Object x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_STRING (Some GlobalEnum.VariantType._TYPE_OBJECT) GlobalEnum.VariantOperator._OP_IN
      (funptr (String.typ @-> Object.typ @-> Bool.typ @-> returning void))
      Bool.s x0  x1 








    let mem_Dictionary x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_STRING (Some GlobalEnum.VariantType._TYPE_DICTIONARY) GlobalEnum.VariantOperator._OP_IN
      (funptr (String.typ @-> Dictionary.typ @-> Bool.typ @-> returning void))
      Bool.s x0  x1 




    let mem_Array x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_STRING (Some GlobalEnum.VariantType._TYPE_ARRAY) GlobalEnum.VariantOperator._OP_IN
      (funptr (String.typ @-> Array.typ @-> Bool.typ @-> returning void))
      Bool.s x0  x1 














    let mem_PackedStringArray x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_STRING (Some GlobalEnum.VariantType._TYPE_PACKED_STRING_ARRAY) GlobalEnum.VariantOperator._OP_IN
      (funptr (String.typ @-> PackedStringArray.typ @-> Bool.typ @-> returning void))
      Bool.s x0  x1 








    end

  module Vector2 = struct
    include M.Vector2
include BuiltinClass0.Vector2

    (** Returns this vector''s angle with respect to the positive X axis, or \[code\](1, 0)\[/code\] vector, in radians.
For example, \[code\]Vector2.RIGHT.angle()\[/code\] will return zero, \[code\]Vector2.DOWN.angle()\[/code\] will return \[code\]PI / 2\[/code\] (a quarter turn, or 90 degrees), and \[code\]Vector2(1, -1).angle()\[/code\] will return \[code\]-PI / 4\[/code\] (a negative eighth turn, or -45 degrees).
\[url=https://raw.githubusercontent.com/godotengine/godot-docs/master/img/vector2_angle.png\]Illustration of the returned angle.\[/url\]
Equivalent to the result of \[method \@GlobalScope.atan2\] when called with the vector''s \[member y\] and \[member x\] as parameters: \[code\]atan2(y, x)\[/code\]. *)
    let angle x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_VECTOR2
      "angle"
      466405837L
      (Vector2.typ @-> returning Float.typ)
      Float.s x0 

    (** Returns the signed angle to the given vector, in radians.
\[url=https://raw.githubusercontent.com/godotengine/godot-docs/master/img/vector2_angle_to.png\]Illustration of the returned angle.\[/url\] *)
    let angle_to x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_VECTOR2
      "angle_to"
      3819070308L
      (Vector2.typ @-> Vector2.typ @-> returning Float.typ)
      Float.s x0  x1 

    (** Returns the angle between the line connecting the two points and the X axis, in radians.
\[code\]a.angle_to_point(b)\[/code\] is equivalent of doing \[code\](b - a).angle()\[/code\].
\[url=https://raw.githubusercontent.com/godotengine/godot-docs/master/img/vector2_angle_to_point.png\]Illustration of the returned angle.\[/url\] *)
    let angle_to_point x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_VECTOR2
      "angle_to_point"
      3819070308L
      (Vector2.typ @-> Vector2.typ @-> returning Float.typ)
      Float.s x0  x1 

    (** Returns the normalized vector pointing from this vector to \[param to\]. This is equivalent to using \[code\](b - a).normalized()\[/code\]. *)
    let direction_to x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_VECTOR2
      "direction_to"
      2026743667L
      (Vector2.typ @-> Vector2.typ @-> returning Vector2.typ)
      Vector2.s x0  x1 

    (** Returns the distance between this vector and \[param to\]. *)
    let distance_to x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_VECTOR2
      "distance_to"
      3819070308L
      (Vector2.typ @-> Vector2.typ @-> returning Float.typ)
      Float.s x0  x1 

    (** Returns the squared distance between this vector and \[param to\].
This method runs faster than \[method distance_to\], so prefer it if you need to compare vectors or need the squared distance for some formula. *)
    let distance_squared_to x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_VECTOR2
      "distance_squared_to"
      3819070308L
      (Vector2.typ @-> Vector2.typ @-> returning Float.typ)
      Float.s x0  x1 

    (** Returns the length (magnitude) of this vector. *)
    let length x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_VECTOR2
      "length"
      466405837L
      (Vector2.typ @-> returning Float.typ)
      Float.s x0 

    (** Returns the squared length (squared magnitude) of this vector.
This method runs faster than \[method length\], so prefer it if you need to compare vectors or need the squared distance for some formula. *)
    let length_squared x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_VECTOR2
      "length_squared"
      466405837L
      (Vector2.typ @-> returning Float.typ)
      Float.s x0 

    (** Returns the vector with a maximum length by limiting its length to \[param length\]. If the vector is non-finite, the result is undefined. *)
    let limit_length x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_VECTOR2
      "limit_length"
      2544004089L
      (Float.typ @-> Vector2.typ @-> returning Vector2.typ)
      Vector2.s x0  x1 

    (** Returns the result of scaling the vector to unit length. Equivalent to \[code\]v / v.length()\[/code\]. Returns \[code\](0, 0)\[/code\] if \[code\]v.length() == 0\[/code\]. See also \[method is_normalized\].
\[b\]Note:\[/b\] This function may return incorrect values if the input vector length is near zero. *)
    let normalized x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_VECTOR2
      "normalized"
      2428350749L
      (Vector2.typ @-> returning Vector2.typ)
      Vector2.s x0 

    (** Returns \[code\]true\[/code\] if the vector is normalized, i.e. its length is approximately equal to 1. *)
    let is_normalized x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_VECTOR2
      "is_normalized"
      3918633141L
      (Vector2.typ @-> returning Bool.typ)
      Bool.s x0 

    (** Returns \[code\]true\[/code\] if this vector and \[param to\] are approximately equal, by running \[method \@GlobalScope.is_equal_approx\] on each component. *)
    let is_equal_approx x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_VECTOR2
      "is_equal_approx"
      3190634762L
      (Vector2.typ @-> Vector2.typ @-> returning Bool.typ)
      Bool.s x0  x1 

    (** Returns \[code\]true\[/code\] if this vector''s values are approximately zero, by running \[method \@GlobalScope.is_zero_approx\] on each component.
This method is faster than using \[method is_equal_approx\] with one value as a zero vector. *)
    let is_zero_approx x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_VECTOR2
      "is_zero_approx"
      3918633141L
      (Vector2.typ @-> returning Bool.typ)
      Bool.s x0 

    (** Returns \[code\]true\[/code\] if this vector is finite, by calling \[method \@GlobalScope.is_finite\] on each component. *)
    let is_finite x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_VECTOR2
      "is_finite"
      3918633141L
      (Vector2.typ @-> returning Bool.typ)
      Bool.s x0 

    (** Returns a vector composed of the \[method \@GlobalScope.fposmod\] of this vector''s components and \[param mod\]. *)
    let posmod x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_VECTOR2
      "posmod"
      2544004089L
      (Float.typ @-> Vector2.typ @-> returning Vector2.typ)
      Vector2.s x0  x1 

    (** Returns a vector composed of the \[method \@GlobalScope.fposmod\] of this vector''s components and \[param modv\]''s components. *)
    let posmodv x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_VECTOR2
      "posmodv"
      2026743667L
      (Vector2.typ @-> Vector2.typ @-> returning Vector2.typ)
      Vector2.s x0  x1 

    (** Returns a new vector resulting from projecting this vector onto the given vector \[param b\]. The resulting new vector is parallel to \[param b\]. See also \[method slide\].
\[b\]Note:\[/b\] If the vector \[param b\] is a zero vector, the components of the resulting new vector will be \[constant \@GDScript.NAN\]. *)
    let project x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_VECTOR2
      "project"
      2026743667L
      (Vector2.typ @-> Vector2.typ @-> returning Vector2.typ)
      Vector2.s x0  x1 

    (** Returns the result of the linear interpolation between this vector and \[param to\] by amount \[param weight\]. \[param weight\] is on the range of \[code\]0.0\[/code\] to \[code\]1.0\[/code\], representing the amount of interpolation. *)
    let lerp x0  x1  x2  = 
    foreign_builtin_method2
      GlobalEnum.VariantType._TYPE_VECTOR2
      "lerp"
      4250033116L
      (Vector2.typ @-> Float.typ @-> Vector2.typ @-> returning Vector2.typ)
      Vector2.s x0  x1  x2 

    (** Returns the result of spherical linear interpolation between this vector and \[param to\], by amount \[param weight\]. \[param weight\] is on the range of 0.0 to 1.0, representing the amount of interpolation.
This method also handles interpolating the lengths if the input vectors have different lengths. For the special case of one or both input vectors having zero length, this method behaves like \[method lerp\]. *)
    let slerp x0  x1  x2  = 
    foreign_builtin_method2
      GlobalEnum.VariantType._TYPE_VECTOR2
      "slerp"
      4250033116L
      (Vector2.typ @-> Float.typ @-> Vector2.typ @-> returning Vector2.typ)
      Vector2.s x0  x1  x2 

    (** Performs a cubic interpolation between this vector and \[param b\] using \[param pre_a\] and \[param post_b\] as handles, and returns the result at position \[param weight\]. \[param weight\] is on the range of 0.0 to 1.0, representing the amount of interpolation. *)
    let cubic_interpolate x0  x1  x2  x3  x4  = 
    foreign_builtin_method4
      GlobalEnum.VariantType._TYPE_VECTOR2
      "cubic_interpolate"
      193522989L
      (Vector2.typ @-> Vector2.typ @-> Vector2.typ @-> Float.typ @-> Vector2.typ @-> returning Vector2.typ)
      Vector2.s x0  x1  x2  x3  x4 

    (** Performs a cubic interpolation between this vector and \[param b\] using \[param pre_a\] and \[param post_b\] as handles, and returns the result at position \[param weight\]. \[param weight\] is on the range of 0.0 to 1.0, representing the amount of interpolation.
It can perform smoother interpolation than \[method cubic_interpolate\] by the time values. *)
    let cubic_interpolate_in_time x0  x1  x2  x3  x4  x5  x6  x7  = 
    foreign_builtin_method7
      GlobalEnum.VariantType._TYPE_VECTOR2
      "cubic_interpolate_in_time"
      1957055074L
      (Vector2.typ @-> Vector2.typ @-> Vector2.typ @-> Float.typ @-> Float.typ @-> Float.typ @-> Float.typ @-> Vector2.typ @-> returning Vector2.typ)
      Vector2.s x0  x1  x2  x3  x4  x5  x6  x7 

    (** Returns the point at the given \[param t\] on the \[url=https://en.wikipedia.org/wiki/B%C3%A9zier_curve\]Bzier curve\[/url\] defined by this vector and the given \[param control_1\], \[param control_2\], and \[param end\] points. *)
    let bezier_interpolate x0  x1  x2  x3  x4  = 
    foreign_builtin_method4
      GlobalEnum.VariantType._TYPE_VECTOR2
      "bezier_interpolate"
      193522989L
      (Vector2.typ @-> Vector2.typ @-> Vector2.typ @-> Float.typ @-> Vector2.typ @-> returning Vector2.typ)
      Vector2.s x0  x1  x2  x3  x4 

    (** Returns the derivative at the given \[param t\] on the \[url=https://en.wikipedia.org/wiki/B%C3%A9zier_curve\]Bzier curve\[/url\] defined by this vector and the given \[param control_1\], \[param control_2\], and \[param end\] points. *)
    let bezier_derivative x0  x1  x2  x3  x4  = 
    foreign_builtin_method4
      GlobalEnum.VariantType._TYPE_VECTOR2
      "bezier_derivative"
      193522989L
      (Vector2.typ @-> Vector2.typ @-> Vector2.typ @-> Float.typ @-> Vector2.typ @-> returning Vector2.typ)
      Vector2.s x0  x1  x2  x3  x4 

    (** Returns the axis of the vector''s highest value. See \[code\]AXIS_ * \[/code\] constants. If all components are equal, this method returns \[constant AXIS_X\]. *)
    let max_axis_index x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_VECTOR2
      "max_axis_index"
      3173160232L
      (Vector2.typ @-> returning Int.typ)
      Int.s x0 

    (** Returns the axis of the vector''s lowest value. See \[code\]AXIS_ * \[/code\] constants. If all components are equal, this method returns \[constant AXIS_Y\]. *)
    let min_axis_index x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_VECTOR2
      "min_axis_index"
      3173160232L
      (Vector2.typ @-> returning Int.typ)
      Int.s x0 

    (** Returns a new vector moved toward \[param to\] by the fixed \[param delta\] amount. Will not go past the final value. *)
    let move_toward x0  x1  x2  = 
    foreign_builtin_method2
      GlobalEnum.VariantType._TYPE_VECTOR2
      "move_toward"
      4250033116L
      (Vector2.typ @-> Float.typ @-> Vector2.typ @-> returning Vector2.typ)
      Vector2.s x0  x1  x2 

    (** Returns the result of rotating this vector by \[param angle\] (in radians). See also \[method \@GlobalScope.deg_to_rad\]. *)
    let rotated x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_VECTOR2
      "rotated"
      2544004089L
      (Float.typ @-> Vector2.typ @-> returning Vector2.typ)
      Vector2.s x0  x1 

    (** Returns a perpendicular vector rotated 90 degrees counter-clockwise compared to the original, with the same length. *)
    let orthogonal x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_VECTOR2
      "orthogonal"
      2428350749L
      (Vector2.typ @-> returning Vector2.typ)
      Vector2.s x0 

    (** Returns a new vector with all components rounded down (towards negative infinity). *)
    let floor x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_VECTOR2
      "floor"
      2428350749L
      (Vector2.typ @-> returning Vector2.typ)
      Vector2.s x0 

    (** Returns a new vector with all components rounded up (towards positive infinity). *)
    let ceil x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_VECTOR2
      "ceil"
      2428350749L
      (Vector2.typ @-> returning Vector2.typ)
      Vector2.s x0 

    (** Returns a new vector with all components rounded to the nearest integer, with halfway cases rounded away from zero. *)
    let round x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_VECTOR2
      "round"
      2428350749L
      (Vector2.typ @-> returning Vector2.typ)
      Vector2.s x0 

    (** Returns the aspect ratio of this vector, the ratio of \[member x\] to \[member y\]. *)
    let aspect x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_VECTOR2
      "aspect"
      466405837L
      (Vector2.typ @-> returning Float.typ)
      Float.s x0 

    (** Returns the dot product of this vector and \[param with\]. This can be used to compare the angle between two vectors. For example, this can be used to determine whether an enemy is facing the player.
The dot product will be \[code\]0\[/code\] for a right angle (90 degrees), greater than 0 for angles narrower than 90 degrees and lower than 0 for angles wider than 90 degrees.
When using unit (normalized) vectors, the result will always be between \[code\]-1.0\[/code\] (180 degree angle) when the vectors are facing opposite directions, and \[code\]1.0\[/code\] (0 degree angle) when the vectors are aligned.
\[b\]Note:\[/b\] \[code\]a.dot(b)\[/code\] is equivalent to \[code\]b.dot(a)\[/code\]. *)
    let dot x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_VECTOR2
      "dot"
      3819070308L
      (Vector2.typ @-> Vector2.typ @-> returning Float.typ)
      Float.s x0  x1 

    (** Returns a new vector resulting from sliding this vector along a line with normal \[param n\]. The resulting new vector is perpendicular to \[param n\], and is equivalent to this vector minus its projection on \[param n\]. See also \[method project\].
\[b\]Note:\[/b\] The vector \[param n\] must be normalized. See also \[method normalized\]. *)
    let slide x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_VECTOR2
      "slide"
      2026743667L
      (Vector2.typ @-> Vector2.typ @-> returning Vector2.typ)
      Vector2.s x0  x1 

    (** Returns the vector ""bounced off"" from a line defined by the given normal \[param n\] perpendicular to the line.
\[b\]Note:\[/b\] \[method bounce\] performs the operation that most engines and frameworks call \[code skip-lint\]reflect()\[/code\]. *)
    let bounce x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_VECTOR2
      "bounce"
      2026743667L
      (Vector2.typ @-> Vector2.typ @-> returning Vector2.typ)
      Vector2.s x0  x1 

    (** Returns the result of reflecting the vector from a line defined by the given direction vector \[param line\].
\[b\]Note:\[/b\] \[method reflect\] differs from what other engines and frameworks call \[code skip-lint\]reflect()\[/code\]. In other engines, \[code skip-lint\]reflect()\[/code\] takes a normal direction which is a direction perpendicular to the line. In Godot, you specify the direction of the line directly. See also \[method bounce\] which does what most engines call \[code skip-lint\]reflect()\[/code\]. *)
    let reflect x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_VECTOR2
      "reflect"
      2026743667L
      (Vector2.typ @-> Vector2.typ @-> returning Vector2.typ)
      Vector2.s x0  x1 

    (** Returns the 2D analog of the cross product for this vector and \[param with\].
This is the signed area of the parallelogram formed by the two vectors. If the second vector is clockwise from the first vector, then the cross product is the positive area. If counter-clockwise, the cross product is the negative area. If the two vectors are parallel this returns zero, making it useful for testing if two vectors are parallel.
\[b\]Note:\[/b\] Cross product is not defined in 2D mathematically. This method embeds the 2D vectors in the XY plane of 3D space and uses their cross product''s Z component as the analog. *)
    let cross x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_VECTOR2
      "cross"
      3819070308L
      (Vector2.typ @-> Vector2.typ @-> returning Float.typ)
      Float.s x0  x1 

    (** Returns a new vector with all components in absolute values (i.e. positive). *)
    let abs x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_VECTOR2
      "abs"
      2428350749L
      (Vector2.typ @-> returning Vector2.typ)
      Vector2.s x0 

    (** Returns a new vector with each component set to \[code\]1.0\[/code\] if it''s positive, \[code\]-1.0\[/code\] if it''s negative, and \[code\]0.0\[/code\] if it''s zero. The result is identical to calling \[method \@GlobalScope.sign\] on each component. *)
    let sign x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_VECTOR2
      "sign"
      2428350749L
      (Vector2.typ @-> returning Vector2.typ)
      Vector2.s x0 

    (** Returns a new vector with all components clamped between the components of \[param min\] and \[param max\], by running \[method \@GlobalScope.clamp\] on each component. *)
    let clamp x0  x1  x2  = 
    foreign_builtin_method2
      GlobalEnum.VariantType._TYPE_VECTOR2
      "clamp"
      318031021L
      (Vector2.typ @-> Vector2.typ @-> Vector2.typ @-> returning Vector2.typ)
      Vector2.s x0  x1  x2 

    (** Returns a new vector with all components clamped between \[param min\] and \[param max\], by running \[method \@GlobalScope.clamp\] on each component. *)
    let clampf x0  x1  x2  = 
    foreign_builtin_method2
      GlobalEnum.VariantType._TYPE_VECTOR2
      "clampf"
      3464402636L
      (Float.typ @-> Float.typ @-> Vector2.typ @-> returning Vector2.typ)
      Vector2.s x0  x1  x2 

    (** Returns a new vector with each component snapped to the nearest multiple of the corresponding component in \[param step\]. This can also be used to round the components to an arbitrary number of decimals. *)
    let snapped x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_VECTOR2
      "snapped"
      2026743667L
      (Vector2.typ @-> Vector2.typ @-> returning Vector2.typ)
      Vector2.s x0  x1 

    (** Returns a new vector with each component snapped to the nearest multiple of \[param step\]. This can also be used to round the components to an arbitrary number of decimals. *)
    let snappedf x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_VECTOR2
      "snappedf"
      2544004089L
      (Float.typ @-> Vector2.typ @-> returning Vector2.typ)
      Vector2.s x0  x1 

    (** Returns the component-wise minimum of this and \[param with\], equivalent to \[code\]Vector2(minf(x, with.x), minf(y, with.y))\[/code\]. *)
    let min x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_VECTOR2
      "min"
      2026743667L
      (Vector2.typ @-> Vector2.typ @-> returning Vector2.typ)
      Vector2.s x0  x1 

    (** Returns the component-wise minimum of this and \[param with\], equivalent to \[code\]Vector2(minf(x, with), minf(y, with))\[/code\]. *)
    let minf x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_VECTOR2
      "minf"
      2544004089L
      (Float.typ @-> Vector2.typ @-> returning Vector2.typ)
      Vector2.s x0  x1 

    (** Returns the component-wise maximum of this and \[param with\], equivalent to \[code\]Vector2(maxf(x, with.x), maxf(y, with.y))\[/code\]. *)
    let max x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_VECTOR2
      "max"
      2026743667L
      (Vector2.typ @-> Vector2.typ @-> returning Vector2.typ)
      Vector2.s x0  x1 

    (** Returns the component-wise maximum of this and \[param with\], equivalent to \[code\]Vector2(maxf(x, with), maxf(y, with))\[/code\]. *)
    let maxf x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_VECTOR2
      "maxf"
      2544004089L
      (Float.typ @-> Vector2.typ @-> returning Vector2.typ)
      Vector2.s x0  x1 

    (** Creates a unit \[Vector2\] rotated to the given \[param angle\] in radians. This is equivalent to doing \[code\]Vector2(cos(angle), sin(angle))\[/code\] or \[code\]Vector2.RIGHT.rotated(angle)\[/code\].
\[codeblock\]
print(Vector2.from_angle(0)) # Prints (1.0, 0.0)
print(Vector2(1, 0).angle()) # Prints 0.0, which is the angle used above.
print(Vector2.from_angle(PI / 2)) # Prints (0.0, 1.0)
\[/codeblock\] *)
    let from_angle x0  = 
    foreign_builtin_method1_static
      GlobalEnum.VariantType._TYPE_VECTOR2
      "from_angle"
      889263119L
      (Float.typ @-> returning Vector2.typ)
      Vector2.s x0 





    (** Returns the negative value of the \[Vector2\]. This is the same as writing \[code\]Vector2(-v.x, -v.y)\[/code\]. This operation flips the direction of the vector while keeping the same magnitude. With floats, the number zero can be either positive or negative. *)
    let (~-) x0  = 
    foreign_builtin_operator1 GlobalEnum.VariantType._TYPE_VECTOR2 None  GlobalEnum.VariantOperator._OP_NEGATE
      (funptr (Vector2.typ @-> Vector2.typ @-> returning void))
      Vector2.s x0 

    (** Returns the same value as if the \[code\]+\[/code\] was not there. Unary \[code\]+\[/code\] does nothing, but sometimes it can make your code more readable. *)
    let (~+) x0  = 
    foreign_builtin_operator1 GlobalEnum.VariantType._TYPE_VECTOR2 None  GlobalEnum.VariantOperator._OP_POSITIVE
      (funptr (Vector2.typ @-> Vector2.typ @-> returning void))
      Vector2.s x0 


    let not x0  = 
    foreign_builtin_operator1 GlobalEnum.VariantType._TYPE_VECTOR2 None  GlobalEnum.VariantOperator._OP_NOT
      (funptr (Vector2.typ @-> Bool.typ @-> returning void))
      Bool.s x0 









    (** Returns \[code\]true\[/code\] if the vectors are exactly equal.
\[b\]Note:\[/b\] Due to floating-point precision errors, consider using \[method is_equal_approx\] instead, which is more reliable.
\[b\]Note:\[/b\] Vectors with \[constant \@GDScript.NAN\] elements don''t behave the same as other vectors. Therefore, the results from this operator may not be accurate if NaNs are included. *)
    let (=) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_VECTOR2 (Some GlobalEnum.VariantType._TYPE_VECTOR2) GlobalEnum.VariantOperator._OP_EQUAL
      (funptr (Vector2.typ @-> Vector2.typ @-> Bool.typ @-> returning void))
      Bool.s
      Conv.Vector2.of_ocaml
      Conv.Vector2.of_ocaml
      Conv.Bool.to_ocaml x0  x1 

    (** Returns \[code\]true\[/code\] if the vectors are not equal.
\[b\]Note:\[/b\] Due to floating-point precision errors, consider using \[method is_equal_approx\] instead, which is more reliable.
\[b\]Note:\[/b\] Vectors with \[constant \@GDScript.NAN\] elements don''t behave the same as other vectors. Therefore, the results from this operator may not be accurate if NaNs are included. *)
    let (<>) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_VECTOR2 (Some GlobalEnum.VariantType._TYPE_VECTOR2) GlobalEnum.VariantOperator._OP_NOT_EQUAL
      (funptr (Vector2.typ @-> Vector2.typ @-> Bool.typ @-> returning void))
      Bool.s
      Conv.Vector2.of_ocaml
      Conv.Vector2.of_ocaml
      Conv.Bool.to_ocaml x0  x1 

    (** Compares two \[Vector2\] vectors by first checking if the X value of the left vector is less than the X value of the \[param right\] vector. If the X values are exactly equal, then it repeats this check with the Y values of the two vectors. This operator is useful for sorting vectors.
\[b\]Note:\[/b\] Vectors with \[constant \@GDScript.NAN\] elements don''t behave the same as other vectors. Therefore, the results from this operator may not be accurate if NaNs are included. *)
    let (<) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_VECTOR2 (Some GlobalEnum.VariantType._TYPE_VECTOR2) GlobalEnum.VariantOperator._OP_LESS
      (funptr (Vector2.typ @-> Vector2.typ @-> Bool.typ @-> returning void))
      Bool.s
      Conv.Vector2.of_ocaml
      Conv.Vector2.of_ocaml
      Conv.Bool.to_ocaml x0  x1 

    (** Compares two \[Vector2\] vectors by first checking if the X value of the left vector is less than or equal to the X value of the \[param right\] vector. If the X values are exactly equal, then it repeats this check with the Y values of the two vectors. This operator is useful for sorting vectors.
\[b\]Note:\[/b\] Vectors with \[constant \@GDScript.NAN\] elements don''t behave the same as other vectors. Therefore, the results from this operator may not be accurate if NaNs are included. *)
    let (<=) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_VECTOR2 (Some GlobalEnum.VariantType._TYPE_VECTOR2) GlobalEnum.VariantOperator._OP_LESS_EQUAL
      (funptr (Vector2.typ @-> Vector2.typ @-> Bool.typ @-> returning void))
      Bool.s
      Conv.Vector2.of_ocaml
      Conv.Vector2.of_ocaml
      Conv.Bool.to_ocaml x0  x1 

    (** Compares two \[Vector2\] vectors by first checking if the X value of the left vector is greater than the X value of the \[param right\] vector. If the X values are exactly equal, then it repeats this check with the Y values of the two vectors. This operator is useful for sorting vectors.
\[b\]Note:\[/b\] Vectors with \[constant \@GDScript.NAN\] elements don''t behave the same as other vectors. Therefore, the results from this operator may not be accurate if NaNs are included. *)
    let (>) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_VECTOR2 (Some GlobalEnum.VariantType._TYPE_VECTOR2) GlobalEnum.VariantOperator._OP_GREATER
      (funptr (Vector2.typ @-> Vector2.typ @-> Bool.typ @-> returning void))
      Bool.s
      Conv.Vector2.of_ocaml
      Conv.Vector2.of_ocaml
      Conv.Bool.to_ocaml x0  x1 

    (** Compares two \[Vector2\] vectors by first checking if the X value of the left vector is greater than or equal to the X value of the \[param right\] vector. If the X values are exactly equal, then it repeats this check with the Y values of the two vectors. This operator is useful for sorting vectors.
\[b\]Note:\[/b\] Vectors with \[constant \@GDScript.NAN\] elements don''t behave the same as other vectors. Therefore, the results from this operator may not be accurate if NaNs are included. *)
    let (>=) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_VECTOR2 (Some GlobalEnum.VariantType._TYPE_VECTOR2) GlobalEnum.VariantOperator._OP_GREATER_EQUAL
      (funptr (Vector2.typ @-> Vector2.typ @-> Bool.typ @-> returning void))
      Bool.s
      Conv.Vector2.of_ocaml
      Conv.Vector2.of_ocaml
      Conv.Bool.to_ocaml x0  x1 

    (** Adds each component of the \[Vector2\] by the components of the given \[Vector2\].
\[codeblock\]
print(Vector2(10, 20) + Vector2(3, 4)) # Prints (13.0, 24.0)
\[/codeblock\] *)
    let (+) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_VECTOR2 (Some GlobalEnum.VariantType._TYPE_VECTOR2) GlobalEnum.VariantOperator._OP_ADD
      (funptr (Vector2.typ @-> Vector2.typ @-> Vector2.typ @-> returning void))
      Vector2.s
      Conv.Vector2.of_ocaml
      Conv.Vector2.of_ocaml
      Conv.Vector2.to_ocaml x0  x1 

    (** Subtracts each component of the \[Vector2\] by the components of the given \[Vector2\].
\[codeblock\]
print(Vector2(10, 20) - Vector2(3, 4)) # Prints (7.0, 16.0)
\[/codeblock\] *)
    let (-) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_VECTOR2 (Some GlobalEnum.VariantType._TYPE_VECTOR2) GlobalEnum.VariantOperator._OP_SUBTRACT
      (funptr (Vector2.typ @-> Vector2.typ @-> Vector2.typ @-> returning void))
      Vector2.s
      Conv.Vector2.of_ocaml
      Conv.Vector2.of_ocaml
      Conv.Vector2.to_ocaml x0  x1 

    (** Multiplies each component of the \[Vector2\] by the components of the given \[Vector2\].
\[codeblock\]
print(Vector2(10, 20)  *  Vector2(3, 4)) # Prints (30.0, 80.0)
\[/codeblock\] *)
    let ( * ) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_VECTOR2 (Some GlobalEnum.VariantType._TYPE_VECTOR2) GlobalEnum.VariantOperator._OP_MULTIPLY
      (funptr (Vector2.typ @-> Vector2.typ @-> Vector2.typ @-> returning void))
      Vector2.s
      Conv.Vector2.of_ocaml
      Conv.Vector2.of_ocaml
      Conv.Vector2.to_ocaml x0  x1 

    (** Divides each component of the \[Vector2\] by the components of the given \[Vector2\].
\[codeblock\]
print(Vector2(10, 20) / Vector2(2, 5)) # Prints (5.0, 4.0)
\[/codeblock\] *)
    let (/) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_VECTOR2 (Some GlobalEnum.VariantType._TYPE_VECTOR2) GlobalEnum.VariantOperator._OP_DIVIDE
      (funptr (Vector2.typ @-> Vector2.typ @-> Vector2.typ @-> returning void))
      Vector2.s
      Conv.Vector2.of_ocaml
      Conv.Vector2.of_ocaml
      Conv.Vector2.to_ocaml x0  x1 




    let mem_Dictionary x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_VECTOR2 (Some GlobalEnum.VariantType._TYPE_DICTIONARY) GlobalEnum.VariantOperator._OP_IN
      (funptr (Vector2.typ @-> Dictionary.typ @-> Bool.typ @-> returning void))
      Bool.s x0  x1 


    let mem_Array x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_VECTOR2 (Some GlobalEnum.VariantType._TYPE_ARRAY) GlobalEnum.VariantOperator._OP_IN
      (funptr (Vector2.typ @-> Array.typ @-> Bool.typ @-> returning void))
      Bool.s x0  x1 


    let mem_PackedVector2Array x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_VECTOR2 (Some GlobalEnum.VariantType._TYPE_PACKED_VECTOR2_ARRAY) GlobalEnum.VariantOperator._OP_IN
      (funptr (Vector2.typ @-> PackedVector2Array.typ @-> Bool.typ @-> returning void))
      Bool.s x0  x1 

    module Axis = struct
      type t = Int.t

      let typ = 
      Int.typ

      (** Enumerated value for the X axis. Returned by \[method max_axis_index\] and \[method min_axis_index\]. *)
      let _AXIS_X = 
      0

      (** Enumerated value for the Y axis. Returned by \[method max_axis_index\] and \[method min_axis_index\]. *)
      let _AXIS_Y = 
      1
      end
    end

  module Vector2i = struct
    include M.Vector2i
include BuiltinClass0.Vector2i

    (** Returns the aspect ratio of this vector, the ratio of \[member x\] to \[member y\]. *)
    let aspect x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_VECTOR2I
      "aspect"
      466405837L
      (Vector2i.typ @-> returning Float.typ)
      Float.s x0 

    (** Returns the axis of the vector''s highest value. See \[code\]AXIS_ * \[/code\] constants. If all components are equal, this method returns \[constant AXIS_X\]. *)
    let max_axis_index x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_VECTOR2I
      "max_axis_index"
      3173160232L
      (Vector2i.typ @-> returning Int.typ)
      Int.s x0 

    (** Returns the axis of the vector''s lowest value. See \[code\]AXIS_ * \[/code\] constants. If all components are equal, this method returns \[constant AXIS_Y\]. *)
    let min_axis_index x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_VECTOR2I
      "min_axis_index"
      3173160232L
      (Vector2i.typ @-> returning Int.typ)
      Int.s x0 

    (** Returns the distance between this vector and \[param to\]. *)
    let distance_to x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_VECTOR2I
      "distance_to"
      707501214L
      (Vector2i.typ @-> Vector2i.typ @-> returning Float.typ)
      Float.s x0  x1 

    (** Returns the squared distance between this vector and \[param to\].
This method runs faster than \[method distance_to\], so prefer it if you need to compare vectors or need the squared distance for some formula. *)
    let distance_squared_to x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_VECTOR2I
      "distance_squared_to"
      1130029528L
      (Vector2i.typ @-> Vector2i.typ @-> returning Int.typ)
      Int.s x0  x1 

    (** Returns the length (magnitude) of this vector. *)
    let length x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_VECTOR2I
      "length"
      466405837L
      (Vector2i.typ @-> returning Float.typ)
      Float.s x0 

    (** Returns the squared length (squared magnitude) of this vector.
This method runs faster than \[method length\], so prefer it if you need to compare vectors or need the squared distance for some formula. *)
    let length_squared x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_VECTOR2I
      "length_squared"
      3173160232L
      (Vector2i.typ @-> returning Int.typ)
      Int.s x0 

    (** Returns a new vector with each component set to \[code\]1\[/code\] if it''s positive, \[code\]-1\[/code\] if it''s negative, and \[code\]0\[/code\] if it''s zero. The result is identical to calling \[method \@GlobalScope.sign\] on each component. *)
    let sign x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_VECTOR2I
      "sign"
      3444277866L
      (Vector2i.typ @-> returning Vector2i.typ)
      Vector2i.s x0 

    (** Returns a new vector with all components in absolute values (i.e. positive). *)
    let abs x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_VECTOR2I
      "abs"
      3444277866L
      (Vector2i.typ @-> returning Vector2i.typ)
      Vector2i.s x0 

    (** Returns a new vector with all components clamped between the components of \[param min\] and \[param max\], by running \[method \@GlobalScope.clamp\] on each component. *)
    let clamp x0  x1  x2  = 
    foreign_builtin_method2
      GlobalEnum.VariantType._TYPE_VECTOR2I
      "clamp"
      186568249L
      (Vector2i.typ @-> Vector2i.typ @-> Vector2i.typ @-> returning Vector2i.typ)
      Vector2i.s x0  x1  x2 

    (** Returns a new vector with all components clamped between \[param min\] and \[param max\], by running \[method \@GlobalScope.clamp\] on each component. *)
    let clampi x0  x1  x2  = 
    foreign_builtin_method2
      GlobalEnum.VariantType._TYPE_VECTOR2I
      "clampi"
      3686769569L
      (Int.typ @-> Int.typ @-> Vector2i.typ @-> returning Vector2i.typ)
      Vector2i.s x0  x1  x2 

    (** Returns a new vector with each component snapped to the closest multiple of the corresponding component in \[param step\]. *)
    let snapped x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_VECTOR2I
      "snapped"
      1735278196L
      (Vector2i.typ @-> Vector2i.typ @-> returning Vector2i.typ)
      Vector2i.s x0  x1 

    (** Returns a new vector with each component snapped to the closest multiple of \[param step\]. *)
    let snappedi x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_VECTOR2I
      "snappedi"
      2161988953L
      (Int.typ @-> Vector2i.typ @-> returning Vector2i.typ)
      Vector2i.s x0  x1 

    (** Returns the component-wise minimum of this and \[param with\], equivalent to \[code\]Vector2i(mini(x, with.x), mini(y, with.y))\[/code\]. *)
    let min x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_VECTOR2I
      "min"
      1735278196L
      (Vector2i.typ @-> Vector2i.typ @-> returning Vector2i.typ)
      Vector2i.s x0  x1 

    (** Returns the component-wise minimum of this and \[param with\], equivalent to \[code\]Vector2i(mini(x, with), mini(y, with))\[/code\]. *)
    let mini x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_VECTOR2I
      "mini"
      2161988953L
      (Int.typ @-> Vector2i.typ @-> returning Vector2i.typ)
      Vector2i.s x0  x1 

    (** Returns the component-wise maximum of this and \[param with\], equivalent to \[code\]Vector2i(maxi(x, with.x), maxi(y, with.y))\[/code\]. *)
    let max x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_VECTOR2I
      "max"
      1735278196L
      (Vector2i.typ @-> Vector2i.typ @-> returning Vector2i.typ)
      Vector2i.s x0  x1 

    (** Returns the component-wise maximum of this and \[param with\], equivalent to \[code\]Vector2i(maxi(x, with), maxi(y, with))\[/code\]. *)
    let maxi x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_VECTOR2I
      "maxi"
      2161988953L
      (Int.typ @-> Vector2i.typ @-> returning Vector2i.typ)
      Vector2i.s x0  x1 





    (** Returns the negative value of the \[Vector2i\]. This is the same as writing \[code\]Vector2i(-v.x, -v.y)\[/code\]. This operation flips the direction of the vector while keeping the same magnitude. *)
    let (~-) x0  = 
    foreign_builtin_operator1 GlobalEnum.VariantType._TYPE_VECTOR2I None  GlobalEnum.VariantOperator._OP_NEGATE
      (funptr (Vector2i.typ @-> Vector2i.typ @-> returning void))
      Vector2i.s x0 

    (** Returns the same value as if the \[code\]+\[/code\] was not there. Unary \[code\]+\[/code\] does nothing, but sometimes it can make your code more readable. *)
    let (~+) x0  = 
    foreign_builtin_operator1 GlobalEnum.VariantType._TYPE_VECTOR2I None  GlobalEnum.VariantOperator._OP_POSITIVE
      (funptr (Vector2i.typ @-> Vector2i.typ @-> returning void))
      Vector2i.s x0 


    let not x0  = 
    foreign_builtin_operator1 GlobalEnum.VariantType._TYPE_VECTOR2I None  GlobalEnum.VariantOperator._OP_NOT
      (funptr (Vector2i.typ @-> Bool.typ @-> returning void))
      Bool.s x0 











    (** Returns \[code\]true\[/code\] if the vectors are equal. *)
    let (=) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_VECTOR2I (Some GlobalEnum.VariantType._TYPE_VECTOR2I) GlobalEnum.VariantOperator._OP_EQUAL
      (funptr (Vector2i.typ @-> Vector2i.typ @-> Bool.typ @-> returning void))
      Bool.s
      Conv.Vector2i.of_ocaml
      Conv.Vector2i.of_ocaml
      Conv.Bool.to_ocaml x0  x1 

    (** Returns \[code\]true\[/code\] if the vectors are not equal. *)
    let (<>) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_VECTOR2I (Some GlobalEnum.VariantType._TYPE_VECTOR2I) GlobalEnum.VariantOperator._OP_NOT_EQUAL
      (funptr (Vector2i.typ @-> Vector2i.typ @-> Bool.typ @-> returning void))
      Bool.s
      Conv.Vector2i.of_ocaml
      Conv.Vector2i.of_ocaml
      Conv.Bool.to_ocaml x0  x1 

    (** Compares two \[Vector2i\] vectors by first checking if the X value of the left vector is less than the X value of the \[param right\] vector. If the X values are exactly equal, then it repeats this check with the Y values of the two vectors. This operator is useful for sorting vectors. *)
    let (<) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_VECTOR2I (Some GlobalEnum.VariantType._TYPE_VECTOR2I) GlobalEnum.VariantOperator._OP_LESS
      (funptr (Vector2i.typ @-> Vector2i.typ @-> Bool.typ @-> returning void))
      Bool.s
      Conv.Vector2i.of_ocaml
      Conv.Vector2i.of_ocaml
      Conv.Bool.to_ocaml x0  x1 

    (** Compares two \[Vector2i\] vectors by first checking if the X value of the left vector is less than or equal to the X value of the \[param right\] vector. If the X values are exactly equal, then it repeats this check with the Y values of the two vectors. This operator is useful for sorting vectors. *)
    let (<=) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_VECTOR2I (Some GlobalEnum.VariantType._TYPE_VECTOR2I) GlobalEnum.VariantOperator._OP_LESS_EQUAL
      (funptr (Vector2i.typ @-> Vector2i.typ @-> Bool.typ @-> returning void))
      Bool.s
      Conv.Vector2i.of_ocaml
      Conv.Vector2i.of_ocaml
      Conv.Bool.to_ocaml x0  x1 

    (** Compares two \[Vector2i\] vectors by first checking if the X value of the left vector is greater than the X value of the \[param right\] vector. If the X values are exactly equal, then it repeats this check with the Y values of the two vectors. This operator is useful for sorting vectors. *)
    let (>) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_VECTOR2I (Some GlobalEnum.VariantType._TYPE_VECTOR2I) GlobalEnum.VariantOperator._OP_GREATER
      (funptr (Vector2i.typ @-> Vector2i.typ @-> Bool.typ @-> returning void))
      Bool.s
      Conv.Vector2i.of_ocaml
      Conv.Vector2i.of_ocaml
      Conv.Bool.to_ocaml x0  x1 

    (** Compares two \[Vector2i\] vectors by first checking if the X value of the left vector is greater than or equal to the X value of the \[param right\] vector. If the X values are exactly equal, then it repeats this check with the Y values of the two vectors. This operator is useful for sorting vectors. *)
    let (>=) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_VECTOR2I (Some GlobalEnum.VariantType._TYPE_VECTOR2I) GlobalEnum.VariantOperator._OP_GREATER_EQUAL
      (funptr (Vector2i.typ @-> Vector2i.typ @-> Bool.typ @-> returning void))
      Bool.s
      Conv.Vector2i.of_ocaml
      Conv.Vector2i.of_ocaml
      Conv.Bool.to_ocaml x0  x1 

    (** Adds each component of the \[Vector2i\] by the components of the given \[Vector2i\].
\[codeblock\]
print(Vector2i(10, 20) + Vector2i(3, 4)) # Prints (13, 24)
\[/codeblock\] *)
    let (+) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_VECTOR2I (Some GlobalEnum.VariantType._TYPE_VECTOR2I) GlobalEnum.VariantOperator._OP_ADD
      (funptr (Vector2i.typ @-> Vector2i.typ @-> Vector2i.typ @-> returning void))
      Vector2i.s
      Conv.Vector2i.of_ocaml
      Conv.Vector2i.of_ocaml
      Conv.Vector2i.to_ocaml x0  x1 

    (** Subtracts each component of the \[Vector2i\] by the components of the given \[Vector2i\].
\[codeblock\]
print(Vector2i(10, 20) - Vector2i(3, 4)) # Prints (7, 16)
\[/codeblock\] *)
    let (-) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_VECTOR2I (Some GlobalEnum.VariantType._TYPE_VECTOR2I) GlobalEnum.VariantOperator._OP_SUBTRACT
      (funptr (Vector2i.typ @-> Vector2i.typ @-> Vector2i.typ @-> returning void))
      Vector2i.s
      Conv.Vector2i.of_ocaml
      Conv.Vector2i.of_ocaml
      Conv.Vector2i.to_ocaml x0  x1 

    (** Multiplies each component of the \[Vector2i\] by the components of the given \[Vector2i\].
\[codeblock\]
print(Vector2i(10, 20)  *  Vector2i(3, 4)) # Prints (30, 80)
\[/codeblock\] *)
    let ( * ) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_VECTOR2I (Some GlobalEnum.VariantType._TYPE_VECTOR2I) GlobalEnum.VariantOperator._OP_MULTIPLY
      (funptr (Vector2i.typ @-> Vector2i.typ @-> Vector2i.typ @-> returning void))
      Vector2i.s
      Conv.Vector2i.of_ocaml
      Conv.Vector2i.of_ocaml
      Conv.Vector2i.to_ocaml x0  x1 

    (** Divides each component of the \[Vector2i\] by the components of the given \[Vector2i\].
\[codeblock\]
print(Vector2i(10, 20) / Vector2i(2, 5)) # Prints (5, 4)
\[/codeblock\] *)
    let (/) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_VECTOR2I (Some GlobalEnum.VariantType._TYPE_VECTOR2I) GlobalEnum.VariantOperator._OP_DIVIDE
      (funptr (Vector2i.typ @-> Vector2i.typ @-> Vector2i.typ @-> returning void))
      Vector2i.s
      Conv.Vector2i.of_ocaml
      Conv.Vector2i.of_ocaml
      Conv.Vector2i.to_ocaml x0  x1 

    (** Gets the remainder of each component of the \[Vector2i\] with the components of the given \[Vector2i\]. This operation uses truncated division, which is often not desired as it does not work well with negative numbers. Consider using \[method \@GlobalScope.posmod\] instead if you want to handle negative numbers.
\[codeblock\]
print(Vector2i(10, -20) % Vector2i(7, 8)) # Prints (3, -4)
\[/codeblock\] *)
    let (%) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_VECTOR2I (Some GlobalEnum.VariantType._TYPE_VECTOR2I) GlobalEnum.VariantOperator._OP_MODULE
      (funptr (Vector2i.typ @-> Vector2i.typ @-> Vector2i.typ @-> returning void))
      Vector2i.s
      Conv.Vector2i.of_ocaml
      Conv.Vector2i.of_ocaml
      Conv.Vector2i.to_ocaml x0  x1 


    let mem_Dictionary x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_VECTOR2I (Some GlobalEnum.VariantType._TYPE_DICTIONARY) GlobalEnum.VariantOperator._OP_IN
      (funptr (Vector2i.typ @-> Dictionary.typ @-> Bool.typ @-> returning void))
      Bool.s x0  x1 


    let mem_Array x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_VECTOR2I (Some GlobalEnum.VariantType._TYPE_ARRAY) GlobalEnum.VariantOperator._OP_IN
      (funptr (Vector2i.typ @-> Array.typ @-> Bool.typ @-> returning void))
      Bool.s x0  x1 

    module Axis = struct
      type t = Int.t

      let typ = 
      Int.typ

      (** Enumerated value for the X axis. Returned by \[method max_axis_index\] and \[method min_axis_index\]. *)
      let _AXIS_X = 
      0

      (** Enumerated value for the Y axis. Returned by \[method max_axis_index\] and \[method min_axis_index\]. *)
      let _AXIS_Y = 
      1
      end
    end

  module Rect2 = struct
    include M.Rect2
include BuiltinClass0.Rect2

    (** Returns the center point of the rectangle. This is the same as \[code\]position + (size / 2.0)\[/code\]. *)
    let get_center x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_RECT2
      "get_center"
      2428350749L
      (Rect2.typ @-> returning Vector2.typ)
      Vector2.s x0 

    (** Returns the rectangle''s area. This is equivalent to \[code\]size.x  *  size.y\[/code\]. See also \[method has_area\]. *)
    let get_area x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_RECT2
      "get_area"
      466405837L
      (Rect2.typ @-> returning Float.typ)
      Float.s x0 

    (** Returns \[code\]true\[/code\] if this rectangle has positive width and height. See also \[method get_area\]. *)
    let has_area x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_RECT2
      "has_area"
      3918633141L
      (Rect2.typ @-> returning Bool.typ)
      Bool.s x0 

    (** Returns \[code\]true\[/code\] if the rectangle contains the given \[param point\]. By convention, points on the right and bottom edges are \[b\]not\[/b\] included.
\[b\]Note:\[/b\] This method is not reliable for \[Rect2\] with a \[i\]negative\[/i\] \[member size\]. Use \[method abs\] first to get a valid rectangle. *)
    let has_point x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_RECT2
      "has_point"
      3190634762L
      (Vector2.typ @-> Rect2.typ @-> returning Bool.typ)
      Bool.s x0  x1 

    (** Returns \[code\]true\[/code\] if this rectangle and \[param rect\] are approximately equal, by calling \[method Vector2.is_equal_approx\] on the \[member position\] and the \[member size\]. *)
    let is_equal_approx x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_RECT2
      "is_equal_approx"
      1908192260L
      (Rect2.typ @-> Rect2.typ @-> returning Bool.typ)
      Bool.s x0  x1 

    (** Returns \[code\]true\[/code\] if this rectangle''s values are finite, by calling \[method Vector2.is_finite\] on the \[member position\] and the \[member size\]. *)
    let is_finite x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_RECT2
      "is_finite"
      3918633141L
      (Rect2.typ @-> returning Bool.typ)
      Bool.s x0 

    (** Returns \[code\]true\[/code\] if this rectangle overlaps with the \[param b\] rectangle. The edges of both rectangles are excluded, unless \[param include_borders\] is \[code\]true\[/code\]. *)
    let intersects x0  x1  x2  = 
    foreign_builtin_method2
      GlobalEnum.VariantType._TYPE_RECT2
      "intersects"
      819294880L
      (Rect2.typ @-> Bool.typ @-> Rect2.typ @-> returning Bool.typ)
      Bool.s x0  x1  x2 

    (** Returns \[code\]true\[/code\] if this rectangle \[i\]completely\[/i\] encloses the \[param b\] rectangle. *)
    let encloses x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_RECT2
      "encloses"
      1908192260L
      (Rect2.typ @-> Rect2.typ @-> returning Bool.typ)
      Bool.s x0  x1 

    (** Returns the intersection between this rectangle and \[param b\]. If the rectangles do not intersect, returns an empty \[Rect2\].
\[codeblocks\]
\[gdscript\]
var rect1 = Rect2(0, 0, 5, 10)
var rect2 = Rect2(2, 0, 8, 4)

var a = rect1.intersection(rect2) # a is Rect2(2, 0, 3, 4)
\[/gdscript\]
\[csharp\]
var rect1 = new Rect2(0, 0, 5, 10);
var rect2 = new Rect2(2, 0, 8, 4);

var a = rect1.Intersection(rect2); // a is Rect2(2, 0, 3, 4)
\[/csharp\]
\[/codeblocks\]
\[b\]Note:\[/b\] If you only need to know whether two rectangles are overlapping, use \[method intersects\], instead. *)
    let intersection x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_RECT2
      "intersection"
      2282977743L
      (Rect2.typ @-> Rect2.typ @-> returning Rect2.typ)
      Rect2.s x0  x1 

    (** Returns a \[Rect2\] that encloses both this rectangle and \[param b\] around the edges. See also \[method encloses\]. *)
    let merge x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_RECT2
      "merge"
      2282977743L
      (Rect2.typ @-> Rect2.typ @-> returning Rect2.typ)
      Rect2.s x0  x1 

    (** Returns a copy of this rectangle expanded to align the edges with the given \[param to\] point, if necessary.
\[codeblocks\]
\[gdscript\]
var rect = Rect2(0, 0, 5, 2)

rect = rect.expand(Vector2(10, 0)) # rect is Rect2(0, 0, 10, 2)
rect = rect.expand(Vector2(-5, 5)) # rect is Rect2(-5, 0, 15, 5)
\[/gdscript\]
\[csharp\]
var rect = new Rect2(0, 0, 5, 2);

rect = rect.Expand(new Vector2(10, 0)); // rect is Rect2(0, 0, 10, 2)
rect = rect.Expand(new Vector2(-5, 5)); // rect is Rect2(-5, 0, 15, 5)
\[/csharp\]
\[/codeblocks\] *)
    let expand x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_RECT2
      "expand"
      293272265L
      (Vector2.typ @-> Rect2.typ @-> returning Rect2.typ)
      Rect2.s x0  x1 

    (** Returns the vertex''s position of this rect that''s the farthest in the given direction. This point is commonly known as the support point in collision detection algorithms. *)
    let get_support x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_RECT2
      "get_support"
      2026743667L
      (Vector2.typ @-> Rect2.typ @-> returning Vector2.typ)
      Vector2.s x0  x1 

    (** Returns a copy of this rectangle extended on all sides by the given \[param amount\]. A negative \[param amount\] shrinks the rectangle instead. See also \[method grow_individual\] and \[method grow_side\].
\[codeblocks\]
\[gdscript\]
var a = Rect2(4, 4, 8, 8).grow(4) # a is Rect2(0, 0, 16, 16)
var b = Rect2(0, 0, 8, 4).grow(2) # b is Rect2(-2, -2, 12, 8)
\[/gdscript\]
\[csharp\]
var a = new Rect2(4, 4, 8, 8).Grow(4); // a is Rect2(0, 0, 16, 16)
var b = new Rect2(0, 0, 8, 4).Grow(2); // b is Rect2(-2, -2, 12, 8)
\[/csharp\]
\[/codeblocks\] *)
    let grow x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_RECT2
      "grow"
      39664498L
      (Float.typ @-> Rect2.typ @-> returning Rect2.typ)
      Rect2.s x0  x1 

    (** Returns a copy of this rectangle with its \[param side\] extended by the given \[param amount\] (see \[enum Side\] constants). A negative \[param amount\] shrinks the rectangle, instead. See also \[method grow\] and \[method grow_individual\]. *)
    let grow_side x0  x1  x2  = 
    foreign_builtin_method2
      GlobalEnum.VariantType._TYPE_RECT2
      "grow_side"
      4177736158L
      (Int.typ @-> Float.typ @-> Rect2.typ @-> returning Rect2.typ)
      Rect2.s x0  x1  x2 

    (** Returns a copy of this rectangle with its \[param left\], \[param top\], \[param right\], and \[param bottom\] sides extended by the given amounts. Negative values shrink the sides, instead. See also \[method grow\] and \[method grow_side\]. *)
    let grow_individual x0  x1  x2  x3  x4  = 
    foreign_builtin_method4
      GlobalEnum.VariantType._TYPE_RECT2
      "grow_individual"
      3203390369L
      (Float.typ @-> Float.typ @-> Float.typ @-> Float.typ @-> Rect2.typ @-> returning Rect2.typ)
      Rect2.s x0  x1  x2  x3  x4 

    (** Returns a \[Rect2\] equivalent to this rectangle, with its width and height modified to be non-negative values, and with its \[member position\] being the top-left corner of the rectangle.
\[codeblocks\]
\[gdscript\]
var rect = Rect2(25, 25, -100, -50)
var absolute = rect.abs() # absolute is Rect2(-75, -25, 100, 50)
\[/gdscript\]
\[csharp\]
var rect = new Rect2(25, 25, -100, -50);
var absolute = rect.Abs(); // absolute is Rect2(-75, -25, 100, 50)
\[/csharp\]
\[/codeblocks\]
\[b\]Note:\[/b\] It''s recommended to use this method when \[member size\] is negative, as most other methods in Godot assume that the \[member position\] is the top-left corner, and the \[member end\] is the bottom-right corner. *)
    let abs x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_RECT2
      "abs"
      3107653634L
      (Rect2.typ @-> returning Rect2.typ)
      Rect2.s x0 






    let not x0  = 
    foreign_builtin_operator1 GlobalEnum.VariantType._TYPE_RECT2 None  GlobalEnum.VariantOperator._OP_NOT
      (funptr (Rect2.typ @-> Bool.typ @-> returning void))
      Bool.s x0 

    (** Returns \[code\]true\[/code\] if both \[member position\] and \[member size\] of the rectangles are exactly equal, respectively.
\[b\]Note:\[/b\] Due to floating-point precision errors, consider using \[method is_equal_approx\] instead, which is more reliable. *)
    let (=) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_RECT2 (Some GlobalEnum.VariantType._TYPE_RECT2) GlobalEnum.VariantOperator._OP_EQUAL
      (funptr (Rect2.typ @-> Rect2.typ @-> Bool.typ @-> returning void))
      Bool.s
      Conv.Rect2.of_ocaml
      Conv.Rect2.of_ocaml
      Conv.Bool.to_ocaml x0  x1 

    (** Returns \[code\]true\[/code\] if the \[member position\] or \[member size\] of both rectangles are not equal.
\[b\]Note:\[/b\] Due to floating-point precision errors, consider using \[method is_equal_approx\] instead, which is more reliable. *)
    let (<>) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_RECT2 (Some GlobalEnum.VariantType._TYPE_RECT2) GlobalEnum.VariantOperator._OP_NOT_EQUAL
      (funptr (Rect2.typ @-> Rect2.typ @-> Bool.typ @-> returning void))
      Bool.s
      Conv.Rect2.of_ocaml
      Conv.Rect2.of_ocaml
      Conv.Bool.to_ocaml x0  x1 




    let mem_Dictionary x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_RECT2 (Some GlobalEnum.VariantType._TYPE_DICTIONARY) GlobalEnum.VariantOperator._OP_IN
      (funptr (Rect2.typ @-> Dictionary.typ @-> Bool.typ @-> returning void))
      Bool.s x0  x1 


    let mem_Array x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_RECT2 (Some GlobalEnum.VariantType._TYPE_ARRAY) GlobalEnum.VariantOperator._OP_IN
      (funptr (Rect2.typ @-> Array.typ @-> Bool.typ @-> returning void))
      Bool.s x0  x1 
    end

  module Rect2i = struct
    include M.Rect2i
include BuiltinClass0.Rect2i

    (** Returns the center point of the rectangle. This is the same as \[code\]position + (size / 2)\[/code\].
\[b\]Note:\[/b\] If the \[member size\] is odd, the result will be rounded towards \[member position\]. *)
    let get_center x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_RECT2I
      "get_center"
      3444277866L
      (Rect2i.typ @-> returning Vector2i.typ)
      Vector2i.s x0 

    (** Returns the rectangle''s area. This is equivalent to \[code\]size.x  *  size.y\[/code\]. See also \[method has_area\]. *)
    let get_area x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_RECT2I
      "get_area"
      3173160232L
      (Rect2i.typ @-> returning Int.typ)
      Int.s x0 

    (** Returns \[code\]true\[/code\] if this rectangle has positive width and height. See also \[method get_area\]. *)
    let has_area x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_RECT2I
      "has_area"
      3918633141L
      (Rect2i.typ @-> returning Bool.typ)
      Bool.s x0 

    (** Returns \[code\]true\[/code\] if the rectangle contains the given \[param point\]. By convention, points on the right and bottom edges are \[b\]not\[/b\] included.
\[b\]Note:\[/b\] This method is not reliable for \[Rect2i\] with a \[i\]negative\[/i\] \[member size\]. Use \[method abs\] first to get a valid rectangle. *)
    let has_point x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_RECT2I
      "has_point"
      328189994L
      (Vector2i.typ @-> Rect2i.typ @-> returning Bool.typ)
      Bool.s x0  x1 

    (** Returns \[code\]true\[/code\] if this rectangle overlaps with the \[param b\] rectangle. The edges of both rectangles are excluded. *)
    let intersects x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_RECT2I
      "intersects"
      3434691493L
      (Rect2i.typ @-> Rect2i.typ @-> returning Bool.typ)
      Bool.s x0  x1 

    (** Returns \[code\]true\[/code\] if this \[Rect2i\] completely encloses another one. *)
    let encloses x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_RECT2I
      "encloses"
      3434691493L
      (Rect2i.typ @-> Rect2i.typ @-> returning Bool.typ)
      Bool.s x0  x1 

    (** Returns the intersection between this rectangle and \[param b\]. If the rectangles do not intersect, returns an empty \[Rect2i\].
\[codeblocks\]
\[gdscript\]
var a = Rect2i(0, 0, 5, 10)
var b = Rect2i(2, 0, 8, 4)

var c = a.intersection(b) # c is Rect2i(2, 0, 3, 4)
\[/gdscript\]
\[csharp\]
var a = new Rect2I(0, 0, 5, 10);
var b = new Rect2I(2, 0, 8, 4);

var c = rect1.Intersection(rect2); // c is Rect2I(2, 0, 3, 4)
\[/csharp\]
\[/codeblocks\]
\[b\]Note:\[/b\] If you only need to know whether two rectangles are overlapping, use \[method intersects\], instead. *)
    let intersection x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_RECT2I
      "intersection"
      717431873L
      (Rect2i.typ @-> Rect2i.typ @-> returning Rect2i.typ)
      Rect2i.s x0  x1 

    (** Returns a \[Rect2i\] that encloses both this rectangle and \[param b\] around the edges. See also \[method encloses\]. *)
    let merge x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_RECT2I
      "merge"
      717431873L
      (Rect2i.typ @-> Rect2i.typ @-> returning Rect2i.typ)
      Rect2i.s x0  x1 

    (** Returns a copy of this rectangle expanded to align the edges with the given \[param to\] point, if necessary.
\[codeblocks\]
\[gdscript\]
var rect = Rect2i(0, 0, 5, 2)

rect = rect.expand(Vector2i(10, 0)) # rect is Rect2i(0, 0, 10, 2)
rect = rect.expand(Vector2i(-5, 5)) # rect is Rect2i(-5, 0, 15, 5)
\[/gdscript\]
\[csharp\]
var rect = new Rect2I(0, 0, 5, 2);

rect = rect.Expand(new Vector2I(10, 0)); // rect is Rect2I(0, 0, 10, 2)
rect = rect.Expand(new Vector2I(-5, 5)); // rect is Rect2I(-5, 0, 15, 5)
\[/csharp\]
\[/codeblocks\] *)
    let expand x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_RECT2I
      "expand"
      1355196872L
      (Vector2i.typ @-> Rect2i.typ @-> returning Rect2i.typ)
      Rect2i.s x0  x1 

    (** Returns a copy of this rectangle extended on all sides by the given \[param amount\]. A negative \[param amount\] shrinks the rectangle instead. See also \[method grow_individual\] and \[method grow_side\].
\[codeblocks\]
\[gdscript\]
var a = Rect2i(4, 4, 8, 8).grow(4) # a is Rect2i(0, 0, 16, 16)
var b = Rect2i(0, 0, 8, 4).grow(2) # b is Rect2i(-2, -2, 12, 8)
\[/gdscript\]
\[csharp\]
var a = new Rect2I(4, 4, 8, 8).Grow(4); // a is Rect2I(0, 0, 16, 16)
var b = new Rect2I(0, 0, 8, 4).Grow(2); // b is Rect2I(-2, -2, 12, 8)
\[/csharp\]
\[/codeblocks\] *)
    let grow x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_RECT2I
      "grow"
      1578070074L
      (Int.typ @-> Rect2i.typ @-> returning Rect2i.typ)
      Rect2i.s x0  x1 

    (** Returns a copy of this rectangle with its \[param side\] extended by the given \[param amount\] (see \[enum Side\] constants). A negative \[param amount\] shrinks the rectangle, instead. See also \[method grow\] and \[method grow_individual\]. *)
    let grow_side x0  x1  x2  = 
    foreign_builtin_method2
      GlobalEnum.VariantType._TYPE_RECT2I
      "grow_side"
      3191154199L
      (Int.typ @-> Int.typ @-> Rect2i.typ @-> returning Rect2i.typ)
      Rect2i.s x0  x1  x2 

    (** Returns a copy of this rectangle with its \[param left\], \[param top\], \[param right\], and \[param bottom\] sides extended by the given amounts. Negative values shrink the sides, instead. See also \[method grow\] and \[method grow_side\]. *)
    let grow_individual x0  x1  x2  x3  x4  = 
    foreign_builtin_method4
      GlobalEnum.VariantType._TYPE_RECT2I
      "grow_individual"
      1893743416L
      (Int.typ @-> Int.typ @-> Int.typ @-> Int.typ @-> Rect2i.typ @-> returning Rect2i.typ)
      Rect2i.s x0  x1  x2  x3  x4 

    (** Returns a \[Rect2i\] equivalent to this rectangle, with its width and height modified to be non-negative values, and with its \[member position\] being the top-left corner of the rectangle.
\[codeblocks\]
\[gdscript\]
var rect = Rect2i(25, 25, -100, -50)
var absolute = rect.abs() # absolute is Rect2i(-75, -25, 100, 50)
\[/gdscript\]
\[csharp\]
var rect = new Rect2I(25, 25, -100, -50);
var absolute = rect.Abs(); // absolute is Rect2I(-75, -25, 100, 50)
\[/csharp\]
\[/codeblocks\]
\[b\]Note:\[/b\] It''s recommended to use this method when \[member size\] is negative, as most other methods in Godot assume that the \[member position\] is the top-left corner, and the \[member end\] is the bottom-right corner. *)
    let abs x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_RECT2I
      "abs"
      1469025700L
      (Rect2i.typ @-> returning Rect2i.typ)
      Rect2i.s x0 






    let not x0  = 
    foreign_builtin_operator1 GlobalEnum.VariantType._TYPE_RECT2I None  GlobalEnum.VariantOperator._OP_NOT
      (funptr (Rect2i.typ @-> Bool.typ @-> returning void))
      Bool.s x0 

    (** Returns \[code\]true\[/code\] if both \[member position\] and \[member size\] of the rectangles are equal, respectively. *)
    let (=) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_RECT2I (Some GlobalEnum.VariantType._TYPE_RECT2I) GlobalEnum.VariantOperator._OP_EQUAL
      (funptr (Rect2i.typ @-> Rect2i.typ @-> Bool.typ @-> returning void))
      Bool.s
      Conv.Rect2i.of_ocaml
      Conv.Rect2i.of_ocaml
      Conv.Bool.to_ocaml x0  x1 

    (** Returns \[code\]true\[/code\] if the \[member position\] or \[member size\] of both rectangles are not equal. *)
    let (<>) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_RECT2I (Some GlobalEnum.VariantType._TYPE_RECT2I) GlobalEnum.VariantOperator._OP_NOT_EQUAL
      (funptr (Rect2i.typ @-> Rect2i.typ @-> Bool.typ @-> returning void))
      Bool.s
      Conv.Rect2i.of_ocaml
      Conv.Rect2i.of_ocaml
      Conv.Bool.to_ocaml x0  x1 


    let mem_Dictionary x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_RECT2I (Some GlobalEnum.VariantType._TYPE_DICTIONARY) GlobalEnum.VariantOperator._OP_IN
      (funptr (Rect2i.typ @-> Dictionary.typ @-> Bool.typ @-> returning void))
      Bool.s x0  x1 


    let mem_Array x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_RECT2I (Some GlobalEnum.VariantType._TYPE_ARRAY) GlobalEnum.VariantOperator._OP_IN
      (funptr (Rect2i.typ @-> Array.typ @-> Bool.typ @-> returning void))
      Bool.s x0  x1 
    end

  module Vector3 = struct
    include M.Vector3
include BuiltinClass0.Vector3

    (** Returns the axis of the vector''s lowest value. See \[code\]AXIS_ * \[/code\] constants. If all components are equal, this method returns \[constant AXIS_Z\]. *)
    let min_axis_index x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_VECTOR3
      "min_axis_index"
      3173160232L
      (Vector3.typ @-> returning Int.typ)
      Int.s x0 

    (** Returns the axis of the vector''s highest value. See \[code\]AXIS_ * \[/code\] constants. If all components are equal, this method returns \[constant AXIS_X\]. *)
    let max_axis_index x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_VECTOR3
      "max_axis_index"
      3173160232L
      (Vector3.typ @-> returning Int.typ)
      Int.s x0 

    (** Returns the unsigned minimum angle to the given vector, in radians. *)
    let angle_to x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_VECTOR3
      "angle_to"
      1047977935L
      (Vector3.typ @-> Vector3.typ @-> returning Float.typ)
      Float.s x0  x1 

    (** Returns the signed angle to the given vector, in radians. The sign of the angle is positive in a counter-clockwise direction and negative in a clockwise direction when viewed from the side specified by the \[param axis\]. *)
    let signed_angle_to x0  x1  x2  = 
    foreign_builtin_method2
      GlobalEnum.VariantType._TYPE_VECTOR3
      "signed_angle_to"
      2781412522L
      (Vector3.typ @-> Vector3.typ @-> Vector3.typ @-> returning Float.typ)
      Float.s x0  x1  x2 

    (** Returns the normalized vector pointing from this vector to \[param to\]. This is equivalent to using \[code\](b - a).normalized()\[/code\]. *)
    let direction_to x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_VECTOR3
      "direction_to"
      2923479887L
      (Vector3.typ @-> Vector3.typ @-> returning Vector3.typ)
      Vector3.s x0  x1 

    (** Returns the distance between this vector and \[param to\]. *)
    let distance_to x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_VECTOR3
      "distance_to"
      1047977935L
      (Vector3.typ @-> Vector3.typ @-> returning Float.typ)
      Float.s x0  x1 

    (** Returns the squared distance between this vector and \[param to\].
This method runs faster than \[method distance_to\], so prefer it if you need to compare vectors or need the squared distance for some formula. *)
    let distance_squared_to x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_VECTOR3
      "distance_squared_to"
      1047977935L
      (Vector3.typ @-> Vector3.typ @-> returning Float.typ)
      Float.s x0  x1 

    (** Returns the length (magnitude) of this vector. *)
    let length x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_VECTOR3
      "length"
      466405837L
      (Vector3.typ @-> returning Float.typ)
      Float.s x0 

    (** Returns the squared length (squared magnitude) of this vector.
This method runs faster than \[method length\], so prefer it if you need to compare vectors or need the squared distance for some formula. *)
    let length_squared x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_VECTOR3
      "length_squared"
      466405837L
      (Vector3.typ @-> returning Float.typ)
      Float.s x0 

    (** Returns the vector with a maximum length by limiting its length to \[param length\]. If the vector is non-finite, the result is undefined. *)
    let limit_length x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_VECTOR3
      "limit_length"
      514930144L
      (Float.typ @-> Vector3.typ @-> returning Vector3.typ)
      Vector3.s x0  x1 

    (** Returns the result of scaling the vector to unit length. Equivalent to \[code\]v / v.length()\[/code\]. Returns \[code\](0, 0, 0)\[/code\] if \[code\]v.length() == 0\[/code\]. See also \[method is_normalized\].
\[b\]Note:\[/b\] This function may return incorrect values if the input vector length is near zero. *)
    let normalized x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_VECTOR3
      "normalized"
      1776574132L
      (Vector3.typ @-> returning Vector3.typ)
      Vector3.s x0 

    (** Returns \[code\]true\[/code\] if the vector is normalized, i.e. its length is approximately equal to 1. *)
    let is_normalized x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_VECTOR3
      "is_normalized"
      3918633141L
      (Vector3.typ @-> returning Bool.typ)
      Bool.s x0 

    (** Returns \[code\]true\[/code\] if this vector and \[param to\] are approximately equal, by running \[method \@GlobalScope.is_equal_approx\] on each component. *)
    let is_equal_approx x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_VECTOR3
      "is_equal_approx"
      1749054343L
      (Vector3.typ @-> Vector3.typ @-> returning Bool.typ)
      Bool.s x0  x1 

    (** Returns \[code\]true\[/code\] if this vector''s values are approximately zero, by running \[method \@GlobalScope.is_zero_approx\] on each component.
This method is faster than using \[method is_equal_approx\] with one value as a zero vector. *)
    let is_zero_approx x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_VECTOR3
      "is_zero_approx"
      3918633141L
      (Vector3.typ @-> returning Bool.typ)
      Bool.s x0 

    (** Returns \[code\]true\[/code\] if this vector is finite, by calling \[method \@GlobalScope.is_finite\] on each component. *)
    let is_finite x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_VECTOR3
      "is_finite"
      3918633141L
      (Vector3.typ @-> returning Bool.typ)
      Bool.s x0 

    (** Returns the inverse of the vector. This is the same as \[code\]Vector3(1.0 / v.x, 1.0 / v.y, 1.0 / v.z)\[/code\]. *)
    let inverse x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_VECTOR3
      "inverse"
      1776574132L
      (Vector3.typ @-> returning Vector3.typ)
      Vector3.s x0 

    (** Returns a new vector with all components clamped between the components of \[param min\] and \[param max\], by running \[method \@GlobalScope.clamp\] on each component. *)
    let clamp x0  x1  x2  = 
    foreign_builtin_method2
      GlobalEnum.VariantType._TYPE_VECTOR3
      "clamp"
      4145107892L
      (Vector3.typ @-> Vector3.typ @-> Vector3.typ @-> returning Vector3.typ)
      Vector3.s x0  x1  x2 

    (** Returns a new vector with all components clamped between \[param min\] and \[param max\], by running \[method \@GlobalScope.clamp\] on each component. *)
    let clampf x0  x1  x2  = 
    foreign_builtin_method2
      GlobalEnum.VariantType._TYPE_VECTOR3
      "clampf"
      2329594628L
      (Float.typ @-> Float.typ @-> Vector3.typ @-> returning Vector3.typ)
      Vector3.s x0  x1  x2 

    (** Returns a new vector with each component snapped to the nearest multiple of the corresponding component in \[param step\]. This can also be used to round the components to an arbitrary number of decimals. *)
    let snapped x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_VECTOR3
      "snapped"
      2923479887L
      (Vector3.typ @-> Vector3.typ @-> returning Vector3.typ)
      Vector3.s x0  x1 

    (** Returns a new vector with each component snapped to the nearest multiple of \[param step\]. This can also be used to round the components to an arbitrary number of decimals. *)
    let snappedf x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_VECTOR3
      "snappedf"
      514930144L
      (Float.typ @-> Vector3.typ @-> returning Vector3.typ)
      Vector3.s x0  x1 

    (** Returns the result of rotating this vector around a given axis by \[param angle\] (in radians). The axis must be a normalized vector. See also \[method \@GlobalScope.deg_to_rad\]. *)
    let rotated x0  x1  x2  = 
    foreign_builtin_method2
      GlobalEnum.VariantType._TYPE_VECTOR3
      "rotated"
      1682608829L
      (Vector3.typ @-> Float.typ @-> Vector3.typ @-> returning Vector3.typ)
      Vector3.s x0  x1  x2 

    (** Returns the result of the linear interpolation between this vector and \[param to\] by amount \[param weight\]. \[param weight\] is on the range of \[code\]0.0\[/code\] to \[code\]1.0\[/code\], representing the amount of interpolation. *)
    let lerp x0  x1  x2  = 
    foreign_builtin_method2
      GlobalEnum.VariantType._TYPE_VECTOR3
      "lerp"
      1682608829L
      (Vector3.typ @-> Float.typ @-> Vector3.typ @-> returning Vector3.typ)
      Vector3.s x0  x1  x2 

    (** Returns the result of spherical linear interpolation between this vector and \[param to\], by amount \[param weight\]. \[param weight\] is on the range of 0.0 to 1.0, representing the amount of interpolation.
This method also handles interpolating the lengths if the input vectors have different lengths. For the special case of one or both input vectors having zero length, this method behaves like \[method lerp\]. *)
    let slerp x0  x1  x2  = 
    foreign_builtin_method2
      GlobalEnum.VariantType._TYPE_VECTOR3
      "slerp"
      1682608829L
      (Vector3.typ @-> Float.typ @-> Vector3.typ @-> returning Vector3.typ)
      Vector3.s x0  x1  x2 

    (** Performs a cubic interpolation between this vector and \[param b\] using \[param pre_a\] and \[param post_b\] as handles, and returns the result at position \[param weight\]. \[param weight\] is on the range of 0.0 to 1.0, representing the amount of interpolation. *)
    let cubic_interpolate x0  x1  x2  x3  x4  = 
    foreign_builtin_method4
      GlobalEnum.VariantType._TYPE_VECTOR3
      "cubic_interpolate"
      2597922253L
      (Vector3.typ @-> Vector3.typ @-> Vector3.typ @-> Float.typ @-> Vector3.typ @-> returning Vector3.typ)
      Vector3.s x0  x1  x2  x3  x4 

    (** Performs a cubic interpolation between this vector and \[param b\] using \[param pre_a\] and \[param post_b\] as handles, and returns the result at position \[param weight\]. \[param weight\] is on the range of 0.0 to 1.0, representing the amount of interpolation.
It can perform smoother interpolation than \[method cubic_interpolate\] by the time values. *)
    let cubic_interpolate_in_time x0  x1  x2  x3  x4  x5  x6  x7  = 
    foreign_builtin_method7
      GlobalEnum.VariantType._TYPE_VECTOR3
      "cubic_interpolate_in_time"
      3256682901L
      (Vector3.typ @-> Vector3.typ @-> Vector3.typ @-> Float.typ @-> Float.typ @-> Float.typ @-> Float.typ @-> Vector3.typ @-> returning Vector3.typ)
      Vector3.s x0  x1  x2  x3  x4  x5  x6  x7 

    (** Returns the point at the given \[param t\] on the \[url=https://en.wikipedia.org/wiki/B%C3%A9zier_curve\]Bzier curve\[/url\] defined by this vector and the given \[param control_1\], \[param control_2\], and \[param end\] points. *)
    let bezier_interpolate x0  x1  x2  x3  x4  = 
    foreign_builtin_method4
      GlobalEnum.VariantType._TYPE_VECTOR3
      "bezier_interpolate"
      2597922253L
      (Vector3.typ @-> Vector3.typ @-> Vector3.typ @-> Float.typ @-> Vector3.typ @-> returning Vector3.typ)
      Vector3.s x0  x1  x2  x3  x4 

    (** Returns the derivative at the given \[param t\] on the \[url=https://en.wikipedia.org/wiki/B%C3%A9zier_curve\]Bzier curve\[/url\] defined by this vector and the given \[param control_1\], \[param control_2\], and \[param end\] points. *)
    let bezier_derivative x0  x1  x2  x3  x4  = 
    foreign_builtin_method4
      GlobalEnum.VariantType._TYPE_VECTOR3
      "bezier_derivative"
      2597922253L
      (Vector3.typ @-> Vector3.typ @-> Vector3.typ @-> Float.typ @-> Vector3.typ @-> returning Vector3.typ)
      Vector3.s x0  x1  x2  x3  x4 

    (** Returns a new vector moved toward \[param to\] by the fixed \[param delta\] amount. Will not go past the final value. *)
    let move_toward x0  x1  x2  = 
    foreign_builtin_method2
      GlobalEnum.VariantType._TYPE_VECTOR3
      "move_toward"
      1682608829L
      (Vector3.typ @-> Float.typ @-> Vector3.typ @-> returning Vector3.typ)
      Vector3.s x0  x1  x2 

    (** Returns the dot product of this vector and \[param with\]. This can be used to compare the angle between two vectors. For example, this can be used to determine whether an enemy is facing the player.
The dot product will be \[code\]0\[/code\] for a right angle (90 degrees), greater than 0 for angles narrower than 90 degrees and lower than 0 for angles wider than 90 degrees.
When using unit (normalized) vectors, the result will always be between \[code\]-1.0\[/code\] (180 degree angle) when the vectors are facing opposite directions, and \[code\]1.0\[/code\] (0 degree angle) when the vectors are aligned.
\[b\]Note:\[/b\] \[code\]a.dot(b)\[/code\] is equivalent to \[code\]b.dot(a)\[/code\]. *)
    let dot x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_VECTOR3
      "dot"
      1047977935L
      (Vector3.typ @-> Vector3.typ @-> returning Float.typ)
      Float.s x0  x1 

    (** Returns the cross product of this vector and \[param with\].
This returns a vector perpendicular to both this and \[param with\], which would be the normal vector of the plane defined by the two vectors. As there are two such vectors, in opposite directions, this method returns the vector defined by a right-handed coordinate system. If the two vectors are parallel this returns an empty vector, making it useful for testing if two vectors are parallel. *)
    let cross x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_VECTOR3
      "cross"
      2923479887L
      (Vector3.typ @-> Vector3.typ @-> returning Vector3.typ)
      Vector3.s x0  x1 

    (** Returns the outer product with \[param with\]. *)
    let outer x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_VECTOR3
      "outer"
      3934786792L
      (Vector3.typ @-> Vector3.typ @-> returning Basis.typ)
      Basis.s x0  x1 

    (** Returns a new vector with all components in absolute values (i.e. positive). *)
    let abs x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_VECTOR3
      "abs"
      1776574132L
      (Vector3.typ @-> returning Vector3.typ)
      Vector3.s x0 

    (** Returns a new vector with all components rounded down (towards negative infinity). *)
    let floor x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_VECTOR3
      "floor"
      1776574132L
      (Vector3.typ @-> returning Vector3.typ)
      Vector3.s x0 

    (** Returns a new vector with all components rounded up (towards positive infinity). *)
    let ceil x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_VECTOR3
      "ceil"
      1776574132L
      (Vector3.typ @-> returning Vector3.typ)
      Vector3.s x0 

    (** Returns a new vector with all components rounded to the nearest integer, with halfway cases rounded away from zero. *)
    let round x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_VECTOR3
      "round"
      1776574132L
      (Vector3.typ @-> returning Vector3.typ)
      Vector3.s x0 

    (** Returns a vector composed of the \[method \@GlobalScope.fposmod\] of this vector''s components and \[param mod\]. *)
    let posmod x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_VECTOR3
      "posmod"
      514930144L
      (Float.typ @-> Vector3.typ @-> returning Vector3.typ)
      Vector3.s x0  x1 

    (** Returns a vector composed of the \[method \@GlobalScope.fposmod\] of this vector''s components and \[param modv\]''s components. *)
    let posmodv x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_VECTOR3
      "posmodv"
      2923479887L
      (Vector3.typ @-> Vector3.typ @-> returning Vector3.typ)
      Vector3.s x0  x1 

    (** Returns a new vector resulting from projecting this vector onto the given vector \[param b\]. The resulting new vector is parallel to \[param b\]. See also \[method slide\].
\[b\]Note:\[/b\] If the vector \[param b\] is a zero vector, the components of the resulting new vector will be \[constant \@GDScript.NAN\]. *)
    let project x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_VECTOR3
      "project"
      2923479887L
      (Vector3.typ @-> Vector3.typ @-> returning Vector3.typ)
      Vector3.s x0  x1 

    (** Returns a new vector resulting from sliding this vector along a plane with normal \[param n\]. The resulting new vector is perpendicular to \[param n\], and is equivalent to this vector minus its projection on \[param n\]. See also \[method project\].
\[b\]Note:\[/b\] The vector \[param n\] must be normalized. See also \[method normalized\]. *)
    let slide x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_VECTOR3
      "slide"
      2923479887L
      (Vector3.typ @-> Vector3.typ @-> returning Vector3.typ)
      Vector3.s x0  x1 

    (** Returns the vector ""bounced off"" from a plane defined by the given normal \[param n\].
\[b\]Note:\[/b\] \[method bounce\] performs the operation that most engines and frameworks call \[code skip-lint\]reflect()\[/code\]. *)
    let bounce x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_VECTOR3
      "bounce"
      2923479887L
      (Vector3.typ @-> Vector3.typ @-> returning Vector3.typ)
      Vector3.s x0  x1 

    (** Returns the result of reflecting the vector through a plane defined by the given normal vector \[param n\].
\[b\]Note:\[/b\] \[method reflect\] differs from what other engines and frameworks call \[code skip-lint\]reflect()\[/code\]. In other engines, \[code skip-lint\]reflect()\[/code\] returns the result of the vector reflected by the given plane. The reflection thus passes through the given normal. While in Godot the reflection passes through the plane and can be thought of as bouncing off the normal. See also \[method bounce\] which does what most engines call \[code skip-lint\]reflect()\[/code\]. *)
    let reflect x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_VECTOR3
      "reflect"
      2923479887L
      (Vector3.typ @-> Vector3.typ @-> returning Vector3.typ)
      Vector3.s x0  x1 

    (** Returns a new vector with each component set to \[code\]1.0\[/code\] if it''s positive, \[code\]-1.0\[/code\] if it''s negative, and \[code\]0.0\[/code\] if it''s zero. The result is identical to calling \[method \@GlobalScope.sign\] on each component. *)
    let sign x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_VECTOR3
      "sign"
      1776574132L
      (Vector3.typ @-> returning Vector3.typ)
      Vector3.s x0 

    (** Returns the octahedral-encoded (oct32) form of this \[Vector3\] as a \[Vector2\]. Since a \[Vector2\] occupies 1/3 less memory compared to \[Vector3\], this form of compression can be used to pass greater amounts of \[method normalized\] \[Vector3\]s without increasing storage or memory requirements. See also \[method octahedron_decode\].
\[b\]Note:\[/b\] \[method octahedron_encode\] can only be used for \[method normalized\] vectors. \[method octahedron_encode\] does \[i\]not\[/i\] check whether this \[Vector3\] is normalized, and will return a value that does not decompress to the original value if the \[Vector3\] is not normalized.
\[b\]Note:\[/b\] Octahedral compression is \[i\]lossy\[/i\], although visual differences are rarely perceptible in real world scenarios. *)
    let octahedron_encode x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_VECTOR3
      "octahedron_encode"
      2428350749L
      (Vector3.typ @-> returning Vector2.typ)
      Vector2.s x0 

    (** Returns the component-wise minimum of this and \[param with\], equivalent to \[code\]Vector3(minf(x, with.x), minf(y, with.y), minf(z, with.z))\[/code\]. *)
    let min x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_VECTOR3
      "min"
      2923479887L
      (Vector3.typ @-> Vector3.typ @-> returning Vector3.typ)
      Vector3.s x0  x1 

    (** Returns the component-wise minimum of this and \[param with\], equivalent to \[code\]Vector3(minf(x, with), minf(y, with), minf(z, with))\[/code\]. *)
    let minf x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_VECTOR3
      "minf"
      514930144L
      (Float.typ @-> Vector3.typ @-> returning Vector3.typ)
      Vector3.s x0  x1 

    (** Returns the component-wise maximum of this and \[param with\], equivalent to \[code\]Vector3(maxf(x, with.x), maxf(y, with.y), maxf(z, with.z))\[/code\]. *)
    let max x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_VECTOR3
      "max"
      2923479887L
      (Vector3.typ @-> Vector3.typ @-> returning Vector3.typ)
      Vector3.s x0  x1 

    (** Returns the component-wise maximum of this and \[param with\], equivalent to \[code\]Vector3(maxf(x, with), maxf(y, with), maxf(z, with))\[/code\]. *)
    let maxf x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_VECTOR3
      "maxf"
      514930144L
      (Float.typ @-> Vector3.typ @-> returning Vector3.typ)
      Vector3.s x0  x1 

    (** Returns the \[Vector3\] from an octahedral-compressed form created using \[method octahedron_encode\] (stored as a \[Vector2\]). *)
    let octahedron_decode x0  = 
    foreign_builtin_method1_static
      GlobalEnum.VariantType._TYPE_VECTOR3
      "octahedron_decode"
      3991820552L
      (Vector2.typ @-> returning Vector3.typ)
      Vector3.s x0 





    (** Returns the negative value of the \[Vector3\]. This is the same as writing \[code\]Vector3(-v.x, -v.y, -v.z)\[/code\]. This operation flips the direction of the vector while keeping the same magnitude. With floats, the number zero can be either positive or negative. *)
    let (~-) x0  = 
    foreign_builtin_operator1 GlobalEnum.VariantType._TYPE_VECTOR3 None  GlobalEnum.VariantOperator._OP_NEGATE
      (funptr (Vector3.typ @-> Vector3.typ @-> returning void))
      Vector3.s x0 

    (** Returns the same value as if the \[code\]+\[/code\] was not there. Unary \[code\]+\[/code\] does nothing, but sometimes it can make your code more readable. *)
    let (~+) x0  = 
    foreign_builtin_operator1 GlobalEnum.VariantType._TYPE_VECTOR3 None  GlobalEnum.VariantOperator._OP_POSITIVE
      (funptr (Vector3.typ @-> Vector3.typ @-> returning void))
      Vector3.s x0 


    let not x0  = 
    foreign_builtin_operator1 GlobalEnum.VariantType._TYPE_VECTOR3 None  GlobalEnum.VariantOperator._OP_NOT
      (funptr (Vector3.typ @-> Bool.typ @-> returning void))
      Bool.s x0 









    (** Returns \[code\]true\[/code\] if the vectors are exactly equal.
\[b\]Note:\[/b\] Due to floating-point precision errors, consider using \[method is_equal_approx\] instead, which is more reliable.
\[b\]Note:\[/b\] Vectors with \[constant \@GDScript.NAN\] elements don''t behave the same as other vectors. Therefore, the results from this operator may not be accurate if NaNs are included. *)
    let (=) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_VECTOR3 (Some GlobalEnum.VariantType._TYPE_VECTOR3) GlobalEnum.VariantOperator._OP_EQUAL
      (funptr (Vector3.typ @-> Vector3.typ @-> Bool.typ @-> returning void))
      Bool.s
      Conv.Vector3.of_ocaml
      Conv.Vector3.of_ocaml
      Conv.Bool.to_ocaml x0  x1 

    (** Returns \[code\]true\[/code\] if the vectors are not equal.
\[b\]Note:\[/b\] Due to floating-point precision errors, consider using \[method is_equal_approx\] instead, which is more reliable.
\[b\]Note:\[/b\] Vectors with \[constant \@GDScript.NAN\] elements don''t behave the same as other vectors. Therefore, the results from this operator may not be accurate if NaNs are included. *)
    let (<>) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_VECTOR3 (Some GlobalEnum.VariantType._TYPE_VECTOR3) GlobalEnum.VariantOperator._OP_NOT_EQUAL
      (funptr (Vector3.typ @-> Vector3.typ @-> Bool.typ @-> returning void))
      Bool.s
      Conv.Vector3.of_ocaml
      Conv.Vector3.of_ocaml
      Conv.Bool.to_ocaml x0  x1 

    (** Compares two \[Vector3\] vectors by first checking if the X value of the left vector is less than the X value of the \[param right\] vector. If the X values are exactly equal, then it repeats this check with the Y values of the two vectors, and then with the Z values. This operator is useful for sorting vectors.
\[b\]Note:\[/b\] Vectors with \[constant \@GDScript.NAN\] elements don''t behave the same as other vectors. Therefore, the results from this operator may not be accurate if NaNs are included. *)
    let (<) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_VECTOR3 (Some GlobalEnum.VariantType._TYPE_VECTOR3) GlobalEnum.VariantOperator._OP_LESS
      (funptr (Vector3.typ @-> Vector3.typ @-> Bool.typ @-> returning void))
      Bool.s
      Conv.Vector3.of_ocaml
      Conv.Vector3.of_ocaml
      Conv.Bool.to_ocaml x0  x1 

    (** Compares two \[Vector3\] vectors by first checking if the X value of the left vector is less than or equal to the X value of the \[param right\] vector. If the X values are exactly equal, then it repeats this check with the Y values of the two vectors, and then with the Z values. This operator is useful for sorting vectors.
\[b\]Note:\[/b\] Vectors with \[constant \@GDScript.NAN\] elements don''t behave the same as other vectors. Therefore, the results from this operator may not be accurate if NaNs are included. *)
    let (<=) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_VECTOR3 (Some GlobalEnum.VariantType._TYPE_VECTOR3) GlobalEnum.VariantOperator._OP_LESS_EQUAL
      (funptr (Vector3.typ @-> Vector3.typ @-> Bool.typ @-> returning void))
      Bool.s
      Conv.Vector3.of_ocaml
      Conv.Vector3.of_ocaml
      Conv.Bool.to_ocaml x0  x1 

    (** Compares two \[Vector3\] vectors by first checking if the X value of the left vector is greater than the X value of the \[param right\] vector. If the X values are exactly equal, then it repeats this check with the Y values of the two vectors, and then with the Z values. This operator is useful for sorting vectors.
\[b\]Note:\[/b\] Vectors with \[constant \@GDScript.NAN\] elements don''t behave the same as other vectors. Therefore, the results from this operator may not be accurate if NaNs are included. *)
    let (>) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_VECTOR3 (Some GlobalEnum.VariantType._TYPE_VECTOR3) GlobalEnum.VariantOperator._OP_GREATER
      (funptr (Vector3.typ @-> Vector3.typ @-> Bool.typ @-> returning void))
      Bool.s
      Conv.Vector3.of_ocaml
      Conv.Vector3.of_ocaml
      Conv.Bool.to_ocaml x0  x1 

    (** Compares two \[Vector3\] vectors by first checking if the X value of the left vector is greater than or equal to the X value of the \[param right\] vector. If the X values are exactly equal, then it repeats this check with the Y values of the two vectors, and then with the Z values. This operator is useful for sorting vectors.
\[b\]Note:\[/b\] Vectors with \[constant \@GDScript.NAN\] elements don''t behave the same as other vectors. Therefore, the results from this operator may not be accurate if NaNs are included. *)
    let (>=) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_VECTOR3 (Some GlobalEnum.VariantType._TYPE_VECTOR3) GlobalEnum.VariantOperator._OP_GREATER_EQUAL
      (funptr (Vector3.typ @-> Vector3.typ @-> Bool.typ @-> returning void))
      Bool.s
      Conv.Vector3.of_ocaml
      Conv.Vector3.of_ocaml
      Conv.Bool.to_ocaml x0  x1 

    (** Adds each component of the \[Vector3\] by the components of the given \[Vector3\].
\[codeblock\]
print(Vector3(10, 20, 30) + Vector3(3, 4, 5)) # Prints (13.0, 24.0, 35.0)
\[/codeblock\] *)
    let (+) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_VECTOR3 (Some GlobalEnum.VariantType._TYPE_VECTOR3) GlobalEnum.VariantOperator._OP_ADD
      (funptr (Vector3.typ @-> Vector3.typ @-> Vector3.typ @-> returning void))
      Vector3.s
      Conv.Vector3.of_ocaml
      Conv.Vector3.of_ocaml
      Conv.Vector3.to_ocaml x0  x1 

    (** Subtracts each component of the \[Vector3\] by the components of the given \[Vector3\].
\[codeblock\]
print(Vector3(10, 20, 30) - Vector3(3, 4, 5)) # Prints (7.0, 16.0, 25.0)
\[/codeblock\] *)
    let (-) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_VECTOR3 (Some GlobalEnum.VariantType._TYPE_VECTOR3) GlobalEnum.VariantOperator._OP_SUBTRACT
      (funptr (Vector3.typ @-> Vector3.typ @-> Vector3.typ @-> returning void))
      Vector3.s
      Conv.Vector3.of_ocaml
      Conv.Vector3.of_ocaml
      Conv.Vector3.to_ocaml x0  x1 

    (** Multiplies each component of the \[Vector3\] by the components of the given \[Vector3\].
\[codeblock\]
print(Vector3(10, 20, 30)  *  Vector3(3, 4, 5)) # Prints (30.0, 80.0, 150.0)
\[/codeblock\] *)
    let ( * ) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_VECTOR3 (Some GlobalEnum.VariantType._TYPE_VECTOR3) GlobalEnum.VariantOperator._OP_MULTIPLY
      (funptr (Vector3.typ @-> Vector3.typ @-> Vector3.typ @-> returning void))
      Vector3.s
      Conv.Vector3.of_ocaml
      Conv.Vector3.of_ocaml
      Conv.Vector3.to_ocaml x0  x1 

    (** Divides each component of the \[Vector3\] by the components of the given \[Vector3\].
\[codeblock\]
print(Vector3(10, 20, 30) / Vector3(2, 5, 3)) # Prints (5.0, 4.0, 10.0)
\[/codeblock\] *)
    let (/) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_VECTOR3 (Some GlobalEnum.VariantType._TYPE_VECTOR3) GlobalEnum.VariantOperator._OP_DIVIDE
      (funptr (Vector3.typ @-> Vector3.typ @-> Vector3.typ @-> returning void))
      Vector3.s
      Conv.Vector3.of_ocaml
      Conv.Vector3.of_ocaml
      Conv.Vector3.to_ocaml x0  x1 








    let mem_Dictionary x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_VECTOR3 (Some GlobalEnum.VariantType._TYPE_DICTIONARY) GlobalEnum.VariantOperator._OP_IN
      (funptr (Vector3.typ @-> Dictionary.typ @-> Bool.typ @-> returning void))
      Bool.s x0  x1 


    let mem_Array x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_VECTOR3 (Some GlobalEnum.VariantType._TYPE_ARRAY) GlobalEnum.VariantOperator._OP_IN
      (funptr (Vector3.typ @-> Array.typ @-> Bool.typ @-> returning void))
      Bool.s x0  x1 


    let mem_PackedVector3Array x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_VECTOR3 (Some GlobalEnum.VariantType._TYPE_PACKED_VECTOR3_ARRAY) GlobalEnum.VariantOperator._OP_IN
      (funptr (Vector3.typ @-> PackedVector3Array.typ @-> Bool.typ @-> returning void))
      Bool.s x0  x1 

    module Axis = struct
      type t = Int.t

      let typ = 
      Int.typ

      (** Enumerated value for the X axis. Returned by \[method max_axis_index\] and \[method min_axis_index\]. *)
      let _AXIS_X = 
      0

      (** Enumerated value for the Y axis. Returned by \[method max_axis_index\] and \[method min_axis_index\]. *)
      let _AXIS_Y = 
      1

      (** Enumerated value for the Z axis. Returned by \[method max_axis_index\] and \[method min_axis_index\]. *)
      let _AXIS_Z = 
      2
      end
    end

  module Vector3i = struct
    include M.Vector3i
include BuiltinClass0.Vector3i

    (** Returns the axis of the vector''s lowest value. See \[code\]AXIS_ * \[/code\] constants. If all components are equal, this method returns \[constant AXIS_Z\]. *)
    let min_axis_index x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_VECTOR3I
      "min_axis_index"
      3173160232L
      (Vector3i.typ @-> returning Int.typ)
      Int.s x0 

    (** Returns the axis of the vector''s highest value. See \[code\]AXIS_ * \[/code\] constants. If all components are equal, this method returns \[constant AXIS_X\]. *)
    let max_axis_index x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_VECTOR3I
      "max_axis_index"
      3173160232L
      (Vector3i.typ @-> returning Int.typ)
      Int.s x0 

    (** Returns the distance between this vector and \[param to\]. *)
    let distance_to x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_VECTOR3I
      "distance_to"
      1975170430L
      (Vector3i.typ @-> Vector3i.typ @-> returning Float.typ)
      Float.s x0  x1 

    (** Returns the squared distance between this vector and \[param to\].
This method runs faster than \[method distance_to\], so prefer it if you need to compare vectors or need the squared distance for some formula. *)
    let distance_squared_to x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_VECTOR3I
      "distance_squared_to"
      2947717320L
      (Vector3i.typ @-> Vector3i.typ @-> returning Int.typ)
      Int.s x0  x1 

    (** Returns the length (magnitude) of this vector. *)
    let length x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_VECTOR3I
      "length"
      466405837L
      (Vector3i.typ @-> returning Float.typ)
      Float.s x0 

    (** Returns the squared length (squared magnitude) of this vector.
This method runs faster than \[method length\], so prefer it if you need to compare vectors or need the squared distance for some formula. *)
    let length_squared x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_VECTOR3I
      "length_squared"
      3173160232L
      (Vector3i.typ @-> returning Int.typ)
      Int.s x0 

    (** Returns a new vector with each component set to \[code\]1\[/code\] if it''s positive, \[code\]-1\[/code\] if it''s negative, and \[code\]0\[/code\] if it''s zero. The result is identical to calling \[method \@GlobalScope.sign\] on each component. *)
    let sign x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_VECTOR3I
      "sign"
      3729604559L
      (Vector3i.typ @-> returning Vector3i.typ)
      Vector3i.s x0 

    (** Returns a new vector with all components in absolute values (i.e. positive). *)
    let abs x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_VECTOR3I
      "abs"
      3729604559L
      (Vector3i.typ @-> returning Vector3i.typ)
      Vector3i.s x0 

    (** Returns a new vector with all components clamped between the components of \[param min\] and \[param max\], by running \[method \@GlobalScope.clamp\] on each component. *)
    let clamp x0  x1  x2  = 
    foreign_builtin_method2
      GlobalEnum.VariantType._TYPE_VECTOR3I
      "clamp"
      1086892323L
      (Vector3i.typ @-> Vector3i.typ @-> Vector3i.typ @-> returning Vector3i.typ)
      Vector3i.s x0  x1  x2 

    (** Returns a new vector with all components clamped between \[param min\] and \[param max\], by running \[method \@GlobalScope.clamp\] on each component. *)
    let clampi x0  x1  x2  = 
    foreign_builtin_method2
      GlobalEnum.VariantType._TYPE_VECTOR3I
      "clampi"
      1077216921L
      (Int.typ @-> Int.typ @-> Vector3i.typ @-> returning Vector3i.typ)
      Vector3i.s x0  x1  x2 

    (** Returns a new vector with each component snapped to the closest multiple of the corresponding component in \[param step\]. *)
    let snapped x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_VECTOR3I
      "snapped"
      1989319750L
      (Vector3i.typ @-> Vector3i.typ @-> returning Vector3i.typ)
      Vector3i.s x0  x1 

    (** Returns a new vector with each component snapped to the closest multiple of \[param step\]. *)
    let snappedi x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_VECTOR3I
      "snappedi"
      2377625641L
      (Int.typ @-> Vector3i.typ @-> returning Vector3i.typ)
      Vector3i.s x0  x1 

    (** Returns the component-wise minimum of this and \[param with\], equivalent to \[code\]Vector3i(mini(x, with.x), mini(y, with.y), mini(z, with.z))\[/code\]. *)
    let min x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_VECTOR3I
      "min"
      1989319750L
      (Vector3i.typ @-> Vector3i.typ @-> returning Vector3i.typ)
      Vector3i.s x0  x1 

    (** Returns the component-wise minimum of this and \[param with\], equivalent to \[code\]Vector3i(mini(x, with), mini(y, with), mini(z, with))\[/code\]. *)
    let mini x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_VECTOR3I
      "mini"
      2377625641L
      (Int.typ @-> Vector3i.typ @-> returning Vector3i.typ)
      Vector3i.s x0  x1 

    (** Returns the component-wise maximum of this and \[param with\], equivalent to \[code\]Vector3i(maxi(x, with.x), maxi(y, with.y), maxi(z, with.z))\[/code\]. *)
    let max x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_VECTOR3I
      "max"
      1989319750L
      (Vector3i.typ @-> Vector3i.typ @-> returning Vector3i.typ)
      Vector3i.s x0  x1 

    (** Returns the component-wise maximum of this and \[param with\], equivalent to \[code\]Vector3i(maxi(x, with), maxi(y, with), maxi(z, with))\[/code\]. *)
    let maxi x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_VECTOR3I
      "maxi"
      2377625641L
      (Int.typ @-> Vector3i.typ @-> returning Vector3i.typ)
      Vector3i.s x0  x1 





    (** Returns the negative value of the \[Vector3i\]. This is the same as writing \[code\]Vector3i(-v.x, -v.y, -v.z)\[/code\]. This operation flips the direction of the vector while keeping the same magnitude. *)
    let (~-) x0  = 
    foreign_builtin_operator1 GlobalEnum.VariantType._TYPE_VECTOR3I None  GlobalEnum.VariantOperator._OP_NEGATE
      (funptr (Vector3i.typ @-> Vector3i.typ @-> returning void))
      Vector3i.s x0 

    (** Returns the same value as if the \[code\]+\[/code\] was not there. Unary \[code\]+\[/code\] does nothing, but sometimes it can make your code more readable. *)
    let (~+) x0  = 
    foreign_builtin_operator1 GlobalEnum.VariantType._TYPE_VECTOR3I None  GlobalEnum.VariantOperator._OP_POSITIVE
      (funptr (Vector3i.typ @-> Vector3i.typ @-> returning void))
      Vector3i.s x0 


    let not x0  = 
    foreign_builtin_operator1 GlobalEnum.VariantType._TYPE_VECTOR3I None  GlobalEnum.VariantOperator._OP_NOT
      (funptr (Vector3i.typ @-> Bool.typ @-> returning void))
      Bool.s x0 











    (** Returns \[code\]true\[/code\] if the vectors are equal. *)
    let (=) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_VECTOR3I (Some GlobalEnum.VariantType._TYPE_VECTOR3I) GlobalEnum.VariantOperator._OP_EQUAL
      (funptr (Vector3i.typ @-> Vector3i.typ @-> Bool.typ @-> returning void))
      Bool.s
      Conv.Vector3i.of_ocaml
      Conv.Vector3i.of_ocaml
      Conv.Bool.to_ocaml x0  x1 

    (** Returns \[code\]true\[/code\] if the vectors are not equal. *)
    let (<>) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_VECTOR3I (Some GlobalEnum.VariantType._TYPE_VECTOR3I) GlobalEnum.VariantOperator._OP_NOT_EQUAL
      (funptr (Vector3i.typ @-> Vector3i.typ @-> Bool.typ @-> returning void))
      Bool.s
      Conv.Vector3i.of_ocaml
      Conv.Vector3i.of_ocaml
      Conv.Bool.to_ocaml x0  x1 

    (** Compares two \[Vector3i\] vectors by first checking if the X value of the left vector is less than the X value of the \[param right\] vector. If the X values are exactly equal, then it repeats this check with the Y values of the two vectors, and then with the Z values. This operator is useful for sorting vectors. *)
    let (<) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_VECTOR3I (Some GlobalEnum.VariantType._TYPE_VECTOR3I) GlobalEnum.VariantOperator._OP_LESS
      (funptr (Vector3i.typ @-> Vector3i.typ @-> Bool.typ @-> returning void))
      Bool.s
      Conv.Vector3i.of_ocaml
      Conv.Vector3i.of_ocaml
      Conv.Bool.to_ocaml x0  x1 

    (** Compares two \[Vector3i\] vectors by first checking if the X value of the left vector is less than or equal to the X value of the \[param right\] vector. If the X values are exactly equal, then it repeats this check with the Y values of the two vectors, and then with the Z values. This operator is useful for sorting vectors. *)
    let (<=) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_VECTOR3I (Some GlobalEnum.VariantType._TYPE_VECTOR3I) GlobalEnum.VariantOperator._OP_LESS_EQUAL
      (funptr (Vector3i.typ @-> Vector3i.typ @-> Bool.typ @-> returning void))
      Bool.s
      Conv.Vector3i.of_ocaml
      Conv.Vector3i.of_ocaml
      Conv.Bool.to_ocaml x0  x1 

    (** Compares two \[Vector3i\] vectors by first checking if the X value of the left vector is greater than the X value of the \[param right\] vector. If the X values are exactly equal, then it repeats this check with the Y values of the two vectors, and then with the Z values. This operator is useful for sorting vectors. *)
    let (>) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_VECTOR3I (Some GlobalEnum.VariantType._TYPE_VECTOR3I) GlobalEnum.VariantOperator._OP_GREATER
      (funptr (Vector3i.typ @-> Vector3i.typ @-> Bool.typ @-> returning void))
      Bool.s
      Conv.Vector3i.of_ocaml
      Conv.Vector3i.of_ocaml
      Conv.Bool.to_ocaml x0  x1 

    (** Compares two \[Vector3i\] vectors by first checking if the X value of the left vector is greater than or equal to the X value of the \[param right\] vector. If the X values are exactly equal, then it repeats this check with the Y values of the two vectors, and then with the Z values. This operator is useful for sorting vectors. *)
    let (>=) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_VECTOR3I (Some GlobalEnum.VariantType._TYPE_VECTOR3I) GlobalEnum.VariantOperator._OP_GREATER_EQUAL
      (funptr (Vector3i.typ @-> Vector3i.typ @-> Bool.typ @-> returning void))
      Bool.s
      Conv.Vector3i.of_ocaml
      Conv.Vector3i.of_ocaml
      Conv.Bool.to_ocaml x0  x1 

    (** Adds each component of the \[Vector3i\] by the components of the given \[Vector3i\].
\[codeblock\]
print(Vector3i(10, 20, 30) + Vector3i(3, 4, 5)) # Prints (13, 24, 35)
\[/codeblock\] *)
    let (+) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_VECTOR3I (Some GlobalEnum.VariantType._TYPE_VECTOR3I) GlobalEnum.VariantOperator._OP_ADD
      (funptr (Vector3i.typ @-> Vector3i.typ @-> Vector3i.typ @-> returning void))
      Vector3i.s
      Conv.Vector3i.of_ocaml
      Conv.Vector3i.of_ocaml
      Conv.Vector3i.to_ocaml x0  x1 

    (** Subtracts each component of the \[Vector3i\] by the components of the given \[Vector3i\].
\[codeblock\]
print(Vector3i(10, 20, 30) - Vector3i(3, 4, 5)) # Prints (7, 16, 25)
\[/codeblock\] *)
    let (-) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_VECTOR3I (Some GlobalEnum.VariantType._TYPE_VECTOR3I) GlobalEnum.VariantOperator._OP_SUBTRACT
      (funptr (Vector3i.typ @-> Vector3i.typ @-> Vector3i.typ @-> returning void))
      Vector3i.s
      Conv.Vector3i.of_ocaml
      Conv.Vector3i.of_ocaml
      Conv.Vector3i.to_ocaml x0  x1 

    (** Multiplies each component of the \[Vector3i\] by the components of the given \[Vector3i\].
\[codeblock\]
print(Vector3i(10, 20, 30)  *  Vector3i(3, 4, 5)) # Prints (30, 80, 150)
\[/codeblock\] *)
    let ( * ) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_VECTOR3I (Some GlobalEnum.VariantType._TYPE_VECTOR3I) GlobalEnum.VariantOperator._OP_MULTIPLY
      (funptr (Vector3i.typ @-> Vector3i.typ @-> Vector3i.typ @-> returning void))
      Vector3i.s
      Conv.Vector3i.of_ocaml
      Conv.Vector3i.of_ocaml
      Conv.Vector3i.to_ocaml x0  x1 

    (** Divides each component of the \[Vector3i\] by the components of the given \[Vector3i\].
\[codeblock\]
print(Vector3i(10, 20, 30) / Vector3i(2, 5, 3)) # Prints (5, 4, 10)
\[/codeblock\] *)
    let (/) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_VECTOR3I (Some GlobalEnum.VariantType._TYPE_VECTOR3I) GlobalEnum.VariantOperator._OP_DIVIDE
      (funptr (Vector3i.typ @-> Vector3i.typ @-> Vector3i.typ @-> returning void))
      Vector3i.s
      Conv.Vector3i.of_ocaml
      Conv.Vector3i.of_ocaml
      Conv.Vector3i.to_ocaml x0  x1 

    (** Gets the remainder of each component of the \[Vector3i\] with the components of the given \[Vector3i\]. This operation uses truncated division, which is often not desired as it does not work well with negative numbers. Consider using \[method \@GlobalScope.posmod\] instead if you want to handle negative numbers.
\[codeblock\]
print(Vector3i(10, -20, 30) % Vector3i(7, 8, 9)) # Prints (3, -4, 3)
\[/codeblock\] *)
    let (%) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_VECTOR3I (Some GlobalEnum.VariantType._TYPE_VECTOR3I) GlobalEnum.VariantOperator._OP_MODULE
      (funptr (Vector3i.typ @-> Vector3i.typ @-> Vector3i.typ @-> returning void))
      Vector3i.s
      Conv.Vector3i.of_ocaml
      Conv.Vector3i.of_ocaml
      Conv.Vector3i.to_ocaml x0  x1 


    let mem_Dictionary x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_VECTOR3I (Some GlobalEnum.VariantType._TYPE_DICTIONARY) GlobalEnum.VariantOperator._OP_IN
      (funptr (Vector3i.typ @-> Dictionary.typ @-> Bool.typ @-> returning void))
      Bool.s x0  x1 


    let mem_Array x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_VECTOR3I (Some GlobalEnum.VariantType._TYPE_ARRAY) GlobalEnum.VariantOperator._OP_IN
      (funptr (Vector3i.typ @-> Array.typ @-> Bool.typ @-> returning void))
      Bool.s x0  x1 

    module Axis = struct
      type t = Int.t

      let typ = 
      Int.typ

      (** Enumerated value for the X axis. Returned by \[method max_axis_index\] and \[method min_axis_index\]. *)
      let _AXIS_X = 
      0

      (** Enumerated value for the Y axis. Returned by \[method max_axis_index\] and \[method min_axis_index\]. *)
      let _AXIS_Y = 
      1

      (** Enumerated value for the Z axis. Returned by \[method max_axis_index\] and \[method min_axis_index\]. *)
      let _AXIS_Z = 
      2
      end
    end

  module Transform2D = struct
    include M.Transform2D
include BuiltinClass0.Transform2D

    (** Returns the \[url=https://en.wikipedia.org/wiki/Invertible_matrix\]inverted version of this transform\[/url\].
\[b\]Note:\[/b\] For this method to return correctly, the transform''s basis needs to be \[i\]orthonormal\[/i\] (see \[method orthonormalized\]). That means the basis should only represent a rotation. If it does not, use \[method affine_inverse\] instead. *)
    let inverse x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_TRANSFORM2D
      "inverse"
      1420440541L
      (Transform2D.typ @-> returning Transform2D.typ)
      Transform2D.s x0 

    (** Returns the inverted version of this transform. Unlike \[method inverse\], this method works with almost any basis, including non-uniform ones, but is slower.
\[b\]Note:\[/b\] For this method to return correctly, the transform''s basis needs to have a determinant that is not exactly \[code\]0.0\[/code\] (see \[method determinant\]). *)
    let affine_inverse x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_TRANSFORM2D
      "affine_inverse"
      1420440541L
      (Transform2D.typ @-> returning Transform2D.typ)
      Transform2D.s x0 

    (** Returns this transform''s rotation (in radians). This is equivalent to \[member x\]''s angle (see \[method Vector2.angle\]). *)
    let get_rotation x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_TRANSFORM2D
      "get_rotation"
      466405837L
      (Transform2D.typ @-> returning Float.typ)
      Float.s x0 

    (** Returns this transform''s translation. Equivalent to \[member origin\]. *)
    let get_origin x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_TRANSFORM2D
      "get_origin"
      2428350749L
      (Transform2D.typ @-> returning Vector2.typ)
      Vector2.s x0 

    (** Returns the length of both \[member x\] and \[member y\], as a \[Vector2\]. If this transform''s basis is not skewed, this value is the scaling factor. It is not affected by rotation.
\[codeblocks\]
\[gdscript\]
var my_transform = Transform2D(
    Vector2(2, 0),
    Vector2(0, 4),
    Vector2(0, 0)
)
# Rotating the Transform2D in any way preserves its scale.
my_transform = my_transform.rotated(TAU / 2)

print(my_transform.get_scale()) # Prints (2.0, 4.0)
\[/gdscript\]
\[csharp\]
var myTransform = new Transform2D(
    Vector3(2.0f, 0.0f),
    Vector3(0.0f, 4.0f),
    Vector3(0.0f, 0.0f)
);
// Rotating the Transform2D in any way preserves its scale.
myTransform = myTransform.Rotated(Mathf.Tau / 2.0f);

GD.Print(myTransform.GetScale()); // Prints (2, 4)
\[/csharp\]
\[/codeblocks\]
\[b\]Note:\[/b\] If the value returned by \[method determinant\] is negative, the scale is also negative. *)
    let get_scale x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_TRANSFORM2D
      "get_scale"
      2428350749L
      (Transform2D.typ @-> returning Vector2.typ)
      Vector2.s x0 

    (** Returns this transform''s skew (in radians). *)
    let get_skew x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_TRANSFORM2D
      "get_skew"
      466405837L
      (Transform2D.typ @-> returning Float.typ)
      Float.s x0 

    (** Returns a copy of this transform with its basis orthonormalized. An orthonormal basis is both \[i\]orthogonal\[/i\] (the axes are perpendicular to each other) and \[i\]normalized\[/i\] (the axes have a length of \[code\]1.0\[/code\]), which also means it can only represent a rotation. *)
    let orthonormalized x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_TRANSFORM2D
      "orthonormalized"
      1420440541L
      (Transform2D.typ @-> returning Transform2D.typ)
      Transform2D.s x0 

    (** Returns a copy of this transform rotated by the given \[param angle\] (in radians).
If \[param angle\] is positive, the transform is rotated clockwise.
This method is an optimized version of multiplying the given transform \[code\]X\[/code\] with a corresponding rotation transform \[code\]R\[/code\] from the left, i.e., \[code\]R  *  X\[/code\].
This can be seen as transforming with respect to the global/parent frame. *)
    let rotated x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_TRANSFORM2D
      "rotated"
      729597514L
      (Float.typ @-> Transform2D.typ @-> returning Transform2D.typ)
      Transform2D.s x0  x1 

    (** Returns a copy of the transform rotated by the given \[param angle\] (in radians).
This method is an optimized version of multiplying the given transform \[code\]X\[/code\] with a corresponding rotation transform \[code\]R\[/code\] from the right, i.e., \[code\]X  *  R\[/code\].
This can be seen as transforming with respect to the local frame. *)
    let rotated_local x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_TRANSFORM2D
      "rotated_local"
      729597514L
      (Float.typ @-> Transform2D.typ @-> returning Transform2D.typ)
      Transform2D.s x0  x1 

    (** Returns a copy of the transform scaled by the given \[param scale\] factor.
This method is an optimized version of multiplying the given transform \[code\]X\[/code\] with a corresponding scaling transform \[code\]S\[/code\] from the left, i.e., \[code\]S  *  X\[/code\].
This can be seen as transforming with respect to the global/parent frame. *)
    let scaled x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_TRANSFORM2D
      "scaled"
      1446323263L
      (Vector2.typ @-> Transform2D.typ @-> returning Transform2D.typ)
      Transform2D.s x0  x1 

    (** Returns a copy of the transform scaled by the given \[param scale\] factor.
This method is an optimized version of multiplying the given transform \[code\]X\[/code\] with a corresponding scaling transform \[code\]S\[/code\] from the right, i.e., \[code\]X  *  S\[/code\].
This can be seen as transforming with respect to the local frame. *)
    let scaled_local x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_TRANSFORM2D
      "scaled_local"
      1446323263L
      (Vector2.typ @-> Transform2D.typ @-> returning Transform2D.typ)
      Transform2D.s x0  x1 

    (** Returns a copy of the transform translated by the given \[param offset\].
This method is an optimized version of multiplying the given transform \[code\]X\[/code\] with a corresponding translation transform \[code\]T\[/code\] from the left, i.e., \[code\]T  *  X\[/code\].
This can be seen as transforming with respect to the global/parent frame. *)
    let translated x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_TRANSFORM2D
      "translated"
      1446323263L
      (Vector2.typ @-> Transform2D.typ @-> returning Transform2D.typ)
      Transform2D.s x0  x1 

    (** Returns a copy of the transform translated by the given \[param offset\].
This method is an optimized version of multiplying the given transform \[code\]X\[/code\] with a corresponding translation transform \[code\]T\[/code\] from the right, i.e., \[code\]X  *  T\[/code\].
This can be seen as transforming with respect to the local frame. *)
    let translated_local x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_TRANSFORM2D
      "translated_local"
      1446323263L
      (Vector2.typ @-> Transform2D.typ @-> returning Transform2D.typ)
      Transform2D.s x0  x1 

    (** Returns the \[url=https://en.wikipedia.org/wiki/Determinant\]determinant\[/url\] of this transform basis''s matrix. For advanced math, this number can be used to determine a few attributes:
- If the determinant is exactly \[code\]0.0\[/code\], the basis is not invertible (see \[method inverse\]).
- If the determinant is a negative number, the basis represents a negative scale.
\[b\]Note:\[/b\] If the basis''s scale is the same for every axis, its determinant is always that scale by the power of 2. *)
    let determinant x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_TRANSFORM2D
      "determinant"
      466405837L
      (Transform2D.typ @-> returning Float.typ)
      Float.s x0 

    (** Returns a copy of the \[param v\] vector, transformed (multiplied) by the transform basis''s matrix. Unlike the multiplication operator (\[code\] * \[/code\]), this method ignores the \[member origin\]. *)
    let basis_xform x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_TRANSFORM2D
      "basis_xform"
      2026743667L
      (Vector2.typ @-> Transform2D.typ @-> returning Vector2.typ)
      Vector2.s x0  x1 

    (** Returns a copy of the \[param v\] vector, transformed (multiplied) by the inverse transform basis''s matrix (see \[method inverse\]). This method ignores the \[member origin\].
\[b\]Note:\[/b\] This method assumes that this transform''s basis is \[i\]orthonormal\[/i\] (see \[method orthonormalized\]). If the basis is not orthonormal, \[code\]transform.affine_inverse().basis_xform(vector)\[/code\] should be used instead (see \[method affine_inverse\]). *)
    let basis_xform_inv x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_TRANSFORM2D
      "basis_xform_inv"
      2026743667L
      (Vector2.typ @-> Transform2D.typ @-> returning Vector2.typ)
      Vector2.s x0  x1 

    (** Returns the result of the linear interpolation between this transform and \[param xform\] by the given \[param weight\].
The \[param weight\] should be between \[code\]0.0\[/code\] and \[code\]1.0\[/code\] (inclusive). Values outside this range are allowed and can be used to perform \[i\]extrapolation\[/i\] instead. *)
    let interpolate_with x0  x1  x2  = 
    foreign_builtin_method2
      GlobalEnum.VariantType._TYPE_TRANSFORM2D
      "interpolate_with"
      359399686L
      (Transform2D.typ @-> Float.typ @-> Transform2D.typ @-> returning Transform2D.typ)
      Transform2D.s x0  x1  x2 

    (** Returns \[code\]true\[/code\] if this transform''s basis is conformal. A conformal basis is both \[i\]orthogonal\[/i\] (the axes are perpendicular to each other) and \[i\]uniform\[/i\] (the axes share the same length). This method can be especially useful during physics calculations. *)
    let is_conformal x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_TRANSFORM2D
      "is_conformal"
      3918633141L
      (Transform2D.typ @-> returning Bool.typ)
      Bool.s x0 

    (** Returns \[code\]true\[/code\] if this transform and \[param xform\] are approximately equal, by running \[method \@GlobalScope.is_equal_approx\] on each component. *)
    let is_equal_approx x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_TRANSFORM2D
      "is_equal_approx"
      3837431929L
      (Transform2D.typ @-> Transform2D.typ @-> returning Bool.typ)
      Bool.s x0  x1 

    (** Returns \[code\]true\[/code\] if this transform is finite, by calling \[method \@GlobalScope.is_finite\] on each component. *)
    let is_finite x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_TRANSFORM2D
      "is_finite"
      3918633141L
      (Transform2D.typ @-> returning Bool.typ)
      Bool.s x0 

    (** Returns a copy of the transform rotated such that the rotated X-axis points towards the \[param target\] position, in global space. *)
    let looking_at x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_TRANSFORM2D
      "looking_at"
      1446323263L
      (Vector2.typ @-> Transform2D.typ @-> returning Transform2D.typ)
      Transform2D.s x0  x1 






    let not x0  = 
    foreign_builtin_operator1 GlobalEnum.VariantType._TYPE_TRANSFORM2D None  GlobalEnum.VariantOperator._OP_NOT
      (funptr (Transform2D.typ @-> Bool.typ @-> returning void))
      Bool.s x0 













    (** Returns \[code\]true\[/code\] if the components of both transforms are exactly equal.
\[b\]Note:\[/b\] Due to floating-point precision errors, consider using \[method is_equal_approx\] instead, which is more reliable. *)
    let (=) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_TRANSFORM2D (Some GlobalEnum.VariantType._TYPE_TRANSFORM2D) GlobalEnum.VariantOperator._OP_EQUAL
      (funptr (Transform2D.typ @-> Transform2D.typ @-> Bool.typ @-> returning void))
      Bool.s
      Conv.Transform2D.of_ocaml
      Conv.Transform2D.of_ocaml
      Conv.Bool.to_ocaml x0  x1 

    (** Returns \[code\]true\[/code\] if the components of both transforms are not equal.
\[b\]Note:\[/b\] Due to floating-point precision errors, consider using \[method is_equal_approx\] instead, which is more reliable. *)
    let (<>) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_TRANSFORM2D (Some GlobalEnum.VariantType._TYPE_TRANSFORM2D) GlobalEnum.VariantOperator._OP_NOT_EQUAL
      (funptr (Transform2D.typ @-> Transform2D.typ @-> Bool.typ @-> returning void))
      Bool.s
      Conv.Transform2D.of_ocaml
      Conv.Transform2D.of_ocaml
      Conv.Bool.to_ocaml x0  x1 

    (** Transforms (multiplies) this transform by the \[param right\] transform.
This is the operation performed between parent and child \[CanvasItem\] nodes.
\[b\]Note:\[/b\] If you need to only modify one attribute of this transform, consider using one of the following methods, instead:
- For translation, see \[method translated\] or \[method translated_local\].
- For rotation, see \[method rotated\] or \[method rotated_local\].
- For scale, see \[method scaled\] or \[method scaled_local\]. *)
    let ( * ) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_TRANSFORM2D (Some GlobalEnum.VariantType._TYPE_TRANSFORM2D) GlobalEnum.VariantOperator._OP_MULTIPLY
      (funptr (Transform2D.typ @-> Transform2D.typ @-> Transform2D.typ @-> returning void))
      Transform2D.s
      Conv.Transform2D.of_ocaml
      Conv.Transform2D.of_ocaml
      Conv.Transform2D.to_ocaml x0  x1 


    let mem_Dictionary x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_TRANSFORM2D (Some GlobalEnum.VariantType._TYPE_DICTIONARY) GlobalEnum.VariantOperator._OP_IN
      (funptr (Transform2D.typ @-> Dictionary.typ @-> Bool.typ @-> returning void))
      Bool.s x0  x1 


    let mem_Array x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_TRANSFORM2D (Some GlobalEnum.VariantType._TYPE_ARRAY) GlobalEnum.VariantOperator._OP_IN
      (funptr (Transform2D.typ @-> Array.typ @-> Bool.typ @-> returning void))
      Bool.s x0  x1 


    end

  module Vector4 = struct
    include M.Vector4
include BuiltinClass0.Vector4

    (** Returns the axis of the vector''s lowest value. See \[code\]AXIS_ * \[/code\] constants. If all components are equal, this method returns \[constant AXIS_W\]. *)
    let min_axis_index x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_VECTOR4
      "min_axis_index"
      3173160232L
      (Vector4.typ @-> returning Int.typ)
      Int.s x0 

    (** Returns the axis of the vector''s highest value. See \[code\]AXIS_ * \[/code\] constants. If all components are equal, this method returns \[constant AXIS_X\]. *)
    let max_axis_index x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_VECTOR4
      "max_axis_index"
      3173160232L
      (Vector4.typ @-> returning Int.typ)
      Int.s x0 

    (** Returns the length (magnitude) of this vector. *)
    let length x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_VECTOR4
      "length"
      466405837L
      (Vector4.typ @-> returning Float.typ)
      Float.s x0 

    (** Returns the squared length (squared magnitude) of this vector.
This method runs faster than \[method length\], so prefer it if you need to compare vectors or need the squared distance for some formula. *)
    let length_squared x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_VECTOR4
      "length_squared"
      466405837L
      (Vector4.typ @-> returning Float.typ)
      Float.s x0 

    (** Returns a new vector with all components in absolute values (i.e. positive). *)
    let abs x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_VECTOR4
      "abs"
      80860099L
      (Vector4.typ @-> returning Vector4.typ)
      Vector4.s x0 

    (** Returns a new vector with each component set to \[code\]1.0\[/code\] if it''s positive, \[code\]-1.0\[/code\] if it''s negative, and \[code\]0.0\[/code\] if it''s zero. The result is identical to calling \[method \@GlobalScope.sign\] on each component. *)
    let sign x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_VECTOR4
      "sign"
      80860099L
      (Vector4.typ @-> returning Vector4.typ)
      Vector4.s x0 

    (** Returns a new vector with all components rounded down (towards negative infinity). *)
    let floor x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_VECTOR4
      "floor"
      80860099L
      (Vector4.typ @-> returning Vector4.typ)
      Vector4.s x0 

    (** Returns a new vector with all components rounded up (towards positive infinity). *)
    let ceil x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_VECTOR4
      "ceil"
      80860099L
      (Vector4.typ @-> returning Vector4.typ)
      Vector4.s x0 

    (** Returns a new vector with all components rounded to the nearest integer, with halfway cases rounded away from zero. *)
    let round x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_VECTOR4
      "round"
      80860099L
      (Vector4.typ @-> returning Vector4.typ)
      Vector4.s x0 

    (** Returns the result of the linear interpolation between this vector and \[param to\] by amount \[param weight\]. \[param weight\] is on the range of \[code\]0.0\[/code\] to \[code\]1.0\[/code\], representing the amount of interpolation. *)
    let lerp x0  x1  x2  = 
    foreign_builtin_method2
      GlobalEnum.VariantType._TYPE_VECTOR4
      "lerp"
      2329757942L
      (Vector4.typ @-> Float.typ @-> Vector4.typ @-> returning Vector4.typ)
      Vector4.s x0  x1  x2 

    (** Performs a cubic interpolation between this vector and \[param b\] using \[param pre_a\] and \[param post_b\] as handles, and returns the result at position \[param weight\]. \[param weight\] is on the range of 0.0 to 1.0, representing the amount of interpolation. *)
    let cubic_interpolate x0  x1  x2  x3  x4  = 
    foreign_builtin_method4
      GlobalEnum.VariantType._TYPE_VECTOR4
      "cubic_interpolate"
      726768410L
      (Vector4.typ @-> Vector4.typ @-> Vector4.typ @-> Float.typ @-> Vector4.typ @-> returning Vector4.typ)
      Vector4.s x0  x1  x2  x3  x4 

    (** Performs a cubic interpolation between this vector and \[param b\] using \[param pre_a\] and \[param post_b\] as handles, and returns the result at position \[param weight\]. \[param weight\] is on the range of 0.0 to 1.0, representing the amount of interpolation.
It can perform smoother interpolation than \[method cubic_interpolate\] by the time values. *)
    let cubic_interpolate_in_time x0  x1  x2  x3  x4  x5  x6  x7  = 
    foreign_builtin_method7
      GlobalEnum.VariantType._TYPE_VECTOR4
      "cubic_interpolate_in_time"
      681631873L
      (Vector4.typ @-> Vector4.typ @-> Vector4.typ @-> Float.typ @-> Float.typ @-> Float.typ @-> Float.typ @-> Vector4.typ @-> returning Vector4.typ)
      Vector4.s x0  x1  x2  x3  x4  x5  x6  x7 

    (** Returns a vector composed of the \[method \@GlobalScope.fposmod\] of this vector''s components and \[param mod\]. *)
    let posmod x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_VECTOR4
      "posmod"
      3129671720L
      (Float.typ @-> Vector4.typ @-> returning Vector4.typ)
      Vector4.s x0  x1 

    (** Returns a vector composed of the \[method \@GlobalScope.fposmod\] of this vector''s components and \[param modv\]''s components. *)
    let posmodv x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_VECTOR4
      "posmodv"
      2031281584L
      (Vector4.typ @-> Vector4.typ @-> returning Vector4.typ)
      Vector4.s x0  x1 

    (** Returns a new vector with each component snapped to the nearest multiple of the corresponding component in \[param step\]. This can also be used to round the components to an arbitrary number of decimals. *)
    let snapped x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_VECTOR4
      "snapped"
      2031281584L
      (Vector4.typ @-> Vector4.typ @-> returning Vector4.typ)
      Vector4.s x0  x1 

    (** Returns a new vector with each component snapped to the nearest multiple of \[param step\]. This can also be used to round the components to an arbitrary number of decimals. *)
    let snappedf x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_VECTOR4
      "snappedf"
      3129671720L
      (Float.typ @-> Vector4.typ @-> returning Vector4.typ)
      Vector4.s x0  x1 

    (** Returns a new vector with all components clamped between the components of \[param min\] and \[param max\], by running \[method \@GlobalScope.clamp\] on each component. *)
    let clamp x0  x1  x2  = 
    foreign_builtin_method2
      GlobalEnum.VariantType._TYPE_VECTOR4
      "clamp"
      823915692L
      (Vector4.typ @-> Vector4.typ @-> Vector4.typ @-> returning Vector4.typ)
      Vector4.s x0  x1  x2 

    (** Returns a new vector with all components clamped between \[param min\] and \[param max\], by running \[method \@GlobalScope.clamp\] on each component. *)
    let clampf x0  x1  x2  = 
    foreign_builtin_method2
      GlobalEnum.VariantType._TYPE_VECTOR4
      "clampf"
      4072091586L
      (Float.typ @-> Float.typ @-> Vector4.typ @-> returning Vector4.typ)
      Vector4.s x0  x1  x2 

    (** Returns the result of scaling the vector to unit length. Equivalent to \[code\]v / v.length()\[/code\]. Returns \[code\](0, 0, 0, 0)\[/code\] if \[code\]v.length() == 0\[/code\]. See also \[method is_normalized\].
\[b\]Note:\[/b\] This function may return incorrect values if the input vector length is near zero. *)
    let normalized x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_VECTOR4
      "normalized"
      80860099L
      (Vector4.typ @-> returning Vector4.typ)
      Vector4.s x0 

    (** Returns \[code\]true\[/code\] if the vector is normalized, i.e. its length is approximately equal to 1. *)
    let is_normalized x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_VECTOR4
      "is_normalized"
      3918633141L
      (Vector4.typ @-> returning Bool.typ)
      Bool.s x0 

    (** Returns the normalized vector pointing from this vector to \[param to\]. This is equivalent to using \[code\](b - a).normalized()\[/code\]. *)
    let direction_to x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_VECTOR4
      "direction_to"
      2031281584L
      (Vector4.typ @-> Vector4.typ @-> returning Vector4.typ)
      Vector4.s x0  x1 

    (** Returns the distance between this vector and \[param to\]. *)
    let distance_to x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_VECTOR4
      "distance_to"
      3770801042L
      (Vector4.typ @-> Vector4.typ @-> returning Float.typ)
      Float.s x0  x1 

    (** Returns the squared distance between this vector and \[param to\].
This method runs faster than \[method distance_to\], so prefer it if you need to compare vectors or need the squared distance for some formula. *)
    let distance_squared_to x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_VECTOR4
      "distance_squared_to"
      3770801042L
      (Vector4.typ @-> Vector4.typ @-> returning Float.typ)
      Float.s x0  x1 

    (** Returns the dot product of this vector and \[param with\]. *)
    let dot x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_VECTOR4
      "dot"
      3770801042L
      (Vector4.typ @-> Vector4.typ @-> returning Float.typ)
      Float.s x0  x1 

    (** Returns the inverse of the vector. This is the same as \[code\]Vector4(1.0 / v.x, 1.0 / v.y, 1.0 / v.z, 1.0 / v.w)\[/code\]. *)
    let inverse x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_VECTOR4
      "inverse"
      80860099L
      (Vector4.typ @-> returning Vector4.typ)
      Vector4.s x0 

    (** Returns \[code\]true\[/code\] if this vector and \[param to\] are approximately equal, by running \[method \@GlobalScope.is_equal_approx\] on each component. *)
    let is_equal_approx x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_VECTOR4
      "is_equal_approx"
      88913544L
      (Vector4.typ @-> Vector4.typ @-> returning Bool.typ)
      Bool.s x0  x1 

    (** Returns \[code\]true\[/code\] if this vector''s values are approximately zero, by running \[method \@GlobalScope.is_zero_approx\] on each component.
This method is faster than using \[method is_equal_approx\] with one value as a zero vector. *)
    let is_zero_approx x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_VECTOR4
      "is_zero_approx"
      3918633141L
      (Vector4.typ @-> returning Bool.typ)
      Bool.s x0 

    (** Returns \[code\]true\[/code\] if this vector is finite, by calling \[method \@GlobalScope.is_finite\] on each component. *)
    let is_finite x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_VECTOR4
      "is_finite"
      3918633141L
      (Vector4.typ @-> returning Bool.typ)
      Bool.s x0 

    (** Returns the component-wise minimum of this and \[param with\], equivalent to \[code\]Vector4(minf(x, with.x), minf(y, with.y), minf(z, with.z), minf(w, with.w))\[/code\]. *)
    let min x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_VECTOR4
      "min"
      2031281584L
      (Vector4.typ @-> Vector4.typ @-> returning Vector4.typ)
      Vector4.s x0  x1 

    (** Returns the component-wise minimum of this and \[param with\], equivalent to \[code\]Vector4(minf(x, with), minf(y, with), minf(z, with), minf(w, with))\[/code\]. *)
    let minf x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_VECTOR4
      "minf"
      3129671720L
      (Float.typ @-> Vector4.typ @-> returning Vector4.typ)
      Vector4.s x0  x1 

    (** Returns the component-wise maximum of this and \[param with\], equivalent to \[code\]Vector4(maxf(x, with.x), maxf(y, with.y), maxf(z, with.z), maxf(w, with.w))\[/code\]. *)
    let max x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_VECTOR4
      "max"
      2031281584L
      (Vector4.typ @-> Vector4.typ @-> returning Vector4.typ)
      Vector4.s x0  x1 

    (** Returns the component-wise maximum of this and \[param with\], equivalent to \[code\]Vector4(maxf(x, with), maxf(y, with), maxf(z, with), maxf(w, with))\[/code\]. *)
    let maxf x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_VECTOR4
      "maxf"
      3129671720L
      (Float.typ @-> Vector4.typ @-> returning Vector4.typ)
      Vector4.s x0  x1 





    (** Returns the negative value of the \[Vector4\]. This is the same as writing \[code\]Vector4(-v.x, -v.y, -v.z, -v.w)\[/code\]. This operation flips the direction of the vector while keeping the same magnitude. With floats, the number zero can be either positive or negative. *)
    let (~-) x0  = 
    foreign_builtin_operator1 GlobalEnum.VariantType._TYPE_VECTOR4 None  GlobalEnum.VariantOperator._OP_NEGATE
      (funptr (Vector4.typ @-> Vector4.typ @-> returning void))
      Vector4.s x0 

    (** Returns the same value as if the \[code\]+\[/code\] was not there. Unary \[code\]+\[/code\] does nothing, but sometimes it can make your code more readable. *)
    let (~+) x0  = 
    foreign_builtin_operator1 GlobalEnum.VariantType._TYPE_VECTOR4 None  GlobalEnum.VariantOperator._OP_POSITIVE
      (funptr (Vector4.typ @-> Vector4.typ @-> returning void))
      Vector4.s x0 


    let not x0  = 
    foreign_builtin_operator1 GlobalEnum.VariantType._TYPE_VECTOR4 None  GlobalEnum.VariantOperator._OP_NOT
      (funptr (Vector4.typ @-> Bool.typ @-> returning void))
      Bool.s x0 









    (** Returns \[code\]true\[/code\] if the vectors are exactly equal.
\[b\]Note:\[/b\] Due to floating-point precision errors, consider using \[method is_equal_approx\] instead, which is more reliable.
\[b\]Note:\[/b\] Vectors with \[constant \@GDScript.NAN\] elements don''t behave the same as other vectors. Therefore, the results from this operator may not be accurate if NaNs are included. *)
    let (=) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_VECTOR4 (Some GlobalEnum.VariantType._TYPE_VECTOR4) GlobalEnum.VariantOperator._OP_EQUAL
      (funptr (Vector4.typ @-> Vector4.typ @-> Bool.typ @-> returning void))
      Bool.s
      Conv.Vector4.of_ocaml
      Conv.Vector4.of_ocaml
      Conv.Bool.to_ocaml x0  x1 

    (** Returns \[code\]true\[/code\] if the vectors are not equal.
\[b\]Note:\[/b\] Due to floating-point precision errors, consider using \[method is_equal_approx\] instead, which is more reliable.
\[b\]Note:\[/b\] Vectors with \[constant \@GDScript.NAN\] elements don''t behave the same as other vectors. Therefore, the results from this operator may not be accurate if NaNs are included. *)
    let (<>) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_VECTOR4 (Some GlobalEnum.VariantType._TYPE_VECTOR4) GlobalEnum.VariantOperator._OP_NOT_EQUAL
      (funptr (Vector4.typ @-> Vector4.typ @-> Bool.typ @-> returning void))
      Bool.s
      Conv.Vector4.of_ocaml
      Conv.Vector4.of_ocaml
      Conv.Bool.to_ocaml x0  x1 

    (** Compares two \[Vector4\] vectors by first checking if the X value of the left vector is less than the X value of the \[param right\] vector. If the X values are exactly equal, then it repeats this check with the Y values of the two vectors, Z values of the two vectors, and then with the W values. This operator is useful for sorting vectors.
\[b\]Note:\[/b\] Vectors with \[constant \@GDScript.NAN\] elements don''t behave the same as other vectors. Therefore, the results from this operator may not be accurate if NaNs are included. *)
    let (<) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_VECTOR4 (Some GlobalEnum.VariantType._TYPE_VECTOR4) GlobalEnum.VariantOperator._OP_LESS
      (funptr (Vector4.typ @-> Vector4.typ @-> Bool.typ @-> returning void))
      Bool.s
      Conv.Vector4.of_ocaml
      Conv.Vector4.of_ocaml
      Conv.Bool.to_ocaml x0  x1 

    (** Compares two \[Vector4\] vectors by first checking if the X value of the left vector is less than or equal to the X value of the \[param right\] vector. If the X values are exactly equal, then it repeats this check with the Y values of the two vectors, Z values of the two vectors, and then with the W values. This operator is useful for sorting vectors.
\[b\]Note:\[/b\] Vectors with \[constant \@GDScript.NAN\] elements don''t behave the same as other vectors. Therefore, the results from this operator may not be accurate if NaNs are included. *)
    let (<=) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_VECTOR4 (Some GlobalEnum.VariantType._TYPE_VECTOR4) GlobalEnum.VariantOperator._OP_LESS_EQUAL
      (funptr (Vector4.typ @-> Vector4.typ @-> Bool.typ @-> returning void))
      Bool.s
      Conv.Vector4.of_ocaml
      Conv.Vector4.of_ocaml
      Conv.Bool.to_ocaml x0  x1 

    (** Compares two \[Vector4\] vectors by first checking if the X value of the left vector is greater than the X value of the \[param right\] vector. If the X values are exactly equal, then it repeats this check with the Y values of the two vectors, Z values of the two vectors, and then with the W values. This operator is useful for sorting vectors.
\[b\]Note:\[/b\] Vectors with \[constant \@GDScript.NAN\] elements don''t behave the same as other vectors. Therefore, the results from this operator may not be accurate if NaNs are included. *)
    let (>) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_VECTOR4 (Some GlobalEnum.VariantType._TYPE_VECTOR4) GlobalEnum.VariantOperator._OP_GREATER
      (funptr (Vector4.typ @-> Vector4.typ @-> Bool.typ @-> returning void))
      Bool.s
      Conv.Vector4.of_ocaml
      Conv.Vector4.of_ocaml
      Conv.Bool.to_ocaml x0  x1 

    (** Compares two \[Vector4\] vectors by first checking if the X value of the left vector is greater than or equal to the X value of the \[param right\] vector. If the X values are exactly equal, then it repeats this check with the Y values of the two vectors, Z values of the two vectors, and then with the W values. This operator is useful for sorting vectors.
\[b\]Note:\[/b\] Vectors with \[constant \@GDScript.NAN\] elements don''t behave the same as other vectors. Therefore, the results from this operator may not be accurate if NaNs are included. *)
    let (>=) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_VECTOR4 (Some GlobalEnum.VariantType._TYPE_VECTOR4) GlobalEnum.VariantOperator._OP_GREATER_EQUAL
      (funptr (Vector4.typ @-> Vector4.typ @-> Bool.typ @-> returning void))
      Bool.s
      Conv.Vector4.of_ocaml
      Conv.Vector4.of_ocaml
      Conv.Bool.to_ocaml x0  x1 

    (** Adds each component of the \[Vector4\] by the components of the given \[Vector4\].
\[codeblock\]
print(Vector4(10, 20, 30, 40) + Vector4(3, 4, 5, 6)) # Prints (13.0, 24.0, 35.0, 46.0)
\[/codeblock\] *)
    let (+) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_VECTOR4 (Some GlobalEnum.VariantType._TYPE_VECTOR4) GlobalEnum.VariantOperator._OP_ADD
      (funptr (Vector4.typ @-> Vector4.typ @-> Vector4.typ @-> returning void))
      Vector4.s
      Conv.Vector4.of_ocaml
      Conv.Vector4.of_ocaml
      Conv.Vector4.to_ocaml x0  x1 

    (** Subtracts each component of the \[Vector4\] by the components of the given \[Vector4\].
\[codeblock\]
print(Vector4(10, 20, 30, 40) - Vector4(3, 4, 5, 6)) # Prints (7.0, 16.0, 25.0, 34.0)
\[/codeblock\] *)
    let (-) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_VECTOR4 (Some GlobalEnum.VariantType._TYPE_VECTOR4) GlobalEnum.VariantOperator._OP_SUBTRACT
      (funptr (Vector4.typ @-> Vector4.typ @-> Vector4.typ @-> returning void))
      Vector4.s
      Conv.Vector4.of_ocaml
      Conv.Vector4.of_ocaml
      Conv.Vector4.to_ocaml x0  x1 

    (** Multiplies each component of the \[Vector4\] by the components of the given \[Vector4\].
\[codeblock\]
print(Vector4(10, 20, 30, 40)  *  Vector4(3, 4, 5, 6)) # Prints (30.0, 80.0, 150.0, 240.0)
\[/codeblock\] *)
    let ( * ) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_VECTOR4 (Some GlobalEnum.VariantType._TYPE_VECTOR4) GlobalEnum.VariantOperator._OP_MULTIPLY
      (funptr (Vector4.typ @-> Vector4.typ @-> Vector4.typ @-> returning void))
      Vector4.s
      Conv.Vector4.of_ocaml
      Conv.Vector4.of_ocaml
      Conv.Vector4.to_ocaml x0  x1 

    (** Divides each component of the \[Vector4\] by the components of the given \[Vector4\].
\[codeblock\]
print(Vector4(10, 20, 30, 40) / Vector4(2, 5, 3, 4)) # Prints (5.0, 4.0, 10.0, 10.0)
\[/codeblock\] *)
    let (/) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_VECTOR4 (Some GlobalEnum.VariantType._TYPE_VECTOR4) GlobalEnum.VariantOperator._OP_DIVIDE
      (funptr (Vector4.typ @-> Vector4.typ @-> Vector4.typ @-> returning void))
      Vector4.s
      Conv.Vector4.of_ocaml
      Conv.Vector4.of_ocaml
      Conv.Vector4.to_ocaml x0  x1 




    let mem_Dictionary x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_VECTOR4 (Some GlobalEnum.VariantType._TYPE_DICTIONARY) GlobalEnum.VariantOperator._OP_IN
      (funptr (Vector4.typ @-> Dictionary.typ @-> Bool.typ @-> returning void))
      Bool.s x0  x1 


    let mem_Array x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_VECTOR4 (Some GlobalEnum.VariantType._TYPE_ARRAY) GlobalEnum.VariantOperator._OP_IN
      (funptr (Vector4.typ @-> Array.typ @-> Bool.typ @-> returning void))
      Bool.s x0  x1 


    let mem_PackedVector4Array x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_VECTOR4 (Some GlobalEnum.VariantType._TYPE_PACKED_VECTOR4_ARRAY) GlobalEnum.VariantOperator._OP_IN
      (funptr (Vector4.typ @-> PackedVector4Array.typ @-> Bool.typ @-> returning void))
      Bool.s x0  x1 

    module Axis = struct
      type t = Int.t

      let typ = 
      Int.typ

      (** Enumerated value for the X axis. Returned by \[method max_axis_index\] and \[method min_axis_index\]. *)
      let _AXIS_X = 
      0

      (** Enumerated value for the Y axis. Returned by \[method max_axis_index\] and \[method min_axis_index\]. *)
      let _AXIS_Y = 
      1

      (** Enumerated value for the Z axis. Returned by \[method max_axis_index\] and \[method min_axis_index\]. *)
      let _AXIS_Z = 
      2

      (** Enumerated value for the W axis. Returned by \[method max_axis_index\] and \[method min_axis_index\]. *)
      let _AXIS_W = 
      3
      end
    end

  module Vector4i = struct
    include M.Vector4i
include BuiltinClass0.Vector4i

    (** Returns the axis of the vector''s lowest value. See \[code\]AXIS_ * \[/code\] constants. If all components are equal, this method returns \[constant AXIS_W\]. *)
    let min_axis_index x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_VECTOR4I
      "min_axis_index"
      3173160232L
      (Vector4i.typ @-> returning Int.typ)
      Int.s x0 

    (** Returns the axis of the vector''s highest value. See \[code\]AXIS_ * \[/code\] constants. If all components are equal, this method returns \[constant AXIS_X\]. *)
    let max_axis_index x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_VECTOR4I
      "max_axis_index"
      3173160232L
      (Vector4i.typ @-> returning Int.typ)
      Int.s x0 

    (** Returns the length (magnitude) of this vector. *)
    let length x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_VECTOR4I
      "length"
      466405837L
      (Vector4i.typ @-> returning Float.typ)
      Float.s x0 

    (** Returns the squared length (squared magnitude) of this vector.
This method runs faster than \[method length\], so prefer it if you need to compare vectors or need the squared distance for some formula. *)
    let length_squared x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_VECTOR4I
      "length_squared"
      3173160232L
      (Vector4i.typ @-> returning Int.typ)
      Int.s x0 

    (** Returns a new vector with each component set to \[code\]1\[/code\] if it''s positive, \[code\]-1\[/code\] if it''s negative, and \[code\]0\[/code\] if it''s zero. The result is identical to calling \[method \@GlobalScope.sign\] on each component. *)
    let sign x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_VECTOR4I
      "sign"
      4134919947L
      (Vector4i.typ @-> returning Vector4i.typ)
      Vector4i.s x0 

    (** Returns a new vector with all components in absolute values (i.e. positive). *)
    let abs x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_VECTOR4I
      "abs"
      4134919947L
      (Vector4i.typ @-> returning Vector4i.typ)
      Vector4i.s x0 

    (** Returns a new vector with all components clamped between the components of \[param min\] and \[param max\], by running \[method \@GlobalScope.clamp\] on each component. *)
    let clamp x0  x1  x2  = 
    foreign_builtin_method2
      GlobalEnum.VariantType._TYPE_VECTOR4I
      "clamp"
      3046490913L
      (Vector4i.typ @-> Vector4i.typ @-> Vector4i.typ @-> returning Vector4i.typ)
      Vector4i.s x0  x1  x2 

    (** Returns a new vector with all components clamped between \[param min\] and \[param max\], by running \[method \@GlobalScope.clamp\] on each component. *)
    let clampi x0  x1  x2  = 
    foreign_builtin_method2
      GlobalEnum.VariantType._TYPE_VECTOR4I
      "clampi"
      2994578256L
      (Int.typ @-> Int.typ @-> Vector4i.typ @-> returning Vector4i.typ)
      Vector4i.s x0  x1  x2 

    (** Returns a new vector with each component snapped to the closest multiple of the corresponding component in \[param step\]. *)
    let snapped x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_VECTOR4I
      "snapped"
      1181693102L
      (Vector4i.typ @-> Vector4i.typ @-> returning Vector4i.typ)
      Vector4i.s x0  x1 

    (** Returns a new vector with each component snapped to the closest multiple of \[param step\]. *)
    let snappedi x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_VECTOR4I
      "snappedi"
      1476494415L
      (Int.typ @-> Vector4i.typ @-> returning Vector4i.typ)
      Vector4i.s x0  x1 

    (** Returns the component-wise minimum of this and \[param with\], equivalent to \[code\]Vector4i(mini(x, with.x), mini(y, with.y), mini(z, with.z), mini(w, with.w))\[/code\]. *)
    let min x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_VECTOR4I
      "min"
      1181693102L
      (Vector4i.typ @-> Vector4i.typ @-> returning Vector4i.typ)
      Vector4i.s x0  x1 

    (** Returns the component-wise minimum of this and \[param with\], equivalent to \[code\]Vector4i(mini(x, with), mini(y, with), mini(z, with), mini(w, with))\[/code\]. *)
    let mini x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_VECTOR4I
      "mini"
      1476494415L
      (Int.typ @-> Vector4i.typ @-> returning Vector4i.typ)
      Vector4i.s x0  x1 

    (** Returns the component-wise maximum of this and \[param with\], equivalent to \[code\]Vector4i(maxi(x, with.x), maxi(y, with.y), maxi(z, with.z), maxi(w, with.w))\[/code\]. *)
    let max x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_VECTOR4I
      "max"
      1181693102L
      (Vector4i.typ @-> Vector4i.typ @-> returning Vector4i.typ)
      Vector4i.s x0  x1 

    (** Returns the component-wise maximum of this and \[param with\], equivalent to \[code\]Vector4i(maxi(x, with), maxi(y, with), maxi(z, with), maxi(w, with))\[/code\]. *)
    let maxi x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_VECTOR4I
      "maxi"
      1476494415L
      (Int.typ @-> Vector4i.typ @-> returning Vector4i.typ)
      Vector4i.s x0  x1 

    (** Returns the distance between this vector and \[param to\]. *)
    let distance_to x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_VECTOR4I
      "distance_to"
      3446086573L
      (Vector4i.typ @-> Vector4i.typ @-> returning Float.typ)
      Float.s x0  x1 

    (** Returns the squared distance between this vector and \[param to\].
This method runs faster than \[method distance_to\], so prefer it if you need to compare vectors or need the squared distance for some formula. *)
    let distance_squared_to x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_VECTOR4I
      "distance_squared_to"
      346708794L
      (Vector4i.typ @-> Vector4i.typ @-> returning Int.typ)
      Int.s x0  x1 





    (** Returns the negative value of the \[Vector4i\]. This is the same as writing \[code\]Vector4i(-v.x, -v.y, -v.z, -v.w)\[/code\]. This operation flips the direction of the vector while keeping the same magnitude. *)
    let (~-) x0  = 
    foreign_builtin_operator1 GlobalEnum.VariantType._TYPE_VECTOR4I None  GlobalEnum.VariantOperator._OP_NEGATE
      (funptr (Vector4i.typ @-> Vector4i.typ @-> returning void))
      Vector4i.s x0 

    (** Returns the same value as if the \[code\]+\[/code\] was not there. Unary \[code\]+\[/code\] does nothing, but sometimes it can make your code more readable. *)
    let (~+) x0  = 
    foreign_builtin_operator1 GlobalEnum.VariantType._TYPE_VECTOR4I None  GlobalEnum.VariantOperator._OP_POSITIVE
      (funptr (Vector4i.typ @-> Vector4i.typ @-> returning void))
      Vector4i.s x0 


    let not x0  = 
    foreign_builtin_operator1 GlobalEnum.VariantType._TYPE_VECTOR4I None  GlobalEnum.VariantOperator._OP_NOT
      (funptr (Vector4i.typ @-> Bool.typ @-> returning void))
      Bool.s x0 











    (** Returns \[code\]true\[/code\] if the vectors are exactly equal. *)
    let (=) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_VECTOR4I (Some GlobalEnum.VariantType._TYPE_VECTOR4I) GlobalEnum.VariantOperator._OP_EQUAL
      (funptr (Vector4i.typ @-> Vector4i.typ @-> Bool.typ @-> returning void))
      Bool.s
      Conv.Vector4i.of_ocaml
      Conv.Vector4i.of_ocaml
      Conv.Bool.to_ocaml x0  x1 

    (** Returns \[code\]true\[/code\] if the vectors are not equal. *)
    let (<>) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_VECTOR4I (Some GlobalEnum.VariantType._TYPE_VECTOR4I) GlobalEnum.VariantOperator._OP_NOT_EQUAL
      (funptr (Vector4i.typ @-> Vector4i.typ @-> Bool.typ @-> returning void))
      Bool.s
      Conv.Vector4i.of_ocaml
      Conv.Vector4i.of_ocaml
      Conv.Bool.to_ocaml x0  x1 

    (** Compares two \[Vector4i\] vectors by first checking if the X value of the left vector is less than the X value of the \[param right\] vector. If the X values are exactly equal, then it repeats this check with the Y values of the two vectors, Z values of the two vectors, and then with the W values. This operator is useful for sorting vectors. *)
    let (<) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_VECTOR4I (Some GlobalEnum.VariantType._TYPE_VECTOR4I) GlobalEnum.VariantOperator._OP_LESS
      (funptr (Vector4i.typ @-> Vector4i.typ @-> Bool.typ @-> returning void))
      Bool.s
      Conv.Vector4i.of_ocaml
      Conv.Vector4i.of_ocaml
      Conv.Bool.to_ocaml x0  x1 

    (** Compares two \[Vector4i\] vectors by first checking if the X value of the left vector is less than or equal to the X value of the \[param right\] vector. If the X values are exactly equal, then it repeats this check with the Y values of the two vectors, Z values of the two vectors, and then with the W values. This operator is useful for sorting vectors. *)
    let (<=) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_VECTOR4I (Some GlobalEnum.VariantType._TYPE_VECTOR4I) GlobalEnum.VariantOperator._OP_LESS_EQUAL
      (funptr (Vector4i.typ @-> Vector4i.typ @-> Bool.typ @-> returning void))
      Bool.s
      Conv.Vector4i.of_ocaml
      Conv.Vector4i.of_ocaml
      Conv.Bool.to_ocaml x0  x1 

    (** Compares two \[Vector4i\] vectors by first checking if the X value of the left vector is greater than the X value of the \[param right\] vector. If the X values are exactly equal, then it repeats this check with the Y values of the two vectors, Z values of the two vectors, and then with the W values. This operator is useful for sorting vectors. *)
    let (>) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_VECTOR4I (Some GlobalEnum.VariantType._TYPE_VECTOR4I) GlobalEnum.VariantOperator._OP_GREATER
      (funptr (Vector4i.typ @-> Vector4i.typ @-> Bool.typ @-> returning void))
      Bool.s
      Conv.Vector4i.of_ocaml
      Conv.Vector4i.of_ocaml
      Conv.Bool.to_ocaml x0  x1 

    (** Compares two \[Vector4i\] vectors by first checking if the X value of the left vector is greater than or equal to the X value of the \[param right\] vector. If the X values are exactly equal, then it repeats this check with the Y values of the two vectors, Z values of the two vectors, and then with the W values. This operator is useful for sorting vectors. *)
    let (>=) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_VECTOR4I (Some GlobalEnum.VariantType._TYPE_VECTOR4I) GlobalEnum.VariantOperator._OP_GREATER_EQUAL
      (funptr (Vector4i.typ @-> Vector4i.typ @-> Bool.typ @-> returning void))
      Bool.s
      Conv.Vector4i.of_ocaml
      Conv.Vector4i.of_ocaml
      Conv.Bool.to_ocaml x0  x1 

    (** Adds each component of the \[Vector4i\] by the components of the given \[Vector4i\].
\[codeblock\]
print(Vector4i(10, 20, 30, 40) + Vector4i(3, 4, 5, 6)) # Prints (13, 24, 35, 46)
\[/codeblock\] *)
    let (+) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_VECTOR4I (Some GlobalEnum.VariantType._TYPE_VECTOR4I) GlobalEnum.VariantOperator._OP_ADD
      (funptr (Vector4i.typ @-> Vector4i.typ @-> Vector4i.typ @-> returning void))
      Vector4i.s
      Conv.Vector4i.of_ocaml
      Conv.Vector4i.of_ocaml
      Conv.Vector4i.to_ocaml x0  x1 

    (** Subtracts each component of the \[Vector4i\] by the components of the given \[Vector4i\].
\[codeblock\]
print(Vector4i(10, 20, 30, 40) - Vector4i(3, 4, 5, 6)) # Prints (7, 16, 25, 34)
\[/codeblock\] *)
    let (-) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_VECTOR4I (Some GlobalEnum.VariantType._TYPE_VECTOR4I) GlobalEnum.VariantOperator._OP_SUBTRACT
      (funptr (Vector4i.typ @-> Vector4i.typ @-> Vector4i.typ @-> returning void))
      Vector4i.s
      Conv.Vector4i.of_ocaml
      Conv.Vector4i.of_ocaml
      Conv.Vector4i.to_ocaml x0  x1 

    (** Multiplies each component of the \[Vector4i\] by the components of the given \[Vector4i\].
\[codeblock\]
print(Vector4i(10, 20, 30, 40)  *  Vector4i(3, 4, 5, 6)) # Prints (30, 80, 150, 240)
\[/codeblock\] *)
    let ( * ) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_VECTOR4I (Some GlobalEnum.VariantType._TYPE_VECTOR4I) GlobalEnum.VariantOperator._OP_MULTIPLY
      (funptr (Vector4i.typ @-> Vector4i.typ @-> Vector4i.typ @-> returning void))
      Vector4i.s
      Conv.Vector4i.of_ocaml
      Conv.Vector4i.of_ocaml
      Conv.Vector4i.to_ocaml x0  x1 

    (** Divides each component of the \[Vector4i\] by the components of the given \[Vector4i\].
\[codeblock\]
print(Vector4i(10, 20, 30, 40) / Vector4i(2, 5, 3, 4)) # Prints (5, 4, 10, 10)
\[/codeblock\] *)
    let (/) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_VECTOR4I (Some GlobalEnum.VariantType._TYPE_VECTOR4I) GlobalEnum.VariantOperator._OP_DIVIDE
      (funptr (Vector4i.typ @-> Vector4i.typ @-> Vector4i.typ @-> returning void))
      Vector4i.s
      Conv.Vector4i.of_ocaml
      Conv.Vector4i.of_ocaml
      Conv.Vector4i.to_ocaml x0  x1 

    (** Gets the remainder of each component of the \[Vector4i\] with the components of the given \[Vector4i\]. This operation uses truncated division, which is often not desired as it does not work well with negative numbers. Consider using \[method \@GlobalScope.posmod\] instead if you want to handle negative numbers.
\[codeblock\]
print(Vector4i(10, -20, 30, -40) % Vector4i(7, 8, 9, 10)) # Prints (3, -4, 3, 0)
\[/codeblock\] *)
    let (%) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_VECTOR4I (Some GlobalEnum.VariantType._TYPE_VECTOR4I) GlobalEnum.VariantOperator._OP_MODULE
      (funptr (Vector4i.typ @-> Vector4i.typ @-> Vector4i.typ @-> returning void))
      Vector4i.s
      Conv.Vector4i.of_ocaml
      Conv.Vector4i.of_ocaml
      Conv.Vector4i.to_ocaml x0  x1 


    let mem_Dictionary x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_VECTOR4I (Some GlobalEnum.VariantType._TYPE_DICTIONARY) GlobalEnum.VariantOperator._OP_IN
      (funptr (Vector4i.typ @-> Dictionary.typ @-> Bool.typ @-> returning void))
      Bool.s x0  x1 


    let mem_Array x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_VECTOR4I (Some GlobalEnum.VariantType._TYPE_ARRAY) GlobalEnum.VariantOperator._OP_IN
      (funptr (Vector4i.typ @-> Array.typ @-> Bool.typ @-> returning void))
      Bool.s x0  x1 

    module Axis = struct
      type t = Int.t

      let typ = 
      Int.typ

      (** Enumerated value for the X axis. Returned by \[method max_axis_index\] and \[method min_axis_index\]. *)
      let _AXIS_X = 
      0

      (** Enumerated value for the Y axis. Returned by \[method max_axis_index\] and \[method min_axis_index\]. *)
      let _AXIS_Y = 
      1

      (** Enumerated value for the Z axis. Returned by \[method max_axis_index\] and \[method min_axis_index\]. *)
      let _AXIS_Z = 
      2

      (** Enumerated value for the W axis. Returned by \[method max_axis_index\] and \[method min_axis_index\]. *)
      let _AXIS_W = 
      3
      end
    end

  module Plane = struct
    include M.Plane
include BuiltinClass0.Plane

    (** Returns a copy of the plane, with normalized \[member normal\] (so it''s a unit vector). Returns \[code\]Plane(0, 0, 0, 0)\[/code\] if \[member normal\] can''t be normalized (it has zero length). *)
    let normalized x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_PLANE
      "normalized"
      1051796340L
      (Plane.typ @-> returning Plane.typ)
      Plane.s x0 

    (** Returns the center of the plane. *)
    let get_center x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_PLANE
      "get_center"
      1776574132L
      (Plane.typ @-> returning Vector3.typ)
      Vector3.s x0 

    (** Returns \[code\]true\[/code\] if this plane and \[param to_plane\] are approximately equal, by running \[method \@GlobalScope.is_equal_approx\] on each component. *)
    let is_equal_approx x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_PLANE
      "is_equal_approx"
      1150170233L
      (Plane.typ @-> Plane.typ @-> returning Bool.typ)
      Bool.s x0  x1 

    (** Returns \[code\]true\[/code\] if this plane is finite, by calling \[method \@GlobalScope.is_finite\] on each component. *)
    let is_finite x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_PLANE
      "is_finite"
      3918633141L
      (Plane.typ @-> returning Bool.typ)
      Bool.s x0 

    (** Returns \[code\]true\[/code\] if \[param point\] is located above the plane. *)
    let is_point_over x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_PLANE
      "is_point_over"
      1749054343L
      (Vector3.typ @-> Plane.typ @-> returning Bool.typ)
      Bool.s x0  x1 

    (** Returns the shortest distance from the plane to the position \[param point\]. If the point is above the plane, the distance will be positive. If below, the distance will be negative. *)
    let distance_to x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_PLANE
      "distance_to"
      1047977935L
      (Vector3.typ @-> Plane.typ @-> returning Float.typ)
      Float.s x0  x1 

    (** Returns \[code\]true\[/code\] if \[param point\] is inside the plane. Comparison uses a custom minimum \[param tolerance\] threshold. *)
    let has_point x0  x1  x2  = 
    foreign_builtin_method2
      GlobalEnum.VariantType._TYPE_PLANE
      "has_point"
      1258189072L
      (Vector3.typ @-> Float.typ @-> Plane.typ @-> returning Bool.typ)
      Bool.s x0  x1  x2 

    (** Returns the orthogonal projection of \[param point\] into a point in the plane. *)
    let project x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_PLANE
      "project"
      2923479887L
      (Vector3.typ @-> Plane.typ @-> returning Vector3.typ)
      Vector3.s x0  x1 

    (** Returns the intersection point of the three planes \[param b\], \[param c\] and this plane. If no intersection is found, \[code\]null\[/code\] is returned. *)
    let intersect_3 x0  x1  x2  = 
    foreign_builtin_method2
      GlobalEnum.VariantType._TYPE_PLANE
      "intersect_3"
      2012052692L
      (Plane.typ @-> Plane.typ @-> Plane.typ @-> returning Variant.typ)
      Variant.s x0  x1  x2 

    (** Returns the intersection point of a ray consisting of the position \[param from\] and the direction normal \[param dir\] with this plane. If no intersection is found, \[code\]null\[/code\] is returned. *)
    let intersects_ray x0  x1  x2  = 
    foreign_builtin_method2
      GlobalEnum.VariantType._TYPE_PLANE
      "intersects_ray"
      2048133369L
      (Vector3.typ @-> Vector3.typ @-> Plane.typ @-> returning Variant.typ)
      Variant.s x0  x1  x2 

    (** Returns the intersection point of a segment from position \[param from\] to position \[param to\] with this plane. If no intersection is found, \[code\]null\[/code\] is returned. *)
    let intersects_segment x0  x1  x2  = 
    foreign_builtin_method2
      GlobalEnum.VariantType._TYPE_PLANE
      "intersects_segment"
      2048133369L
      (Vector3.typ @-> Vector3.typ @-> Plane.typ @-> returning Variant.typ)
      Variant.s x0  x1  x2 





    (** Returns the negative value of the \[Plane\]. This is the same as writing \[code\]Plane(-p.normal, -p.d)\[/code\]. This operation flips the direction of the normal vector and also flips the distance value, resulting in a Plane that is in the same place, but facing the opposite direction. *)
    let (~-) x0  = 
    foreign_builtin_operator1 GlobalEnum.VariantType._TYPE_PLANE None  GlobalEnum.VariantOperator._OP_NEGATE
      (funptr (Plane.typ @-> Plane.typ @-> returning void))
      Plane.s x0 

    (** Returns the same value as if the \[code\]+\[/code\] was not there. Unary \[code\]+\[/code\] does nothing, but sometimes it can make your code more readable. *)
    let (~+) x0  = 
    foreign_builtin_operator1 GlobalEnum.VariantType._TYPE_PLANE None  GlobalEnum.VariantOperator._OP_POSITIVE
      (funptr (Plane.typ @-> Plane.typ @-> returning void))
      Plane.s x0 


    let not x0  = 
    foreign_builtin_operator1 GlobalEnum.VariantType._TYPE_PLANE None  GlobalEnum.VariantOperator._OP_NOT
      (funptr (Plane.typ @-> Bool.typ @-> returning void))
      Bool.s x0 

    (** Returns \[code\]true\[/code\] if the planes are exactly equal.
\[b\]Note:\[/b\] Due to floating-point precision errors, consider using \[method is_equal_approx\] instead, which is more reliable. *)
    let (=) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_PLANE (Some GlobalEnum.VariantType._TYPE_PLANE) GlobalEnum.VariantOperator._OP_EQUAL
      (funptr (Plane.typ @-> Plane.typ @-> Bool.typ @-> returning void))
      Bool.s
      Conv.Plane.of_ocaml
      Conv.Plane.of_ocaml
      Conv.Bool.to_ocaml x0  x1 

    (** Returns \[code\]true\[/code\] if the planes are not equal.
\[b\]Note:\[/b\] Due to floating-point precision errors, consider using \[method is_equal_approx\] instead, which is more reliable. *)
    let (<>) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_PLANE (Some GlobalEnum.VariantType._TYPE_PLANE) GlobalEnum.VariantOperator._OP_NOT_EQUAL
      (funptr (Plane.typ @-> Plane.typ @-> Bool.typ @-> returning void))
      Bool.s
      Conv.Plane.of_ocaml
      Conv.Plane.of_ocaml
      Conv.Bool.to_ocaml x0  x1 




    let mem_Dictionary x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_PLANE (Some GlobalEnum.VariantType._TYPE_DICTIONARY) GlobalEnum.VariantOperator._OP_IN
      (funptr (Plane.typ @-> Dictionary.typ @-> Bool.typ @-> returning void))
      Bool.s x0  x1 


    let mem_Array x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_PLANE (Some GlobalEnum.VariantType._TYPE_ARRAY) GlobalEnum.VariantOperator._OP_IN
      (funptr (Plane.typ @-> Array.typ @-> Bool.typ @-> returning void))
      Bool.s x0  x1 
    end

  module Quaternion = struct
    include M.Quaternion
include BuiltinClass0.Quaternion

    (** Returns this quaternion''s length, also called magnitude. *)
    let length x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_QUATERNION
      "length"
      466405837L
      (Quaternion.typ @-> returning Float.typ)
      Float.s x0 

    (** Returns this quaternion''s length, squared.
\[b\]Note:\[/b\] This method is faster than \[method length\], so prefer it if you only need to compare quaternion lengths. *)
    let length_squared x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_QUATERNION
      "length_squared"
      466405837L
      (Quaternion.typ @-> returning Float.typ)
      Float.s x0 

    (** Returns a copy of this quaternion, normalized so that its length is \[code\]1.0\[/code\]. See also \[method is_normalized\]. *)
    let normalized x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_QUATERNION
      "normalized"
      4274879941L
      (Quaternion.typ @-> returning Quaternion.typ)
      Quaternion.s x0 

    (** Returns \[code\]true\[/code\] if this quaternion is normalized. See also \[method normalized\]. *)
    let is_normalized x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_QUATERNION
      "is_normalized"
      3918633141L
      (Quaternion.typ @-> returning Bool.typ)
      Bool.s x0 

    (** Returns \[code\]true\[/code\] if this quaternion and \[param to\] are approximately equal, by calling \[method \@GlobalScope.is_equal_approx\] on each component. *)
    let is_equal_approx x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_QUATERNION
      "is_equal_approx"
      1682156903L
      (Quaternion.typ @-> Quaternion.typ @-> returning Bool.typ)
      Bool.s x0  x1 

    (** Returns \[code\]true\[/code\] if this quaternion is finite, by calling \[method \@GlobalScope.is_finite\] on each component. *)
    let is_finite x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_QUATERNION
      "is_finite"
      3918633141L
      (Quaternion.typ @-> returning Bool.typ)
      Bool.s x0 

    (** Returns the inverse version of this quaternion, inverting the sign of every component except \[member w\]. *)
    let inverse x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_QUATERNION
      "inverse"
      4274879941L
      (Quaternion.typ @-> returning Quaternion.typ)
      Quaternion.s x0 

    (** Returns the logarithm of this quaternion. Multiplies this quaternion''s rotation axis by its rotation angle, and stores the result in the returned quaternion''s vector part (\[member x\], \[member y\], and \[member z\]). The returned quaternion''s real part (\[member w\]) is always \[code\]0.0\[/code\]. *)
    let log x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_QUATERNION
      "log"
      4274879941L
      (Quaternion.typ @-> returning Quaternion.typ)
      Quaternion.s x0 

    (** Returns the exponential of this quaternion. The rotation axis of the result is the normalized rotation axis of this quaternion, the angle of the result is the length of the vector part of this quaternion. *)
    let exp x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_QUATERNION
      "exp"
      4274879941L
      (Quaternion.typ @-> returning Quaternion.typ)
      Quaternion.s x0 

    (** Returns the angle between this quaternion and \[param to\]. This is the magnitude of the angle you would need to rotate by to get from one to the other.
\[b\]Note:\[/b\] The magnitude of the floating-point error for this method is abnormally high, so methods such as \[code\]is_zero_approx\[/code\] will not work reliably. *)
    let angle_to x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_QUATERNION
      "angle_to"
      3244682419L
      (Quaternion.typ @-> Quaternion.typ @-> returning Float.typ)
      Float.s x0  x1 

    (** Returns the dot product between this quaternion and \[param with\].
This is equivalent to \[code\](quat.x  *  with.x) + (quat.y  *  with.y) + (quat.z  *  with.z) + (quat.w  *  with.w)\[/code\]. *)
    let dot x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_QUATERNION
      "dot"
      3244682419L
      (Quaternion.typ @-> Quaternion.typ @-> returning Float.typ)
      Float.s x0  x1 

    (** Performs a spherical-linear interpolation with the \[param to\] quaternion, given a \[param weight\] and returns the result. Both this quaternion and \[param to\] must be normalized. *)
    let slerp x0  x1  x2  = 
    foreign_builtin_method2
      GlobalEnum.VariantType._TYPE_QUATERNION
      "slerp"
      1773590316L
      (Quaternion.typ @-> Float.typ @-> Quaternion.typ @-> returning Quaternion.typ)
      Quaternion.s x0  x1  x2 

    (** Performs a spherical-linear interpolation with the \[param to\] quaternion, given a \[param weight\] and returns the result. Unlike \[method slerp\], this method does not check if the rotation path is smaller than 90 degrees. Both this quaternion and \[param to\] must be normalized. *)
    let slerpni x0  x1  x2  = 
    foreign_builtin_method2
      GlobalEnum.VariantType._TYPE_QUATERNION
      "slerpni"
      1773590316L
      (Quaternion.typ @-> Float.typ @-> Quaternion.typ @-> returning Quaternion.typ)
      Quaternion.s x0  x1  x2 

    (** Performs a spherical cubic interpolation between quaternions \[param pre_a\], this vector, \[param b\], and \[param post_b\], by the given amount \[param weight\]. *)
    let spherical_cubic_interpolate x0  x1  x2  x3  x4  = 
    foreign_builtin_method4
      GlobalEnum.VariantType._TYPE_QUATERNION
      "spherical_cubic_interpolate"
      2150967576L
      (Quaternion.typ @-> Quaternion.typ @-> Quaternion.typ @-> Float.typ @-> Quaternion.typ @-> returning Quaternion.typ)
      Quaternion.s x0  x1  x2  x3  x4 

    (** Performs a spherical cubic interpolation between quaternions \[param pre_a\], this vector, \[param b\], and \[param post_b\], by the given amount \[param weight\].
It can perform smoother interpolation than \[method spherical_cubic_interpolate\] by the time values. *)
    let spherical_cubic_interpolate_in_time x0  x1  x2  x3  x4  x5  x6  x7  = 
    foreign_builtin_method7
      GlobalEnum.VariantType._TYPE_QUATERNION
      "spherical_cubic_interpolate_in_time"
      1436023539L
      (Quaternion.typ @-> Quaternion.typ @-> Quaternion.typ @-> Float.typ @-> Float.typ @-> Float.typ @-> Float.typ @-> Quaternion.typ @-> returning Quaternion.typ)
      Quaternion.s x0  x1  x2  x3  x4  x5  x6  x7 

    (** Returns this quaternion''s rotation as a \[Vector3\] of \[url=https://en.wikipedia.org/wiki/Euler_angles\]Euler angles\[/url\], in radians.
The order of each consecutive rotation can be changed with \[param order\] (see \[enum EulerOrder\] constants). By default, the YXZ convention is used (\[constant EULER_ORDER_YXZ\]): Z (roll) is calculated first, then X (pitch), and lastly Y (yaw). When using the opposite method \[method from_euler\], this order is reversed. *)
    let get_euler x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_QUATERNION
      "get_euler"
      1394941017L
      (Int.typ @-> Quaternion.typ @-> returning Vector3.typ)
      Vector3.s x0  x1 

    (** Constructs a new \[Quaternion\] from the given \[Vector3\] of \[url=https://en.wikipedia.org/wiki/Euler_angles\]Euler angles\[/url\], in radians. This method always uses the YXZ convention (\[constant EULER_ORDER_YXZ\]). *)
    let from_euler x0  = 
    foreign_builtin_method1_static
      GlobalEnum.VariantType._TYPE_QUATERNION
      "from_euler"
      4053467903L
      (Vector3.typ @-> returning Quaternion.typ)
      Quaternion.s x0 

    (** Returns the rotation axis of the rotation represented by this quaternion. *)
    let get_axis x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_QUATERNION
      "get_axis"
      1776574132L
      (Quaternion.typ @-> returning Vector3.typ)
      Vector3.s x0 

    (** Returns the angle of the rotation represented by this quaternion.
\[b\]Note:\[/b\] The quaternion must be normalized. *)
    let get_angle x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_QUATERNION
      "get_angle"
      466405837L
      (Quaternion.typ @-> returning Float.typ)
      Float.s x0 





    (** Returns the negative value of the \[Quaternion\]. This is the same as multiplying all components by \[code\]-1\[/code\]. This operation results in a quaternion that represents the same rotation. *)
    let (~-) x0  = 
    foreign_builtin_operator1 GlobalEnum.VariantType._TYPE_QUATERNION None  GlobalEnum.VariantOperator._OP_NEGATE
      (funptr (Quaternion.typ @-> Quaternion.typ @-> returning void))
      Quaternion.s x0 

    (** Returns the same value as if the \[code\]+\[/code\] was not there. Unary \[code\]+\[/code\] does nothing, but sometimes it can make your code more readable. *)
    let (~+) x0  = 
    foreign_builtin_operator1 GlobalEnum.VariantType._TYPE_QUATERNION None  GlobalEnum.VariantOperator._OP_POSITIVE
      (funptr (Quaternion.typ @-> Quaternion.typ @-> returning void))
      Quaternion.s x0 


    let not x0  = 
    foreign_builtin_operator1 GlobalEnum.VariantType._TYPE_QUATERNION None  GlobalEnum.VariantOperator._OP_NOT
      (funptr (Quaternion.typ @-> Bool.typ @-> returning void))
      Bool.s x0 











    (** Returns \[code\]true\[/code\] if the components of both quaternions are exactly equal.
\[b\]Note:\[/b\] Due to floating-point precision errors, consider using \[method is_equal_approx\] instead, which is more reliable. *)
    let (=) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_QUATERNION (Some GlobalEnum.VariantType._TYPE_QUATERNION) GlobalEnum.VariantOperator._OP_EQUAL
      (funptr (Quaternion.typ @-> Quaternion.typ @-> Bool.typ @-> returning void))
      Bool.s
      Conv.Quaternion.of_ocaml
      Conv.Quaternion.of_ocaml
      Conv.Bool.to_ocaml x0  x1 

    (** Returns \[code\]true\[/code\] if the components of both quaternions are not exactly equal.
\[b\]Note:\[/b\] Due to floating-point precision errors, consider using \[method is_equal_approx\] instead, which is more reliable. *)
    let (<>) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_QUATERNION (Some GlobalEnum.VariantType._TYPE_QUATERNION) GlobalEnum.VariantOperator._OP_NOT_EQUAL
      (funptr (Quaternion.typ @-> Quaternion.typ @-> Bool.typ @-> returning void))
      Bool.s
      Conv.Quaternion.of_ocaml
      Conv.Quaternion.of_ocaml
      Conv.Bool.to_ocaml x0  x1 

    (** Adds each component of the left \[Quaternion\] to the right \[Quaternion\].
This operation is not meaningful on its own, but it can be used as a part of a larger expression, such as approximating an intermediate rotation between two nearby rotations. *)
    let (+) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_QUATERNION (Some GlobalEnum.VariantType._TYPE_QUATERNION) GlobalEnum.VariantOperator._OP_ADD
      (funptr (Quaternion.typ @-> Quaternion.typ @-> Quaternion.typ @-> returning void))
      Quaternion.s
      Conv.Quaternion.of_ocaml
      Conv.Quaternion.of_ocaml
      Conv.Quaternion.to_ocaml x0  x1 

    (** Subtracts each component of the left \[Quaternion\] by the right \[Quaternion\].
This operation is not meaningful on its own, but it can be used as a part of a larger expression. *)
    let (-) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_QUATERNION (Some GlobalEnum.VariantType._TYPE_QUATERNION) GlobalEnum.VariantOperator._OP_SUBTRACT
      (funptr (Quaternion.typ @-> Quaternion.typ @-> Quaternion.typ @-> returning void))
      Quaternion.s
      Conv.Quaternion.of_ocaml
      Conv.Quaternion.of_ocaml
      Conv.Quaternion.to_ocaml x0  x1 

    (** Composes (multiplies) two quaternions. This rotates the \[param right\] quaternion (the child) by this quaternion (the parent). *)
    let ( * ) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_QUATERNION (Some GlobalEnum.VariantType._TYPE_QUATERNION) GlobalEnum.VariantOperator._OP_MULTIPLY
      (funptr (Quaternion.typ @-> Quaternion.typ @-> Quaternion.typ @-> returning void))
      Quaternion.s
      Conv.Quaternion.of_ocaml
      Conv.Quaternion.of_ocaml
      Conv.Quaternion.to_ocaml x0  x1 


    let mem_Dictionary x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_QUATERNION (Some GlobalEnum.VariantType._TYPE_DICTIONARY) GlobalEnum.VariantOperator._OP_IN
      (funptr (Quaternion.typ @-> Dictionary.typ @-> Bool.typ @-> returning void))
      Bool.s x0  x1 


    let mem_Array x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_QUATERNION (Some GlobalEnum.VariantType._TYPE_ARRAY) GlobalEnum.VariantOperator._OP_IN
      (funptr (Quaternion.typ @-> Array.typ @-> Bool.typ @-> returning void))
      Bool.s x0  x1 
    end

  module AABB = struct
    include M.AABB
include BuiltinClass0.AABB

    (** Returns an \[AABB\] equivalent to this bounding box, with its width, height, and depth modified to be non-negative values.
\[codeblocks\]
\[gdscript\]
var box = AABB(Vector3(5, 0, 5), Vector3(-20, -10, -5))
var absolute = box.abs()
print(absolute.position) # Prints (-15.0, -10.0, 0.0)
print(absolute.size)     # Prints (20.0, 10.0, 5.0)
\[/gdscript\]
\[csharp\]
var box = new Aabb(new Vector3(5, 0, 5), new Vector3(-20, -10, -5));
var absolute = box.Abs();
GD.Print(absolute.Position); // Prints (-15, -10, 0)
GD.Print(absolute.Size);     // Prints (20, 10, 5)
\[/csharp\]
\[/codeblocks\]
\[b\]Note:\[/b\] It''s recommended to use this method when \[member size\] is negative, as most other methods in Godot assume that the \[member size\]''s components are greater than \[code\]0\[/code\]. *)
    let abs x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_AABB
      "abs"
      1576868580L
      (AABB.typ @-> returning AABB.typ)
      AABB.s x0 

    (** Returns the center point of the bounding box. This is the same as \[code\]position + (size / 2.0)\[/code\]. *)
    let get_center x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_AABB
      "get_center"
      1776574132L
      (AABB.typ @-> returning Vector3.typ)
      Vector3.s x0 

    (** Returns the bounding box''s volume. This is equivalent to \[code\]size.x  *  size.y  *  size.z\[/code\]. See also \[method has_volume\]. *)
    let get_volume x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_AABB
      "get_volume"
      466405837L
      (AABB.typ @-> returning Float.typ)
      Float.s x0 

    (** Returns \[code\]true\[/code\] if this bounding box''s width, height, and depth are all positive. See also \[method get_volume\]. *)
    let has_volume x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_AABB
      "has_volume"
      3918633141L
      (AABB.typ @-> returning Bool.typ)
      Bool.s x0 

    (** Returns \[code\]true\[/code\] if this bounding box has a surface or a length, that is, at least one component of \[member size\] is greater than \[code\]0\[/code\]. Otherwise, returns \[code\]false\[/code\]. *)
    let has_surface x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_AABB
      "has_surface"
      3918633141L
      (AABB.typ @-> returning Bool.typ)
      Bool.s x0 

    (** Returns \[code\]true\[/code\] if the bounding box contains the given \[param point\]. By convention, points exactly on the right, top, and front sides are \[b\]not\[/b\] included.
\[b\]Note:\[/b\] This method is not reliable for \[AABB\] with a \[i\]negative\[/i\] \[member size\]. Use \[method abs\] first to get a valid bounding box. *)
    let has_point x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_AABB
      "has_point"
      1749054343L
      (Vector3.typ @-> AABB.typ @-> returning Bool.typ)
      Bool.s x0  x1 

    (** Returns \[code\]true\[/code\] if this bounding box and \[param aabb\] are approximately equal, by calling \[method Vector3.is_equal_approx\] on the \[member position\] and the \[member size\]. *)
    let is_equal_approx x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_AABB
      "is_equal_approx"
      299946684L
      (AABB.typ @-> AABB.typ @-> returning Bool.typ)
      Bool.s x0  x1 

    (** Returns \[code\]true\[/code\] if this bounding box''s values are finite, by calling \[method Vector3.is_finite\] on the \[member position\] and the \[member size\]. *)
    let is_finite x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_AABB
      "is_finite"
      3918633141L
      (AABB.typ @-> returning Bool.typ)
      Bool.s x0 

    (** Returns \[code\]true\[/code\] if this bounding box overlaps with the box \[param with\]. The edges of both boxes are \[i\]always\[/i\] excluded. *)
    let intersects x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_AABB
      "intersects"
      299946684L
      (AABB.typ @-> AABB.typ @-> returning Bool.typ)
      Bool.s x0  x1 

    (** Returns \[code\]true\[/code\] if this bounding box \[i\]completely\[/i\] encloses the \[param with\] box. The edges of both boxes are included.
\[codeblocks\]
\[gdscript\]
var a = AABB(Vector3(0, 0, 0), Vector3(4, 4, 4))
var b = AABB(Vector3(1, 1, 1), Vector3(3, 3, 3))
var c = AABB(Vector3(2, 2, 2), Vector3(8, 8, 8))

print(a.encloses(a)) # Prints true
print(a.encloses(b)) # Prints true
print(a.encloses(c)) # Prints false
\[/gdscript\]
\[csharp\]
var a = new Aabb(new Vector3(0, 0, 0), new Vector3(4, 4, 4));
var b = new Aabb(new Vector3(1, 1, 1), new Vector3(3, 3, 3));
var c = new Aabb(new Vector3(2, 2, 2), new Vector3(8, 8, 8));

GD.Print(a.Encloses(a)); // Prints True
GD.Print(a.Encloses(b)); // Prints True
GD.Print(a.Encloses(c)); // Prints False
\[/csharp\]
\[/codeblocks\] *)
    let encloses x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_AABB
      "encloses"
      299946684L
      (AABB.typ @-> AABB.typ @-> returning Bool.typ)
      Bool.s x0  x1 

    (** Returns \[code\]true\[/code\] if this bounding box is on both sides of the given \[param plane\]. *)
    let intersects_plane x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_AABB
      "intersects_plane"
      1150170233L
      (Plane.typ @-> AABB.typ @-> returning Bool.typ)
      Bool.s x0  x1 

    (** Returns the intersection between this bounding box and \[param with\]. If the boxes do not intersect, returns an empty \[AABB\]. If the boxes intersect at the edge, returns a flat \[AABB\] with no volume (see \[method has_surface\] and \[method has_volume\]).
\[codeblocks\]
\[gdscript\]
var box1 = AABB(Vector3(0, 0, 0), Vector3(5, 2, 8))
var box2 = AABB(Vector3(2, 0, 2), Vector3(8, 4, 4))

var intersection = box1.intersection(box2)
print(intersection.position) # Prints (2.0, 0.0, 2.0)
print(intersection.size)     # Prints (3.0, 2.0, 4.0)
\[/gdscript\]
\[csharp\]
var box1 = new Aabb(new Vector3(0, 0, 0), new Vector3(5, 2, 8));
var box2 = new Aabb(new Vector3(2, 0, 2), new Vector3(8, 4, 4));

var intersection = box1.Intersection(box2);
GD.Print(intersection.Position); // Prints (2, 0, 2)
GD.Print(intersection.Size);     // Prints (3, 2, 4)
\[/csharp\]
\[/codeblocks\]
\[b\]Note:\[/b\] If you only need to know whether two bounding boxes are intersecting, use \[method intersects\], instead. *)
    let intersection x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_AABB
      "intersection"
      1271470306L
      (AABB.typ @-> AABB.typ @-> returning AABB.typ)
      AABB.s x0  x1 

    (** Returns an \[AABB\] that encloses both this bounding box and \[param with\] around the edges. See also \[method encloses\]. *)
    let merge x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_AABB
      "merge"
      1271470306L
      (AABB.typ @-> AABB.typ @-> returning AABB.typ)
      AABB.s x0  x1 

    (** Returns a copy of this bounding box expanded to align the edges with the given \[param to_point\], if necessary.
\[codeblocks\]
\[gdscript\]
var box = AABB(Vector3(0, 0, 0), Vector3(5, 2, 5))

box = box.expand(Vector3(10, 0, 0))
print(box.position) # Prints (0.0, 0.0, 0.0)
print(box.size)     # Prints (10.0, 2.0, 5.0)

box = box.expand(Vector3(-5, 0, 5))
print(box.position) # Prints (-5.0, 0.0, 0.0)
print(box.size)     # Prints (15.0, 2.0, 5.0)
\[/gdscript\]
\[csharp\]
var box = new Aabb(new Vector3(0, 0, 0), new Vector3(5, 2, 5));

box = box.Expand(new Vector3(10, 0, 0));
GD.Print(box.Position); // Prints (0, 0, 0)
GD.Print(box.Size);     // Prints (10, 2, 5)

box = box.Expand(new Vector3(-5, 0, 5));
GD.Print(box.Position); // Prints (-5, 0, 0)
GD.Print(box.Size);     // Prints (15, 2, 5)
\[/csharp\]
\[/codeblocks\] *)
    let expand x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_AABB
      "expand"
      2851643018L
      (Vector3.typ @-> AABB.typ @-> returning AABB.typ)
      AABB.s x0  x1 

    (** Returns a copy of this bounding box extended on all sides by the given amount \[param by\]. A negative amount shrinks the box instead.
\[codeblocks\]
\[gdscript\]
var a = AABB(Vector3(4, 4, 4), Vector3(8, 8, 8)).grow(4)
print(a.position) # Prints (0.0, 0.0, 0.0)
print(a.size)     # Prints (16.0, 16.0, 16.0)

var b = AABB(Vector3(0, 0, 0), Vector3(8, 4, 2)).grow(2)
print(b.position) # Prints (-2.0, -2.0, -2.0)
print(b.size)     # Prints (12.0, 8.0, 6.0)
\[/gdscript\]
\[csharp\]
var a = new Aabb(new Vector3(4, 4, 4), new Vector3(8, 8, 8)).Grow(4);
GD.Print(a.Position); // Prints (0, 0, 0)
GD.Print(a.Size);     // Prints (16, 16, 16)

var b = new Aabb(new Vector3(0, 0, 0), new Vector3(8, 4, 2)).Grow(2);
GD.Print(b.Position); // Prints (-2, -2, -2)
GD.Print(b.Size);     // Prints (12, 8, 6)
\[/csharp\]
\[/codeblocks\] *)
    let grow x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_AABB
      "grow"
      239217291L
      (Float.typ @-> AABB.typ @-> returning AABB.typ)
      AABB.s x0  x1 

    (** Returns the vertex''s position of this bounding box that''s the farthest in the given direction. This point is commonly known as the support point in collision detection algorithms. *)
    let get_support x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_AABB
      "get_support"
      2923479887L
      (Vector3.typ @-> AABB.typ @-> returning Vector3.typ)
      Vector3.s x0  x1 

    (** Returns the longest normalized axis of this bounding box''s \[member size\], as a \[Vector3\] (\[constant Vector3.RIGHT\], \[constant Vector3.UP\], or \[constant Vector3.BACK\]).
\[codeblocks\]
\[gdscript\]
var box = AABB(Vector3(0, 0, 0), Vector3(2, 4, 8))

print(box.get_longest_axis())       # Prints (0.0, 0.0, 1.0)
print(box.get_longest_axis_index()) # Prints 2
print(box.get_longest_axis_size())  # Prints 8.0
\[/gdscript\]
\[csharp\]
var box = new Aabb(new Vector3(0, 0, 0), new Vector3(2, 4, 8));

GD.Print(box.GetLongestAxis());      // Prints (0, 0, 1)
GD.Print(box.GetLongestAxisIndex()); // Prints Z
GD.Print(box.GetLongestAxisSize());  // Prints 8
\[/csharp\]
\[/codeblocks\]
See also \[method get_longest_axis_index\] and \[method get_longest_axis_size\]. *)
    let get_longest_axis x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_AABB
      "get_longest_axis"
      1776574132L
      (AABB.typ @-> returning Vector3.typ)
      Vector3.s x0 

    (** Returns the index to the longest axis of this bounding box''s \[member size\] (see \[constant Vector3.AXIS_X\], \[constant Vector3.AXIS_Y\], and \[constant Vector3.AXIS_Z\]).
For an example, see \[method get_longest_axis\]. *)
    let get_longest_axis_index x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_AABB
      "get_longest_axis_index"
      3173160232L
      (AABB.typ @-> returning Int.typ)
      Int.s x0 

    (** Returns the longest dimension of this bounding box''s \[member size\].
For an example, see \[method get_longest_axis\]. *)
    let get_longest_axis_size x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_AABB
      "get_longest_axis_size"
      466405837L
      (AABB.typ @-> returning Float.typ)
      Float.s x0 

    (** Returns the shortest normalized axis of this bounding box''s \[member size\], as a \[Vector3\] (\[constant Vector3.RIGHT\], \[constant Vector3.UP\], or \[constant Vector3.BACK\]).
\[codeblocks\]
\[gdscript\]
var box = AABB(Vector3(0, 0, 0), Vector3(2, 4, 8))

print(box.get_shortest_axis())       # Prints (1.0, 0.0, 0.0)
print(box.get_shortest_axis_index()) # Prints 0
print(box.get_shortest_axis_size())  # Prints 2.0
\[/gdscript\]
\[csharp\]
var box = new Aabb(new Vector3(0, 0, 0), new Vector3(2, 4, 8));

GD.Print(box.GetShortestAxis());      // Prints (1, 0, 0)
GD.Print(box.GetShortestAxisIndex()); // Prints X
GD.Print(box.GetShortestAxisSize());  // Prints 2
\[/csharp\]
\[/codeblocks\]
See also \[method get_shortest_axis_index\] and \[method get_shortest_axis_size\]. *)
    let get_shortest_axis x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_AABB
      "get_shortest_axis"
      1776574132L
      (AABB.typ @-> returning Vector3.typ)
      Vector3.s x0 

    (** Returns the index to the shortest axis of this bounding box''s \[member size\] (see \[constant Vector3.AXIS_X\], \[constant Vector3.AXIS_Y\], and \[constant Vector3.AXIS_Z\]).
For an example, see \[method get_shortest_axis\]. *)
    let get_shortest_axis_index x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_AABB
      "get_shortest_axis_index"
      3173160232L
      (AABB.typ @-> returning Int.typ)
      Int.s x0 

    (** Returns the shortest dimension of this bounding box''s \[member size\].
For an example, see \[method get_shortest_axis\]. *)
    let get_shortest_axis_size x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_AABB
      "get_shortest_axis_size"
      466405837L
      (AABB.typ @-> returning Float.typ)
      Float.s x0 

    (** Returns the position of one of the 8 vertices that compose this bounding box. With a \[param idx\] of \[code\]0\[/code\] this is the same as \[member position\], and a \[param idx\] of \[code\]7\[/code\] is the same as \[member end\]. *)
    let get_endpoint x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_AABB
      "get_endpoint"
      1394941017L
      (Int.typ @-> AABB.typ @-> returning Vector3.typ)
      Vector3.s x0  x1 

    (** Returns the first point where this bounding box and the given segment intersect, as a \[Vector3\]. If no intersection occurs, returns \[code\]null\[/code\].
The segment begins at \[param from\] and ends at \[param to\]. *)
    let intersects_segment x0  x1  x2  = 
    foreign_builtin_method2
      GlobalEnum.VariantType._TYPE_AABB
      "intersects_segment"
      2048133369L
      (Vector3.typ @-> Vector3.typ @-> AABB.typ @-> returning Variant.typ)
      Variant.s x0  x1  x2 

    (** Returns the first point where this bounding box and the given ray intersect, as a \[Vector3\]. If no intersection occurs, returns \[code\]null\[/code\].
The ray begin at \[param from\], faces \[param dir\] and extends towards infinity. *)
    let intersects_ray x0  x1  x2  = 
    foreign_builtin_method2
      GlobalEnum.VariantType._TYPE_AABB
      "intersects_ray"
      2048133369L
      (Vector3.typ @-> Vector3.typ @-> AABB.typ @-> returning Variant.typ)
      Variant.s x0  x1  x2 






    let not x0  = 
    foreign_builtin_operator1 GlobalEnum.VariantType._TYPE_AABB None  GlobalEnum.VariantOperator._OP_NOT
      (funptr (AABB.typ @-> Bool.typ @-> returning void))
      Bool.s x0 

    (** Returns \[code\]true\[/code\] if both \[member position\] and \[member size\] of the bounding boxes are exactly equal, respectively.
\[b\]Note:\[/b\] Due to floating-point precision errors, consider using \[method is_equal_approx\] instead, which is more reliable. *)
    let (=) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_AABB (Some GlobalEnum.VariantType._TYPE_AABB) GlobalEnum.VariantOperator._OP_EQUAL
      (funptr (AABB.typ @-> AABB.typ @-> Bool.typ @-> returning void))
      Bool.s
      Conv.AABB.of_ocaml
      Conv.AABB.of_ocaml
      Conv.Bool.to_ocaml x0  x1 

    (** Returns \[code\]true\[/code\] if the \[member position\] or \[member size\] of both bounding boxes are not equal.
\[b\]Note:\[/b\] Due to floating-point precision errors, consider using \[method is_equal_approx\] instead, which is more reliable. *)
    let (<>) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_AABB (Some GlobalEnum.VariantType._TYPE_AABB) GlobalEnum.VariantOperator._OP_NOT_EQUAL
      (funptr (AABB.typ @-> AABB.typ @-> Bool.typ @-> returning void))
      Bool.s
      Conv.AABB.of_ocaml
      Conv.AABB.of_ocaml
      Conv.Bool.to_ocaml x0  x1 




    let mem_Dictionary x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_AABB (Some GlobalEnum.VariantType._TYPE_DICTIONARY) GlobalEnum.VariantOperator._OP_IN
      (funptr (AABB.typ @-> Dictionary.typ @-> Bool.typ @-> returning void))
      Bool.s x0  x1 


    let mem_Array x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_AABB (Some GlobalEnum.VariantType._TYPE_ARRAY) GlobalEnum.VariantOperator._OP_IN
      (funptr (AABB.typ @-> Array.typ @-> Bool.typ @-> returning void))
      Bool.s x0  x1 
    end

  module Basis = struct
    include M.Basis
include BuiltinClass0.Basis

    (** Returns the \[url=https://en.wikipedia.org/wiki/Invertible_matrix\]inverse of this basis''s matrix\[/url\]. *)
    let inverse x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_BASIS
      "inverse"
      594669093L
      (Basis.typ @-> returning Basis.typ)
      Basis.s x0 

    (** Returns the transposed version of this basis. This turns the basis matrix''s columns into rows, and its rows into columns.
\[codeblocks\]
\[gdscript\]
var my_basis = Basis(
    Vector3(1, 2, 3),
    Vector3(4, 5, 6),
    Vector3(7, 8, 9)
)
my_basis = my_basis.transposed()

print(my_basis.x) # Prints (1.0, 4.0, 7.0)
print(my_basis.y) # Prints (2.0, 5.0, 8.0)
print(my_basis.z) # Prints (3.0, 6.0, 9.0)
\[/gdscript\]
\[csharp\]
var myBasis = new Basis(
    new Vector3(1.0f, 2.0f, 3.0f),
    new Vector3(4.0f, 5.0f, 6.0f),
    new Vector3(7.0f, 8.0f, 9.0f)
);
myBasis = myBasis.Transposed();

GD.Print(myBasis.X); // Prints (1, 4, 7)
GD.Print(myBasis.Y); // Prints (2, 5, 8)
GD.Print(myBasis.Z); // Prints (3, 6, 9)
\[/csharp\]
\[/codeblocks\] *)
    let transposed x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_BASIS
      "transposed"
      594669093L
      (Basis.typ @-> returning Basis.typ)
      Basis.s x0 

    (** Returns the orthonormalized version of this basis. An orthonormal basis is both \[i\]orthogonal\[/i\] (the axes are perpendicular to each other) and \[i\]normalized\[/i\] (the axes have a length of \[code\]1.0\[/code\]), which also means it can only represent a rotation.
It is often useful to call this method to avoid rounding errors on a rotating basis:
\[codeblocks\]
\[gdscript\]
# Rotate this Node3D every frame.
func _process(delta):
    basis = basis.rotated(Vector3.UP, TAU  *  delta)
    basis = basis.rotated(Vector3.RIGHT, TAU  *  delta)

    basis = basis.orthonormalized()
\[/gdscript\]
\[csharp\]
// Rotate this Node3D every frame.
public override void _Process(double delta)
\{!
    Basis = Basis.Rotated(Vector3.Up, Mathf.Tau  *  (float)delta)
                 .Rotated(Vector3.Right, Mathf.Tau  *  (float)delta)
                 .Orthonormalized();
\}
\[/csharp\]
\[/codeblocks\] *)
    let orthonormalized x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_BASIS
      "orthonormalized"
      594669093L
      (Basis.typ @-> returning Basis.typ)
      Basis.s x0 

    (** Returns the \[url=https://en.wikipedia.org/wiki/Determinant\]determinant\[/url\] of this basis''s matrix. For advanced math, this number can be used to determine a few attributes:
- If the determinant is exactly \[code\]0.0\[/code\], the basis is not invertible (see \[method inverse\]).
- If the determinant is a negative number, the basis represents a negative scale.
\[b\]Note:\[/b\] If the basis''s scale is the same for every axis, its determinant is always that scale by the power of 2. *)
    let determinant x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_BASIS
      "determinant"
      466405837L
      (Basis.typ @-> returning Float.typ)
      Float.s x0 

    (** Returns a copy of this basis rotated around the given \[param axis\] by the given \[param angle\] (in radians).
The \[param axis\] must be a normalized vector (see \[method Vector3.normalized\]). If \[param angle\] is positive, the basis is rotated counter-clockwise around the axis.
\[codeblocks\]
\[gdscript\]
var my_basis = Basis.IDENTITY
var angle = TAU / 2

my_basis = my_basis.rotated(Vector3.UP, angle)    # Rotate around the up axis (yaw).
my_basis = my_basis.rotated(Vector3.RIGHT, angle) # Rotate around the right axis (pitch).
my_basis = my_basis.rotated(Vector3.BACK, angle)  # Rotate around the back axis (roll).
\[/gdscript\]
\[csharp\]
var myBasis = Basis.Identity;
var angle = Mathf.Tau / 2.0f;

myBasis = myBasis.Rotated(Vector3.Up, angle);    // Rotate around the up axis (yaw).
myBasis = myBasis.Rotated(Vector3.Right, angle); // Rotate around the right axis (pitch).
myBasis = myBasis.Rotated(Vector3.Back, angle);  // Rotate around the back axis (roll).
\[/csharp\]
\[/codeblocks\] *)
    let rotated x0  x1  x2  = 
    foreign_builtin_method2
      GlobalEnum.VariantType._TYPE_BASIS
      "rotated"
      1998708965L
      (Vector3.typ @-> Float.typ @-> Basis.typ @-> returning Basis.typ)
      Basis.s x0  x1  x2 

    (** Returns this basis with each axis''s components scaled by the given \[param scale\]''s components.
The basis matrix''s rows are multiplied by \[param scale\]''s components. This operation is a global scale (relative to the parent).
\[codeblocks\]
\[gdscript\]
var my_basis = Basis(
    Vector3(1, 1, 1),
    Vector3(2, 2, 2),
    Vector3(3, 3, 3)
)
my_basis = my_basis.scaled(Vector3(0, 2, -2))

print(my_basis.x) # Prints (0.0, 2.0, -2.0)
print(my_basis.y) # Prints (0.0, 4.0, -4.0)
print(my_basis.z) # Prints (0.0, 6.0, -6.0)
\[/gdscript\]
\[csharp\]
var myBasis = new Basis(
    new Vector3(1.0f, 1.0f, 1.0f),
    new Vector3(2.0f, 2.0f, 2.0f),
    new Vector3(3.0f, 3.0f, 3.0f)
);
myBasis = myBasis.Scaled(new Vector3(0.0f, 2.0f, -2.0f));

GD.Print(myBasis.X); // Prints (0, 2, -2)
GD.Print(myBasis.Y); // Prints (0, 4, -4)
GD.Print(myBasis.Z); // Prints (0, 6, -6)
\[/csharp\]
\[/codeblocks\] *)
    let scaled x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_BASIS
      "scaled"
      3934786792L
      (Vector3.typ @-> Basis.typ @-> returning Basis.typ)
      Basis.s x0  x1 

    (** Returns the length of each axis of this basis, as a \[Vector3\]. If the basis is not sheared, this value is the scaling factor. It is not affected by rotation.
\[codeblocks\]
\[gdscript\]
var my_basis = Basis(
    Vector3(2, 0, 0),
    Vector3(0, 4, 0),
    Vector3(0, 0, 8)
)
# Rotating the Basis in any way preserves its scale.
my_basis = my_basis.rotated(Vector3.UP, TAU / 2)
my_basis = my_basis.rotated(Vector3.RIGHT, TAU / 4)

print(my_basis.get_scale()) # Prints (2.0, 4.0, 8.0)
\[/gdscript\]
\[csharp\]
var myBasis = new Basis(
    Vector3(2.0f, 0.0f, 0.0f),
    Vector3(0.0f, 4.0f, 0.0f),
    Vector3(0.0f, 0.0f, 8.0f)
);
// Rotating the Basis in any way preserves its scale.
myBasis = myBasis.Rotated(Vector3.Up, Mathf.Tau / 2.0f);
myBasis = myBasis.Rotated(Vector3.Right, Mathf.Tau / 4.0f);

GD.Print(myBasis.Scale); // Prints (2, 4, 8)
\[/csharp\]
\[/codeblocks\]
\[b\]Note:\[/b\] If the value returned by \[method determinant\] is negative, the scale is also negative. *)
    let get_scale x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_BASIS
      "get_scale"
      1776574132L
      (Basis.typ @-> returning Vector3.typ)
      Vector3.s x0 

    (** Returns this basis''s rotation as a \[Vector3\] of \[url=https://en.wikipedia.org/wiki/Euler_angles\]Euler angles\[/url\], in radians. For the returned value:
- The \[member Vector3.x\] contains the angle around the \[member x\] axis (pitch);
- The \[member Vector3.y\] contains the angle around the \[member y\] axis (yaw);
- The \[member Vector3.z\] contains the angle around the \[member z\] axis (roll).
The order of each consecutive rotation can be changed with \[param order\] (see \[enum EulerOrder\] constants). By default, the YXZ convention is used (\[constant EULER_ORDER_YXZ\]): Z (roll) is calculated first, then X (pitch), and lastly Y (yaw). When using the opposite method \[method from_euler\], this order is reversed.
\[b\]Note:\[/b\] For this method to return correctly, the basis needs to be \[i\]orthonormal\[/i\] (see \[method orthonormalized\]).
\[b\]Note:\[/b\] Euler angles are much more intuitive but are not suitable for 3D math. Because of this, consider using the \[method get_rotation_quaternion\] method instead, which returns a \[Quaternion\].
\[b\]Note:\[/b\] In the Inspector dock, a basis''s rotation is often displayed in Euler angles (in degrees), as is the case with the \[member Node3D.rotation\] property. *)
    let get_euler x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_BASIS
      "get_euler"
      1394941017L
      (Int.typ @-> Basis.typ @-> returning Vector3.typ)
      Vector3.s x0  x1 

    (** Returns the transposed dot product between \[param with\] and the \[member x\] axis (see \[method transposed\]).
This is equivalent to \[code\]basis.x.dot(vector)\[/code\]. *)
    let tdotx x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_BASIS
      "tdotx"
      1047977935L
      (Vector3.typ @-> Basis.typ @-> returning Float.typ)
      Float.s x0  x1 

    (** Returns the transposed dot product between \[param with\] and the \[member y\] axis (see \[method transposed\]).
This is equivalent to \[code\]basis.y.dot(vector)\[/code\]. *)
    let tdoty x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_BASIS
      "tdoty"
      1047977935L
      (Vector3.typ @-> Basis.typ @-> returning Float.typ)
      Float.s x0  x1 

    (** Returns the transposed dot product between \[param with\] and the \[member z\] axis (see \[method transposed\]).
This is equivalent to \[code\]basis.z.dot(vector)\[/code\]. *)
    let tdotz x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_BASIS
      "tdotz"
      1047977935L
      (Vector3.typ @-> Basis.typ @-> returning Float.typ)
      Float.s x0  x1 

    (** Performs a spherical-linear interpolation with the \[param to\] basis, given a \[param weight\]. Both this basis and \[param to\] should represent a rotation.
\[b\]Example:\[/b\] Smoothly rotate a \[Node3D\] to the target basis over time, with a \[Tween\]:
\[codeblock\]
var start_basis = Basis.IDENTITY
var target_basis = Basis.IDENTITY.rotated(Vector3.UP, TAU / 2)

func _ready():
    create_tween().tween_method(interpolate, 0.0, 1.0, 5.0).set_trans(Tween.TRANS_EXPO)

func interpolate(weight):
    basis = start_basis.slerp(target_basis, weight)
\[/codeblock\] *)
    let slerp x0  x1  x2  = 
    foreign_builtin_method2
      GlobalEnum.VariantType._TYPE_BASIS
      "slerp"
      3118673011L
      (Basis.typ @-> Float.typ @-> Basis.typ @-> returning Basis.typ)
      Basis.s x0  x1  x2 

    (** Returns \[code\]true\[/code\] if this basis is conformal. A conformal basis is both \[i\]orthogonal\[/i\] (the axes are perpendicular to each other) and \[i\]uniform\[/i\] (the axes share the same length). This method can be especially useful during physics calculations. *)
    let is_conformal x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_BASIS
      "is_conformal"
      3918633141L
      (Basis.typ @-> returning Bool.typ)
      Bool.s x0 

    (** Returns \[code\]true\[/code\] if this basis and \[param b\] are approximately equal, by calling \[method \@GlobalScope.is_equal_approx\] on all vector components. *)
    let is_equal_approx x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_BASIS
      "is_equal_approx"
      3165333982L
      (Basis.typ @-> Basis.typ @-> returning Bool.typ)
      Bool.s x0  x1 

    (** Returns \[code\]true\[/code\] if this basis is finite, by calling \[method \@GlobalScope.is_finite\] on all vector components. *)
    let is_finite x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_BASIS
      "is_finite"
      3918633141L
      (Basis.typ @-> returning Bool.typ)
      Bool.s x0 

    (** Returns this basis''s rotation as a \[Quaternion\].
\[b\]Note:\[/b\] Quaternions are much more suitable for 3D math but are less intuitive. For user interfaces, consider using the \[method get_euler\] method, which returns Euler angles. *)
    let get_rotation_quaternion x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_BASIS
      "get_rotation_quaternion"
      4274879941L
      (Basis.typ @-> returning Quaternion.typ)
      Quaternion.s x0 

    (** Creates a new \[Basis\] with a rotation such that the forward axis (-Z) points towards the \[param target\] position.
By default, the -Z axis (camera forward) is treated as forward (implies +X is right). If \[param use_model_front\] is \[code\]true\[/code\], the +Z axis (asset front) is treated as forward (implies +X is left) and points toward the \[param target\] position.
The up axis (+Y) points as close to the \[param up\] vector as possible while staying perpendicular to the forward axis. The returned basis is orthonormalized (see \[method orthonormalized\]).
The \[param target\] and the \[param up\] cannot be \[constant Vector3.ZERO\], and shouldn''t be colinear to avoid unintended rotation around local Z axis. *)
    let looking_at x0  x1  x2  = 
    foreign_builtin_method3_static
      GlobalEnum.VariantType._TYPE_BASIS
      "looking_at"
      3728732505L
      (Vector3.typ @-> Vector3.typ @-> Bool.typ @-> returning Basis.typ)
      Basis.s x0  x1  x2 

    (** Constructs a new \[Basis\] that only represents scale, with no rotation or shear, from the given \[param scale\] vector.
\[codeblocks\]
\[gdscript\]
var my_basis = Basis.from_scale(Vector3(2, 4, 8))

print(my_basis.x) # Prints (2.0, 0.0, 0.0)
print(my_basis.y) # Prints (0.0, 4.0, 0.0)
print(my_basis.z) # Prints (0.0, 0.0, 8.0)
\[/gdscript\]
\[csharp\]
var myBasis = Basis.FromScale(new Vector3(2.0f, 4.0f, 8.0f));

GD.Print(myBasis.X); // Prints (2, 0, 0)
GD.Print(myBasis.Y); // Prints (0, 4, 0)
GD.Print(myBasis.Z); // Prints (0, 0, 8)
\[/csharp\]
\[/codeblocks\]
\[b\]Note:\[/b\] In linear algebra, the matrix of this basis is also known as a \[url=https://en.wikipedia.org/wiki/Diagonal_matrix\]diagonal matrix\[/url\]. *)
    let from_scale x0  = 
    foreign_builtin_method1_static
      GlobalEnum.VariantType._TYPE_BASIS
      "from_scale"
      3703240166L
      (Vector3.typ @-> returning Basis.typ)
      Basis.s x0 

    (** Constructs a new \[Basis\] that only represents rotation from the given \[Vector3\] of \[url=https://en.wikipedia.org/wiki/Euler_angles\]Euler angles\[/url\], in radians.
- The \[member Vector3.x\] should contain the angle around the \[member x\] axis (pitch);
- The \[member Vector3.y\] should contain the angle around the \[member y\] axis (yaw);
- The \[member Vector3.z\] should contain the angle around the \[member z\] axis (roll).
\[codeblocks\]
\[gdscript\]
# Creates a Basis whose z axis points down.
var my_basis = Basis.from_euler(Vector3(TAU / 4, 0, 0))

print(my_basis.z) # Prints (0.0, -1.0, 0.0)
\[/gdscript\]
\[csharp\]
// Creates a Basis whose z axis points down.
var myBasis = Basis.FromEuler(new Vector3(Mathf.Tau / 4.0f, 0.0f, 0.0f));

GD.Print(myBasis.Z); // Prints (0, -1, 0)
\[/csharp\]
\[/codeblocks\]
The order of each consecutive rotation can be changed with \[param order\] (see \[enum EulerOrder\] constants). By default, the YXZ convention is used (\[constant EULER_ORDER_YXZ\]): the basis rotates first around the Y axis (yaw), then X (pitch), and lastly Z (roll). When using the opposite method \[method get_euler\], this order is reversed. *)
    let from_euler x0  x1  = 
    foreign_builtin_method2_static
      GlobalEnum.VariantType._TYPE_BASIS
      "from_euler"
      2802321791L
      (Vector3.typ @-> Int.typ @-> returning Basis.typ)
      Basis.s x0  x1 






    let not x0  = 
    foreign_builtin_operator1 GlobalEnum.VariantType._TYPE_BASIS None  GlobalEnum.VariantOperator._OP_NOT
      (funptr (Basis.typ @-> Bool.typ @-> returning void))
      Bool.s x0 











    (** Returns \[code\]true\[/code\] if the components of both \[Basis\] matrices are exactly equal.
\[b\]Note:\[/b\] Due to floating-point precision errors, consider using \[method is_equal_approx\] instead, which is more reliable. *)
    let (=) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_BASIS (Some GlobalEnum.VariantType._TYPE_BASIS) GlobalEnum.VariantOperator._OP_EQUAL
      (funptr (Basis.typ @-> Basis.typ @-> Bool.typ @-> returning void))
      Bool.s
      Conv.Basis.of_ocaml
      Conv.Basis.of_ocaml
      Conv.Bool.to_ocaml x0  x1 

    (** Returns \[code\]true\[/code\] if the components of both \[Basis\] matrices are not equal.
\[b\]Note:\[/b\] Due to floating-point precision errors, consider using \[method is_equal_approx\] instead, which is more reliable. *)
    let (<>) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_BASIS (Some GlobalEnum.VariantType._TYPE_BASIS) GlobalEnum.VariantOperator._OP_NOT_EQUAL
      (funptr (Basis.typ @-> Basis.typ @-> Bool.typ @-> returning void))
      Bool.s
      Conv.Basis.of_ocaml
      Conv.Basis.of_ocaml
      Conv.Bool.to_ocaml x0  x1 

    (** Transforms (multiplies) the \[param right\] basis by this basis.
This is the operation performed between parent and child \[Node3D\]s. *)
    let ( * ) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_BASIS (Some GlobalEnum.VariantType._TYPE_BASIS) GlobalEnum.VariantOperator._OP_MULTIPLY
      (funptr (Basis.typ @-> Basis.typ @-> Basis.typ @-> returning void))
      Basis.s
      Conv.Basis.of_ocaml
      Conv.Basis.of_ocaml
      Conv.Basis.to_ocaml x0  x1 


    let mem_Dictionary x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_BASIS (Some GlobalEnum.VariantType._TYPE_DICTIONARY) GlobalEnum.VariantOperator._OP_IN
      (funptr (Basis.typ @-> Dictionary.typ @-> Bool.typ @-> returning void))
      Bool.s x0  x1 


    let mem_Array x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_BASIS (Some GlobalEnum.VariantType._TYPE_ARRAY) GlobalEnum.VariantOperator._OP_IN
      (funptr (Basis.typ @-> Array.typ @-> Bool.typ @-> returning void))
      Bool.s x0  x1 
    end

  module Transform3D = struct
    include M.Transform3D
include BuiltinClass0.Transform3D

    (** Returns the \[url=https://en.wikipedia.org/wiki/Invertible_matrix\]inverted version of this transform\[/url\]. See also \[method Basis.inverse\].
\[b\]Note:\[/b\] For this method to return correctly, the transform''s \[member basis\] needs to be \[i\]orthonormal\[/i\] (see \[method orthonormalized\]). That means the basis should only represent a rotation. If it does not, use \[method affine_inverse\] instead. *)
    let inverse x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_TRANSFORM3D
      "inverse"
      3816817146L
      (Transform3D.typ @-> returning Transform3D.typ)
      Transform3D.s x0 

    (** Returns the inverted version of this transform. Unlike \[method inverse\], this method works with almost any \[member basis\], including non-uniform ones, but is slower. See also \[method Basis.inverse\].
\[b\]Note:\[/b\] For this method to return correctly, the transform''s \[member basis\] needs to have a determinant that is not exactly \[code\]0.0\[/code\] (see \[method Basis.determinant\]). *)
    let affine_inverse x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_TRANSFORM3D
      "affine_inverse"
      3816817146L
      (Transform3D.typ @-> returning Transform3D.typ)
      Transform3D.s x0 

    (** Returns a copy of this transform with its \[member basis\] orthonormalized. An orthonormal basis is both \[i\]orthogonal\[/i\] (the axes are perpendicular to each other) and \[i\]normalized\[/i\] (the axes have a length of \[code\]1.0\[/code\]), which also means it can only represent a rotation. See also \[method Basis.orthonormalized\]. *)
    let orthonormalized x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_TRANSFORM3D
      "orthonormalized"
      3816817146L
      (Transform3D.typ @-> returning Transform3D.typ)
      Transform3D.s x0 

    (** Returns a copy of this transform rotated around the given \[param axis\] by the given \[param angle\] (in radians).
The \[param axis\] must be a normalized vector (see \[method Vector3.normalized\]). If \[param angle\] is positive, the basis is rotated counter-clockwise around the axis.
This method is an optimized version of multiplying the given transform \[code\]X\[/code\] with a corresponding rotation transform \[code\]R\[/code\] from the left, i.e., \[code\]R  *  X\[/code\].
This can be seen as transforming with respect to the global/parent frame. *)
    let rotated x0  x1  x2  = 
    foreign_builtin_method2
      GlobalEnum.VariantType._TYPE_TRANSFORM3D
      "rotated"
      1563203923L
      (Vector3.typ @-> Float.typ @-> Transform3D.typ @-> returning Transform3D.typ)
      Transform3D.s x0  x1  x2 

    (** Returns a copy of this transform rotated around the given \[param axis\] by the given \[param angle\] (in radians).
The \[param axis\] must be a normalized vector in the transform''s local coordinate system. For example, to rotate around the local X-axis, use \[constant Vector3.RIGHT\].
This method is an optimized version of multiplying the given transform \[code\]X\[/code\] with a corresponding rotation transform \[code\]R\[/code\] from the right, i.e., \[code\]X  *  R\[/code\].
This can be seen as transforming with respect to the local frame. *)
    let rotated_local x0  x1  x2  = 
    foreign_builtin_method2
      GlobalEnum.VariantType._TYPE_TRANSFORM3D
      "rotated_local"
      1563203923L
      (Vector3.typ @-> Float.typ @-> Transform3D.typ @-> returning Transform3D.typ)
      Transform3D.s x0  x1  x2 

    (** Returns a copy of this transform scaled by the given \[param scale\] factor.
This method is an optimized version of multiplying the given transform \[code\]X\[/code\] with a corresponding scaling transform \[code\]S\[/code\] from the left, i.e., \[code\]S  *  X\[/code\].
This can be seen as transforming with respect to the global/parent frame. *)
    let scaled x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_TRANSFORM3D
      "scaled"
      1405596198L
      (Vector3.typ @-> Transform3D.typ @-> returning Transform3D.typ)
      Transform3D.s x0  x1 

    (** Returns a copy of this transform scaled by the given \[param scale\] factor.
This method is an optimized version of multiplying the given transform \[code\]X\[/code\] with a corresponding scaling transform \[code\]S\[/code\] from the right, i.e., \[code\]X  *  S\[/code\].
This can be seen as transforming with respect to the local frame. *)
    let scaled_local x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_TRANSFORM3D
      "scaled_local"
      1405596198L
      (Vector3.typ @-> Transform3D.typ @-> returning Transform3D.typ)
      Transform3D.s x0  x1 

    (** Returns a copy of this transform translated by the given \[param offset\].
This method is an optimized version of multiplying the given transform \[code\]X\[/code\] with a corresponding translation transform \[code\]T\[/code\] from the left, i.e., \[code\]T  *  X\[/code\].
This can be seen as transforming with respect to the global/parent frame. *)
    let translated x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_TRANSFORM3D
      "translated"
      1405596198L
      (Vector3.typ @-> Transform3D.typ @-> returning Transform3D.typ)
      Transform3D.s x0  x1 

    (** Returns a copy of this transform translated by the given \[param offset\].
This method is an optimized version of multiplying the given transform \[code\]X\[/code\] with a corresponding translation transform \[code\]T\[/code\] from the right, i.e., \[code\]X  *  T\[/code\].
This can be seen as transforming with respect to the local frame. *)
    let translated_local x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_TRANSFORM3D
      "translated_local"
      1405596198L
      (Vector3.typ @-> Transform3D.typ @-> returning Transform3D.typ)
      Transform3D.s x0  x1 

    (** Returns a copy of this transform rotated so that the forward axis (-Z) points towards the \[param target\] position.
The up axis (+Y) points as close to the \[param up\] vector as possible while staying perpendicular to the forward axis. The resulting transform is orthonormalized. The existing rotation, scale, and skew information from the original transform is discarded. The \[param target\] and \[param up\] vectors cannot be zero, cannot be parallel to each other, and are defined in global/parent space.
If \[param use_model_front\] is \[code\]true\[/code\], the +Z axis (asset front) is treated as forward (implies +X is left) and points toward the \[param target\] position. By default, the -Z axis (camera forward) is treated as forward (implies +X is right). *)
    let looking_at x0  x1  x2  x3  = 
    foreign_builtin_method3
      GlobalEnum.VariantType._TYPE_TRANSFORM3D
      "looking_at"
      90889270L
      (Vector3.typ @-> Vector3.typ @-> Bool.typ @-> Transform3D.typ @-> returning Transform3D.typ)
      Transform3D.s x0  x1  x2  x3 

    (** Returns the result of the linear interpolation between this transform and \[param xform\] by the given \[param weight\].
The \[param weight\] should be between \[code\]0.0\[/code\] and \[code\]1.0\[/code\] (inclusive). Values outside this range are allowed and can be used to perform \[i\]extrapolation\[/i\] instead. *)
    let interpolate_with x0  x1  x2  = 
    foreign_builtin_method2
      GlobalEnum.VariantType._TYPE_TRANSFORM3D
      "interpolate_with"
      1786453358L
      (Transform3D.typ @-> Float.typ @-> Transform3D.typ @-> returning Transform3D.typ)
      Transform3D.s x0  x1  x2 

    (** Returns \[code\]true\[/code\] if this transform and \[param xform\] are approximately equal, by running \[method \@GlobalScope.is_equal_approx\] on each component. *)
    let is_equal_approx x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_TRANSFORM3D
      "is_equal_approx"
      696001652L
      (Transform3D.typ @-> Transform3D.typ @-> returning Bool.typ)
      Bool.s x0  x1 

    (** Returns \[code\]true\[/code\] if this transform is finite, by calling \[method \@GlobalScope.is_finite\] on each component. *)
    let is_finite x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_TRANSFORM3D
      "is_finite"
      3918633141L
      (Transform3D.typ @-> returning Bool.typ)
      Bool.s x0 






    let not x0  = 
    foreign_builtin_operator1 GlobalEnum.VariantType._TYPE_TRANSFORM3D None  GlobalEnum.VariantOperator._OP_NOT
      (funptr (Transform3D.typ @-> Bool.typ @-> returning void))
      Bool.s x0 















    (** Returns \[code\]true\[/code\] if the components of both transforms are exactly equal.
\[b\]Note:\[/b\] Due to floating-point precision errors, consider using \[method is_equal_approx\] instead, which is more reliable. *)
    let (=) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_TRANSFORM3D (Some GlobalEnum.VariantType._TYPE_TRANSFORM3D) GlobalEnum.VariantOperator._OP_EQUAL
      (funptr (Transform3D.typ @-> Transform3D.typ @-> Bool.typ @-> returning void))
      Bool.s
      Conv.Transform3D.of_ocaml
      Conv.Transform3D.of_ocaml
      Conv.Bool.to_ocaml x0  x1 

    (** Returns \[code\]true\[/code\] if the components of both transforms are not equal.
\[b\]Note:\[/b\] Due to floating-point precision errors, consider using \[method is_equal_approx\] instead, which is more reliable. *)
    let (<>) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_TRANSFORM3D (Some GlobalEnum.VariantType._TYPE_TRANSFORM3D) GlobalEnum.VariantOperator._OP_NOT_EQUAL
      (funptr (Transform3D.typ @-> Transform3D.typ @-> Bool.typ @-> returning void))
      Bool.s
      Conv.Transform3D.of_ocaml
      Conv.Transform3D.of_ocaml
      Conv.Bool.to_ocaml x0  x1 

    (** Transforms (multiplies) this transform by the \[param right\] transform.
This is the operation performed between parent and child \[Node3D\]s.
\[b\]Note:\[/b\] If you need to only modify one attribute of this transform, consider using one of the following methods, instead:
- For translation, see \[method translated\] or \[method translated_local\].
- For rotation, see \[method rotated\] or \[method rotated_local\].
- For scale, see \[method scaled\] or \[method scaled_local\]. *)
    let ( * ) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_TRANSFORM3D (Some GlobalEnum.VariantType._TYPE_TRANSFORM3D) GlobalEnum.VariantOperator._OP_MULTIPLY
      (funptr (Transform3D.typ @-> Transform3D.typ @-> Transform3D.typ @-> returning void))
      Transform3D.s
      Conv.Transform3D.of_ocaml
      Conv.Transform3D.of_ocaml
      Conv.Transform3D.to_ocaml x0  x1 


    let mem_Dictionary x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_TRANSFORM3D (Some GlobalEnum.VariantType._TYPE_DICTIONARY) GlobalEnum.VariantOperator._OP_IN
      (funptr (Transform3D.typ @-> Dictionary.typ @-> Bool.typ @-> returning void))
      Bool.s x0  x1 


    let mem_Array x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_TRANSFORM3D (Some GlobalEnum.VariantType._TYPE_ARRAY) GlobalEnum.VariantOperator._OP_IN
      (funptr (Transform3D.typ @-> Array.typ @-> Bool.typ @-> returning void))
      Bool.s x0  x1 


    end

  module Projection = struct
    include M.Projection
include BuiltinClass0.Projection

    (** Creates a new \[Projection\] that projects positions from a depth range of \[code\]-1\[/code\] to \[code\]1\[/code\] to one that ranges from \[code\]0\[/code\] to \[code\]1\[/code\], and flips the projected positions vertically, according to \[param flip_y\]. *)
    let create_depth_correction x0  = 
    foreign_builtin_method1_static
      GlobalEnum.VariantType._TYPE_PROJECTION
      "create_depth_correction"
      1228516048L
      (Bool.typ @-> returning Projection.typ)
      Projection.s x0 

    (** Creates a new \[Projection\] that projects positions into the given \[Rect2\]. *)
    let create_light_atlas_rect x0  = 
    foreign_builtin_method1_static
      GlobalEnum.VariantType._TYPE_PROJECTION
      "create_light_atlas_rect"
      2654950662L
      (Rect2.typ @-> returning Projection.typ)
      Projection.s x0 

    (** Creates a new \[Projection\] that projects positions using a perspective projection with the given Y-axis field of view (in degrees), X:Y aspect ratio, and clipping planes.
\[param flip_fov\] determines whether the projection''s field of view is flipped over its diagonal. *)
    let create_perspective x0  x1  x2  x3  x4  = 
    foreign_builtin_method5_static
      GlobalEnum.VariantType._TYPE_PROJECTION
      "create_perspective"
      390915442L
      (Float.typ @-> Float.typ @-> Float.typ @-> Float.typ @-> Bool.typ @-> returning Projection.typ)
      Projection.s x0  x1  x2  x3  x4 

    (** Creates a new \[Projection\] that projects positions using a perspective projection with the given Y-axis field of view (in degrees), X:Y aspect ratio, and clipping distances. The projection is adjusted for a head-mounted display with the given distance between eyes and distance to a point that can be focused on.
\[param eye\] creates the projection for the left eye when set to 1, or the right eye when set to 2.
\[param flip_fov\] determines whether the projection''s field of view is flipped over its diagonal. *)
    let create_perspective_hmd x0  x1  x2  x3  x4  x5  x6  x7  = 
    foreign_builtin_method8_static
      GlobalEnum.VariantType._TYPE_PROJECTION
      "create_perspective_hmd"
      2857674800L
      (Float.typ @-> Float.typ @-> Float.typ @-> Float.typ @-> Bool.typ @-> Int.typ @-> Float.typ @-> Float.typ @-> returning Projection.typ)
      Projection.s x0  x1  x2  x3  x4  x5  x6  x7 

    (** Creates a new \[Projection\] for projecting positions onto a head-mounted display with the given X:Y aspect ratio, distance between eyes, display width, distance to lens, oversampling factor, and depth clipping planes.
\[param eye\] creates the projection for the left eye when set to 1, or the right eye when set to 2. *)
    let create_for_hmd x0  x1  x2  x3  x4  x5  x6  x7  = 
    foreign_builtin_method8_static
      GlobalEnum.VariantType._TYPE_PROJECTION
      "create_for_hmd"
      4184144994L
      (Int.typ @-> Float.typ @-> Float.typ @-> Float.typ @-> Float.typ @-> Float.typ @-> Float.typ @-> Float.typ @-> returning Projection.typ)
      Projection.s x0  x1  x2  x3  x4  x5  x6  x7 

    (** Creates a new \[Projection\] that projects positions using an orthogonal projection with the given clipping planes. *)
    let create_orthogonal x0  x1  x2  x3  x4  x5  = 
    foreign_builtin_method6_static
      GlobalEnum.VariantType._TYPE_PROJECTION
      "create_orthogonal"
      3707929169L
      (Float.typ @-> Float.typ @-> Float.typ @-> Float.typ @-> Float.typ @-> Float.typ @-> returning Projection.typ)
      Projection.s x0  x1  x2  x3  x4  x5 

    (** Creates a new \[Projection\] that projects positions using an orthogonal projection with the given size, X:Y aspect ratio, and clipping planes.
\[param flip_fov\] determines whether the projection''s field of view is flipped over its diagonal. *)
    let create_orthogonal_aspect x0  x1  x2  x3  x4  = 
    foreign_builtin_method5_static
      GlobalEnum.VariantType._TYPE_PROJECTION
      "create_orthogonal_aspect"
      390915442L
      (Float.typ @-> Float.typ @-> Float.typ @-> Float.typ @-> Bool.typ @-> returning Projection.typ)
      Projection.s x0  x1  x2  x3  x4 

    (** Creates a new \[Projection\] that projects positions in a frustum with the given clipping planes. *)
    let create_frustum x0  x1  x2  x3  x4  x5  = 
    foreign_builtin_method6_static
      GlobalEnum.VariantType._TYPE_PROJECTION
      "create_frustum"
      3707929169L
      (Float.typ @-> Float.typ @-> Float.typ @-> Float.typ @-> Float.typ @-> Float.typ @-> returning Projection.typ)
      Projection.s x0  x1  x2  x3  x4  x5 

    (** Creates a new \[Projection\] that projects positions in a frustum with the given size, X:Y aspect ratio, offset, and clipping planes.
\[param flip_fov\] determines whether the projection''s field of view is flipped over its diagonal. *)
    let create_frustum_aspect x0  x1  x2  x3  x4  x5  = 
    foreign_builtin_method6_static
      GlobalEnum.VariantType._TYPE_PROJECTION
      "create_frustum_aspect"
      1535076251L
      (Float.typ @-> Float.typ @-> Vector2.typ @-> Float.typ @-> Float.typ @-> Bool.typ @-> returning Projection.typ)
      Projection.s x0  x1  x2  x3  x4  x5 

    (** Creates a new \[Projection\] that scales a given projection to fit around a given \[AABB\] in projection space. *)
    let create_fit_aabb x0  = 
    foreign_builtin_method1_static
      GlobalEnum.VariantType._TYPE_PROJECTION
      "create_fit_aabb"
      2264694907L
      (AABB.typ @-> returning Projection.typ)
      Projection.s x0 

    (** Returns a scalar value that is the signed factor by which areas are scaled by this matrix. If the sign is negative, the matrix flips the orientation of the area.
The determinant can be used to calculate the invertibility of a matrix or solve linear systems of equations involving the matrix, among other applications. *)
    let determinant x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_PROJECTION
      "determinant"
      466405837L
      (Projection.typ @-> returning Float.typ)
      Float.s x0 

    (** Returns a \[Projection\] with the near clipping distance adjusted to be \[param new_znear\].
\[b\]Note:\[/b\] The original \[Projection\] must be a perspective projection. *)
    let perspective_znear_adjusted x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_PROJECTION
      "perspective_znear_adjusted"
      3584785443L
      (Float.typ @-> Projection.typ @-> returning Projection.typ)
      Projection.s x0  x1 

    (** Returns the clipping plane of this \[Projection\] whose index is given by \[param plane\].
\[param plane\] should be equal to one of \[constant PLANE_NEAR\], \[constant PLANE_FAR\], \[constant PLANE_LEFT\], \[constant PLANE_TOP\], \[constant PLANE_RIGHT\], or \[constant PLANE_BOTTOM\]. *)
    let get_projection_plane x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_PROJECTION
      "get_projection_plane"
      1551184160L
      (Int.typ @-> Projection.typ @-> returning Plane.typ)
      Plane.s x0  x1 

    (** Returns a copy of this \[Projection\] with the signs of the values of the Y column flipped. *)
    let flipped_y x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_PROJECTION
      "flipped_y"
      4212530932L
      (Projection.typ @-> returning Projection.typ)
      Projection.s x0 

    (** Returns a \[Projection\] with the X and Y values from the given \[Vector2\] added to the first and second values of the final column respectively. *)
    let jitter_offseted x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_PROJECTION
      "jitter_offseted"
      2448438599L
      (Vector2.typ @-> Projection.typ @-> returning Projection.typ)
      Projection.s x0  x1 

    (** Returns the vertical field of view of the projection (in degrees) associated with the given horizontal field of view (in degrees) and aspect ratio.
\[b\]Note:\[/b\] Unlike most methods of \[Projection\], \[param aspect\] is expected to be 1 divided by the X:Y aspect ratio. *)
    let get_fovy x0  x1  = 
    foreign_builtin_method2_static
      GlobalEnum.VariantType._TYPE_PROJECTION
      "get_fovy"
      3514207532L
      (Float.typ @-> Float.typ @-> returning Float.typ)
      Float.s x0  x1 

    (** Returns the distance for this \[Projection\] beyond which positions are clipped. *)
    let get_z_far x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_PROJECTION
      "get_z_far"
      466405837L
      (Projection.typ @-> returning Float.typ)
      Float.s x0 

    (** Returns the distance for this \[Projection\] before which positions are clipped. *)
    let get_z_near x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_PROJECTION
      "get_z_near"
      466405837L
      (Projection.typ @-> returning Float.typ)
      Float.s x0 

    (** Returns the X:Y aspect ratio of this \[Projection\]''s viewport. *)
    let get_aspect x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_PROJECTION
      "get_aspect"
      466405837L
      (Projection.typ @-> returning Float.typ)
      Float.s x0 

    (** Returns the horizontal field of view of the projection (in degrees). *)
    let get_fov x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_PROJECTION
      "get_fov"
      466405837L
      (Projection.typ @-> returning Float.typ)
      Float.s x0 

    (** Returns \[code\]true\[/code\] if this \[Projection\] performs an orthogonal projection. *)
    let is_orthogonal x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_PROJECTION
      "is_orthogonal"
      3918633141L
      (Projection.typ @-> returning Bool.typ)
      Bool.s x0 

    (** Returns the dimensions of the viewport plane that this \[Projection\] projects positions onto, divided by two. *)
    let get_viewport_half_extents x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_PROJECTION
      "get_viewport_half_extents"
      2428350749L
      (Projection.typ @-> returning Vector2.typ)
      Vector2.s x0 

    (** Returns the dimensions of the far clipping plane of the projection, divided by two. *)
    let get_far_plane_half_extents x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_PROJECTION
      "get_far_plane_half_extents"
      2428350749L
      (Projection.typ @-> returning Vector2.typ)
      Vector2.s x0 

    (** Returns a \[Projection\] that performs the inverse of this \[Projection\]''s projective transformation. *)
    let inverse x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_PROJECTION
      "inverse"
      4212530932L
      (Projection.typ @-> returning Projection.typ)
      Projection.s x0 

    (** Returns the number of pixels with the given pixel width displayed per meter, after this \[Projection\] is applied. *)
    let get_pixels_per_meter x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_PROJECTION
      "get_pixels_per_meter"
      4103005248L
      (Int.typ @-> Projection.typ @-> returning Int.typ)
      Int.s x0  x1 

    (** Returns the factor by which the visible level of detail is scaled by this \[Projection\]. *)
    let get_lod_multiplier x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_PROJECTION
      "get_lod_multiplier"
      466405837L
      (Projection.typ @-> returning Float.typ)
      Float.s x0 






    let not x0  = 
    foreign_builtin_operator1 GlobalEnum.VariantType._TYPE_PROJECTION None  GlobalEnum.VariantOperator._OP_NOT
      (funptr (Projection.typ @-> Bool.typ @-> returning void))
      Bool.s x0 



    (** Returns \[code\]true\[/code\] if the projections are equal.
\[b\]Note:\[/b\] Due to floating-point precision errors, this may return \[code\]false\[/code\], even if the projections are virtually equal. An \[code\]is_equal_approx\[/code\] method may be added in a future version of Godot. *)
    let (=) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_PROJECTION (Some GlobalEnum.VariantType._TYPE_PROJECTION) GlobalEnum.VariantOperator._OP_EQUAL
      (funptr (Projection.typ @-> Projection.typ @-> Bool.typ @-> returning void))
      Bool.s
      Conv.Projection.of_ocaml
      Conv.Projection.of_ocaml
      Conv.Bool.to_ocaml x0  x1 

    (** Returns \[code\]true\[/code\] if the projections are not equal.
\[b\]Note:\[/b\] Due to floating-point precision errors, this may return \[code\]true\[/code\], even if the projections are virtually equal. An \[code\]is_equal_approx\[/code\] method may be added in a future version of Godot. *)
    let (<>) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_PROJECTION (Some GlobalEnum.VariantType._TYPE_PROJECTION) GlobalEnum.VariantOperator._OP_NOT_EQUAL
      (funptr (Projection.typ @-> Projection.typ @-> Bool.typ @-> returning void))
      Bool.s
      Conv.Projection.of_ocaml
      Conv.Projection.of_ocaml
      Conv.Bool.to_ocaml x0  x1 

    (** Returns a \[Projection\] that applies the combined transformations of this \[Projection\] and \[param right\]. *)
    let ( * ) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_PROJECTION (Some GlobalEnum.VariantType._TYPE_PROJECTION) GlobalEnum.VariantOperator._OP_MULTIPLY
      (funptr (Projection.typ @-> Projection.typ @-> Projection.typ @-> returning void))
      Projection.s
      Conv.Projection.of_ocaml
      Conv.Projection.of_ocaml
      Conv.Projection.to_ocaml x0  x1 


    let mem_Dictionary x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_PROJECTION (Some GlobalEnum.VariantType._TYPE_DICTIONARY) GlobalEnum.VariantOperator._OP_IN
      (funptr (Projection.typ @-> Dictionary.typ @-> Bool.typ @-> returning void))
      Bool.s x0  x1 


    let mem_Array x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_PROJECTION (Some GlobalEnum.VariantType._TYPE_ARRAY) GlobalEnum.VariantOperator._OP_IN
      (funptr (Projection.typ @-> Array.typ @-> Bool.typ @-> returning void))
      Bool.s x0  x1 

    module Planes = struct
      type t = Int.t

      let typ = 
      Int.typ

      (** The index value of the projection''s near clipping plane. *)
      let _PLANE_NEAR = 
      0

      (** The index value of the projection''s far clipping plane. *)
      let _PLANE_FAR = 
      1

      (** The index value of the projection''s left clipping plane. *)
      let _PLANE_LEFT = 
      2

      (** The index value of the projection''s top clipping plane. *)
      let _PLANE_TOP = 
      3

      (** The index value of the projection''s right clipping plane. *)
      let _PLANE_RIGHT = 
      4

      (** The index value of the projection bottom clipping plane. *)
      let _PLANE_BOTTOM = 
      5
      end
    end

  module Color = struct
    include M.Color
include BuiltinClass0.Color

    (** Returns the color converted to a 32-bit integer in ARGB format (each component is 8 bits). ARGB is more compatible with DirectX.
\[codeblocks\]
\[gdscript\]
var color = Color(1, 0.5, 0.2)
print(color.to_argb32()) # Prints 4294934323
\[/gdscript\]
\[csharp\]
var color = new Color(1.0f, 0.5f, 0.2f);
GD.Print(color.ToArgb32()); // Prints 4294934323
\[/csharp\]
\[/codeblocks\] *)
    let to_argb32 x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_COLOR
      "to_argb32"
      3173160232L
      (Color.typ @-> returning Int.typ)
      Int.s x0 

    (** Returns the color converted to a 32-bit integer in ABGR format (each component is 8 bits). ABGR is the reversed version of the default RGBA format.
\[codeblocks\]
\[gdscript\]
var color = Color(1, 0.5, 0.2)
print(color.to_abgr32()) # Prints 4281565439
\[/gdscript\]
\[csharp\]
var color = new Color(1.0f, 0.5f, 0.2f);
GD.Print(color.ToAbgr32()); // Prints 4281565439
\[/csharp\]
\[/codeblocks\] *)
    let to_abgr32 x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_COLOR
      "to_abgr32"
      3173160232L
      (Color.typ @-> returning Int.typ)
      Int.s x0 

    (** Returns the color converted to a 32-bit integer in RGBA format (each component is 8 bits). RGBA is Godot''s default format. This method is the inverse of \[method hex\].
\[codeblocks\]
\[gdscript\]
var color = Color(1, 0.5, 0.2)
print(color.to_rgba32()) # Prints 4286526463
\[/gdscript\]
\[csharp\]
var color = new Color(1, 0.5f, 0.2f);
GD.Print(color.ToRgba32()); // Prints 4286526463
\[/csharp\]
\[/codeblocks\] *)
    let to_rgba32 x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_COLOR
      "to_rgba32"
      3173160232L
      (Color.typ @-> returning Int.typ)
      Int.s x0 

    (** Returns the color converted to a 64-bit integer in ARGB format (each component is 16 bits). ARGB is more compatible with DirectX.
\[codeblocks\]
\[gdscript\]
var color = Color(1, 0.5, 0.2)
print(color.to_argb64()) # Prints -2147470541
\[/gdscript\]
\[csharp\]
var color = new Color(1.0f, 0.5f, 0.2f);
GD.Print(color.ToArgb64()); // Prints -2147470541
\[/csharp\]
\[/codeblocks\] *)
    let to_argb64 x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_COLOR
      "to_argb64"
      3173160232L
      (Color.typ @-> returning Int.typ)
      Int.s x0 

    (** Returns the color converted to a 64-bit integer in ABGR format (each component is 16 bits). ABGR is the reversed version of the default RGBA format.
\[codeblocks\]
\[gdscript\]
var color = Color(1, 0.5, 0.2)
print(color.to_abgr64()) # Prints -225178692812801
\[/gdscript\]
\[csharp\]
var color = new Color(1.0f, 0.5f, 0.2f);
GD.Print(color.ToAbgr64()); // Prints -225178692812801
\[/csharp\]
\[/codeblocks\] *)
    let to_abgr64 x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_COLOR
      "to_abgr64"
      3173160232L
      (Color.typ @-> returning Int.typ)
      Int.s x0 

    (** Returns the color converted to a 64-bit integer in RGBA format (each component is 16 bits). RGBA is Godot''s default format. This method is the inverse of \[method hex64\].
\[codeblocks\]
\[gdscript\]
var color = Color(1, 0.5, 0.2)
print(color.to_rgba64()) # Prints -140736629309441
\[/gdscript\]
\[csharp\]
var color = new Color(1, 0.5f, 0.2f);
GD.Print(color.ToRgba64()); // Prints -140736629309441
\[/csharp\]
\[/codeblocks\] *)
    let to_rgba64 x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_COLOR
      "to_rgba64"
      3173160232L
      (Color.typ @-> returning Int.typ)
      Int.s x0 

    (** Returns the color converted to an HTML hexadecimal color \[String\] in RGBA format, without the hash (\[code\]#\[/code\]) prefix.
Setting \[param with_alpha\] to \[code\]false\[/code\], excludes alpha from the hexadecimal string, using RGB format instead of RGBA format.
\[codeblocks\]
\[gdscript\]
var white = Color(1, 1, 1, 0.5)
var with_alpha = white.to_html() # Returns ""ffffff7f""
var without_alpha = white.to_html(false) # Returns ""ffffff""
\[/gdscript\]
\[csharp\]
var white = new Color(1, 1, 1, 0.5f);
string withAlpha = white.ToHtml(); // Returns ""ffffff7f""
string withoutAlpha = white.ToHtml(false); // Returns ""ffffff""
\[/csharp\]
\[/codeblocks\] *)
    let to_html x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_COLOR
      "to_html"
      3429816538L
      (Bool.typ @-> Color.typ @-> returning String.typ)
      String.s x0  x1 

    (** Returns a new color with all components clamped between the components of \[param min\] and \[param max\], by running \[method \@GlobalScope.clamp\] on each component. *)
    let clamp x0  x1  x2  = 
    foreign_builtin_method2
      GlobalEnum.VariantType._TYPE_COLOR
      "clamp"
      105651410L
      (Color.typ @-> Color.typ @-> Color.typ @-> returning Color.typ)
      Color.s x0  x1  x2 

    (** Returns the color with its \[member r\], \[member g\], and \[member b\] components inverted (\[code\](1 - r, 1 - g, 1 - b, a)\[/code\]).
\[codeblocks\]
\[gdscript\]
var black = Color.WHITE.inverted()
var color = Color(0.3, 0.4, 0.9)
var inverted_color = color.inverted() # Equivalent to `Color(0.7, 0.6, 0.1)`
\[/gdscript\]
\[csharp\]
var black = Colors.White.Inverted();
var color = new Color(0.3f, 0.4f, 0.9f);
Color invertedColor = color.Inverted(); // Equivalent to `new Color(0.7f, 0.6f, 0.1f)`
\[/csharp\]
\[/codeblocks\] *)
    let inverted x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_COLOR
      "inverted"
      3334027602L
      (Color.typ @-> returning Color.typ)
      Color.s x0 

    (** Returns the linear interpolation between this color''s components and \[param to\]''s components. The interpolation factor \[param weight\] should be between 0.0 and 1.0 (inclusive). See also \[method \@GlobalScope.lerp\].
\[codeblocks\]
\[gdscript\]
var red = Color(1.0, 0.0, 0.0)
var aqua = Color(0.0, 1.0, 0.8)

red.lerp(aqua, 0.2) # Returns Color(0.8, 0.2, 0.16)
red.lerp(aqua, 0.5) # Returns Color(0.5, 0.5, 0.4)
red.lerp(aqua, 1.0) # Returns Color(0.0, 1.0, 0.8)
\[/gdscript\]
\[csharp\]
var red = new Color(1.0f, 0.0f, 0.0f);
var aqua = new Color(0.0f, 1.0f, 0.8f);

red.Lerp(aqua, 0.2f); // Returns Color(0.8f, 0.2f, 0.16f)
red.Lerp(aqua, 0.5f); // Returns Color(0.5f, 0.5f, 0.4f)
red.Lerp(aqua, 1.0f); // Returns Color(0.0f, 1.0f, 0.8f)
\[/csharp\]
\[/codeblocks\] *)
    let lerp x0  x1  x2  = 
    foreign_builtin_method2
      GlobalEnum.VariantType._TYPE_COLOR
      "lerp"
      402949615L
      (Color.typ @-> Float.typ @-> Color.typ @-> returning Color.typ)
      Color.s x0  x1  x2 

    (** Returns a new color resulting from making this color lighter by the specified \[param amount\], which should be a ratio from 0.0 to 1.0. See also \[method darkened\].
\[codeblocks\]
\[gdscript\]
var green = Color(0.0, 1.0, 0.0)
var light_green = green.lightened(0.2) # 20% lighter than regular green
\[/gdscript\]
\[csharp\]
var green = new Color(0.0f, 1.0f, 0.0f);
Color lightGreen = green.Lightened(0.2f); // 20% lighter than regular green
\[/csharp\]
\[/codeblocks\] *)
    let lightened x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_COLOR
      "lightened"
      1466039168L
      (Float.typ @-> Color.typ @-> returning Color.typ)
      Color.s x0  x1 

    (** Returns a new color resulting from making this color darker by the specified \[param amount\] (ratio from 0.0 to 1.0). See also \[method lightened\].
\[codeblocks\]
\[gdscript\]
var green = Color(0.0, 1.0, 0.0)
var darkgreen = green.darkened(0.2) # 20% darker than regular green
\[/gdscript\]
\[csharp\]
var green = new Color(0.0f, 1.0f, 0.0f);
Color darkgreen = green.Darkened(0.2f); // 20% darker than regular green
\[/csharp\]
\[/codeblocks\] *)
    let darkened x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_COLOR
      "darkened"
      1466039168L
      (Float.typ @-> Color.typ @-> returning Color.typ)
      Color.s x0  x1 

    (** Returns a new color resulting from overlaying this color over the given color. In a painting program, you can imagine it as the \[param over\] color painted over this color (including alpha).
\[codeblocks\]
\[gdscript\]
var bg = Color(0.0, 1.0, 0.0, 0.5) # Green with alpha of 50%
var fg = Color(1.0, 0.0, 0.0, 0.5) # Red with alpha of 50%
var blended_color = bg.blend(fg) # Brown with alpha of 75%
\[/gdscript\]
\[csharp\]
var bg = new Color(0.0f, 1.0f, 0.0f, 0.5f); // Green with alpha of 50%
var fg = new Color(1.0f, 0.0f, 0.0f, 0.5f); // Red with alpha of 50%
Color blendedColor = bg.Blend(fg); // Brown with alpha of 75%
\[/csharp\]
\[/codeblocks\] *)
    let blend x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_COLOR
      "blend"
      3803690977L
      (Color.typ @-> Color.typ @-> returning Color.typ)
      Color.s x0  x1 

    (** Returns the light intensity of the color, as a value between 0.0 and 1.0 (inclusive). This is useful when determining light or dark color. Colors with a luminance smaller than 0.5 can be generally considered dark.
\[b\]Note:\[/b\] \[method get_luminance\] relies on the color being in the linear color space to return an accurate relative luminance value. If the color is in the sRGB color space, use \[method srgb_to_linear\] to convert it to the linear color space first. *)
    let get_luminance x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_COLOR
      "get_luminance"
      466405837L
      (Color.typ @-> returning Float.typ)
      Float.s x0 

    (** Returns the color converted to the linear color space. This method assumes the original color already is in the sRGB color space. See also \[method linear_to_srgb\] which performs the opposite operation. *)
    let srgb_to_linear x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_COLOR
      "srgb_to_linear"
      3334027602L
      (Color.typ @-> returning Color.typ)
      Color.s x0 

    (** Returns the color converted to the \[url=https://en.wikipedia.org/wiki/SRGB\]sRGB\[/url\] color space. This method assumes the original color is in the linear color space. See also \[method srgb_to_linear\] which performs the opposite operation. *)
    let linear_to_srgb x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_COLOR
      "linear_to_srgb"
      3334027602L
      (Color.typ @-> returning Color.typ)
      Color.s x0 

    (** Returns \[code\]true\[/code\] if this color and \[param to\] are approximately equal, by running \[method \@GlobalScope.is_equal_approx\] on each component. *)
    let is_equal_approx x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_COLOR
      "is_equal_approx"
      3167426256L
      (Color.typ @-> Color.typ @-> returning Bool.typ)
      Bool.s x0  x1 

    (** Returns the \[Color\] associated with the provided \[param hex\] integer in 32-bit RGBA format (8 bits per channel). This method is the inverse of \[method to_rgba32\].
In GDScript and C#, the \[int\] is best visualized with hexadecimal notation (\[code\]""0x""\[/code\] prefix, making it \[code\]""0xRRGGBBAA""\[/code\]).
\[codeblocks\]
\[gdscript\]
var red = Color.hex(0xff0000ff)
var dark_cyan = Color.hex(0x008b8bff)
var my_color = Color.hex(0xbbefd2a4)
\[/gdscript\]
\[csharp\]
var red = new Color(0xff0000ff);
var dark_cyan = new Color(0x008b8bff);
var my_color = new Color(0xbbefd2a4);
\[/csharp\]
\[/codeblocks\]
If you want to use hex notation in a constant expression, use the equivalent constructor instead (i.e. \[code\]Color(0xRRGGBBAA)\[/code\]). *)
    let hex x0  = 
    foreign_builtin_method1_static
      GlobalEnum.VariantType._TYPE_COLOR
      "hex"
      351421375L
      (Int.typ @-> returning Color.typ)
      Color.s x0 

    (** Returns the \[Color\] associated with the provided \[param hex\] integer in 64-bit RGBA format (16 bits per channel). This method is the inverse of \[method to_rgba64\].
In GDScript and C#, the \[int\] is best visualized with hexadecimal notation (\[code\]""0x""\[/code\] prefix, making it \[code\]""0xRRRRGGGGBBBBAAAA""\[/code\]). *)
    let hex64 x0  = 
    foreign_builtin_method1_static
      GlobalEnum.VariantType._TYPE_COLOR
      "hex64"
      351421375L
      (Int.typ @-> returning Color.typ)
      Color.s x0 

    (** Returns a new color from \[param rgba\], an HTML hexadecimal color string. \[param rgba\] is not case-sensitive, and may be prefixed by a hash sign (\[code\]#\[/code\]).
\[param rgba\] must be a valid three-digit or six-digit hexadecimal color string, and may contain an alpha channel value. If \[param rgba\] does not contain an alpha channel value, an alpha channel value of 1.0 is applied. If \[param rgba\] is invalid, returns an empty color.
\[codeblocks\]
\[gdscript\]
var blue = Color.html(""#0000ff"") # blue is Color(0.0, 0.0, 1.0, 1.0)
var green = Color.html(""#0F0"")   # green is Color(0.0, 1.0, 0.0, 1.0)
var col = Color.html(""663399cc"") # col is Color(0.4, 0.2, 0.6, 0.8)
\[/gdscript\]
\[csharp\]
var blue = Color.FromHtml(""#0000ff""); // blue is Color(0.0, 0.0, 1.0, 1.0)
var green = Color.FromHtml(""#0F0"");   // green is Color(0.0, 1.0, 0.0, 1.0)
var col = Color.FromHtml(""663399cc""); // col is Color(0.4, 0.2, 0.6, 0.8)
\[/csharp\]
\[/codeblocks\] *)
    let html x0  = 
    foreign_builtin_method1_static
      GlobalEnum.VariantType._TYPE_COLOR
      "html"
      2500054655L
      (String.typ @-> returning Color.typ)
      Color.s x0 

    (** Returns \[code\]true\[/code\] if \[param color\] is a valid HTML hexadecimal color string. The string must be a hexadecimal value (case-insensitive) of either 3, 4, 6 or 8 digits, and may be prefixed by a hash sign (\[code\]#\[/code\]). This method is identical to \[method String.is_valid_html_color\].
\[codeblocks\]
\[gdscript\]
Color.html_is_valid(""#55aaFF"")   # Returns true
Color.html_is_valid(""#55AAFF20"") # Returns true
Color.html_is_valid(""55AAFF"")    # Returns true
Color.html_is_valid(""#F2C"")      # Returns true

Color.html_is_valid(""#AABBC"")    # Returns false
Color.html_is_valid(""#55aaFF5"")  # Returns false
\[/gdscript\]
\[csharp\]
Color.HtmlIsValid(""#55AAFF"");   // Returns true
Color.HtmlIsValid(""#55AAFF20""); // Returns true
Color.HtmlIsValid(""55AAFF"");    // Returns true
Color.HtmlIsValid(""#F2C"");      // Returns true

Color.HtmlIsValid(""#AABBC"");    // Returns false
Color.HtmlIsValid(""#55aaFF5"");  // Returns false
\[/csharp\]
\[/codeblocks\] *)
    let html_is_valid x0  = 
    foreign_builtin_method1_static
      GlobalEnum.VariantType._TYPE_COLOR
      "html_is_valid"
      2942997125L
      (String.typ @-> returning Bool.typ)
      Bool.s x0 

    (** Creates a \[Color\] from the given string, which can be either an HTML color code or a named color (case-insensitive). Returns \[param default\] if the color cannot be inferred from the string.
If you want to create a color from String in a constant expression, use the equivalent constructor instead (i.e. \[code\]Color(""color string"")\[/code\]). *)
    let from_string x0  x1  = 
    foreign_builtin_method2_static
      GlobalEnum.VariantType._TYPE_COLOR
      "from_string"
      3755044230L
      (String.typ @-> Color.typ @-> returning Color.typ)
      Color.s x0  x1 

    (** Constructs a color from an \[url=https://en.wikipedia.org/wiki/HSL_and_HSV\]HSV profile\[/url\]. The hue (\[param h\]), saturation (\[param s\]), and value (\[param v\]) are typically between 0.0 and 1.0.
\[codeblocks\]
\[gdscript\]
var color = Color.from_hsv(0.58, 0.5, 0.79, 0.8)
\[/gdscript\]
\[csharp\]
var color = Color.FromHsv(0.58f, 0.5f, 0.79f, 0.8f);
\[/csharp\]
\[/codeblocks\] *)
    let from_hsv x0  x1  x2  x3  = 
    foreign_builtin_method4_static
      GlobalEnum.VariantType._TYPE_COLOR
      "from_hsv"
      1573799446L
      (Float.typ @-> Float.typ @-> Float.typ @-> Float.typ @-> returning Color.typ)
      Color.s x0  x1  x2  x3 

    (** Constructs a color from an \[url=https://bottosson.github.io/posts/colorpicker/\]OK HSL profile\[/url\]. The hue (\[param h\]), saturation (\[param s\]), and lightness (\[param l\]) are typically between 0.0 and 1.0.
\[codeblocks\]
\[gdscript\]
var color = Color.from_ok_hsl(0.58, 0.5, 0.79, 0.8)
\[/gdscript\]
\[csharp\]
var color = Color.FromOkHsl(0.58f, 0.5f, 0.79f, 0.8f);
\[/csharp\]
\[/codeblocks\] *)
    let from_ok_hsl x0  x1  x2  x3  = 
    foreign_builtin_method4_static
      GlobalEnum.VariantType._TYPE_COLOR
      "from_ok_hsl"
      1573799446L
      (Float.typ @-> Float.typ @-> Float.typ @-> Float.typ @-> returning Color.typ)
      Color.s x0  x1  x2  x3 

    (** Decodes a \[Color\] from an RGBE9995 format integer. See \[constant Image.FORMAT_RGBE9995\]. *)
    let from_rgbe9995 x0  = 
    foreign_builtin_method1_static
      GlobalEnum.VariantType._TYPE_COLOR
      "from_rgbe9995"
      351421375L
      (Int.typ @-> returning Color.typ)
      Color.s x0 

    (** Returns a \[Color\] constructed from red (\[param r8\]), green (\[param g8\]), blue (\[param b8\]), and optionally alpha (\[param a8\]) integer channels, each divided by \[code\]255.0\[/code\] for their final value.
\[codeblock\]
var red = Color.from_rgba8(255, 0, 0)             # Same as Color(1, 0, 0).
var dark_blue = Color.from_rgba8(0, 0, 51)        # Same as Color(0, 0, 0.2).
var my_color = Color.from_rgba8(306, 255, 0, 102) # Same as Color(1.2, 1, 0, 0.4).
\[/codeblock\]
\[b\]Note:\[/b\] Due to the lower precision of \[method from_rgba8\] compared to the standard \[Color\] constructor, a color created with \[method from_rgba8\] will generally not be equal to the same color created with the standard \[Color\] constructor. Use \[method is_equal_approx\] for comparisons to avoid issues with floating-point precision error. *)
    let from_rgba8 x0  x1  x2  x3  = 
    foreign_builtin_method4_static
      GlobalEnum.VariantType._TYPE_COLOR
      "from_rgba8"
      3072934735L
      (Int.typ @-> Int.typ @-> Int.typ @-> Int.typ @-> returning Color.typ)
      Color.s x0  x1  x2  x3 





    (** Inverts the given color. This is equivalent to \[code\]Color.WHITE - c\[/code\] or \[code\]Color(1 - c.r, 1 - c.g, 1 - c.b, 1 - c.a)\[/code\]. Unlike with \[method inverted\], the \[member a\] component is inverted, too. *)
    let (~-) x0  = 
    foreign_builtin_operator1 GlobalEnum.VariantType._TYPE_COLOR None  GlobalEnum.VariantOperator._OP_NEGATE
      (funptr (Color.typ @-> Color.typ @-> returning void))
      Color.s x0 

    (** Returns the same value as if the \[code\]+\[/code\] was not there. Unary \[code\]+\[/code\] does nothing, but sometimes it can make your code more readable. *)
    let (~+) x0  = 
    foreign_builtin_operator1 GlobalEnum.VariantType._TYPE_COLOR None  GlobalEnum.VariantOperator._OP_POSITIVE
      (funptr (Color.typ @-> Color.typ @-> returning void))
      Color.s x0 


    let not x0  = 
    foreign_builtin_operator1 GlobalEnum.VariantType._TYPE_COLOR None  GlobalEnum.VariantOperator._OP_NOT
      (funptr (Color.typ @-> Bool.typ @-> returning void))
      Bool.s x0 









    (** Returns \[code\]true\[/code\] if the colors are exactly equal.
\[b\]Note:\[/b\] Due to floating-point precision errors, consider using \[method is_equal_approx\] instead, which is more reliable. *)
    let (=) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_COLOR (Some GlobalEnum.VariantType._TYPE_COLOR) GlobalEnum.VariantOperator._OP_EQUAL
      (funptr (Color.typ @-> Color.typ @-> Bool.typ @-> returning void))
      Bool.s
      Conv.Color.of_ocaml
      Conv.Color.of_ocaml
      Conv.Bool.to_ocaml x0  x1 

    (** Returns \[code\]true\[/code\] if the colors are not exactly equal.
\[b\]Note:\[/b\] Due to floating-point precision errors, consider using \[method is_equal_approx\] instead, which is more reliable. *)
    let (<>) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_COLOR (Some GlobalEnum.VariantType._TYPE_COLOR) GlobalEnum.VariantOperator._OP_NOT_EQUAL
      (funptr (Color.typ @-> Color.typ @-> Bool.typ @-> returning void))
      Bool.s
      Conv.Color.of_ocaml
      Conv.Color.of_ocaml
      Conv.Bool.to_ocaml x0  x1 

    (** Adds each component of the \[Color\] with the components of the given \[Color\]. *)
    let (+) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_COLOR (Some GlobalEnum.VariantType._TYPE_COLOR) GlobalEnum.VariantOperator._OP_ADD
      (funptr (Color.typ @-> Color.typ @-> Color.typ @-> returning void))
      Color.s
      Conv.Color.of_ocaml
      Conv.Color.of_ocaml
      Conv.Color.to_ocaml x0  x1 

    (** Subtracts each component of the \[Color\] by the components of the given \[Color\]. *)
    let (-) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_COLOR (Some GlobalEnum.VariantType._TYPE_COLOR) GlobalEnum.VariantOperator._OP_SUBTRACT
      (funptr (Color.typ @-> Color.typ @-> Color.typ @-> returning void))
      Color.s
      Conv.Color.of_ocaml
      Conv.Color.of_ocaml
      Conv.Color.to_ocaml x0  x1 

    (** Multiplies each component of the \[Color\] by the components of the given \[Color\]. *)
    let ( * ) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_COLOR (Some GlobalEnum.VariantType._TYPE_COLOR) GlobalEnum.VariantOperator._OP_MULTIPLY
      (funptr (Color.typ @-> Color.typ @-> Color.typ @-> returning void))
      Color.s
      Conv.Color.of_ocaml
      Conv.Color.of_ocaml
      Conv.Color.to_ocaml x0  x1 

    (** Divides each component of the \[Color\] by the components of the given \[Color\]. *)
    let (/) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_COLOR (Some GlobalEnum.VariantType._TYPE_COLOR) GlobalEnum.VariantOperator._OP_DIVIDE
      (funptr (Color.typ @-> Color.typ @-> Color.typ @-> returning void))
      Color.s
      Conv.Color.of_ocaml
      Conv.Color.of_ocaml
      Conv.Color.to_ocaml x0  x1 


    let mem_Dictionary x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_COLOR (Some GlobalEnum.VariantType._TYPE_DICTIONARY) GlobalEnum.VariantOperator._OP_IN
      (funptr (Color.typ @-> Dictionary.typ @-> Bool.typ @-> returning void))
      Bool.s x0  x1 


    let mem_Array x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_COLOR (Some GlobalEnum.VariantType._TYPE_ARRAY) GlobalEnum.VariantOperator._OP_IN
      (funptr (Color.typ @-> Array.typ @-> Bool.typ @-> returning void))
      Bool.s x0  x1 


    let mem_PackedColorArray x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_COLOR (Some GlobalEnum.VariantType._TYPE_PACKED_COLOR_ARRAY) GlobalEnum.VariantOperator._OP_IN
      (funptr (Color.typ @-> PackedColorArray.typ @-> Bool.typ @-> returning void))
      Bool.s x0  x1 
    end

  module StringName = struct
    include M.StringName
include BuiltinClass0.StringName

    (** Performs a case-sensitive comparison to another string. Returns \[code\]-1\[/code\] if less than, \[code\]1\[/code\] if greater than, or \[code\]0\[/code\] if equal. ""Less than"" and ""greater than"" are determined by the \[url=https://en.wikipedia.org/wiki/List_of_Unicode_characters\]Unicode code points\[/url\] of each string, which roughly matches the alphabetical order.
With different string lengths, returns \[code\]1\[/code\] if this string is longer than the \[param to\] string, or \[code\]-1\[/code\] if shorter. Note that the length of empty strings is \[i\]always\[/i\] \[code\]0\[/code\].
To get a \[bool\] result from a string comparison, use the \[code\]==\[/code\] operator instead. See also \[method nocasecmp_to\], \[method filecasecmp_to\], and \[method naturalcasecmp_to\]. *)
    let casecmp_to x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_STRING_NAME
      "casecmp_to"
      2920860731L
      (String.typ @-> StringName.typ @-> returning Int.typ)
      Int.s x0  x1 

    (** Performs a \[b\]case-insensitive\[/b\] comparison to another string. Returns \[code\]-1\[/code\] if less than, \[code\]1\[/code\] if greater than, or \[code\]0\[/code\] if equal. ""Less than"" or ""greater than"" are determined by the \[url=https://en.wikipedia.org/wiki/List_of_Unicode_characters\]Unicode code points\[/url\] of each string, which roughly matches the alphabetical order. Internally, lowercase characters are converted to uppercase for the comparison.
With different string lengths, returns \[code\]1\[/code\] if this string is longer than the \[param to\] string, or \[code\]-1\[/code\] if shorter. Note that the length of empty strings is \[i\]always\[/i\] \[code\]0\[/code\].
To get a \[bool\] result from a string comparison, use the \[code\]==\[/code\] operator instead. See also \[method casecmp_to\], \[method filenocasecmp_to\], and \[method naturalnocasecmp_to\]. *)
    let nocasecmp_to x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_STRING_NAME
      "nocasecmp_to"
      2920860731L
      (String.typ @-> StringName.typ @-> returning Int.typ)
      Int.s x0  x1 

    (** Performs a \[b\]case-sensitive\[/b\], \[i\]natural order\[/i\] comparison to another string. Returns \[code\]-1\[/code\] if less than, \[code\]1\[/code\] if greater than, or \[code\]0\[/code\] if equal. ""Less than"" or ""greater than"" are determined by the \[url=https://en.wikipedia.org/wiki/List_of_Unicode_characters\]Unicode code points\[/url\] of each string, which roughly matches the alphabetical order.
When used for sorting, natural order comparison orders sequences of numbers by the combined value of each digit as is often expected, instead of the single digit''s value. A sorted sequence of numbered strings will be \[code\]\[""1"", ""2"", ""3"", ...\]\[/code\], not \[code\]\[""1"", ""10"", ""2"", ""3"", ...\]\[/code\].
With different string lengths, returns \[code\]1\[/code\] if this string is longer than the \[param to\] string, or \[code\]-1\[/code\] if shorter. Note that the length of empty strings is \[i\]always\[/i\] \[code\]0\[/code\].
To get a \[bool\] result from a string comparison, use the \[code\]==\[/code\] operator instead. See also \[method naturalnocasecmp_to\], \[method filecasecmp_to\], and \[method nocasecmp_to\]. *)
    let naturalcasecmp_to x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_STRING_NAME
      "naturalcasecmp_to"
      2920860731L
      (String.typ @-> StringName.typ @-> returning Int.typ)
      Int.s x0  x1 

    (** Performs a \[b\]case-insensitive\[/b\], \[i\]natural order\[/i\] comparison to another string. Returns \[code\]-1\[/code\] if less than, \[code\]1\[/code\] if greater than, or \[code\]0\[/code\] if equal. ""Less than"" or ""greater than"" are determined by the \[url=https://en.wikipedia.org/wiki/List_of_Unicode_characters\]Unicode code points\[/url\] of each string, which roughly matches the alphabetical order. Internally, lowercase characters are converted to uppercase for the comparison.
When used for sorting, natural order comparison orders sequences of numbers by the combined value of each digit as is often expected, instead of the single digit''s value. A sorted sequence of numbered strings will be \[code\]\[""1"", ""2"", ""3"", ...\]\[/code\], not \[code\]\[""1"", ""10"", ""2"", ""3"", ...\]\[/code\].
With different string lengths, returns \[code\]1\[/code\] if this string is longer than the \[param to\] string, or \[code\]-1\[/code\] if shorter. Note that the length of empty strings is \[i\]always\[/i\] \[code\]0\[/code\].
To get a \[bool\] result from a string comparison, use the \[code\]==\[/code\] operator instead. See also \[method naturalcasecmp_to\], \[method filenocasecmp_to\], and \[method casecmp_to\]. *)
    let naturalnocasecmp_to x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_STRING_NAME
      "naturalnocasecmp_to"
      2920860731L
      (String.typ @-> StringName.typ @-> returning Int.typ)
      Int.s x0  x1 

    (** Like \[method naturalcasecmp_to\] but prioritizes strings that begin with periods (\[code\].\[/code\]) and underscores (\[code\]_\[/code\]) before any other character. Useful when sorting folders or file names.
To get a \[bool\] result from a string comparison, use the \[code\]==\[/code\] operator instead. See also \[method filenocasecmp_to\], \[method naturalcasecmp_to\], and \[method casecmp_to\]. *)
    let filecasecmp_to x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_STRING_NAME
      "filecasecmp_to"
      2920860731L
      (String.typ @-> StringName.typ @-> returning Int.typ)
      Int.s x0  x1 

    (** Like \[method naturalnocasecmp_to\] but prioritizes strings that begin with periods (\[code\].\[/code\]) and underscores (\[code\]_\[/code\]) before any other character. Useful when sorting folders or file names.
To get a \[bool\] result from a string comparison, use the \[code\]==\[/code\] operator instead. See also \[method filecasecmp_to\], \[method naturalnocasecmp_to\], and \[method nocasecmp_to\]. *)
    let filenocasecmp_to x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_STRING_NAME
      "filenocasecmp_to"
      2920860731L
      (String.typ @-> StringName.typ @-> returning Int.typ)
      Int.s x0  x1 

    (** Returns the number of characters in the string. Empty strings (\[code\]""""\[/code\]) always return \[code\]0\[/code\]. See also \[method is_empty\]. *)
    let length x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_STRING_NAME
      "length"
      3173160232L
      (StringName.typ @-> returning Int.typ)
      Int.s x0 

    (** Returns part of the string from the position \[param from\] with length \[param len\]. If \[param len\] is \[code\]-1\[/code\] (as by default), returns the rest of the string starting from the given position. *)
    let substr x0  x1  x2  = 
    foreign_builtin_method2
      GlobalEnum.VariantType._TYPE_STRING_NAME
      "substr"
      787537301L
      (Int.typ @-> Int.typ @-> StringName.typ @-> returning String.typ)
      String.s x0  x1  x2 

    (** Splits the string using a \[param delimiter\] and returns the substring at index \[param slice\]. Returns the original string if \[param delimiter\] does not occur in the string. Returns an empty string if the \[param slice\] does not exist.
This is faster than \[method split\], if you only need one substring.
\[codeblock\]
print(""i/am/example/hi"".get_slice(""/"", 2)) # Prints ""example""
\[/codeblock\] *)
    let get_slice x0  x1  x2  = 
    foreign_builtin_method2
      GlobalEnum.VariantType._TYPE_STRING_NAME
      "get_slice"
      3535100402L
      (String.typ @-> Int.typ @-> StringName.typ @-> returning String.typ)
      String.s x0  x1  x2 

    (** Splits the string using a Unicode character with code \[param delimiter\] and returns the substring at index \[param slice\]. Returns an empty string if the \[param slice\] does not exist.
This is faster than \[method split\], if you only need one substring. *)
    let get_slicec x0  x1  x2  = 
    foreign_builtin_method2
      GlobalEnum.VariantType._TYPE_STRING_NAME
      "get_slicec"
      787537301L
      (Int.typ @-> Int.typ @-> StringName.typ @-> returning String.typ)
      String.s x0  x1  x2 

    (** Returns the total number of slices when the string is split with the given \[param delimiter\] (see \[method split\]). *)
    let get_slice_count x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_STRING_NAME
      "get_slice_count"
      2920860731L
      (String.typ @-> StringName.typ @-> returning Int.typ)
      Int.s x0  x1 

    (** Returns the index of the \[b\]first\[/b\] occurrence of \[param what\] in this string, or \[code\]-1\[/code\] if there are none. The search''s start can be specified with \[param from\], continuing to the end of the string.
\[codeblocks\]
\[gdscript\]
print(""Team"".find(""I"")) # Prints -1

print(""Potato"".find(""t""))    # Prints 2
print(""Potato"".find(""t"", 3)) # Prints 4
print(""Potato"".find(""t"", 5)) # Prints -1
\[/gdscript\]
\[csharp\]
GD.Print(""Team"".Find(""I"")); // Prints -1

GD.Print(""Potato"".Find(""t""));    // Prints 2
GD.Print(""Potato"".Find(""t"", 3)); // Prints 4
GD.Print(""Potato"".Find(""t"", 5)); // Prints -1
\[/csharp\]
\[/codeblocks\]
\[b\]Note:\[/b\] If you just want to know whether the string contains \[param what\], use \[method contains\]. In GDScript, you may also use the \[code\]in\[/code\] operator. *)
    let find x0  x1  x2  = 
    foreign_builtin_method2
      GlobalEnum.VariantType._TYPE_STRING_NAME
      "find"
      1760645412L
      (String.typ @-> Int.typ @-> StringName.typ @-> returning Int.typ)
      Int.s x0  x1  x2 

    (** Returns the index of the \[b\]first\[/b\] \[b\]case-insensitive\[/b\] occurrence of \[param what\] in this string, or \[code\]-1\[/code\] if there are none. The starting search index can be specified with \[param from\], continuing to the end of the string. *)
    let findn x0  x1  x2  = 
    foreign_builtin_method2
      GlobalEnum.VariantType._TYPE_STRING_NAME
      "findn"
      1760645412L
      (String.typ @-> Int.typ @-> StringName.typ @-> returning Int.typ)
      Int.s x0  x1  x2 

    (** Returns the number of occurrences of the substring \[param what\] between \[param from\] and \[param to\] positions. If \[param to\] is 0, the search continues until the end of the string. *)
    let count x0  x1  x2  x3  = 
    foreign_builtin_method3
      GlobalEnum.VariantType._TYPE_STRING_NAME
      "count"
      2343087891L
      (String.typ @-> Int.typ @-> Int.typ @-> StringName.typ @-> returning Int.typ)
      Int.s x0  x1  x2  x3 

    (** Returns the number of occurrences of the substring \[param what\] between \[param from\] and \[param to\] positions, \[b\]ignoring case\[/b\]. If \[param to\] is 0, the search continues until the end of the string. *)
    let countn x0  x1  x2  x3  = 
    foreign_builtin_method3
      GlobalEnum.VariantType._TYPE_STRING_NAME
      "countn"
      2343087891L
      (String.typ @-> Int.typ @-> Int.typ @-> StringName.typ @-> returning Int.typ)
      Int.s x0  x1  x2  x3 

    (** Returns the index of the \[b\]last\[/b\] occurrence of \[param what\] in this string, or \[code\]-1\[/code\] if there are none. The search''s start can be specified with \[param from\], continuing to the beginning of the string. This method is the reverse of \[method find\]. *)
    let rfind x0  x1  x2  = 
    foreign_builtin_method2
      GlobalEnum.VariantType._TYPE_STRING_NAME
      "rfind"
      1760645412L
      (String.typ @-> Int.typ @-> StringName.typ @-> returning Int.typ)
      Int.s x0  x1  x2 

    (** Returns the index of the \[b\]last\[/b\] \[b\]case-insensitive\[/b\] occurrence of \[param what\] in this string, or \[code\]-1\[/code\] if there are none. The starting search index can be specified with \[param from\], continuing to the beginning of the string. This method is the reverse of \[method findn\]. *)
    let rfindn x0  x1  x2  = 
    foreign_builtin_method2
      GlobalEnum.VariantType._TYPE_STRING_NAME
      "rfindn"
      1760645412L
      (String.typ @-> Int.typ @-> StringName.typ @-> returning Int.typ)
      Int.s x0  x1  x2 

    (** Does a simple expression match (also called ""glob"" or ""globbing""), where \[code\] * \[/code\] matches zero or more arbitrary characters and \[code\]?\[/code\] matches any single character except a period (\[code\].\[/code\]). An empty string or empty expression always evaluates to \[code\]false\[/code\]. *)
    let match_ x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_STRING_NAME
      "match_"
      2566493496L
      (String.typ @-> StringName.typ @-> returning Bool.typ)
      Bool.s x0  x1 

    (** Does a simple \[b\]case-insensitive\[/b\] expression match, where \[code\] * \[/code\] matches zero or more arbitrary characters and \[code\]?\[/code\] matches any single character except a period (\[code\].\[/code\]). An empty string or empty expression always evaluates to \[code\]false\[/code\]. *)
    let matchn x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_STRING_NAME
      "matchn"
      2566493496L
      (String.typ @-> StringName.typ @-> returning Bool.typ)
      Bool.s x0  x1 

    (** Returns \[code\]true\[/code\] if the string begins with the given \[param text\]. See also \[method ends_with\]. *)
    let begins_with x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_STRING_NAME
      "begins_with"
      2566493496L
      (String.typ @-> StringName.typ @-> returning Bool.typ)
      Bool.s x0  x1 

    (** Returns \[code\]true\[/code\] if the string ends with the given \[param text\]. See also \[method begins_with\]. *)
    let ends_with x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_STRING_NAME
      "ends_with"
      2566493496L
      (String.typ @-> StringName.typ @-> returning Bool.typ)
      Bool.s x0  x1 

    (** Returns \[code\]true\[/code\] if all characters of this string can be found in \[param text\] in their original order.
\[codeblock\]
var text = ""Wow, incredible!""

print(""inedible"".is_subsequence_of(text)) # Prints true
print(""Word!"".is_subsequence_of(text))    # Prints true
print(""Window"".is_subsequence_of(text))   # Prints false
print("""".is_subsequence_of(text))         # Prints true
\[/codeblock\] *)
    let is_subsequence_of x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_STRING_NAME
      "is_subsequence_of"
      2566493496L
      (String.typ @-> StringName.typ @-> returning Bool.typ)
      Bool.s x0  x1 

    (** Returns \[code\]true\[/code\] if all characters of this string can be found in \[param text\] in their original order, \[b\]ignoring case\[/b\]. *)
    let is_subsequence_ofn x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_STRING_NAME
      "is_subsequence_ofn"
      2566493496L
      (String.typ @-> StringName.typ @-> returning Bool.typ)
      Bool.s x0  x1 

    (** Returns an array containing the bigrams (pairs of consecutive characters) of this string.
\[codeblock\]
print(""Get up!"".bigrams()) # Prints \[""Ge"", ""et"", ""t "", "" u"", ""up"", ""p!""\]
\[/codeblock\] *)
    let bigrams x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_STRING_NAME
      "bigrams"
      747180633L
      (StringName.typ @-> returning PackedStringArray.typ)
      PackedStringArray.s x0 

    (** Returns the similarity index (\[url=https://en.wikipedia.org/wiki/S%C3%B8rensen%E2%80%93Dice_coefficient\]Srensen-Dice coefficient\[/url\]) of this string compared to another. A result of \[code\]1.0\[/code\] means totally similar, while \[code\]0.0\[/code\] means totally dissimilar.
\[codeblock\]
print(""ABC123"".similarity(""ABC123"")) # Prints 1.0
print(""ABC123"".similarity(""XYZ456"")) # Prints 0.0
print(""ABC123"".similarity(""123ABC"")) # Prints 0.8
print(""ABC123"".similarity(""abc123"")) # Prints 0.4
\[/codeblock\] *)
    let similarity x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_STRING_NAME
      "similarity"
      2697460964L
      (String.typ @-> StringName.typ @-> returning Float.typ)
      Float.s x0  x1 

    (** Formats the string by replacing all occurrences of \[param placeholder\] with the elements of \[param values\].
\[param values\] can be a \[Dictionary\], an \[Array\], or an \[Object\]. Any underscores in \[param placeholder\] will be replaced with the corresponding keys in advance. Array elements use their index as keys.
\[codeblock\]
# Prints ""Waiting for Godot is a play by Samuel Beckett, and Godot Engine is named after it.""
var use_array_values = ""Waiting for \{!0\} is a play by \{!1\}, and \{!0\} Engine is named after it.""
print(use_array_values.format(\[""Godot"", ""Samuel Beckett""\]))

# Prints ""User 42 is Godot.""
print(""User \{!id\} is \{!name\}."".format(\{!""id"": 42, ""name"": ""Godot""\}))
\[/codeblock\]
Some additional handling is performed when \[param values\] is an \[Array\]. If \[param placeholder\] does not contain an underscore, the elements of the \[param values\] array will be used to replace one occurrence of the placeholder in order; If an element of \[param values\] is another 2-element array, it''ll be interpreted as a key-value pair.
\[codeblock\]
# Prints ""User 42 is Godot.""
print(""User \{!\} is \{!\}."".format(\[42, ""Godot""\], ""\{!\}""))
print(""User \{!id\} is \{!name\}."".format(\[\[""id"", 42\], \[""name"", ""Godot""\]\]))
\[/codeblock\]
When passing an \[Object\], the property names from \[method Object.get_property_list\] are used as keys.
\[codeblock\]
# Prints ""Visible true, position (0, 0)""
var node = Node2D.new()
print(""Visible \{!visible\}, position \{!position\}"".format(node))
\[/codeblock\]
See also the \[url=$DOCS_URL/tutorials/scripting/gdscript/gdscript_format_string.html\]GDScript format string\[/url\] tutorial.
\[b\]Note:\[/b\] Each replacement is done sequentially for each element of \[param values\], \[b\]not\[/b\] all at once. This means that if any element is inserted and it contains another placeholder, it may be changed by the next replacement. While this can be very useful, it often causes unexpected results. If not necessary, make sure \[param values\]''s elements do not contain placeholders.
\[codeblock\]
print(""\{!0\} \{!1\}"".format(\[""\{!1\}"", ""x""\]))           # Prints ""x x""
print(""\{!0\} \{!1\}"".format(\[""x"", ""\{!0\}""\]))           # Prints ""x \{!0\}""
print(""\{!a\} \{!b\}"".format(\{!""a"": ""\{!b\}"", ""b"": ""c""\})) # Prints ""c c""
print(""\{!a\} \{!b\}"".format(\{!""b"": ""c"", ""a"": ""\{!b\}""\})) # Prints ""\{!b\} c""
\[/codeblock\]
\[b\]Note:\[/b\] In C#, it''s recommended to \[url=https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/tokens/interpolated\]interpolate strings with ""$""\[/url\], instead. *)
    let format x0  x1  x2  = 
    foreign_builtin_method2
      GlobalEnum.VariantType._TYPE_STRING_NAME
      "format"
      3212199029L
      (Variant.typ @-> String.typ @-> StringName.typ @-> returning String.typ)
      String.s x0  x1  x2 

    (** Replaces all occurrences of \[param what\] inside the string with the given \[param forwhat\]. *)
    let replace x0  x1  x2  = 
    foreign_builtin_method2
      GlobalEnum.VariantType._TYPE_STRING_NAME
      "replace"
      1340436205L
      (String.typ @-> String.typ @-> StringName.typ @-> returning String.typ)
      String.s x0  x1  x2 

    (** Replaces all \[b\]case-insensitive\[/b\] occurrences of \[param what\] inside the string with the given \[param forwhat\]. *)
    let replacen x0  x1  x2  = 
    foreign_builtin_method2
      GlobalEnum.VariantType._TYPE_STRING_NAME
      "replacen"
      1340436205L
      (String.typ @-> String.typ @-> StringName.typ @-> returning String.typ)
      String.s x0  x1  x2 

    (** Repeats this string a number of times. \[param count\] needs to be greater than \[code\]0\[/code\]. Otherwise, returns an empty string. *)
    let repeat x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_STRING_NAME
      "repeat"
      2162347432L
      (Int.typ @-> StringName.typ @-> returning String.typ)
      String.s x0  x1 

    (** Returns the copy of this string in reverse order. This operation works on unicode codepoints, rather than sequences of codepoints, and may break things like compound letters or emojis. *)
    let reverse x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_STRING_NAME
      "reverse"
      3942272618L
      (StringName.typ @-> returning String.typ)
      String.s x0 

    (** Inserts \[param what\] at the given \[param position\] in the string. *)
    let insert x0  x1  x2  = 
    foreign_builtin_method2
      GlobalEnum.VariantType._TYPE_STRING_NAME
      "insert"
      248737229L
      (Int.typ @-> String.typ @-> StringName.typ @-> returning String.typ)
      String.s x0  x1  x2 

    (** Returns a string with \[param chars\] characters erased starting from \[param position\]. If \[param chars\] goes beyond the string''s length given the specified \[param position\], fewer characters will be erased from the returned string. Returns an empty string if either \[param position\] or \[param chars\] is negative. Returns the original string unmodified if \[param chars\] is \[code\]0\[/code\]. *)
    let erase x0  x1  x2  = 
    foreign_builtin_method2
      GlobalEnum.VariantType._TYPE_STRING_NAME
      "erase"
      787537301L
      (Int.typ @-> Int.typ @-> StringName.typ @-> returning String.typ)
      String.s x0  x1  x2 

    (** Changes the appearance of the string: replaces underscores (\[code\]_\[/code\]) with spaces, adds spaces before uppercase letters in the middle of a word, converts all letters to lowercase, then converts the first one and each one following a space to uppercase.
\[codeblocks\]
\[gdscript\]
""move_local_x"".capitalize()   # Returns ""Move Local X""
""sceneFile_path"".capitalize() # Returns ""Scene File Path""
""2D, FPS, PNG"".capitalize()   # Returns ""2d, Fps, Png""
\[/gdscript\]
\[csharp\]
""move_local_x"".Capitalize();   // Returns ""Move Local X""
""sceneFile_path"".Capitalize(); // Returns ""Scene File Path""
""2D, FPS, PNG"".Capitalize();   // Returns ""2d, Fps, Png""
\[/csharp\]
\[/codeblocks\] *)
    let capitalize x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_STRING_NAME
      "capitalize"
      3942272618L
      (StringName.typ @-> returning String.typ)
      String.s x0 

    (** Returns the string converted to \[code\]camelCase\[/code\]. *)
    let to_camel_case x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_STRING_NAME
      "to_camel_case"
      3942272618L
      (StringName.typ @-> returning String.typ)
      String.s x0 

    (** Returns the string converted to \[code\]PascalCase\[/code\]. *)
    let to_pascal_case x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_STRING_NAME
      "to_pascal_case"
      3942272618L
      (StringName.typ @-> returning String.typ)
      String.s x0 

    (** Returns the string converted to \[code\]snake_case\[/code\].
\[b\]Note:\[/b\] Numbers followed by a \[i\]single\[/i\] letter are not separated in the conversion to keep some words (such as ""2D"") together.
\[codeblocks\]
\[gdscript\]
""Node2D"".to_snake_case()               # Returns ""node_2d""
""2nd place"".to_snake_case()            # Returns ""2_nd_place""
""Texture3DAssetFolder"".to_snake_case() # Returns ""texture_3d_asset_folder""
\[/gdscript\]
\[csharp\]
""Node2D"".ToSnakeCase();               // Returns ""node_2d""
""2nd place"".ToSnakeCase();            // Returns ""2_nd_place""
""Texture3DAssetFolder"".ToSnakeCase(); // Returns ""texture_3d_asset_folder""
\[/csharp\]
\[/codeblocks\] *)
    let to_snake_case x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_STRING_NAME
      "to_snake_case"
      3942272618L
      (StringName.typ @-> returning String.typ)
      String.s x0 

    (** Splits the string using a \[param delimiter\] and returns an array of the substrings. If \[param delimiter\] is an empty string, each substring will be a single character. This method is the opposite of \[method join\].
If \[param allow_empty\] is \[code\]false\[/code\], empty strings between adjacent delimiters are excluded from the array.
If \[param maxsplit\] is greater than \[code\]0\[/code\], the number of splits may not exceed \[param maxsplit\]. By default, the entire string is split.
\[codeblocks\]
\[gdscript\]
var some_array = ""One,Two,Three,Four"".split("","", true, 2)

print(some_array.size()) # Prints 3
print(some_array\[0\])     # Prints ""One""
print(some_array\[1\])     # Prints ""Two""
print(some_array\[2\])     # Prints ""Three,Four""
\[/gdscript\]
\[csharp\]
// C#''s `Split()` does not support the `maxsplit` parameter.
var someArray = ""One,Two,Three"".Split("","");

GD.Print(someArray\[0\]); // Prints ""One""
GD.Print(someArray\[1\]); // Prints ""Two""
GD.Print(someArray\[2\]); // Prints ""Three""
\[/csharp\]
\[/codeblocks\]
\[b\]Note:\[/b\] If you only need one substring from the array, consider using \[method get_slice\] which is faster. If you need to split strings with more complex rules, use the \[RegEx\] class instead. *)
    let split x0  x1  x2  x3  = 
    foreign_builtin_method3
      GlobalEnum.VariantType._TYPE_STRING_NAME
      "split"
      1252735785L
      (String.typ @-> Bool.typ @-> Int.typ @-> StringName.typ @-> returning PackedStringArray.typ)
      PackedStringArray.s x0  x1  x2  x3 

    (** Splits the string using a \[param delimiter\] and returns an array of the substrings, starting from the end of the string. The splits in the returned array appear in the same order as the original string. If \[param delimiter\] is an empty string, each substring will be a single character.
If \[param allow_empty\] is \[code\]false\[/code\], empty strings between adjacent delimiters are excluded from the array.
If \[param maxsplit\] is greater than \[code\]0\[/code\], the number of splits may not exceed \[param maxsplit\]. By default, the entire string is split, which is mostly identical to \[method split\].
\[codeblocks\]
\[gdscript\]
var some_string = ""One,Two,Three,Four""
var some_array = some_string.rsplit("","", true, 1)

print(some_array.size()) # Prints 2
print(some_array\[0\])     # Prints ""One,Two,Three""
print(some_array\[1\])     # Prints ""Four""
\[/gdscript\]
\[csharp\]
// In C#, there is no String.RSplit() method.
\[/csharp\]
\[/codeblocks\] *)
    let rsplit x0  x1  x2  x3  = 
    foreign_builtin_method3
      GlobalEnum.VariantType._TYPE_STRING_NAME
      "rsplit"
      1252735785L
      (String.typ @-> Bool.typ @-> Int.typ @-> StringName.typ @-> returning PackedStringArray.typ)
      PackedStringArray.s x0  x1  x2  x3 

    (** Splits the string into floats by using a \[param delimiter\] and returns a \[PackedFloat64Array\].
If \[param allow_empty\] is \[code\]false\[/code\], empty or invalid \[float\] conversions between adjacent delimiters are excluded.
\[codeblock\]
var a = ""1,2,4.5"".split_floats("","")         # a is \[1.0, 2.0, 4.5\]
var c = ""1| ||4.5"".split_floats(""|"")        # c is \[1.0, 0.0, 0.0, 4.5\]
var b = ""1| ||4.5"".split_floats(""|"", false) # b is \[1.0, 4.5\]
\[/codeblock\] *)
    let split_floats x0  x1  x2  = 
    foreign_builtin_method2
      GlobalEnum.VariantType._TYPE_STRING_NAME
      "split_floats"
      2092079095L
      (String.typ @-> Bool.typ @-> StringName.typ @-> returning PackedFloat64Array.typ)
      PackedFloat64Array.s x0  x1  x2 

    (** Returns the concatenation of \[param parts\]'' elements, with each element separated by the string calling this method. This method is the opposite of \[method split\].
\[codeblocks\]
\[gdscript\]
var fruits = \[""Apple"", ""Orange"", ""Pear"", ""Kiwi""\]

print("", "".join(fruits))  # Prints ""Apple, Orange, Pear, Kiwi""
print(""---"".join(fruits)) # Prints ""Apple---Orange---Pear---Kiwi""
\[/gdscript\]
\[csharp\]
string\[\] fruits = \[""Apple"", ""Orange"", ""Pear"", ""Kiwi""\];

// In C#, this method is static.
GD.Print(string.Join("", "", fruits));  // Prints ""Apple, Orange, Pear, Kiwi""
GD.Print(string.Join(""---"", fruits)); // Prints ""Apple---Orange---Pear---Kiwi""
\[/csharp\]
\[/codeblocks\] *)
    let join x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_STRING_NAME
      "join"
      3595973238L
      (PackedStringArray.typ @-> StringName.typ @-> returning String.typ)
      String.s x0  x1 

    (** Returns the string converted to \[code\]UPPERCASE\[/code\]. *)
    let to_upper x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_STRING_NAME
      "to_upper"
      3942272618L
      (StringName.typ @-> returning String.typ)
      String.s x0 

    (** Returns the string converted to \[code\]lowercase\[/code\]. *)
    let to_lower x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_STRING_NAME
      "to_lower"
      3942272618L
      (StringName.typ @-> returning String.typ)
      String.s x0 

    (** Returns the first \[param length\] characters from the beginning of the string. If \[param length\] is negative, strips the last \[param length\] characters from the string''s end.
\[codeblock\]
print(""Hello World!"".left(3))  # Prints ""Hel""
print(""Hello World!"".left(-4)) # Prints ""Hello Wo""
\[/codeblock\] *)
    let left x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_STRING_NAME
      "left"
      2162347432L
      (Int.typ @-> StringName.typ @-> returning String.typ)
      String.s x0  x1 

    (** Returns the last \[param length\] characters from the end of the string. If \[param length\] is negative, strips the first \[param length\] characters from the string''s beginning.
\[codeblock\]
print(""Hello World!"".right(3))  # Prints ""ld!""
print(""Hello World!"".right(-4)) # Prints ""o World!""
\[/codeblock\] *)
    let right x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_STRING_NAME
      "right"
      2162347432L
      (Int.typ @-> StringName.typ @-> returning String.typ)
      String.s x0  x1 

    (** Strips all non-printable characters from the beginning and the end of the string. These include spaces, tabulations (\[code\]\t\[/code\]), and newlines (\[code\]\n\[/code\] \[code\]\r\[/code\]).
If \[param left\] is \[code\]false\[/code\], ignores the string''s beginning. Likewise, if \[param right\] is \[code\]false\[/code\], ignores the string''s end. *)
    let strip_edges x0  x1  x2  = 
    foreign_builtin_method2
      GlobalEnum.VariantType._TYPE_STRING_NAME
      "strip_edges"
      907855311L
      (Bool.typ @-> Bool.typ @-> StringName.typ @-> returning String.typ)
      String.s x0  x1  x2 

    (** Strips all escape characters from the string. These include all non-printable control characters of the first page of the ASCII table (values from 0 to 31), such as tabulation (\[code\]\t\[/code\]) and newline (\[code\]\n\[/code\], \[code\]\r\[/code\]) characters, but \[i\]not\[/i\] spaces. *)
    let strip_escapes x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_STRING_NAME
      "strip_escapes"
      3942272618L
      (StringName.typ @-> returning String.typ)
      String.s x0 

    (** Removes a set of characters defined in \[param chars\] from the string''s beginning. See also \[method rstrip\].
\[b\]Note:\[/b\] \[param chars\] is not a prefix. Use \[method trim_prefix\] to remove a single prefix, rather than a set of characters. *)
    let lstrip x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_STRING_NAME
      "lstrip"
      3134094431L
      (String.typ @-> StringName.typ @-> returning String.typ)
      String.s x0  x1 

    (** Removes a set of characters defined in \[param chars\] from the string''s end. See also \[method lstrip\].
\[b\]Note:\[/b\] \[param chars\] is not a suffix. Use \[method trim_suffix\] to remove a single suffix, rather than a set of characters. *)
    let rstrip x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_STRING_NAME
      "rstrip"
      3134094431L
      (String.typ @-> StringName.typ @-> returning String.typ)
      String.s x0  x1 

    (** If the string is a valid file name or path, returns the file extension without the leading period (\[code\].\[/code\]). Otherwise, returns an empty string.
\[codeblock\]
var a = ""/path/to/file.txt"".get_extension() # a is ""txt""
var b = ""cool.txt"".get_extension()          # b is ""txt""
var c = ""cool.font.tres"".get_extension()    # c is ""tres""
var d = "".pack1"".get_extension()            # d is ""pack1""

var e = ""file.txt."".get_extension()  # e is """"
var f = ""file.txt.."".get_extension() # f is """"
var g = ""txt"".get_extension()        # g is """"
var h = """".get_extension()           # h is """"
\[/codeblock\] *)
    let get_extension x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_STRING_NAME
      "get_extension"
      3942272618L
      (StringName.typ @-> returning String.typ)
      String.s x0 

    (** If the string is a valid file path, returns the full file path, without the extension.
\[codeblock\]
var base = ""/path/to/file.txt"".get_basename() # base is ""/path/to/file""
\[/codeblock\] *)
    let get_basename x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_STRING_NAME
      "get_basename"
      3942272618L
      (StringName.typ @-> returning String.typ)
      String.s x0 

    (** Concatenates \[param file\] at the end of the string as a subpath, adding \[code\]/\[/code\] if necessary.
\[b\]Example:\[/b\] \[code\]""this/is"".path_join(""path"") == ""this/is/path""\[/code\]. *)
    let path_join x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_STRING_NAME
      "path_join"
      3134094431L
      (String.typ @-> StringName.typ @-> returning String.typ)
      String.s x0  x1 

    (** Returns the character code at position \[param at\]. *)
    let unicode_at x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_STRING_NAME
      "unicode_at"
      4103005248L
      (Int.typ @-> StringName.typ @-> returning Int.typ)
      Int.s x0  x1 

    (** Indents every line of the string with the given \[param prefix\]. Empty lines are not indented. See also \[method dedent\] to remove indentation.
For example, the string can be indented with two tabulations using \[code\]""\t\t""\[/code\], or four spaces using \[code\]""    ""\[/code\]. *)
    let indent x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_STRING_NAME
      "indent"
      3134094431L
      (String.typ @-> StringName.typ @-> returning String.typ)
      String.s x0  x1 

    (** Returns a copy of the string with indentation (leading tabs and spaces) removed. See also \[method indent\] to add indentation. *)
    let dedent x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_STRING_NAME
      "dedent"
      3942272618L
      (StringName.typ @-> returning String.typ)
      String.s x0 

    (** Returns the \[url=https://en.wikipedia.org/wiki/MD5\]MD5 hash\[/url\] of the string as another \[String\]. *)
    let md5_text x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_STRING_NAME
      "md5_text"
      3942272618L
      (StringName.typ @-> returning String.typ)
      String.s x0 

    (** Returns the \[url=https://en.wikipedia.org/wiki/SHA-1\]SHA-1\[/url\] hash of the string as another \[String\]. *)
    let sha1_text x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_STRING_NAME
      "sha1_text"
      3942272618L
      (StringName.typ @-> returning String.typ)
      String.s x0 

    (** Returns the \[url=https://en.wikipedia.org/wiki/SHA-2\]SHA-256\[/url\] hash of the string as another \[String\]. *)
    let sha256_text x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_STRING_NAME
      "sha256_text"
      3942272618L
      (StringName.typ @-> returning String.typ)
      String.s x0 

    (** Returns the \[url=https://en.wikipedia.org/wiki/MD5\]MD5 hash\[/url\] of the string as a \[PackedByteArray\]. *)
    let md5_buffer x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_STRING_NAME
      "md5_buffer"
      247621236L
      (StringName.typ @-> returning PackedByteArray.typ)
      PackedByteArray.s x0 

    (** Returns the \[url=https://en.wikipedia.org/wiki/SHA-1\]SHA-1\[/url\] hash of the string as a \[PackedByteArray\]. *)
    let sha1_buffer x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_STRING_NAME
      "sha1_buffer"
      247621236L
      (StringName.typ @-> returning PackedByteArray.typ)
      PackedByteArray.s x0 

    (** Returns the \[url=https://en.wikipedia.org/wiki/SHA-2\]SHA-256\[/url\] hash of the string as a \[PackedByteArray\]. *)
    let sha256_buffer x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_STRING_NAME
      "sha256_buffer"
      247621236L
      (StringName.typ @-> returning PackedByteArray.typ)
      PackedByteArray.s x0 

    (** Returns \[code\]true\[/code\] if the string''s length is \[code\]0\[/code\] (\[code\]""""\[/code\]). See also \[method length\]. *)
    let is_empty x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_STRING_NAME
      "is_empty"
      3918633141L
      (StringName.typ @-> returning Bool.typ)
      Bool.s x0 

    (** Returns \[code\]true\[/code\] if the string contains \[param what\]. In GDScript, this corresponds to the \[code\]in\[/code\] operator.
\[codeblocks\]
\[gdscript\]
print(""Node"".contains(""de"")) # Prints true
print(""team"".contains(""I""))  # Prints false
print(""I"" in ""team"")         # Prints false
\[/gdscript\]
\[csharp\]
GD.Print(""Node"".Contains(""de"")); // Prints True
GD.Print(""team"".Contains(""I""));  // Prints False
\[/csharp\]
\[/codeblocks\]
If you need to know where \[param what\] is within the string, use \[method find\]. See also \[method containsn\]. *)
    let contains x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_STRING_NAME
      "contains"
      2566493496L
      (String.typ @-> StringName.typ @-> returning Bool.typ)
      Bool.s x0  x1 

    (** Returns \[code\]true\[/code\] if the string contains \[param what\], \[b\]ignoring case\[/b\].
If you need to know where \[param what\] is within the string, use \[method findn\]. See also \[method contains\]. *)
    let containsn x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_STRING_NAME
      "containsn"
      2566493496L
      (String.typ @-> StringName.typ @-> returning Bool.typ)
      Bool.s x0  x1 

    (** Returns \[code\]true\[/code\] if the string is a path to a file or directory, and its starting point is explicitly defined. This method is the opposite of \[method is_relative_path\].
This includes all paths starting with \[code\]""res://""\[/code\], \[code\]""user://""\[/code\], \[code\]""C:\""\[/code\], \[code\]""/""\[/code\], etc. *)
    let is_absolute_path x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_STRING_NAME
      "is_absolute_path"
      3918633141L
      (StringName.typ @-> returning Bool.typ)
      Bool.s x0 

    (** Returns \[code\]true\[/code\] if the string is a path, and its starting point is dependent on context. The path could begin from the current directory, or the current \[Node\] (if the string is derived from a \[NodePath\]), and may sometimes be prefixed with \[code\]""./""\[/code\]. This method is the opposite of \[method is_absolute_path\]. *)
    let is_relative_path x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_STRING_NAME
      "is_relative_path"
      3918633141L
      (StringName.typ @-> returning Bool.typ)
      Bool.s x0 

    (** If the string is a valid file path, converts the string into a canonical path. This is the shortest possible path, without \[code\]""./""\[/code\], and all the unnecessary \[code\]""..""\[/code\] and \[code\]""/""\[/code\].
\[codeblock\]
var simple_path = ""./path/to///../file"".simplify_path()
print(simple_path) # Prints ""path/file""
\[/codeblock\] *)
    let simplify_path x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_STRING_NAME
      "simplify_path"
      3942272618L
      (StringName.typ @-> returning String.typ)
      String.s x0 

    (** If the string is a valid file path, returns the base directory name.
\[codeblock\]
var dir_path = ""/path/to/file.txt"".get_base_dir() # dir_path is ""/path/to""
\[/codeblock\] *)
    let get_base_dir x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_STRING_NAME
      "get_base_dir"
      3942272618L
      (StringName.typ @-> returning String.typ)
      String.s x0 

    (** If the string is a valid file path, returns the file name, including the extension.
\[codeblock\]
var file = ""/path/to/icon.png"".get_file() # file is ""icon.png""
\[/codeblock\] *)
    let get_file x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_STRING_NAME
      "get_file"
      3942272618L
      (StringName.typ @-> returning String.typ)
      String.s x0 

    (** Returns a copy of the string with special characters escaped using the XML standard. If \[param escape_quotes\] is \[code\]true\[/code\], the single quote (\[code\]''\[/code\]) and double quote (\[code\]""\[/code\]) characters are also escaped. *)
    let xml_escape x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_STRING_NAME
      "xml_escape"
      3429816538L
      (Bool.typ @-> StringName.typ @-> returning String.typ)
      String.s x0  x1 

    (** Returns a copy of the string with escaped characters replaced by their meanings according to the XML standard. *)
    let xml_unescape x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_STRING_NAME
      "xml_unescape"
      3942272618L
      (StringName.typ @-> returning String.typ)
      String.s x0 

    (** Encodes the string to URL-friendly format. This method is meant to properly encode the parameters in a URL when sending an HTTP request. See also \[method uri_decode\].
\[codeblocks\]
\[gdscript\]
var prefix = ""$DOCS_URL/?highlight=""
var url = prefix + ""Godot Engine:docs"".uri_encode()

print(url) # Prints ""$DOCS_URL/?highlight=Godot%20Engine%3%docs""
\[/gdscript\]
\[csharp\]
var prefix = ""$DOCS_URL/?highlight="";
var url = prefix + ""Godot Engine:docs"".URIEncode();

GD.Print(url); // Prints ""$DOCS_URL/?highlight=Godot%20Engine%3%docs""
\[/csharp\]
\[/codeblocks\] *)
    let uri_encode x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_STRING_NAME
      "uri_encode"
      3942272618L
      (StringName.typ @-> returning String.typ)
      String.s x0 

    (** Decodes the string from its URL-encoded format. This method is meant to properly decode the parameters in a URL when receiving an HTTP request. See also \[method uri_encode\].
\[codeblocks\]
\[gdscript\]
var url = ""$DOCS_URL/?highlight=Godot%20Engine%3%docs""
print(url.uri_decode()) # Prints ""$DOCS_URL/?highlight=Godot Engine:docs""
\[/gdscript\]
\[csharp\]
var url = ""$DOCS_URL/?highlight=Godot%20Engine%3%docs""
GD.Print(url.URIDecode()) // Prints ""$DOCS_URL/?highlight=Godot Engine:docs""
\[/csharp\]
\[/codeblocks\] *)
    let uri_decode x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_STRING_NAME
      "uri_decode"
      3942272618L
      (StringName.typ @-> returning String.typ)
      String.s x0 

    (** Returns a copy of the string with special characters escaped using the C language standard. *)
    let c_escape x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_STRING_NAME
      "c_escape"
      3942272618L
      (StringName.typ @-> returning String.typ)
      String.s x0 

    (** Returns a copy of the string with escaped characters replaced by their meanings. Supported escape sequences are \[code\]\''\[/code\], \[code\]\""\[/code\], \[code\]\\\[/code\], \[code\]\a\[/code\], \[code\]\b\[/code\], \[code\]\f\[/code\], \[code\]\n\[/code\], \[code\]\r\[/code\], \[code\]\t\[/code\], \[code\]\v\[/code\].
\[b\]Note:\[/b\] Unlike the GDScript parser, this method doesn''t support the \[code\]\uXXXX\[/code\] escape sequence. *)
    let c_unescape x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_STRING_NAME
      "c_unescape"
      3942272618L
      (StringName.typ @-> returning String.typ)
      String.s x0 

    (** Returns a copy of the string with special characters escaped using the JSON standard. Because it closely matches the C standard, it is possible to use \[method c_unescape\] to unescape the string, if necessary. *)
    let json_escape x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_STRING_NAME
      "json_escape"
      3942272618L
      (StringName.typ @-> returning String.typ)
      String.s x0 

    (** Returns a copy of the string with all characters that are not allowed in \[member Node.name\] (\[code\].\[/code\] \[code\]:\[/code\] \[code\]\@\[/code\] \[code\]/\[/code\] \[code\]""\[/code\] \[code\]%\[/code\]) replaced with underscores. *)
    let validate_node_name x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_STRING_NAME
      "validate_node_name"
      3942272618L
      (StringName.typ @-> returning String.typ)
      String.s x0 

    (** Returns a copy of the string with all characters that are not allowed in \[method is_valid_filename\] replaced with underscores. *)
    let validate_filename x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_STRING_NAME
      "validate_filename"
      3942272618L
      (StringName.typ @-> returning String.typ)
      String.s x0 

    (** Returns \[code\]true\[/code\] if this string is a valid ASCII identifier. A valid ASCII identifier may contain only letters, digits, and underscores (\[code\]_\[/code\]), and the first character may not be a digit.
\[codeblock\]
print(""node_2d"".is_valid_ascii_identifier())    # Prints true
print(""TYPE_FLOAT"".is_valid_ascii_identifier()) # Prints true
print(""1st_method"".is_valid_ascii_identifier()) # Prints false
print(""MyMethod#2"".is_valid_ascii_identifier()) # Prints false
\[/codeblock\]
See also \[method is_valid_unicode_identifier\]. *)
    let is_valid_ascii_identifier x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_STRING_NAME
      "is_valid_ascii_identifier"
      3918633141L
      (StringName.typ @-> returning Bool.typ)
      Bool.s x0 

    (** Returns \[code\]true\[/code\] if this string is a valid Unicode identifier.
A valid Unicode identifier must begin with a Unicode character of class \[code\]XID_Start\[/code\] or \[code\]""_""\[/code\], and may contain Unicode characters of class \[code\]XID_Continue\[/code\] in the other positions.
\[codeblock\]
print(""node_2d"".is_valid_unicode_identifier())      # Prints true
print(""1st_method"".is_valid_unicode_identifier())   # Prints false
print(""MyMethod#2"".is_valid_unicode_identifier())   # Prints false
print(""llkpessg"".is_valid_unicode_identifier()) # Prints true
print("""".is_valid_unicode_identifier()) # Prints true
print("""".is_valid_unicode_identifier())         # Prints true
\[/codeblock\]
See also \[method is_valid_ascii_identifier\].
\[b\]Note:\[/b\] This method checks identifiers the same way as GDScript. See \[method TextServer.is_valid_identifier\] for more advanced checks. *)
    let is_valid_unicode_identifier x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_STRING_NAME
      "is_valid_unicode_identifier"
      3918633141L
      (StringName.typ @-> returning Bool.typ)
      Bool.s x0 

    (** Returns \[code\]true\[/code\] if this string is a valid identifier. A valid identifier may contain only letters, digits and underscores (\[code\]_\[/code\]), and the first character may not be a digit.
\[codeblock\]
print(""node_2d"".is_valid_identifier())    # Prints true
print(""TYPE_FLOAT"".is_valid_identifier()) # Prints true
print(""1st_method"".is_valid_identifier()) # Prints false
print(""MyMethod#2"".is_valid_identifier()) # Prints false
\[/codeblock\] *)
    let is_valid_identifier x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_STRING_NAME
      "is_valid_identifier"
      3918633141L
      (StringName.typ @-> returning Bool.typ)
      Bool.s x0 

    (** Returns \[code\]true\[/code\] if this string represents a valid integer. A valid integer only contains digits, and may be prefixed with a positive (\[code\]+\[/code\]) or negative (\[code\]-\[/code\]) sign. See also \[method to_int\].
\[codeblock\]
print(""7"".is_valid_int())    # Prints true
print(""1.65"".is_valid_int()) # Prints false
print(""Hi"".is_valid_int())   # Prints false
print(""+3"".is_valid_int())   # Prints true
print(""-12"".is_valid_int())  # Prints true
\[/codeblock\] *)
    let is_valid_int x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_STRING_NAME
      "is_valid_int"
      3918633141L
      (StringName.typ @-> returning Bool.typ)
      Bool.s x0 

    (** Returns \[code\]true\[/code\] if this string represents a valid floating-point number. A valid float may contain only digits, one decimal point (\[code\].\[/code\]), and the exponent letter (\[code\]e\[/code\]). It may also be prefixed with a positive (\[code\]+\[/code\]) or negative (\[code\]-\[/code\]) sign. Any valid integer is also a valid float (see \[method is_valid_int\]). See also \[method to_float\].
\[codeblock\]
print(""1.7"".is_valid_float())   # Prints true
print(""24"".is_valid_float())    # Prints true
print(""7e3"".is_valid_float())   # Prints true
print(""Hello"".is_valid_float()) # Prints false
\[/codeblock\] *)
    let is_valid_float x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_STRING_NAME
      "is_valid_float"
      3918633141L
      (StringName.typ @-> returning Bool.typ)
      Bool.s x0 

    (** Returns \[code\]true\[/code\] if this string is a valid hexadecimal number. A valid hexadecimal number only contains digits or letters \[code\]A\[/code\] to \[code\]F\[/code\] (either uppercase or lowercase), and may be prefixed with a positive (\[code\]+\[/code\]) or negative (\[code\]-\[/code\]) sign.
If \[param with_prefix\] is \[code\]true\[/code\], the hexadecimal number needs to prefixed by \[code\]""0x""\[/code\] to be considered valid.
\[codeblock\]
print(""A08E"".is_valid_hex_number())    # Prints true
print(""-AbCdEf"".is_valid_hex_number()) # Prints true
print(""2.5"".is_valid_hex_number())     # Prints false

print(""0xDEADC0DE"".is_valid_hex_number(true)) # Prints true
\[/codeblock\] *)
    let is_valid_hex_number x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_STRING_NAME
      "is_valid_hex_number"
      593672999L
      (Bool.typ @-> StringName.typ @-> returning Bool.typ)
      Bool.s x0  x1 

    (** Returns \[code\]true\[/code\] if this string is a valid color in hexadecimal HTML notation. The string must be a hexadecimal value (see \[method is_valid_hex_number\]) of either 3, 4, 6 or 8 digits, and may be prefixed by a hash sign (\[code\]#\[/code\]). Other HTML notations for colors, such as names or \[code\]hsl()\[/code\], are not considered valid. See also \[method Color.html\]. *)
    let is_valid_html_color x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_STRING_NAME
      "is_valid_html_color"
      3918633141L
      (StringName.typ @-> returning Bool.typ)
      Bool.s x0 

    (** Returns \[code\]true\[/code\] if this string represents a well-formatted IPv4 or IPv6 address. This method considers \[url=https://en.wikipedia.org/wiki/Reserved_IP_addresses\]reserved IP addresses\[/url\] such as \[code\]""0.0.0.0""\[/code\] and \[code\]""ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff""\[/code\] as valid. *)
    let is_valid_ip_address x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_STRING_NAME
      "is_valid_ip_address"
      3918633141L
      (StringName.typ @-> returning Bool.typ)
      Bool.s x0 

    (** Returns \[code\]true\[/code\] if this string does not contain characters that are not allowed in file names (\[code\]:\[/code\] \[code\]/\[/code\] \[code\]\\[/code\] \[code\]?\[/code\] \[code\] * \[/code\] \[code\]""\[/code\] \[code\]|\[/code\] \[code\]%\[/code\] \[code\]<\[/code\] \[code\]>\[/code\]). *)
    let is_valid_filename x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_STRING_NAME
      "is_valid_filename"
      3918633141L
      (StringName.typ @-> returning Bool.typ)
      Bool.s x0 

    (** Converts the string representing an integer number into an \[int\]. This method removes any non-number character and stops at the first decimal point (\[code\].\[/code\]). See also \[method is_valid_int\].
\[codeblock\]
var a = ""123"".to_int()    # a is 123
var b = ""x1y2z3"".to_int() # b is 123
var c = ""-1.2.3"".to_int() # c is -1
var d = ""Hello!"".to_int() # d is 0
\[/codeblock\] *)
    let to_int x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_STRING_NAME
      "to_int"
      3173160232L
      (StringName.typ @-> returning Int.typ)
      Int.s x0 

    (** Converts the string representing a decimal number into a \[float\]. This method stops on the first non-number character, except the first decimal point (\[code\].\[/code\]) and the exponent letter (\[code\]e\[/code\]). See also \[method is_valid_float\].
\[codeblock\]
var a = ""12.35"".to_float()  # a is 12.35
var b = ""1.2.3"".to_float()  # b is 1.2
var c = ""12xy3"".to_float()  # c is 12.0
var d = ""1e3"".to_float()    # d is 1000.0
var e = ""Hello!"".to_float() # e is 0.0
\[/codeblock\] *)
    let to_float x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_STRING_NAME
      "to_float"
      466405837L
      (StringName.typ @-> returning Float.typ)
      Float.s x0 

    (** Converts the string representing a hexadecimal number into an \[int\]. The string may be optionally prefixed with \[code\]""0x""\[/code\], and an additional \[code\]-\[/code\] prefix for negative numbers.
\[codeblocks\]
\[gdscript\]
print(""0xff"".hex_to_int()) # Prints 255
print(""ab"".hex_to_int())   # Prints 171
\[/gdscript\]
\[csharp\]
GD.Print(""0xff"".HexToInt()); // Prints 255
GD.Print(""ab"".HexToInt());   // Prints 171
\[/csharp\]
\[/codeblocks\] *)
    let hex_to_int x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_STRING_NAME
      "hex_to_int"
      3173160232L
      (StringName.typ @-> returning Int.typ)
      Int.s x0 

    (** Converts the string representing a binary number into an \[int\]. The string may optionally be prefixed with \[code\]""0b""\[/code\], and an additional \[code\]-\[/code\] prefix for negative numbers.
\[codeblocks\]
\[gdscript\]
print(""101"".bin_to_int())   # Prints 5
print(""0b101"".bin_to_int()) # Prints 5
print(""-0b10"".bin_to_int()) # Prints -2
\[/gdscript\]
\[csharp\]
GD.Print(""101"".BinToInt());   // Prints 5
GD.Print(""0b101"".BinToInt()); // Prints 5
GD.Print(""-0b10"".BinToInt()); // Prints -2
\[/csharp\]
\[/codeblocks\] *)
    let bin_to_int x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_STRING_NAME
      "bin_to_int"
      3173160232L
      (StringName.typ @-> returning Int.typ)
      Int.s x0 

    (** Formats the string to be at least \[param min_length\] long by adding \[param character\]s to the left of the string, if necessary. See also \[method rpad\]. *)
    let lpad x0  x1  x2  = 
    foreign_builtin_method2
      GlobalEnum.VariantType._TYPE_STRING_NAME
      "lpad"
      248737229L
      (Int.typ @-> String.typ @-> StringName.typ @-> returning String.typ)
      String.s x0  x1  x2 

    (** Formats the string to be at least \[param min_length\] long, by adding \[param character\]s to the right of the string, if necessary. See also \[method lpad\]. *)
    let rpad x0  x1  x2  = 
    foreign_builtin_method2
      GlobalEnum.VariantType._TYPE_STRING_NAME
      "rpad"
      248737229L
      (Int.typ @-> String.typ @-> StringName.typ @-> returning String.typ)
      String.s x0  x1  x2 

    (** Formats the string representing a number to have an exact number of \[param digits\] \[i\]after\[/i\] the decimal point. *)
    let pad_decimals x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_STRING_NAME
      "pad_decimals"
      2162347432L
      (Int.typ @-> StringName.typ @-> returning String.typ)
      String.s x0  x1 

    (** Formats the string representing a number to have an exact number of \[param digits\] \[i\]before\[/i\] the decimal point. *)
    let pad_zeros x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_STRING_NAME
      "pad_zeros"
      2162347432L
      (Int.typ @-> StringName.typ @-> returning String.typ)
      String.s x0  x1 

    (** Removes the given \[param prefix\] from the start of the string, or returns the string unchanged. *)
    let trim_prefix x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_STRING_NAME
      "trim_prefix"
      3134094431L
      (String.typ @-> StringName.typ @-> returning String.typ)
      String.s x0  x1 

    (** Removes the given \[param suffix\] from the end of the string, or returns the string unchanged. *)
    let trim_suffix x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_STRING_NAME
      "trim_suffix"
      3134094431L
      (String.typ @-> StringName.typ @-> returning String.typ)
      String.s x0  x1 

    (** Converts the string to an \[url=https://en.wikipedia.org/wiki/ASCII\]ASCII\[/url\]/Latin-1 encoded \[PackedByteArray\]. This method is slightly faster than \[method to_utf8_buffer\], but replaces all unsupported characters with spaces. This is the inverse of \[method PackedByteArray.get_string_from_ascii\]. *)
    let to_ascii_buffer x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_STRING_NAME
      "to_ascii_buffer"
      247621236L
      (StringName.typ @-> returning PackedByteArray.typ)
      PackedByteArray.s x0 

    (** Converts the string to a \[url=https://en.wikipedia.org/wiki/UTF-8\]UTF-8\[/url\] encoded \[PackedByteArray\]. This method is slightly slower than \[method to_ascii_buffer\], but supports all UTF-8 characters. For most cases, prefer using this method. This is the inverse of \[method PackedByteArray.get_string_from_utf8\]. *)
    let to_utf8_buffer x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_STRING_NAME
      "to_utf8_buffer"
      247621236L
      (StringName.typ @-> returning PackedByteArray.typ)
      PackedByteArray.s x0 

    (** Converts the string to a \[url=https://en.wikipedia.org/wiki/UTF-16\]UTF-16\[/url\] encoded \[PackedByteArray\]. This is the inverse of \[method PackedByteArray.get_string_from_utf16\]. *)
    let to_utf16_buffer x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_STRING_NAME
      "to_utf16_buffer"
      247621236L
      (StringName.typ @-> returning PackedByteArray.typ)
      PackedByteArray.s x0 

    (** Converts the string to a \[url=https://en.wikipedia.org/wiki/UTF-32\]UTF-32\[/url\] encoded \[PackedByteArray\]. This is the inverse of \[method PackedByteArray.get_string_from_utf32\]. *)
    let to_utf32_buffer x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_STRING_NAME
      "to_utf32_buffer"
      247621236L
      (StringName.typ @-> returning PackedByteArray.typ)
      PackedByteArray.s x0 

    (** Decodes a hexadecimal string as a \[PackedByteArray\].
\[codeblocks\]
\[gdscript\]
var text = ""hello world""
var encoded = text.to_utf8_buffer().hex_encode() # outputs ""68656c6c6f20776f726c64""
print(buf.hex_decode().get_string_from_utf8())
\[/gdscript\]
\[csharp\]
var text = ""hello world"";
var encoded = text.ToUtf8Buffer().HexEncode(); // outputs ""68656c6c6f20776f726c64""
GD.Print(buf.HexDecode().GetStringFromUtf8());
\[/csharp\]
\[/codeblocks\] *)
    let hex_decode x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_STRING_NAME
      "hex_decode"
      247621236L
      (StringName.typ @-> returning PackedByteArray.typ)
      PackedByteArray.s x0 

    (** Converts the string to a \[url=https://en.wikipedia.org/wiki/Wide_character\]wide character\[/url\] (\[code\]wchar_t\[/code\], UTF-16 on Windows, UTF-32 on other platforms) encoded \[PackedByteArray\]. This is the inverse of \[method PackedByteArray.get_string_from_wchar\]. *)
    let to_wchar_buffer x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_STRING_NAME
      "to_wchar_buffer"
      247621236L
      (StringName.typ @-> returning PackedByteArray.typ)
      PackedByteArray.s x0 

    (** Returns the 32-bit hash value representing the string''s contents.
\[b\]Note:\[/b\] Strings with equal hash values are \[i\]not\[/i\] guaranteed to be the same, as a result of hash collisions. On the contrary, strings with different hash values are guaranteed to be different. *)
    let hash x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_STRING_NAME
      "hash"
      3173160232L
      (StringName.typ @-> returning Int.typ)
      Int.s x0 








    let not x0  = 
    foreign_builtin_operator1 GlobalEnum.VariantType._TYPE_STRING_NAME None  GlobalEnum.VariantOperator._OP_NOT
      (funptr (StringName.typ @-> Bool.typ @-> returning void))
      Bool.s x0 
















    let mem_String x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_STRING_NAME (Some GlobalEnum.VariantType._TYPE_STRING) GlobalEnum.VariantOperator._OP_IN
      (funptr (StringName.typ @-> String.typ @-> Bool.typ @-> returning void))
      Bool.s x0  x1 

































    (** Returns \[code\]true\[/code\] if the \[StringName\] and \[param right\] refer to the same name. Comparisons between \[StringName\]s are much faster than regular \[String\] comparisons. *)
    let (=) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_STRING_NAME (Some GlobalEnum.VariantType._TYPE_STRING_NAME) GlobalEnum.VariantOperator._OP_EQUAL
      (funptr (StringName.typ @-> StringName.typ @-> Bool.typ @-> returning void))
      Bool.s
      Conv.StringName.of_ocaml
      Conv.StringName.of_ocaml
      Conv.Bool.to_ocaml x0  x1 

    (** Returns \[code\]true\[/code\] if the \[StringName\] and \[param right\] do not refer to the same name. Comparisons between \[StringName\]s are much faster than regular \[String\] comparisons. *)
    let (<>) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_STRING_NAME (Some GlobalEnum.VariantType._TYPE_STRING_NAME) GlobalEnum.VariantOperator._OP_NOT_EQUAL
      (funptr (StringName.typ @-> StringName.typ @-> Bool.typ @-> returning void))
      Bool.s
      Conv.StringName.of_ocaml
      Conv.StringName.of_ocaml
      Conv.Bool.to_ocaml x0  x1 

    (** Returns \[code\]true\[/code\] if the left \[StringName\]''s pointer comes before \[param right\]. Note that this will not match their \[url=https://en.wikipedia.org/wiki/List_of_Unicode_characters\]Unicode order\[/url\]. *)
    let (<) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_STRING_NAME (Some GlobalEnum.VariantType._TYPE_STRING_NAME) GlobalEnum.VariantOperator._OP_LESS
      (funptr (StringName.typ @-> StringName.typ @-> Bool.typ @-> returning void))
      Bool.s
      Conv.StringName.of_ocaml
      Conv.StringName.of_ocaml
      Conv.Bool.to_ocaml x0  x1 

    (** Returns \[code\]true\[/code\] if the left \[StringName\]''s pointer comes before \[param right\] or if they are the same. Note that this will not match their \[url=https://en.wikipedia.org/wiki/List_of_Unicode_characters\]Unicode order\[/url\]. *)
    let (<=) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_STRING_NAME (Some GlobalEnum.VariantType._TYPE_STRING_NAME) GlobalEnum.VariantOperator._OP_LESS_EQUAL
      (funptr (StringName.typ @-> StringName.typ @-> Bool.typ @-> returning void))
      Bool.s
      Conv.StringName.of_ocaml
      Conv.StringName.of_ocaml
      Conv.Bool.to_ocaml x0  x1 

    (** Returns \[code\]true\[/code\] if the left \[StringName\]''s pointer comes after \[param right\]. Note that this will not match their \[url=https://en.wikipedia.org/wiki/List_of_Unicode_characters\]Unicode order\[/url\]. *)
    let (>) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_STRING_NAME (Some GlobalEnum.VariantType._TYPE_STRING_NAME) GlobalEnum.VariantOperator._OP_GREATER
      (funptr (StringName.typ @-> StringName.typ @-> Bool.typ @-> returning void))
      Bool.s
      Conv.StringName.of_ocaml
      Conv.StringName.of_ocaml
      Conv.Bool.to_ocaml x0  x1 

    (** Returns \[code\]true\[/code\] if the left \[StringName\]''s pointer comes after \[param right\] or if they are the same. Note that this will not match their \[url=https://en.wikipedia.org/wiki/List_of_Unicode_characters\]Unicode order\[/url\]. *)
    let (>=) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_STRING_NAME (Some GlobalEnum.VariantType._TYPE_STRING_NAME) GlobalEnum.VariantOperator._OP_GREATER_EQUAL
      (funptr (StringName.typ @-> StringName.typ @-> Bool.typ @-> returning void))
      Bool.s
      Conv.StringName.of_ocaml
      Conv.StringName.of_ocaml
      Conv.Bool.to_ocaml x0  x1 

    (** Appends \[param right\] at the end of this \[StringName\], returning a \[String\]. This is also known as a string concatenation. *)
    let (+) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_STRING_NAME (Some GlobalEnum.VariantType._TYPE_STRING_NAME) GlobalEnum.VariantOperator._OP_ADD
      (funptr (StringName.typ @-> StringName.typ @-> String.typ @-> returning void))
      String.s
      Conv.StringName.of_ocaml
      Conv.StringName.of_ocaml
      Conv.String.to_ocaml x0  x1 


    let (%) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_STRING_NAME (Some GlobalEnum.VariantType._TYPE_STRING_NAME) GlobalEnum.VariantOperator._OP_MODULE
      (funptr (StringName.typ @-> StringName.typ @-> String.typ @-> returning void))
      String.s
      Conv.StringName.of_ocaml
      Conv.StringName.of_ocaml
      Conv.String.to_ocaml x0  x1 


    let mem_StringName x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_STRING_NAME (Some GlobalEnum.VariantType._TYPE_STRING_NAME) GlobalEnum.VariantOperator._OP_IN
      (funptr (StringName.typ @-> StringName.typ @-> Bool.typ @-> returning void))
      Bool.s x0  x1 






    let mem_Object x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_STRING_NAME (Some GlobalEnum.VariantType._TYPE_OBJECT) GlobalEnum.VariantOperator._OP_IN
      (funptr (StringName.typ @-> Object.typ @-> Bool.typ @-> returning void))
      Bool.s x0  x1 








    let mem_Dictionary x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_STRING_NAME (Some GlobalEnum.VariantType._TYPE_DICTIONARY) GlobalEnum.VariantOperator._OP_IN
      (funptr (StringName.typ @-> Dictionary.typ @-> Bool.typ @-> returning void))
      Bool.s x0  x1 




    let mem_Array x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_STRING_NAME (Some GlobalEnum.VariantType._TYPE_ARRAY) GlobalEnum.VariantOperator._OP_IN
      (funptr (StringName.typ @-> Array.typ @-> Bool.typ @-> returning void))
      Bool.s x0  x1 














    let mem_PackedStringArray x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_STRING_NAME (Some GlobalEnum.VariantType._TYPE_PACKED_STRING_ARRAY) GlobalEnum.VariantOperator._OP_IN
      (funptr (StringName.typ @-> PackedStringArray.typ @-> Bool.typ @-> returning void))
      Bool.s x0  x1 








    end

  module NodePath = struct
    include M.NodePath
include BuiltinClass0.NodePath

    (** Returns \[code\]true\[/code\] if the node path is absolute. Unlike a relative path, an absolute path is represented by a leading slash character (\[code\]/\[/code\]) and always begins from the \[SceneTree\]. It can be used to reliably access nodes from the root node (e.g. \[code\]""/root/Global""\[/code\] if an autoload named ""Global"" exists). *)
    let is_absolute x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_NODE_PATH
      "is_absolute"
      3918633141L
      (NodePath.typ @-> returning Bool.typ)
      Bool.s x0 

    (** Returns the number of node names in the path. Property subnames are not included.
For example, \[code\]""../RigidBody2D/Sprite2D:texture""\[/code\] contains 3 node names. *)
    let get_name_count x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_NODE_PATH
      "get_name_count"
      3173160232L
      (NodePath.typ @-> returning Int.typ)
      Int.s x0 

    (** Returns the node name indicated by \[param idx\], starting from 0. If \[param idx\] is out of bounds, an error is generated. See also \[method get_subname_count\] and \[method get_name_count\].
\[codeblocks\]
\[gdscript\]
var sprite_path = NodePath(""../RigidBody2D/Sprite2D"")
print(sprite_path.get_name(0)) # Prints ""..""
print(sprite_path.get_name(1)) # Prints ""RigidBody2D""
print(sprite_path.get_name(2)) # Prints ""Sprite""
\[/gdscript\]
\[csharp\]
var spritePath = new NodePath(""../RigidBody2D/Sprite2D"");
GD.Print(spritePath.GetName(0)); // Prints ""..""
GD.Print(spritePath.GetName(1)); // Prints ""PathFollow2D""
GD.Print(spritePath.GetName(2)); // Prints ""Sprite""
\[/csharp\]
\[/codeblocks\] *)
    let get_name x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_NODE_PATH
      "get_name"
      2948586938L
      (Int.typ @-> NodePath.typ @-> returning StringName.typ)
      StringName.s x0  x1 

    (** Returns the number of property names (""subnames"") in the path. Each subname in the node path is listed after a colon character (\[code\]:\[/code\]).
For example, \[code\]""Level/RigidBody2D/Sprite2D:texture:resource_name""\[/code\] contains 2 subnames. *)
    let get_subname_count x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_NODE_PATH
      "get_subname_count"
      3173160232L
      (NodePath.typ @-> returning Int.typ)
      Int.s x0 

    (** Returns the 32-bit hash value representing the node path''s contents.
\[b\]Note:\[/b\] Node paths with equal hash values are \[i\]not\[/i\] guaranteed to be the same, as a result of hash collisions. Node paths with different hash values are guaranteed to be different. *)
    let hash x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_NODE_PATH
      "hash"
      3173160232L
      (NodePath.typ @-> returning Int.typ)
      Int.s x0 

    (** Returns the property name indicated by \[param idx\], starting from 0. If \[param idx\] is out of bounds, an error is generated. See also \[method get_subname_count\].
\[codeblocks\]
\[gdscript\]
var path_to_name = NodePath(""Sprite2D:texture:resource_name"")
print(path_to_name.get_subname(0)) # Prints ""texture""
print(path_to_name.get_subname(1)) # Prints ""resource_name""
\[/gdscript\]
\[csharp\]
var pathToName = new NodePath(""Sprite2D:texture:resource_name"");
GD.Print(pathToName.GetSubname(0)); // Prints ""texture""
GD.Print(pathToName.GetSubname(1)); // Prints ""resource_name""
\[/csharp\]
\[/codeblocks\] *)
    let get_subname x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_NODE_PATH
      "get_subname"
      2948586938L
      (Int.typ @-> NodePath.typ @-> returning StringName.typ)
      StringName.s x0  x1 

    (** Returns all node names concatenated with a slash character (\[code\]/\[/code\]) as a single \[StringName\]. *)
    let get_concatenated_names x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_NODE_PATH
      "get_concatenated_names"
      1825232092L
      (NodePath.typ @-> returning StringName.typ)
      StringName.s x0 

    (** Returns all property subnames concatenated with a colon character (\[code\]:\[/code\]) as a single \[StringName\].
\[codeblocks\]
\[gdscript\]
var node_path = ^""Sprite2D:texture:resource_name""
print(node_path.get_concatenated_subnames()) # Prints ""texture:resource_name""
\[/gdscript\]
\[csharp\]
var nodePath = new NodePath(""Sprite2D:texture:resource_name"");
GD.Print(nodePath.GetConcatenatedSubnames()); // Prints ""texture:resource_name""
\[/csharp\]
\[/codeblocks\] *)
    let get_concatenated_subnames x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_NODE_PATH
      "get_concatenated_subnames"
      1825232092L
      (NodePath.typ @-> returning StringName.typ)
      StringName.s x0 

    (** Returns the slice of the \[NodePath\], from \[param begin\] (inclusive) to \[param end\] (exclusive), as a new \[NodePath\].
The absolute value of \[param begin\] and \[param end\] will be clamped to the sum of \[method get_name_count\] and \[method get_subname_count\], so the default value for \[param end\] makes it slice to the end of the \[NodePath\] by default (i.e. \[code\]path.slice(1)\[/code\] is a shorthand for \[code\]path.slice(1, path.get_name_count() + path.get_subname_count())\[/code\]).
If either \[param begin\] or \[param end\] are negative, they will be relative to the end of the \[NodePath\] (i.e. \[code\]path.slice(0, -2)\[/code\] is a shorthand for \[code\]path.slice(0, path.get_name_count() + path.get_subname_count() - 2)\[/code\]). *)
    let slice x0  x1  x2  = 
    foreign_builtin_method2
      GlobalEnum.VariantType._TYPE_NODE_PATH
      "slice"
      421628484L
      (Int.typ @-> Int.typ @-> NodePath.typ @-> returning NodePath.typ)
      NodePath.s x0  x1  x2 

    (** Returns a copy of this node path with a colon character (\[code\]:\[/code\]) prefixed, transforming it to a pure property path with no node names (relative to the current node).
\[codeblocks\]
\[gdscript\]
# node_path points to the ""x"" property of the child node named ""position"".
var node_path = ^""position:x""

# property_path points to the ""position"" in the ""x"" axis of this node.
var property_path = node_path.get_as_property_path()
print(property_path) # Prints "":position:x""
\[/gdscript\]
\[csharp\]
// nodePath points to the ""x"" property of the child node named ""position"".
var nodePath = new NodePath(""position:x"");

// propertyPath points to the ""position"" in the ""x"" axis of this node.
NodePath propertyPath = nodePath.GetAsPropertyPath();
GD.Print(propertyPath); // Prints "":position:x""
\[/csharp\]
\[/codeblocks\] *)
    let get_as_property_path x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_NODE_PATH
      "get_as_property_path"
      1598598043L
      (NodePath.typ @-> returning NodePath.typ)
      NodePath.s x0 

    (** Returns \[code\]true\[/code\] if the node path has been constructed from an empty \[String\] (\[code\]""""\[/code\]). *)
    let is_empty x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_NODE_PATH
      "is_empty"
      3918633141L
      (NodePath.typ @-> returning Bool.typ)
      Bool.s x0 






    let not x0  = 
    foreign_builtin_operator1 GlobalEnum.VariantType._TYPE_NODE_PATH None  GlobalEnum.VariantOperator._OP_NOT
      (funptr (NodePath.typ @-> Bool.typ @-> returning void))
      Bool.s x0 

    (** Returns \[code\]true\[/code\] if two node paths are equal, that is, they are composed of the same node names and subnames in the same order. *)
    let (=) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_NODE_PATH (Some GlobalEnum.VariantType._TYPE_NODE_PATH) GlobalEnum.VariantOperator._OP_EQUAL
      (funptr (NodePath.typ @-> NodePath.typ @-> Bool.typ @-> returning void))
      Bool.s
      Conv.NodePath.of_ocaml
      Conv.NodePath.of_ocaml
      Conv.Bool.to_ocaml x0  x1 

    (** Returns \[code\]true\[/code\] if two node paths are not equal. *)
    let (<>) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_NODE_PATH (Some GlobalEnum.VariantType._TYPE_NODE_PATH) GlobalEnum.VariantOperator._OP_NOT_EQUAL
      (funptr (NodePath.typ @-> NodePath.typ @-> Bool.typ @-> returning void))
      Bool.s
      Conv.NodePath.of_ocaml
      Conv.NodePath.of_ocaml
      Conv.Bool.to_ocaml x0  x1 


    let mem_Dictionary x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_NODE_PATH (Some GlobalEnum.VariantType._TYPE_DICTIONARY) GlobalEnum.VariantOperator._OP_IN
      (funptr (NodePath.typ @-> Dictionary.typ @-> Bool.typ @-> returning void))
      Bool.s x0  x1 


    let mem_Array x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_NODE_PATH (Some GlobalEnum.VariantType._TYPE_ARRAY) GlobalEnum.VariantOperator._OP_IN
      (funptr (NodePath.typ @-> Array.typ @-> Bool.typ @-> returning void))
      Bool.s x0  x1 
    end

  module RID = struct
    include M.RID
include BuiltinClass0.RID

    (** Returns \[code\]true\[/code\] if the \[RID\] is not \[code\]0\[/code\]. *)
    let is_valid x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_RID
      "is_valid"
      3918633141L
      (RID.typ @-> returning Bool.typ)
      Bool.s x0 

    (** Returns the ID of the referenced low-level resource. *)
    let get_id x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_RID
      "get_id"
      3173160232L
      (RID.typ @-> returning Int.typ)
      Int.s x0 






    let not x0  = 
    foreign_builtin_operator1 GlobalEnum.VariantType._TYPE_RID None  GlobalEnum.VariantOperator._OP_NOT
      (funptr (RID.typ @-> Bool.typ @-> returning void))
      Bool.s x0 

    (** Returns \[code\]true\[/code\] if both \[RID\]s are equal, which means they both refer to the same low-level resource. *)
    let (=) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_RID (Some GlobalEnum.VariantType._TYPE_RID) GlobalEnum.VariantOperator._OP_EQUAL
      (funptr (RID.typ @-> RID.typ @-> Bool.typ @-> returning void))
      Bool.s
      Conv.RID.of_ocaml
      Conv.RID.of_ocaml
      Conv.Bool.to_ocaml x0  x1 

    (** Returns \[code\]true\[/code\] if the \[RID\]s are not equal. *)
    let (<>) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_RID (Some GlobalEnum.VariantType._TYPE_RID) GlobalEnum.VariantOperator._OP_NOT_EQUAL
      (funptr (RID.typ @-> RID.typ @-> Bool.typ @-> returning void))
      Bool.s
      Conv.RID.of_ocaml
      Conv.RID.of_ocaml
      Conv.Bool.to_ocaml x0  x1 

    (** Returns \[code\]true\[/code\] if the \[RID\]''s ID is less than \[param right\]''s ID. *)
    let (<) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_RID (Some GlobalEnum.VariantType._TYPE_RID) GlobalEnum.VariantOperator._OP_LESS
      (funptr (RID.typ @-> RID.typ @-> Bool.typ @-> returning void))
      Bool.s
      Conv.RID.of_ocaml
      Conv.RID.of_ocaml
      Conv.Bool.to_ocaml x0  x1 

    (** Returns \[code\]true\[/code\] if the \[RID\]''s ID is less than or equal to \[param right\]''s ID. *)
    let (<=) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_RID (Some GlobalEnum.VariantType._TYPE_RID) GlobalEnum.VariantOperator._OP_LESS_EQUAL
      (funptr (RID.typ @-> RID.typ @-> Bool.typ @-> returning void))
      Bool.s
      Conv.RID.of_ocaml
      Conv.RID.of_ocaml
      Conv.Bool.to_ocaml x0  x1 

    (** Returns \[code\]true\[/code\] if the \[RID\]''s ID is greater than \[param right\]''s ID. *)
    let (>) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_RID (Some GlobalEnum.VariantType._TYPE_RID) GlobalEnum.VariantOperator._OP_GREATER
      (funptr (RID.typ @-> RID.typ @-> Bool.typ @-> returning void))
      Bool.s
      Conv.RID.of_ocaml
      Conv.RID.of_ocaml
      Conv.Bool.to_ocaml x0  x1 

    (** Returns \[code\]true\[/code\] if the \[RID\]''s ID is greater than or equal to \[param right\]''s ID. *)
    let (>=) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_RID (Some GlobalEnum.VariantType._TYPE_RID) GlobalEnum.VariantOperator._OP_GREATER_EQUAL
      (funptr (RID.typ @-> RID.typ @-> Bool.typ @-> returning void))
      Bool.s
      Conv.RID.of_ocaml
      Conv.RID.of_ocaml
      Conv.Bool.to_ocaml x0  x1 


    let mem_Dictionary x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_RID (Some GlobalEnum.VariantType._TYPE_DICTIONARY) GlobalEnum.VariantOperator._OP_IN
      (funptr (RID.typ @-> Dictionary.typ @-> Bool.typ @-> returning void))
      Bool.s x0  x1 


    let mem_Array x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_RID (Some GlobalEnum.VariantType._TYPE_ARRAY) GlobalEnum.VariantOperator._OP_IN
      (funptr (RID.typ @-> Array.typ @-> Bool.typ @-> returning void))
      Bool.s x0  x1 
    end

  module Callable = struct
    include M.Callable
include BuiltinClass0.Callable

    (** Creates a new \[Callable\] for the method named \[param method\] in the specified \[param variant\]. To represent a method of a built-in \[Variant\] type, a custom callable is used (see \[method is_custom\]). If \[param variant\] is \[Object\], then a standard callable will be created instead.
\[b\]Note:\[/b\] This method is always necessary for the \[Dictionary\] type, as property syntax is used to access its entries. You may also use this method when \[param variant\]''s type is not known in advance (for polymorphism). *)
    let create x0  x1  = 
    foreign_builtin_method2_static
      GlobalEnum.VariantType._TYPE_CALLABLE
      "create"
      1709381114L
      (Variant.typ @-> StringName.typ @-> returning Callable.typ)
      Callable.s x0  x1 

    (** Calls the method represented by this \[Callable\]. Unlike \[method call\], this method expects all arguments to be contained inside the \[param arguments\] \[Array\]. *)
    let callv x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_CALLABLE
      "callv"
      413578926L
      (Array.typ @-> Callable.typ @-> returning Variant.typ)
      Variant.s x0  x1 

    (** Returns \[code\]true\[/code\] if this \[Callable\] has no target to call the method on. Equivalent to \[code\]callable == Callable()\[/code\].
\[b\]Note:\[/b\] This is \[i\]not\[/i\] the same as \[code\]not is_valid()\[/code\] and using \[code\]not is_null()\[/code\] will \[i\]not\[/i\] guarantee that this callable can be called. Use \[method is_valid\] instead. *)
    let is_null x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_CALLABLE
      "is_null"
      3918633141L
      (Callable.typ @-> returning Bool.typ)
      Bool.s x0 

    (** Returns \[code\]true\[/code\] if this \[Callable\] is a custom callable. Custom callables are used:
- for binding/unbinding arguments (see \[method bind\] and \[method unbind\]);
- for representing methods of built-in \[Variant\] types (see \[method create\]);
- for representing global, lambda, and RPC functions in GDScript;
- for other purposes in the core, GDExtension, and C#. *)
    let is_custom x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_CALLABLE
      "is_custom"
      3918633141L
      (Callable.typ @-> returning Bool.typ)
      Bool.s x0 

    (** Returns \[code\]true\[/code\] if this \[Callable\] is a standard callable. This method is the opposite of \[method is_custom\]. Returns \[code\]false\[/code\] if this callable is a lambda function. *)
    let is_standard x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_CALLABLE
      "is_standard"
      3918633141L
      (Callable.typ @-> returning Bool.typ)
      Bool.s x0 

    (** Returns \[code\]true\[/code\] if the callable''s object exists and has a valid method name assigned, or is a custom callable. *)
    let is_valid x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_CALLABLE
      "is_valid"
      3918633141L
      (Callable.typ @-> returning Bool.typ)
      Bool.s x0 

    (** Returns the object on which this \[Callable\] is called. *)
    let get_object x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_CALLABLE
      "get_object"
      4008621732L
      (Callable.typ @-> returning Object.typ)
      Object.s x0 

    (** Returns the ID of this \[Callable\]''s object (see \[method Object.get_instance_id\]). *)
    let get_object_id x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_CALLABLE
      "get_object_id"
      3173160232L
      (Callable.typ @-> returning Int.typ)
      Int.s x0 

    (** Returns the name of the method represented by this \[Callable\]. If the callable is a GDScript lambda function, returns the function''s name or \[code\]""<anonymous lambda>""\[/code\]. *)
    let get_method x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_CALLABLE
      "get_method"
      1825232092L
      (Callable.typ @-> returning StringName.typ)
      StringName.s x0 

    (** Returns the total number of arguments this \[Callable\] should take, including optional arguments. This means that any arguments bound with \[method bind\] are \[i\]subtracted\[/i\] from the result, and any arguments unbound with \[method unbind\] are \[i\]added\[/i\] to the result. *)
    let get_argument_count x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_CALLABLE
      "get_argument_count"
      3173160232L
      (Callable.typ @-> returning Int.typ)
      Int.s x0 

    (** Returns the total amount of arguments bound via successive \[method bind\] or \[method unbind\] calls. This is the same as the size of the array returned by \[method get_bound_arguments\]. See \[method get_bound_arguments\] for details.
\[b\]Note:\[/b\] The \[method get_bound_arguments_count\] and \[method get_unbound_arguments_count\] methods can both return positive values. *)
    let get_bound_arguments_count x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_CALLABLE
      "get_bound_arguments_count"
      3173160232L
      (Callable.typ @-> returning Int.typ)
      Int.s x0 

    (** Returns the array of arguments bound via successive \[method bind\] or \[method unbind\] calls. These arguments will be added \[i\]after\[/i\] the arguments passed to the call, from which \[method get_unbound_arguments_count\] arguments on the right have been previously excluded.
\[codeblock\]
func get_effective_arguments(callable, call_args):
    assert(call_args.size() - callable.get_unbound_arguments_count() >= 0)
    var result = call_args.slice(0, call_args.size() - callable.get_unbound_arguments_count())
    result.append_array(callable.get_bound_arguments())
    return result
\[/codeblock\] *)
    let get_bound_arguments x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_CALLABLE
      "get_bound_arguments"
      4144163970L
      (Callable.typ @-> returning Array.typ)
      Array.s x0 

    (** Returns the total amount of arguments unbound via successive \[method bind\] or \[method unbind\] calls. See \[method get_bound_arguments\] for details.
\[b\]Note:\[/b\] The \[method get_bound_arguments_count\] and \[method get_unbound_arguments_count\] methods can both return positive values. *)
    let get_unbound_arguments_count x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_CALLABLE
      "get_unbound_arguments_count"
      3173160232L
      (Callable.typ @-> returning Int.typ)
      Int.s x0 

    (** Returns the 32-bit hash value of this \[Callable\]''s object.
\[b\]Note:\[/b\] \[Callable\]s with equal content will always produce identical hash values. However, the reverse is not true. Returning identical hash values does \[i\]not\[/i\] imply the callables are equal, because different callables can have identical hash values due to hash collisions. The engine uses a 32-bit hash algorithm for \[method hash\]. *)
    let hash x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_CALLABLE
      "hash"
      3173160232L
      (Callable.typ @-> returning Int.typ)
      Int.s x0 

    (** Returns a copy of this \[Callable\] with one or more arguments bound, reading them from an array. When called, the bound arguments are passed \[i\]after\[/i\] the arguments supplied by \[method call\]. See also \[method unbind\].
\[b\]Note:\[/b\] When this method is chained with other similar methods, the order in which the argument list is modified is read from right to left. *)
    let bindv x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_CALLABLE
      "bindv"
      3564560322L
      (Array.typ @-> Callable.typ @-> returning Callable.typ)
      Callable.s x0  x1 

    (** Returns a copy of this \[Callable\] with a number of arguments unbound. In other words, when the new callable is called the last few arguments supplied by the user are ignored, according to \[param argcount\]. The remaining arguments are passed to the callable. This allows to use the original callable in a context that attempts to pass more arguments than this callable can handle, e.g. a signal with a fixed number of arguments. See also \[method bind\].
\[b\]Note:\[/b\] When this method is chained with other similar methods, the order in which the argument list is modified is read from right to left.
\[codeblock\]
func _ready():
    foo.unbind(1).call(1, 2) # Calls foo(1).
    foo.bind(3, 4).unbind(1).call(1, 2) # Calls foo(1, 3, 4), note that it does not change the arguments from bind.
\[/codeblock\] *)
    let unbind x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_CALLABLE
      "unbind"
      755001590L
      (Int.typ @-> Callable.typ @-> returning Callable.typ)
      Callable.s x0  x1 

    (** Calls the method represented by this \[Callable\]. Arguments can be passed and should match the method''s signature. *)
    let call x0  = 
    foreign_builtin_method0v
      GlobalEnum.VariantType._TYPE_CALLABLE
      "call"
      3643564216L
      (Variadic.typ @-> Callable.typ @-> returning Variant.typ)
      Variant.s x0 

    (** Calls the method represented by this \[Callable\] in deferred mode, i.e. at the end of the current frame. Arguments can be passed and should match the method''s signature.
\[codeblocks\]
\[gdscript\]
func _ready():
    grab_focus.call_deferred()
\[/gdscript\]
\[csharp\]
public override void _Ready()
\{!
    Callable.From(GrabFocus).CallDeferred();
\}
\[/csharp\]
\[/codeblocks\]
\[b\]Note:\[/b\] Deferred calls are processed at idle time. Idle time happens mainly at the end of process and physics frames. In it, deferred calls will be run until there are none left, which means you can defer calls from other deferred calls and they''ll still be run in the current idle time cycle. This means you should not call a method deferred from itself (or from a method called by it), as this causes infinite recursion the same way as if you had called the method directly.
See also \[method Object.call_deferred\]. *)
    let call_deferred x0  = 
    foreign_builtin_method0v_void
      GlobalEnum.VariantType._TYPE_CALLABLE
      "call_deferred"
      3286317445L
      (Variadic.typ @-> Callable.typ @-> returning Void.typ)
      Void.s x0 

    (** Perform an RPC (Remote Procedure Call) on all connected peers. This is used for multiplayer and is normally not available, unless the function being called has been marked as \[i\]RPC\[/i\] (using \[annotation \@GDScript.\@rpc\] or \[method Node.rpc_config\]). Calling this method on unsupported functions will result in an error. See \[method Node.rpc\]. *)
    let rpc x0  = 
    foreign_builtin_method0v_void
      GlobalEnum.VariantType._TYPE_CALLABLE
      "rpc"
      3286317445L
      (Variadic.typ @-> Callable.typ @-> returning Void.typ)
      Void.s x0 

    (** Perform an RPC (Remote Procedure Call) on a specific peer ID (see multiplayer documentation for reference). This is used for multiplayer and is normally not available unless the function being called has been marked as \[i\]RPC\[/i\] (using \[annotation \@GDScript.\@rpc\] or \[method Node.rpc_config\]). Calling this method on unsupported functions will result in an error. See \[method Node.rpc_id\]. *)
    let rpc_id x0  x1  = 
    foreign_builtin_method1v_void
      GlobalEnum.VariantType._TYPE_CALLABLE
      "rpc_id"
      2270047679L
      (Int.typ @-> Variadic.typ @-> Callable.typ @-> returning Void.typ)
      Void.s x0  x1 

    (** Returns a copy of this \[Callable\] with one or more arguments bound. When called, the bound arguments are passed \[i\]after\[/i\] the arguments supplied by \[method call\]. See also \[method unbind\].
\[b\]Note:\[/b\] When this method is chained with other similar methods, the order in which the argument list is modified is read from right to left. *)
    let bind x0  = 
    foreign_builtin_method0v
      GlobalEnum.VariantType._TYPE_CALLABLE
      "bind"
      3224143119L
      (Variadic.typ @-> Callable.typ @-> returning Callable.typ)
      Callable.s x0 






    let not x0  = 
    foreign_builtin_operator1 GlobalEnum.VariantType._TYPE_CALLABLE None  GlobalEnum.VariantOperator._OP_NOT
      (funptr (Callable.typ @-> Bool.typ @-> returning void))
      Bool.s x0 

    (** Returns \[code\]true\[/code\] if both \[Callable\]s invoke the same custom target. *)
    let (=) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_CALLABLE (Some GlobalEnum.VariantType._TYPE_CALLABLE) GlobalEnum.VariantOperator._OP_EQUAL
      (funptr (Callable.typ @-> Callable.typ @-> Bool.typ @-> returning void))
      Bool.s
      Conv.Callable.of_ocaml
      Conv.Callable.of_ocaml
      Conv.Bool.to_ocaml x0  x1 

    (** Returns \[code\]true\[/code\] if both \[Callable\]s invoke different targets. *)
    let (<>) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_CALLABLE (Some GlobalEnum.VariantType._TYPE_CALLABLE) GlobalEnum.VariantOperator._OP_NOT_EQUAL
      (funptr (Callable.typ @-> Callable.typ @-> Bool.typ @-> returning void))
      Bool.s
      Conv.Callable.of_ocaml
      Conv.Callable.of_ocaml
      Conv.Bool.to_ocaml x0  x1 


    let mem_Dictionary x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_CALLABLE (Some GlobalEnum.VariantType._TYPE_DICTIONARY) GlobalEnum.VariantOperator._OP_IN
      (funptr (Callable.typ @-> Dictionary.typ @-> Bool.typ @-> returning void))
      Bool.s x0  x1 


    let mem_Array x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_CALLABLE (Some GlobalEnum.VariantType._TYPE_ARRAY) GlobalEnum.VariantOperator._OP_IN
      (funptr (Callable.typ @-> Array.typ @-> Bool.typ @-> returning void))
      Bool.s x0  x1 
    end

  module Signal = struct
    include M.Signal
include BuiltinClass0.Signal

    (** Returns \[code\]true\[/code\] if this \[Signal\] has no object and the signal name is empty. Equivalent to \[code\]signal == Signal()\[/code\]. *)
    let is_null x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_SIGNAL
      "is_null"
      3918633141L
      (Signal.typ @-> returning Bool.typ)
      Bool.s x0 

    (** Returns the object emitting this signal. *)
    let get_object x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_SIGNAL
      "get_object"
      4008621732L
      (Signal.typ @-> returning Object.typ)
      Object.s x0 

    (** Returns the ID of the object emitting this signal (see \[method Object.get_instance_id\]). *)
    let get_object_id x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_SIGNAL
      "get_object_id"
      3173160232L
      (Signal.typ @-> returning Int.typ)
      Int.s x0 

    (** Returns the name of this signal. *)
    let get_name x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_SIGNAL
      "get_name"
      1825232092L
      (Signal.typ @-> returning StringName.typ)
      StringName.s x0 

    (** Connects this signal to the specified \[param callable\]. Optional \[param flags\] can be also added to configure the connection''s behavior (see \[enum Object.ConnectFlags\] constants). You can provide additional arguments to the connected \[param callable\] by using \[method Callable.bind\].
A signal can only be connected once to the same \[Callable\]. If the signal is already connected, returns \[constant ERR_INVALID_PARAMETER\] and pushes an error message, unless the signal is connected with \[constant Object.CONNECT_REFERENCE_COUNTED\]. To prevent this, use \[method is_connected\] first to check for existing connections.
\[codeblock\]
for button in $Buttons.get_children():
    button.pressed.connect(_on_pressed.bind(button))

func _on_pressed(button):
    print(button.name, "" was pressed"")
\[/codeblock\] *)
    let connect x0  x1  x2  = 
    foreign_builtin_method2
      GlobalEnum.VariantType._TYPE_SIGNAL
      "connect"
      979702392L
      (Callable.typ @-> Int.typ @-> Signal.typ @-> returning Int.typ)
      Int.s x0  x1  x2 

    (** Disconnects this signal from the specified \[Callable\]. If the connection does not exist, generates an error. Use \[method is_connected\] to make sure that the connection exists. *)
    let disconnect x0  x1  = 
    foreign_builtin_method1_void
      GlobalEnum.VariantType._TYPE_SIGNAL
      "disconnect"
      3470848906L
      (Callable.typ @-> Signal.typ @-> returning Void.typ)
      Void.s x0  x1 

    (** Returns \[code\]true\[/code\] if the specified \[Callable\] is connected to this signal. *)
    let is_connected x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_SIGNAL
      "is_connected"
      4129521963L
      (Callable.typ @-> Signal.typ @-> returning Bool.typ)
      Bool.s x0  x1 

    (** Returns an \[Array\] of connections for this signal. Each connection is represented as a \[Dictionary\] that contains three entries:
- \[code\]signal\[/code\] is a reference to this signal;
- \[code\]callable\[/code\] is a reference to the connected \[Callable\];
- \[code\]flags\[/code\] is a combination of \[enum Object.ConnectFlags\]. *)
    let get_connections x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_SIGNAL
      "get_connections"
      4144163970L
      (Signal.typ @-> returning Array.typ)
      Array.s x0 

    (** Returns \[code\]true\[/code\] if any \[Callable\] is connected to this signal. *)
    let has_connections x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_SIGNAL
      "has_connections"
      3918633141L
      (Signal.typ @-> returning Bool.typ)
      Bool.s x0 

    (** Emits this signal. All \[Callable\]s connected to this signal will be triggered. This method supports a variable number of arguments, so parameters can be passed as a comma separated list. *)
    let emit x0  = 
    foreign_builtin_method0v_void
      GlobalEnum.VariantType._TYPE_SIGNAL
      "emit"
      3286317445L
      (Variadic.typ @-> Signal.typ @-> returning Void.typ)
      Void.s x0 






    let not x0  = 
    foreign_builtin_operator1 GlobalEnum.VariantType._TYPE_SIGNAL None  GlobalEnum.VariantOperator._OP_NOT
      (funptr (Signal.typ @-> Bool.typ @-> returning void))
      Bool.s x0 

    (** Returns \[code\]true\[/code\] if both signals share the same object and name. *)
    let (=) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_SIGNAL (Some GlobalEnum.VariantType._TYPE_SIGNAL) GlobalEnum.VariantOperator._OP_EQUAL
      (funptr (Signal.typ @-> Signal.typ @-> Bool.typ @-> returning void))
      Bool.s
      Conv.Signal.of_ocaml
      Conv.Signal.of_ocaml
      Conv.Bool.to_ocaml x0  x1 

    (** Returns \[code\]true\[/code\] if the signals do not share the same object and name. *)
    let (<>) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_SIGNAL (Some GlobalEnum.VariantType._TYPE_SIGNAL) GlobalEnum.VariantOperator._OP_NOT_EQUAL
      (funptr (Signal.typ @-> Signal.typ @-> Bool.typ @-> returning void))
      Bool.s
      Conv.Signal.of_ocaml
      Conv.Signal.of_ocaml
      Conv.Bool.to_ocaml x0  x1 


    let mem_Dictionary x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_SIGNAL (Some GlobalEnum.VariantType._TYPE_DICTIONARY) GlobalEnum.VariantOperator._OP_IN
      (funptr (Signal.typ @-> Dictionary.typ @-> Bool.typ @-> returning void))
      Bool.s x0  x1 


    let mem_Array x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_SIGNAL (Some GlobalEnum.VariantType._TYPE_ARRAY) GlobalEnum.VariantOperator._OP_IN
      (funptr (Signal.typ @-> Array.typ @-> Bool.typ @-> returning void))
      Bool.s x0  x1 
    end

  module Dictionary = struct
    include M.Dictionary
include BuiltinClass0.Dictionary

    (** Returns the number of entries in the dictionary. Empty dictionaries (\[code\]\{! \}\[/code\]) always return \[code\]0\[/code\]. See also \[method is_empty\]. *)
    let size x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_DICTIONARY
      "size"
      3173160232L
      (Dictionary.typ @-> returning Int.typ)
      Int.s x0 

    (** Returns \[code\]true\[/code\] if the dictionary is empty (its size is \[code\]0\[/code\]). See also \[method size\]. *)
    let is_empty x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_DICTIONARY
      "is_empty"
      3918633141L
      (Dictionary.typ @-> returning Bool.typ)
      Bool.s x0 

    (** Clears the dictionary, removing all entries from it. *)
    let clear x0  = 
    foreign_builtin_method0_void
      GlobalEnum.VariantType._TYPE_DICTIONARY
      "clear"
      3218959716L
      (Dictionary.typ @-> returning Void.typ)
      Void.s x0 

    (** Assigns elements of another \[param dictionary\] into the dictionary. Resizes the dictionary to match \[param dictionary\]. Performs type conversions if the dictionary is typed. *)
    let assign x0  x1  = 
    foreign_builtin_method1_void
      GlobalEnum.VariantType._TYPE_DICTIONARY
      "assign"
      3642266950L
      (Dictionary.typ @-> Dictionary.typ @-> returning Void.typ)
      Void.s x0  x1 

    (** Sorts the dictionary in-place by key. This can be used to ensure dictionaries with the same contents produce equivalent results when getting the \[method keys\], getting the \[method values\], and converting to a string. This is also useful when wanting a JSON representation consistent with what is in memory, and useful for storing on a database that requires dictionaries to be sorted. *)
    let sort x0  = 
    foreign_builtin_method0_void
      GlobalEnum.VariantType._TYPE_DICTIONARY
      "sort"
      3218959716L
      (Dictionary.typ @-> returning Void.typ)
      Void.s x0 

    (** Adds entries from \[param dictionary\] to this dictionary. By default, duplicate keys are not copied over, unless \[param overwrite\] is \[code\]true\[/code\].
\[codeblocks\]
\[gdscript\]
var dict = \{! ""item"": ""sword"", ""quantity"": 2 \}
var other_dict = \{! ""quantity"": 15, ""color"": ""silver"" \}

# Overwriting of existing keys is disabled by default.
dict.merge(other_dict)
print(dict)  # \{! ""item"": ""sword"", ""quantity"": 2, ""color"": ""silver"" \}

# With overwriting of existing keys enabled.
dict.merge(other_dict, true)
print(dict)  # \{! ""item"": ""sword"", ""quantity"": 15, ""color"": ""silver"" \}
\[/gdscript\]
\[csharp\]
var dict = new Godot.Collections.Dictionary
\{!
    \[""item""\] = ""sword"",
    \[""quantity""\] = 2,
\};

var otherDict = new Godot.Collections.Dictionary
\{!
    \[""quantity""\] = 15,
    \[""color""\] = ""silver"",
\};

// Overwriting of existing keys is disabled by default.
dict.Merge(otherDict);
GD.Print(dict); // \{! ""item"": ""sword"", ""quantity"": 2, ""color"": ""silver"" \}

// With overwriting of existing keys enabled.
dict.Merge(otherDict, true);
GD.Print(dict); // \{! ""item"": ""sword"", ""quantity"": 15, ""color"": ""silver"" \}
\[/csharp\]
\[/codeblocks\]
\[b\]Note:\[/b\] \[method merge\] is \[i\]not\[/i\] recursive. Nested dictionaries are considered as keys that can be overwritten or not depending on the value of \[param overwrite\], but they will never be merged together. *)
    let merge x0  x1  x2  = 
    foreign_builtin_method2_void
      GlobalEnum.VariantType._TYPE_DICTIONARY
      "merge"
      2079548978L
      (Dictionary.typ @-> Bool.typ @-> Dictionary.typ @-> returning Void.typ)
      Void.s x0  x1  x2 

    (** Returns a copy of this dictionary merged with the other \[param dictionary\]. By default, duplicate keys are not copied over, unless \[param overwrite\] is \[code\]true\[/code\]. See also \[method merge\].
This method is useful for quickly making dictionaries with default values:
\[codeblock\]
var base = \{! ""fruit"": ""apple"", ""vegetable"": ""potato"" \}
var extra = \{! ""fruit"": ""orange"", ""dressing"": ""vinegar"" \}
# Prints \{! ""fruit"": ""orange"", ""vegetable"": ""potato"", ""dressing"": ""vinegar"" \}
print(extra.merged(base))
# Prints \{! ""fruit"": ""apple"", ""vegetable"": ""potato"", ""dressing"": ""vinegar"" \}
print(extra.merged(base, true))
\[/codeblock\] *)
    let merged x0  x1  x2  = 
    foreign_builtin_method2
      GlobalEnum.VariantType._TYPE_DICTIONARY
      "merged"
      2271165639L
      (Dictionary.typ @-> Bool.typ @-> Dictionary.typ @-> returning Dictionary.typ)
      Dictionary.s x0  x1  x2 

    (** Returns \[code\]true\[/code\] if the dictionary contains an entry with the given \[param key\].
\[codeblocks\]
\[gdscript\]
var my_dict = \{!
    ""Godot"" : 4,
    210 : null,
\}

print(my_dict.has(""Godot"")) # Prints true
print(my_dict.has(210))     # Prints true
print(my_dict.has(4))       # Prints false
\[/gdscript\]
\[csharp\]
var myDict = new Godot.Collections.Dictionary
\{!
    \{! ""Godot"", 4 \},
    \{! 210, default \},
\};

GD.Print(myDict.ContainsKey(""Godot"")); // Prints True
GD.Print(myDict.ContainsKey(210));     // Prints True
GD.Print(myDict.ContainsKey(4));       // Prints False
\[/csharp\]
\[/codeblocks\]
In GDScript, this is equivalent to the \[code\]in\[/code\] operator:
\[codeblock\]
if ""Godot"" in \{!""Godot"": 4\}:
    print(""The key is here!"") # Will be printed.
\[/codeblock\]
\[b\]Note:\[/b\] This method returns \[code\]true\[/code\] as long as the \[param key\] exists, even if its corresponding value is \[code\]null\[/code\]. *)
    let has x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_DICTIONARY
      "has"
      3680194679L
      (Variant.typ @-> Dictionary.typ @-> returning Bool.typ)
      Bool.s x0  x1 

    (** Returns \[code\]true\[/code\] if the dictionary contains all keys in the given \[param keys\] array.
\[codeblock\]
var data = \{!""width"" : 10, ""height"" : 20\}
data.has_all(\[""height"", ""width""\]) # Returns true
\[/codeblock\] *)
    let has_all x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_DICTIONARY
      "has_all"
      2988181878L
      (Array.typ @-> Dictionary.typ @-> returning Bool.typ)
      Bool.s x0  x1 

    (** Finds and returns the first key whose associated value is equal to \[param value\], or \[code\]null\[/code\] if it is not found.
\[b\]Note:\[/b\] \[code\]null\[/code\] is also a valid key. If inside the dictionary, \[method find_key\] may give misleading results. *)
    let find_key x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_DICTIONARY
      "find_key"
      1988825835L
      (Variant.typ @-> Dictionary.typ @-> returning Variant.typ)
      Variant.s x0  x1 

    (** Removes the dictionary entry by key, if it exists. Returns \[code\]true\[/code\] if the given \[param key\] existed in the dictionary, otherwise \[code\]false\[/code\].
\[b\]Note:\[/b\] Do not erase entries while iterating over the dictionary. You can iterate over the \[method keys\] array instead. *)
    let erase x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_DICTIONARY
      "erase"
      1776646889L
      (Variant.typ @-> Dictionary.typ @-> returning Bool.typ)
      Bool.s x0  x1 

    (** Returns a hashed 32-bit integer value representing the dictionary contents.
\[codeblocks\]
\[gdscript\]
var dict1 = \{!""A"": 10, ""B"": 2\}
var dict2 = \{!""A"": 10, ""B"": 2\}

print(dict1.hash() == dict2.hash()) # Prints true
\[/gdscript\]
\[csharp\]
var dict1 = new Godot.Collections.Dictionary\{!\{!""A"", 10\}, \{!""B"", 2\}\};
var dict2 = new Godot.Collections.Dictionary\{!\{!""A"", 10\}, \{!""B"", 2\}\};

// Godot.Collections.Dictionary has no Hash() method. Use GD.Hash() instead.
GD.Print(GD.Hash(dict1) == GD.Hash(dict2)); // Prints True
\[/csharp\]
\[/codeblocks\]
\[b\]Note:\[/b\] Dictionaries with the same entries but in a different order will not have the same hash.
\[b\]Note:\[/b\] Dictionaries with equal hash values are \[i\]not\[/i\] guaranteed to be the same, because of hash collisions. On the contrary, dictionaries with different hash values are guaranteed to be different. *)
    let hash x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_DICTIONARY
      "hash"
      3173160232L
      (Dictionary.typ @-> returning Int.typ)
      Int.s x0 

    (** Returns the list of keys in the dictionary. *)
    let keys x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_DICTIONARY
      "keys"
      4144163970L
      (Dictionary.typ @-> returning Array.typ)
      Array.s x0 

    (** Returns the list of values in this dictionary. *)
    let values x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_DICTIONARY
      "values"
      4144163970L
      (Dictionary.typ @-> returning Array.typ)
      Array.s x0 

    (** Creates and returns a new copy of the dictionary. If \[param deep\] is \[code\]true\[/code\], inner \[Dictionary\] and \[Array\] keys and values are also copied, recursively. *)
    let duplicate x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_DICTIONARY
      "duplicate"
      830099069L
      (Bool.typ @-> Dictionary.typ @-> returning Dictionary.typ)
      Dictionary.s x0  x1 

    (** Returns the corresponding value for the given \[param key\] in the dictionary. If the \[param key\] does not exist, returns \[param default\], or \[code\]null\[/code\] if the parameter is omitted. *)
    let get x0  x1  x2  = 
    foreign_builtin_method2
      GlobalEnum.VariantType._TYPE_DICTIONARY
      "get"
      2205440559L
      (Variant.typ @-> Variant.typ @-> Dictionary.typ @-> returning Variant.typ)
      Variant.s x0  x1  x2 

    (** Gets a value and ensures the key is set. If the \[param key\] exists in the dictionary, this behaves like \[method get\]. Otherwise, the \[param default\] value is inserted into the dictionary and returned. *)
    let get_or_add x0  x1  x2  = 
    foreign_builtin_method2
      GlobalEnum.VariantType._TYPE_DICTIONARY
      "get_or_add"
      1052551076L
      (Variant.typ @-> Variant.typ @-> Dictionary.typ @-> returning Variant.typ)
      Variant.s x0  x1  x2 

    (** Sets the value of the element at the given \[param key\] to the given \[param value\]. This is the same as using the \[code\]\[\]\[/code\] operator (\[code\]array\[index\] = value\[/code\]). *)
    let set x0  x1  x2  = 
    foreign_builtin_method2
      GlobalEnum.VariantType._TYPE_DICTIONARY
      "set"
      2175348267L
      (Variant.typ @-> Variant.typ @-> Dictionary.typ @-> returning Bool.typ)
      Bool.s x0  x1  x2 

    (** Returns \[code\]true\[/code\] if the dictionary is typed. Typed dictionaries can only store keys/values of their associated type and provide type safety for the \[code\]\[\]\[/code\] operator. Methods of typed dictionary still return \[Variant\]. *)
    let is_typed x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_DICTIONARY
      "is_typed"
      3918633141L
      (Dictionary.typ @-> returning Bool.typ)
      Bool.s x0 

    (** Returns \[code\]true\[/code\] if the dictionary''s keys are typed. *)
    let is_typed_key x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_DICTIONARY
      "is_typed_key"
      3918633141L
      (Dictionary.typ @-> returning Bool.typ)
      Bool.s x0 

    (** Returns \[code\]true\[/code\] if the dictionary''s values are typed. *)
    let is_typed_value x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_DICTIONARY
      "is_typed_value"
      3918633141L
      (Dictionary.typ @-> returning Bool.typ)
      Bool.s x0 

    (** Returns \[code\]true\[/code\] if the dictionary is typed the same as \[param dictionary\]. *)
    let is_same_typed x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_DICTIONARY
      "is_same_typed"
      3471775634L
      (Dictionary.typ @-> Dictionary.typ @-> returning Bool.typ)
      Bool.s x0  x1 

    (** Returns \[code\]true\[/code\] if the dictionary''s keys are typed the same as \[param dictionary\]''s keys. *)
    let is_same_typed_key x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_DICTIONARY
      "is_same_typed_key"
      3471775634L
      (Dictionary.typ @-> Dictionary.typ @-> returning Bool.typ)
      Bool.s x0  x1 

    (** Returns \[code\]true\[/code\] if the dictionary''s values are typed the same as \[param dictionary\]''s values. *)
    let is_same_typed_value x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_DICTIONARY
      "is_same_typed_value"
      3471775634L
      (Dictionary.typ @-> Dictionary.typ @-> returning Bool.typ)
      Bool.s x0  x1 

    (** Returns the built-in \[Variant\] type of the typed dictionary''s keys as a \[enum Variant.Type\] constant. If the keys are not typed, returns \[constant TYPE_NIL\]. See also \[method is_typed_key\]. *)
    let get_typed_key_builtin x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_DICTIONARY
      "get_typed_key_builtin"
      3173160232L
      (Dictionary.typ @-> returning Int.typ)
      Int.s x0 

    (** Returns the built-in \[Variant\] type of the typed dictionary''s values as a \[enum Variant.Type\] constant. If the values are not typed, returns \[constant TYPE_NIL\]. See also \[method is_typed_value\]. *)
    let get_typed_value_builtin x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_DICTIONARY
      "get_typed_value_builtin"
      3173160232L
      (Dictionary.typ @-> returning Int.typ)
      Int.s x0 

    (** Returns the \[b\]built-in\[/b\] class name of the typed dictionary''s keys, if the built-in \[Variant\] type is \[constant TYPE_OBJECT\]. Otherwise, returns an empty \[StringName\]. See also \[method is_typed_key\] and \[method Object.get_class\]. *)
    let get_typed_key_class_name x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_DICTIONARY
      "get_typed_key_class_name"
      1825232092L
      (Dictionary.typ @-> returning StringName.typ)
      StringName.s x0 

    (** Returns the \[b\]built-in\[/b\] class name of the typed dictionary''s values, if the built-in \[Variant\] type is \[constant TYPE_OBJECT\]. Otherwise, returns an empty \[StringName\]. See also \[method is_typed_value\] and \[method Object.get_class\]. *)
    let get_typed_value_class_name x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_DICTIONARY
      "get_typed_value_class_name"
      1825232092L
      (Dictionary.typ @-> returning StringName.typ)
      StringName.s x0 

    (** Returns the \[Script\] instance associated with this typed dictionary''s keys, or \[code\]null\[/code\] if it does not exist. See also \[method is_typed_key\]. *)
    let get_typed_key_script x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_DICTIONARY
      "get_typed_key_script"
      1460142086L
      (Dictionary.typ @-> returning Variant.typ)
      Variant.s x0 

    (** Returns the \[Script\] instance associated with this typed dictionary''s values, or \[code\]null\[/code\] if it does not exist. See also \[method is_typed_value\]. *)
    let get_typed_value_script x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_DICTIONARY
      "get_typed_value_script"
      1460142086L
      (Dictionary.typ @-> returning Variant.typ)
      Variant.s x0 

    (** Makes the dictionary read-only, i.e. disables modification of the dictionary''s contents. Does not apply to nested content, e.g. content of nested dictionaries. *)
    let make_read_only x0  = 
    foreign_builtin_method0_void
      GlobalEnum.VariantType._TYPE_DICTIONARY
      "make_read_only"
      3218959716L
      (Dictionary.typ @-> returning Void.typ)
      Void.s x0 

    (** Returns \[code\]true\[/code\] if the dictionary is read-only. See \[method make_read_only\]. Dictionaries are automatically read-only if declared with \[code\]const\[/code\] keyword. *)
    let is_read_only x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_DICTIONARY
      "is_read_only"
      3918633141L
      (Dictionary.typ @-> returning Bool.typ)
      Bool.s x0 

    (** Returns \[code\]true\[/code\] if the two dictionaries contain the same keys and values, inner \[Dictionary\] and \[Array\] keys and values are compared recursively. *)
    let recursive_equal x0  x1  x2  = 
    foreign_builtin_method2
      GlobalEnum.VariantType._TYPE_DICTIONARY
      "recursive_equal"
      1404404751L
      (Dictionary.typ @-> Int.typ @-> Dictionary.typ @-> returning Bool.typ)
      Bool.s x0  x1  x2 






    let not x0  = 
    foreign_builtin_operator1 GlobalEnum.VariantType._TYPE_DICTIONARY None  GlobalEnum.VariantOperator._OP_NOT
      (funptr (Dictionary.typ @-> Bool.typ @-> returning void))
      Bool.s x0 

    (** Returns \[code\]true\[/code\] if the two dictionaries contain the same keys and values. The order of the entries does not matter.
\[b\]Note:\[/b\] In C#, by convention, this operator compares by \[b\]reference\[/b\]. If you need to compare by value, iterate over both dictionaries. *)
    let (=) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_DICTIONARY (Some GlobalEnum.VariantType._TYPE_DICTIONARY) GlobalEnum.VariantOperator._OP_EQUAL
      (funptr (Dictionary.typ @-> Dictionary.typ @-> Bool.typ @-> returning void))
      Bool.s
      Conv.Dictionary.of_ocaml
      Conv.Dictionary.of_ocaml
      Conv.Bool.to_ocaml x0  x1 

    (** Returns \[code\]true\[/code\] if the two dictionaries do not contain the same keys and values. *)
    let (<>) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_DICTIONARY (Some GlobalEnum.VariantType._TYPE_DICTIONARY) GlobalEnum.VariantOperator._OP_NOT_EQUAL
      (funptr (Dictionary.typ @-> Dictionary.typ @-> Bool.typ @-> returning void))
      Bool.s
      Conv.Dictionary.of_ocaml
      Conv.Dictionary.of_ocaml
      Conv.Bool.to_ocaml x0  x1 


    let mem_Dictionary x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_DICTIONARY (Some GlobalEnum.VariantType._TYPE_DICTIONARY) GlobalEnum.VariantOperator._OP_IN
      (funptr (Dictionary.typ @-> Dictionary.typ @-> Bool.typ @-> returning void))
      Bool.s x0  x1 


    let mem_Array x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_DICTIONARY (Some GlobalEnum.VariantType._TYPE_ARRAY) GlobalEnum.VariantOperator._OP_IN
      (funptr (Dictionary.typ @-> Array.typ @-> Bool.typ @-> returning void))
      Bool.s x0  x1 
    end

  module Array = struct
    include M.Array
include BuiltinClass0.Array

    (** Returns the number of elements in the array. Empty arrays (\[code\]\[\]\[/code\]) always return \[code\]0\[/code\]. See also \[method is_empty\]. *)
    let size x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_ARRAY
      "size"
      3173160232L
      (Array.typ @-> returning Int.typ)
      Int.s x0 

    (** Returns \[code\]true\[/code\] if the array is empty (\[code\]\[\]\[/code\]). See also \[method size\]. *)
    let is_empty x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_ARRAY
      "is_empty"
      3918633141L
      (Array.typ @-> returning Bool.typ)
      Bool.s x0 

    (** Removes all elements from the array. This is equivalent to using \[method resize\] with a size of \[code\]0\[/code\]. *)
    let clear x0  = 
    foreign_builtin_method0_void
      GlobalEnum.VariantType._TYPE_ARRAY
      "clear"
      3218959716L
      (Array.typ @-> returning Void.typ)
      Void.s x0 

    (** Returns a hashed 32-bit integer value representing the array and its contents.
\[b\]Note:\[/b\] Arrays with equal hash values are \[i\]not\[/i\] guaranteed to be the same, as a result of hash collisions. On the countrary, arrays with different hash values are guaranteed to be different. *)
    let hash x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_ARRAY
      "hash"
      3173160232L
      (Array.typ @-> returning Int.typ)
      Int.s x0 

    (** Assigns elements of another \[param array\] into the array. Resizes the array to match \[param array\]. Performs type conversions if the array is typed. *)
    let assign x0  x1  = 
    foreign_builtin_method1_void
      GlobalEnum.VariantType._TYPE_ARRAY
      "assign"
      2307260970L
      (Array.typ @-> Array.typ @-> returning Void.typ)
      Void.s x0  x1 

    (** Returns the element at the given \[param index\] in the array. This is the same as using the \[code\]\[\]\[/code\] operator (\[code\]array\[index\]\[/code\]). *)
    let get x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_ARRAY
      "get"
      708700221L
      (Int.typ @-> Array.typ @-> returning Variant.typ)
      Variant.s x0  x1 

    (** Sets the value of the element at the given \[param index\] to the given \[param value\]. This will not change the size of the array, it only changes the value at an index already in the array. This is the same as using the \[code\]\[\]\[/code\] operator (\[code\]array\[index\] = value\[/code\]). *)
    let set x0  x1  x2  = 
    foreign_builtin_method2_void
      GlobalEnum.VariantType._TYPE_ARRAY
      "set"
      3798478031L
      (Int.typ @-> Variant.typ @-> Array.typ @-> returning Void.typ)
      Void.s x0  x1  x2 

    (** Appends an element at the end of the array. See also \[method push_front\]. *)
    let push_back x0  x1  = 
    foreign_builtin_method1_void
      GlobalEnum.VariantType._TYPE_ARRAY
      "push_back"
      3316032543L
      (Variant.typ @-> Array.typ @-> returning Void.typ)
      Void.s x0  x1 

    (** Adds an element at the beginning of the array. See also \[method push_back\].
\[b\]Note:\[/b\] This method shifts every other element''s index forward, which may have a noticeable performance cost, especially on larger arrays. *)
    let push_front x0  x1  = 
    foreign_builtin_method1_void
      GlobalEnum.VariantType._TYPE_ARRAY
      "push_front"
      3316032543L
      (Variant.typ @-> Array.typ @-> returning Void.typ)
      Void.s x0  x1 

    (** Appends \[param value\] at the end of the array (alias of \[method push_back\]). *)
    let append x0  x1  = 
    foreign_builtin_method1_void
      GlobalEnum.VariantType._TYPE_ARRAY
      "append"
      3316032543L
      (Variant.typ @-> Array.typ @-> returning Void.typ)
      Void.s x0  x1 

    (** Appends another \[param array\] at the end of this array.
\[codeblock\]
var numbers = \[1, 2, 3\]
var extra = \[4, 5, 6\]
numbers.append_array(extra)
print(numbers) # Prints \[1, 2, 3, 4, 5, 6\]
\[/codeblock\] *)
    let append_array x0  x1  = 
    foreign_builtin_method1_void
      GlobalEnum.VariantType._TYPE_ARRAY
      "append_array"
      2307260970L
      (Array.typ @-> Array.typ @-> returning Void.typ)
      Void.s x0  x1 

    (** Sets the array''s number of elements to \[param size\]. If \[param size\] is smaller than the array''s current size, the elements at the end are removed. If \[param size\] is greater, new default elements (usually \[code\]null\[/code\]) are added, depending on the array''s type.
Returns \[constant OK\] on success, or one of the other \[enum Error\] constants if this method fails.
\[b\]Note:\[/b\] Calling this method once and assigning the new values is faster than calling \[method append\] for every new element. *)
    let resize x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_ARRAY
      "resize"
      848867239L
      (Int.typ @-> Array.typ @-> returning Int.typ)
      Int.s x0  x1 

    (** Inserts a new element (\[param value\]) at a given index (\[param position\]) in the array. \[param position\] should be between \[code\]0\[/code\] and the array''s \[method size\].
Returns \[constant OK\] on success, or one of the other \[enum Error\] constants if this method fails.
\[b\]Note:\[/b\] Every element''s index after \[param position\] needs to be shifted forward, which may have a noticeable performance cost, especially on larger arrays. *)
    let insert x0  x1  x2  = 
    foreign_builtin_method2
      GlobalEnum.VariantType._TYPE_ARRAY
      "insert"
      3176316662L
      (Int.typ @-> Variant.typ @-> Array.typ @-> returning Int.typ)
      Int.s x0  x1  x2 

    (** Removes the element from the array at the given index (\[param position\]). If the index is out of bounds, this method fails.
If you need to return the removed element, use \[method pop_at\]. To remove an element by value, use \[method erase\] instead.
\[b\]Note:\[/b\] This method shifts every element''s index after \[param position\] back, which may have a noticeable performance cost, especially on larger arrays.
\[b\]Note:\[/b\] The \[param position\] cannot be negative. To remove an element relative to the end of the array, use \[code\]arr.remove_at(arr.size() - (i + 1))\[/code\]. To remove the last element from the array, use \[code\]arr.resize(arr.size() - 1)\[/code\]. *)
    let remove_at x0  x1  = 
    foreign_builtin_method1_void
      GlobalEnum.VariantType._TYPE_ARRAY
      "remove_at"
      2823966027L
      (Int.typ @-> Array.typ @-> returning Void.typ)
      Void.s x0  x1 

    (** Assigns the given \[param value\] to all elements in the array.
This method can often be combined with \[method resize\] to create an array with a given size and initialized elements:
\[codeblocks\]
\[gdscript\]
var array = \[\]
array.resize(5)
array.fill(2)
print(array) # Prints \[2, 2, 2, 2, 2\]
\[/gdscript\]
\[csharp\]
Godot.Collections.Array array = \[\];
array.Resize(5);
array.Fill(2);
GD.Print(array); // Prints \[2, 2, 2, 2, 2\]
\[/csharp\]
\[/codeblocks\]
\[b\]Note:\[/b\] If \[param value\] is a \[Variant\] passed by reference (\[Object\]-derived, \[Array\], \[Dictionary\], etc.), the array will be filled with references to the same \[param value\], which are not duplicates. *)
    let fill x0  x1  = 
    foreign_builtin_method1_void
      GlobalEnum.VariantType._TYPE_ARRAY
      "fill"
      3316032543L
      (Variant.typ @-> Array.typ @-> returning Void.typ)
      Void.s x0  x1 

    (** Finds and removes the first occurrence of \[param value\] from the array. If \[param value\] does not exist in the array, nothing happens. To remove an element by index, use \[method remove_at\] instead.
\[b\]Note:\[/b\] This method shifts every element''s index after the removed \[param value\] back, which may have a noticeable performance cost, especially on larger arrays.
\[b\]Note:\[/b\] Erasing elements while iterating over arrays is \[b\]not\[/b\] supported and will result in unpredictable behavior. *)
    let erase x0  x1  = 
    foreign_builtin_method1_void
      GlobalEnum.VariantType._TYPE_ARRAY
      "erase"
      3316032543L
      (Variant.typ @-> Array.typ @-> returning Void.typ)
      Void.s x0  x1 

    (** Returns the first element of the array. If the array is empty, fails and returns \[code\]null\[/code\]. See also \[method back\].
\[b\]Note:\[/b\] Unlike with the \[code\]\[\]\[/code\] operator (\[code\]array\[0\]\[/code\]), an error is generated without stopping project execution. *)
    let front x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_ARRAY
      "front"
      1460142086L
      (Array.typ @-> returning Variant.typ)
      Variant.s x0 

    (** Returns the last element of the array. If the array is empty, fails and returns \[code\]null\[/code\]. See also \[method front\].
\[b\]Note:\[/b\] Unlike with the \[code\]\[\]\[/code\] operator (\[code\]array\[-1\]\[/code\]), an error is generated without stopping project execution. *)
    let back x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_ARRAY
      "back"
      1460142086L
      (Array.typ @-> returning Variant.typ)
      Variant.s x0 

    (** Returns a random element from the array. Generates an error and returns \[code\]null\[/code\] if the array is empty.
\[codeblocks\]
\[gdscript\]
# May print 1, 2, 3.25, or ""Hi"".
print(\[1, 2, 3.25, ""Hi""\].pick_random())
\[/gdscript\]
\[csharp\]
Godot.Collections.Array array = \[1, 2, 3.25f, ""Hi""\];
GD.Print(array.PickRandom()); // May print 1, 2, 3.25, or ""Hi"".
\[/csharp\]
\[/codeblocks\]
\[b\]Note:\[/b\] Like many similar functions in the engine (such as \[method \@GlobalScope.randi\] or \[method shuffle\]), this method uses a common, global random seed. To get a predictable outcome from this method, see \[method \@GlobalScope.seed\]. *)
    let pick_random x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_ARRAY
      "pick_random"
      1460142086L
      (Array.typ @-> returning Variant.typ)
      Variant.s x0 

    (** Returns the index of the \[b\]first\[/b\] occurrence of \[param what\] in this array, or \[code\]-1\[/code\] if there are none. The search''s start can be specified with \[param from\], continuing to the end of the array.
\[b\]Note:\[/b\] If you just want to know whether the array contains \[param what\], use \[method has\] (\[code\]Contains\[/code\] in C#). In GDScript, you may also use the \[code\]in\[/code\] operator.
\[b\]Note:\[/b\] For performance reasons, the search is affected by \[param what\]''s \[enum Variant.Type\]. For example, \[code\]7\[/code\] (\[int\]) and \[code\]7.0\[/code\] (\[float\]) are not considered equal for this method. *)
    let find x0  x1  x2  = 
    foreign_builtin_method2
      GlobalEnum.VariantType._TYPE_ARRAY
      "find"
      2336346817L
      (Variant.typ @-> Int.typ @-> Array.typ @-> returning Int.typ)
      Int.s x0  x1  x2 

    (** Returns the index of the \[b\]first\[/b\] element in the array that causes \[param method\] to return \[code\]true\[/code\], or \[code\]-1\[/code\] if there are none. The search''s start can be specified with \[param from\], continuing to the end of the array.
\[param method\] is a callable that takes an element of the array, and returns a \[bool\].
\[b\]Note:\[/b\] If you just want to know whether the array contains \[i\]anything\[/i\] that satisfies \[param method\], use \[method any\].
\[codeblocks\]
\[gdscript\]
func is_even(number):
    return number % 2 == 0

func _ready():
    print(\[1, 3, 4, 7\].find_custom(is_even.bind())) # Prints 2
\[/gdscript\]
\[/codeblocks\] *)
    let find_custom x0  x1  x2  = 
    foreign_builtin_method2
      GlobalEnum.VariantType._TYPE_ARRAY
      "find_custom"
      2145562546L
      (Callable.typ @-> Int.typ @-> Array.typ @-> returning Int.typ)
      Int.s x0  x1  x2 

    (** Returns the index of the \[b\]last\[/b\] occurrence of \[param what\] in this array, or \[code\]-1\[/code\] if there are none. The search''s start can be specified with \[param from\], continuing to the beginning of the array. This method is the reverse of \[method find\]. *)
    let rfind x0  x1  x2  = 
    foreign_builtin_method2
      GlobalEnum.VariantType._TYPE_ARRAY
      "rfind"
      2336346817L
      (Variant.typ @-> Int.typ @-> Array.typ @-> returning Int.typ)
      Int.s x0  x1  x2 

    (** Returns the index of the \[b\]last\[/b\] element of the array that causes \[param method\] to return \[code\]true\[/code\], or \[code\]-1\[/code\] if there are none. The search''s start can be specified with \[param from\], continuing to the beginning of the array. This method is the reverse of \[method find_custom\]. *)
    let rfind_custom x0  x1  x2  = 
    foreign_builtin_method2
      GlobalEnum.VariantType._TYPE_ARRAY
      "rfind_custom"
      2145562546L
      (Callable.typ @-> Int.typ @-> Array.typ @-> returning Int.typ)
      Int.s x0  x1  x2 

    (** Returns the number of times an element is in the array.
To count how many elements in an array satisfy a condition, see \[method reduce\]. *)
    let count x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_ARRAY
      "count"
      1481661226L
      (Variant.typ @-> Array.typ @-> returning Int.typ)
      Int.s x0  x1 

    (** Returns \[code\]true\[/code\] if the array contains the given \[param value\].
\[codeblocks\]
\[gdscript\]
print(\[""inside"", 7\].has(""inside""))  # Prints true
print(\[""inside"", 7\].has(""outside"")) # Prints false
print(\[""inside"", 7\].has(7))         # Prints true
print(\[""inside"", 7\].has(""7""))       # Prints false
\[/gdscript\]
\[csharp\]
Godot.Collections.Array arr = \[""inside"", 7\];
// By C# convention, this method is renamed to `Contains`.
GD.Print(arr.Contains(""inside""));  // Prints True
GD.Print(arr.Contains(""outside"")); // Prints False
GD.Print(arr.Contains(7));         // Prints True
GD.Print(arr.Contains(""7""));       // Prints False
\[/csharp\]
\[/codeblocks\]
In GDScript, this is equivalent to the \[code\]in\[/code\] operator:
\[codeblock\]
if 4 in \[2, 4, 6, 8\]:
    print(""4 is here!"") # Will be printed.
\[/codeblock\]
\[b\]Note:\[/b\] For performance reasons, the search is affected by the \[param value\]''s \[enum Variant.Type\]. For example, \[code\]7\[/code\] (\[int\]) and \[code\]7.0\[/code\] (\[float\]) are not considered equal for this method. *)
    let has x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_ARRAY
      "has"
      3680194679L
      (Variant.typ @-> Array.typ @-> returning Bool.typ)
      Bool.s x0  x1 

    (** Removes and returns the last element of the array. Returns \[code\]null\[/code\] if the array is empty, without generating an error. See also \[method pop_front\]. *)
    let pop_back x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_ARRAY
      "pop_back"
      1321915136L
      (Array.typ @-> returning Variant.typ)
      Variant.s x0 

    (** Removes and returns the first element of the array. Returns \[code\]null\[/code\] if the array is empty, without generating an error. See also \[method pop_back\].
\[b\]Note:\[/b\] This method shifts every other element''s index back, which may have a noticeable performance cost, especially on larger arrays. *)
    let pop_front x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_ARRAY
      "pop_front"
      1321915136L
      (Array.typ @-> returning Variant.typ)
      Variant.s x0 

    (** Removes and returns the element of the array at index \[param position\]. If negative, \[param position\] is considered relative to the end of the array. Returns \[code\]null\[/code\] if the array is empty. If \[param position\] is out of bounds, an error message is also generated.
\[b\]Note:\[/b\] This method shifts every element''s index after \[param position\] back, which may have a noticeable performance cost, especially on larger arrays. *)
    let pop_at x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_ARRAY
      "pop_at"
      3518259424L
      (Int.typ @-> Array.typ @-> returning Variant.typ)
      Variant.s x0  x1 

    (** Sorts the array in ascending order. The final order is dependent on the ""less than"" (\[code\]<\[/code\]) comparison between elements.
\[codeblocks\]
\[gdscript\]
var numbers = \[10, 5, 2.5, 8\]
numbers.sort()
print(numbers) # Prints \[2.5, 5, 8, 10\]
\[/gdscript\]
\[csharp\]
Godot.Collections.Array numbers = \[10, 5, 2.5, 8\];
numbers.Sort();
GD.Print(numbers); // Prints \[2.5, 5, 8, 10\]
\[/csharp\]
\[/codeblocks\]
\[b\]Note:\[/b\] The sorting algorithm used is not \[url=https://en.wikipedia.org/wiki/Sorting_algorithm#Stability\]stable\[/url\]. This means that equivalent elements (such as \[code\]2\[/code\] and \[code\]2.0\[/code\]) may have their order changed when calling \[method sort\]. *)
    let sort x0  = 
    foreign_builtin_method0_void
      GlobalEnum.VariantType._TYPE_ARRAY
      "sort"
      3218959716L
      (Array.typ @-> returning Void.typ)
      Void.s x0 

    (** Sorts the array using a custom \[Callable\].
\[param func\] is called as many times as necessary, receiving two array elements as arguments. The function should return \[code\]true\[/code\] if the first element should be moved \[i\]before\[/i\] the second one, otherwise it should return \[code\]false\[/code\].
\[codeblock\]
func sort_ascending(a, b):
    if a\[1\] < b\[1\]:
        return true
    return false

func _ready():
    var my_items = \[\[""Tomato"", 5\], \[""Apple"", 9\], \[""Rice"", 4\]\]
    my_items.sort_custom(sort_ascending)
    print(my_items) # Prints \[\[""Rice"", 4\], \[""Tomato"", 5\], \[""Apple"", 9\]\]

    # Sort descending, using a lambda function.
    my_items.sort_custom(func(a, b): return a\[1\] > b\[1\])
    print(my_items) # Prints \[\[""Apple"", 9\], \[""Tomato"", 5\], \[""Rice"", 4\]\]
\[/codeblock\]
It may also be necessary to use this method to sort strings by natural order, with \[method String.naturalnocasecmp_to\], as in the following example:
\[codeblock\]
var files = \[""newfile1"", ""newfile2"", ""newfile10"", ""newfile11""\]
files.sort_custom(func(a, b): return a.naturalnocasecmp_to(b) < 0)
print(files) # Prints \[""newfile1"", ""newfile2"", ""newfile10"", ""newfile11""\]
\[/codeblock\]
\[b\]Note:\[/b\] In C#, this method is not supported.
\[b\]Note:\[/b\] The sorting algorithm used is not \[url=https://en.wikipedia.org/wiki/Sorting_algorithm#Stability\]stable\[/url\]. This means that values considered equal may have their order changed when calling this method.
\[b\]Note:\[/b\] You should not randomize the return value of \[param func\], as the heapsort algorithm expects a consistent result. Randomizing the return value will result in unexpected behavior. *)
    let sort_custom x0  x1  = 
    foreign_builtin_method1_void
      GlobalEnum.VariantType._TYPE_ARRAY
      "sort_custom"
      3470848906L
      (Callable.typ @-> Array.typ @-> returning Void.typ)
      Void.s x0  x1 

    (** Shuffles all elements of the array in a random order.
\[b\]Note:\[/b\] Like many similar functions in the engine (such as \[method \@GlobalScope.randi\] or \[method pick_random\]), this method uses a common, global random seed. To get a predictable outcome from this method, see \[method \@GlobalScope.seed\]. *)
    let shuffle x0  = 
    foreign_builtin_method0_void
      GlobalEnum.VariantType._TYPE_ARRAY
      "shuffle"
      3218959716L
      (Array.typ @-> returning Void.typ)
      Void.s x0 

    (** Returns the index of \[param value\] in the sorted array. If it cannot be found, returns where \[param value\] should be inserted to keep the array sorted. The algorithm used is \[url=https://en.wikipedia.org/wiki/Binary_search_algorithm\]binary search\[/url\].
If \[param before\] is \[code\]true\[/code\] (as by default), the returned index comes before all existing elements equal to \[param value\] in the array.
\[codeblock\]
var numbers = \[2, 4, 8, 10\]
var idx = numbers.bsearch(7)

numbers.insert(idx, 7)
print(numbers) # Prints \[2, 4, 7, 8, 10\]

var fruits = \[""Apple"", ""Lemon"", ""Lemon"", ""Orange""\]
print(fruits.bsearch(""Lemon"", true))  # Prints 1, points at the first ""Lemon"".
print(fruits.bsearch(""Lemon"", false)) # Prints 3, points at ""Orange"".
\[/codeblock\]
\[b\]Note:\[/b\] Calling \[method bsearch\] on an \[i\]unsorted\[/i\] array will result in unexpected behavior. Use \[method sort\] before calling this method. *)
    let bsearch x0  x1  x2  = 
    foreign_builtin_method2
      GlobalEnum.VariantType._TYPE_ARRAY
      "bsearch"
      3372222236L
      (Variant.typ @-> Bool.typ @-> Array.typ @-> returning Int.typ)
      Int.s x0  x1  x2 

    (** Returns the index of \[param value\] in the sorted array. If it cannot be found, returns where \[param value\] should be inserted to keep the array sorted (using \[param func\] for the comparisons). The algorithm used is \[url=https://en.wikipedia.org/wiki/Binary_search_algorithm\]binary search\[/url\].
Similar to \[method sort_custom\], \[param func\] is called as many times as necessary, receiving one array element and \[param value\] as arguments. The function should return \[code\]true\[/code\] if the array element should be \[i\]behind\[/i\] \[param value\], otherwise it should return \[code\]false\[/code\].
If \[param before\] is \[code\]true\[/code\] (as by default), the returned index comes before all existing elements equal to \[param value\] in the array.
\[codeblock\]
func sort_by_amount(a, b):
    if a\[1\] < b\[1\]:
        return true
    return false

func _ready():
    var my_items = \[\[""Tomato"", 2\], \[""Kiwi"", 5\], \[""Rice"", 9\]\]

    var apple = \[""Apple"", 5\]
    # ""Apple"" is inserted before ""Kiwi"".
    my_items.insert(my_items.bsearch_custom(apple, sort_by_amount, true), apple)

    var banana = \[""Banana"", 5\]
    # ""Banana"" is inserted after ""Kiwi"".
    my_items.insert(my_items.bsearch_custom(banana, sort_by_amount, false), banana)

    # Prints \[\[""Tomato"", 2\], \[""Apple"", 5\], \[""Kiwi"", 5\], \[""Banana"", 5\], \[""Rice"", 9\]\]
    print(my_items)
\[/codeblock\]
\[b\]Note:\[/b\] Calling \[method bsearch_custom\] on an \[i\]unsorted\[/i\] array will result in unexpected behavior. Use \[method sort_custom\] with \[param func\] before calling this method. *)
    let bsearch_custom x0  x1  x2  x3  = 
    foreign_builtin_method3
      GlobalEnum.VariantType._TYPE_ARRAY
      "bsearch_custom"
      161317131L
      (Variant.typ @-> Callable.typ @-> Bool.typ @-> Array.typ @-> returning Int.typ)
      Int.s x0  x1  x2  x3 

    (** Reverses the order of all elements in the array. *)
    let reverse x0  = 
    foreign_builtin_method0_void
      GlobalEnum.VariantType._TYPE_ARRAY
      "reverse"
      3218959716L
      (Array.typ @-> returning Void.typ)
      Void.s x0 

    (** Returns a new copy of the array.
By default, a \[b\]shallow\[/b\] copy is returned: all nested \[Array\] and \[Dictionary\] elements are shared with the original array. Modifying them in one array will also affect them in the other.\[br\]If \[param deep\] is \[code\]true\[/code\], a \[b\]deep\[/b\] copy is returned: all nested arrays and dictionaries are also duplicated (recursively). *)
    let duplicate x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_ARRAY
      "duplicate"
      636440122L
      (Bool.typ @-> Array.typ @-> returning Array.typ)
      Array.s x0  x1 

    (** Returns a new \[Array\] containing this array''s elements, from index \[param begin\] (inclusive) to \[param end\] (exclusive), every \[param step\] elements.
If either \[param begin\] or \[param end\] are negative, their value is relative to the end of the array.
If \[param step\] is negative, this method iterates through the array in reverse, returning a slice ordered backwards. For this to work, \[param begin\] must be greater than \[param end\].
If \[param deep\] is \[code\]true\[/code\], all nested \[Array\] and \[Dictionary\] elements in the slice are duplicated from the original, recursively. See also \[method duplicate\]).
\[codeblock\]
var letters = \[""A"", ""B"", ""C"", ""D"", ""E"", ""F""\]

print(letters.slice(0, 2))  # Prints \[""A"", ""B""\]
print(letters.slice(2, -2)) # Prints \[""C"", ""D""\]
print(letters.slice(-2, 6)) # Prints \[""E"", ""F""\]

print(letters.slice(0, 6, 2))  # Prints \[""A"", ""C"", ""E""\]
print(letters.slice(4, 1, -1)) # Prints \[""E"", ""D"", ""C""\]
\[/codeblock\] *)
    let slice x0  x1  x2  x3  x4  = 
    foreign_builtin_method4
      GlobalEnum.VariantType._TYPE_ARRAY
      "slice"
      1393718243L
      (Int.typ @-> Int.typ @-> Int.typ @-> Bool.typ @-> Array.typ @-> returning Array.typ)
      Array.s x0  x1  x2  x3  x4 

    (** Calls the given \[Callable\] on each element in the array and returns a new, filtered \[Array\].
The \[param method\] receives one of the array elements as an argument, and should return \[code\]true\[/code\] to add the element to the filtered array, or \[code\]false\[/code\] to exclude it.
\[codeblock\]
func is_even(number):
    return number % 2 == 0

func _ready():
    print(\[1, 4, 5, 8\].filter(is_even)) # Prints \[4, 8\]

    # Same as above, but using a lambda function.
    print(\[1, 4, 5, 8\].filter(func(number): return number % 2 == 0))
\[/codeblock\]
See also \[method any\], \[method all\], \[method map\] and \[method reduce\]. *)
    let filter x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_ARRAY
      "filter"
      4075186556L
      (Callable.typ @-> Array.typ @-> returning Array.typ)
      Array.s x0  x1 

    (** Calls the given \[Callable\] for each element in the array and returns a new array filled with values returned by the \[param method\].
The \[param method\] should take one \[Variant\] parameter (the current array element) and can return any \[Variant\].
\[codeblock\]
func double(number):
    return number  *  2

func _ready():
    print(\[1, 2, 3\].map(double)) # Prints \[2, 4, 6\]

    # Same as above, but using a lambda function.
    print(\[1, 2, 3\].map(func(element): return element  *  2))
\[/codeblock\]
See also \[method filter\], \[method reduce\], \[method any\] and \[method all\]. *)
    let map x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_ARRAY
      "map"
      4075186556L
      (Callable.typ @-> Array.typ @-> returning Array.typ)
      Array.s x0  x1 

    (** Calls the given \[Callable\] for each element in array, accumulates the result in \[param accum\], then returns it.
The \[param method\] takes two arguments: the current value of \[param accum\] and the current array element. If \[param accum\] is \[code\]null\[/code\] (as by default), the iteration will start from the second element, with the first one used as initial value of \[param accum\].
\[codeblock\]
func sum(accum, number):
    return accum + number

func _ready():
    print(\[1, 2, 3\].reduce(sum, 0))  # Prints 6
    print(\[1, 2, 3\].reduce(sum, 10)) # Prints 16

    # Same as above, but using a lambda function.
    print(\[1, 2, 3\].reduce(func(accum, number): return accum + number, 10))
\[/codeblock\]
If \[method max\] is not desirable, this method may also be used to implement a custom comparator:
\[codeblock\]
func _ready():
    var arr = \[Vector2i(5, 0), Vector2i(3, 4), Vector2i(1, 2)\]

    var longest_vec = arr.reduce(func(max, vec): return vec if is_length_greater(vec, max) else max)
    print(longest_vec) # Prints (3, 4)

func is_length_greater(a, b):
    return a.length() > b.length()
\[/codeblock\]
This method can also be used to count how many elements in an array satisfy a certain condition, similar to \[method count\]:
\[codeblock\]
func is_even(number):
    return number % 2 == 0

func _ready():
    var arr = \[1, 2, 3, 4, 5\]
    # If the current element is even, increment count, otherwise leave count the same.
    var even_count = arr.reduce(func(count, next): return count + 1 if is_even(next) else count, 0)
    print(even_count) # Prints 2
\[/codeblock\]
See also \[method map\], \[method filter\], \[method any\], and \[method all\]. *)
    let reduce x0  x1  x2  = 
    foreign_builtin_method2
      GlobalEnum.VariantType._TYPE_ARRAY
      "reduce"
      4272450342L
      (Callable.typ @-> Variant.typ @-> Array.typ @-> returning Variant.typ)
      Variant.s x0  x1  x2 

    (** Calls the given \[Callable\] on each element in the array and returns \[code\]true\[/code\] if the \[Callable\] returns \[code\]true\[/code\] for \[i\]one or more\[/i\] elements in the array. If the \[Callable\] returns \[code\]false\[/code\] for all elements in the array, this method returns \[code\]false\[/code\].
The \[param method\] should take one \[Variant\] parameter (the current array element) and return a \[bool\].
\[codeblock\]
func greater_than_5(number):
    return number > 5

func _ready():
    print(\[6, 10, 6\].any(greater_than_5)) # Prints true (3 elements evaluate to true).
    print(\[4, 10, 4\].any(greater_than_5)) # Prints true (1 elements evaluate to true).
    print(\[4, 4, 4\].any(greater_than_5))  # Prints false (0 elements evaluate to true).
    print(\[\].any(greater_than_5))         # Prints false (0 elements evaluate to true).

    # Same as the first line above, but using a lambda function.
    print(\[6, 10, 6\].any(func(number): return number > 5)) # Prints true
\[/codeblock\]
See also \[method all\], \[method filter\], \[method map\] and \[method reduce\].
\[b\]Note:\[/b\] Unlike relying on the size of an array returned by \[method filter\], this method will return as early as possible to improve performance (especially with large arrays).
\[b\]Note:\[/b\] For an empty array, this method always returns \[code\]false\[/code\]. *)
    let any x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_ARRAY
      "any"
      4129521963L
      (Callable.typ @-> Array.typ @-> returning Bool.typ)
      Bool.s x0  x1 

    (** Calls the given \[Callable\] on each element in the array and returns \[code\]true\[/code\] if the \[Callable\] returns \[code\]true\[/code\] for \[i\]all\[/i\] elements in the array. If the \[Callable\] returns \[code\]false\[/code\] for one array element or more, this method returns \[code\]false\[/code\].
The \[param method\] should take one \[Variant\] parameter (the current array element) and return a \[bool\].
\[codeblocks\]
\[gdscript\]
func greater_than_5(number):
    return number > 5

func _ready():
    print(\[6, 10, 6\].all(greater_than_5)) # Prints true (3/3 elements evaluate to true).
    print(\[4, 10, 4\].all(greater_than_5)) # Prints false (1/3 elements evaluate to true).
    print(\[4, 4, 4\].all(greater_than_5))  # Prints false (0/3 elements evaluate to true).
    print(\[\].all(greater_than_5))         # Prints true (0/0 elements evaluate to true).

    # Same as the first line above, but using a lambda function.
    print(\[6, 10, 6\].all(func(element): return element > 5)) # Prints true
\[/gdscript\]
\[csharp\]
private static bool GreaterThan5(int number)
\{!
    return number > 5;
\}

public override void _Ready()
\{!
    // Prints True (3/3 elements evaluate to true).
    GD.Print(new Godot.Collections.Array>int< \{! 6, 10, 6 \}.All(GreaterThan5));
    // Prints False (1/3 elements evaluate to true).
    GD.Print(new Godot.Collections.Array>int< \{! 4, 10, 4 \}.All(GreaterThan5));
    // Prints False (0/3 elements evaluate to true).
    GD.Print(new Godot.Collections.Array>int< \{! 4, 4, 4 \}.All(GreaterThan5));
    // Prints True (0/0 elements evaluate to true).
    GD.Print(new Godot.Collections.Array>int< \{! \}.All(GreaterThan5));

    // Same as the first line above, but using a lambda function.
    GD.Print(new Godot.Collections.Array>int< \{! 6, 10, 6 \}.All(element => element > 5)); // Prints True
\}
\[/csharp\]
\[/codeblocks\]
See also \[method any\], \[method filter\], \[method map\] and \[method reduce\].
\[b\]Note:\[/b\] Unlike relying on the size of an array returned by \[method filter\], this method will return as early as possible to improve performance (especially with large arrays).
\[b\]Note:\[/b\] For an empty array, this method \[url=https://en.wikipedia.org/wiki/Vacuous_truth\]always\[/url\] returns \[code\]true\[/code\]. *)
    let all x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_ARRAY
      "all"
      4129521963L
      (Callable.typ @-> Array.typ @-> returning Bool.typ)
      Bool.s x0  x1 

    (** Returns the maximum value contained in the array, if all elements can be compared. Otherwise, returns \[code\]null\[/code\]. See also \[method min\].
To find the maximum value using a custom comparator, you can use \[method reduce\]. *)
    let max x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_ARRAY
      "max"
      1460142086L
      (Array.typ @-> returning Variant.typ)
      Variant.s x0 

    (** Returns the minimum value contained in the array, if all elements can be compared. Otherwise, returns \[code\]null\[/code\]. See also \[method max\]. *)
    let min x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_ARRAY
      "min"
      1460142086L
      (Array.typ @-> returning Variant.typ)
      Variant.s x0 

    (** Returns \[code\]true\[/code\] if the array is typed. Typed arrays can only contain elements of a specific type, as defined by the typed array constructor. The methods of a typed array are still expected to return a generic \[Variant\].
In GDScript, it is possible to define a typed array with static typing:
\[codeblock\]
var numbers: Array\[float\] = \[0.2, 4.2, -2.0\]
print(numbers.is_typed()) # Prints true
\[/codeblock\] *)
    let is_typed x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_ARRAY
      "is_typed"
      3918633141L
      (Array.typ @-> returning Bool.typ)
      Bool.s x0 

    (** Returns \[code\]true\[/code\] if this array is typed the same as the given \[param array\]. See also \[method is_typed\]. *)
    let is_same_typed x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_ARRAY
      "is_same_typed"
      2988181878L
      (Array.typ @-> Array.typ @-> returning Bool.typ)
      Bool.s x0  x1 

    (** Returns the built-in \[Variant\] type of the typed array as a \[enum Variant.Type\] constant. If the array is not typed, returns \[constant TYPE_NIL\]. See also \[method is_typed\]. *)
    let get_typed_builtin x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_ARRAY
      "get_typed_builtin"
      3173160232L
      (Array.typ @-> returning Int.typ)
      Int.s x0 

    (** Returns the \[b\]built-in\[/b\] class name of the typed array, if the built-in \[Variant\] type \[constant TYPE_OBJECT\]. Otherwise, returns an empty \[StringName\]. See also \[method is_typed\] and \[method Object.get_class\]. *)
    let get_typed_class_name x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_ARRAY
      "get_typed_class_name"
      1825232092L
      (Array.typ @-> returning StringName.typ)
      StringName.s x0 

    (** Returns the \[Script\] instance associated with this typed array, or \[code\]null\[/code\] if it does not exist. See also \[method is_typed\]. *)
    let get_typed_script x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_ARRAY
      "get_typed_script"
      1460142086L
      (Array.typ @-> returning Variant.typ)
      Variant.s x0 

    (** Makes the array read-only. The array''s elements cannot be overridden with different values, and their order cannot change. Does not apply to nested elements, such as dictionaries.
In GDScript, arrays are automatically read-only if declared with the \[code\]const\[/code\] keyword. *)
    let make_read_only x0  = 
    foreign_builtin_method0_void
      GlobalEnum.VariantType._TYPE_ARRAY
      "make_read_only"
      3218959716L
      (Array.typ @-> returning Void.typ)
      Void.s x0 

    (** Returns \[code\]true\[/code\] if the array is read-only. See \[method make_read_only\].
In GDScript, arrays are automatically read-only if declared with the \[code\]const\[/code\] keyword. *)
    let is_read_only x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_ARRAY
      "is_read_only"
      3918633141L
      (Array.typ @-> returning Bool.typ)
      Bool.s x0 






    let not x0  = 
    foreign_builtin_operator1 GlobalEnum.VariantType._TYPE_ARRAY None  GlobalEnum.VariantOperator._OP_NOT
      (funptr (Array.typ @-> Bool.typ @-> returning void))
      Bool.s x0 


    let mem_Dictionary x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_ARRAY (Some GlobalEnum.VariantType._TYPE_DICTIONARY) GlobalEnum.VariantOperator._OP_IN
      (funptr (Array.typ @-> Dictionary.typ @-> Bool.typ @-> returning void))
      Bool.s x0  x1 

    (** Compares the left operand \[Array\] against the \[param right\] \[Array\]. Returns \[code\]true\[/code\] if the sizes and contents of the arrays are equal, \[code\]false\[/code\] otherwise. *)
    let (=) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_ARRAY (Some GlobalEnum.VariantType._TYPE_ARRAY) GlobalEnum.VariantOperator._OP_EQUAL
      (funptr (Array.typ @-> Array.typ @-> Bool.typ @-> returning void))
      Bool.s
      Conv.Array.of_ocaml
      Conv.Array.of_ocaml
      Conv.Bool.to_ocaml x0  x1 

    (** Returns \[code\]true\[/code\] if the array''s size or its elements are different than \[param right\]''s. *)
    let (<>) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_ARRAY (Some GlobalEnum.VariantType._TYPE_ARRAY) GlobalEnum.VariantOperator._OP_NOT_EQUAL
      (funptr (Array.typ @-> Array.typ @-> Bool.typ @-> returning void))
      Bool.s
      Conv.Array.of_ocaml
      Conv.Array.of_ocaml
      Conv.Bool.to_ocaml x0  x1 

    (** Compares the elements of both arrays in order, starting from index \[code\]0\[/code\] and ending on the last index in common between both arrays. For each pair of elements, returns \[code\]true\[/code\] if this array''s element is less than \[param right\]''s, \[code\]false\[/code\] if this element is greater. Otherwise, continues to the next pair.
If all searched elements are equal, returns \[code\]true\[/code\] if this array''s size is less than \[param right\]''s, otherwise returns \[code\]false\[/code\]. *)
    let (<) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_ARRAY (Some GlobalEnum.VariantType._TYPE_ARRAY) GlobalEnum.VariantOperator._OP_LESS
      (funptr (Array.typ @-> Array.typ @-> Bool.typ @-> returning void))
      Bool.s
      Conv.Array.of_ocaml
      Conv.Array.of_ocaml
      Conv.Bool.to_ocaml x0  x1 

    (** Compares the elements of both arrays in order, starting from index \[code\]0\[/code\] and ending on the last index in common between both arrays. For each pair of elements, returns \[code\]true\[/code\] if this array''s element is less than \[param right\]''s, \[code\]false\[/code\] if this element is greater. Otherwise, continues to the next pair.
If all searched elements are equal, returns \[code\]true\[/code\] if this array''s size is less or equal to \[param right\]''s, otherwise returns \[code\]false\[/code\]. *)
    let (<=) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_ARRAY (Some GlobalEnum.VariantType._TYPE_ARRAY) GlobalEnum.VariantOperator._OP_LESS_EQUAL
      (funptr (Array.typ @-> Array.typ @-> Bool.typ @-> returning void))
      Bool.s
      Conv.Array.of_ocaml
      Conv.Array.of_ocaml
      Conv.Bool.to_ocaml x0  x1 

    (** Compares the elements of both arrays in order, starting from index \[code\]0\[/code\] and ending on the last index in common between both arrays. For each pair of elements, returns \[code\]true\[/code\] if this array''s element is greater than \[param right\]''s, \[code\]false\[/code\] if this element is less. Otherwise, continues to the next pair.
If all searched elements are equal, returns \[code\]true\[/code\] if this array''s size is greater than \[param right\]''s, otherwise returns \[code\]false\[/code\]. *)
    let (>) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_ARRAY (Some GlobalEnum.VariantType._TYPE_ARRAY) GlobalEnum.VariantOperator._OP_GREATER
      (funptr (Array.typ @-> Array.typ @-> Bool.typ @-> returning void))
      Bool.s
      Conv.Array.of_ocaml
      Conv.Array.of_ocaml
      Conv.Bool.to_ocaml x0  x1 

    (** Compares the elements of both arrays in order, starting from index \[code\]0\[/code\] and ending on the last index in common between both arrays. For each pair of elements, returns \[code\]true\[/code\] if this array''s element is greater than \[param right\]''s, \[code\]false\[/code\] if this element is less. Otherwise, continues to the next pair.
If all searched elements are equal, returns \[code\]true\[/code\] if this array''s size is greater or equal to \[param right\]''s, otherwise returns \[code\]false\[/code\]. *)
    let (>=) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_ARRAY (Some GlobalEnum.VariantType._TYPE_ARRAY) GlobalEnum.VariantOperator._OP_GREATER_EQUAL
      (funptr (Array.typ @-> Array.typ @-> Bool.typ @-> returning void))
      Bool.s
      Conv.Array.of_ocaml
      Conv.Array.of_ocaml
      Conv.Bool.to_ocaml x0  x1 

    (** Appends the \[param right\] array to the left operand, creating a new \[Array\]. This is also known as an array concatenation.
\[codeblocks\]
\[gdscript\]
var array1 = \[""One"", 2\]
var array2 = \[3, ""Four""\]
print(array1 + array2) # Prints \[""One"", 2, 3, ""Four""\]
\[/gdscript\]
\[csharp\]
// Note that concatenation is not possible with C#''s native Array type.
Godot.Collections.Array array1 = \[""One"", 2\];
Godot.Collections.Array array2 = \[3, ""Four""\];
GD.Print(array1 + array2); // Prints \[""One"", 2, 3, ""Four""\]
\[/csharp\]
\[/codeblocks\]
\[b\]Note:\[/b\] For existing arrays, \[method append_array\] is much more efficient than concatenation and assignment with the \[code\]+=\[/code\] operator. *)
    let (+) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_ARRAY (Some GlobalEnum.VariantType._TYPE_ARRAY) GlobalEnum.VariantOperator._OP_ADD
      (funptr (Array.typ @-> Array.typ @-> Array.typ @-> returning void))
      Array.s
      Conv.Array.of_ocaml
      Conv.Array.of_ocaml
      Conv.Array.to_ocaml x0  x1 


    let mem_Array x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_ARRAY (Some GlobalEnum.VariantType._TYPE_ARRAY) GlobalEnum.VariantOperator._OP_IN
      (funptr (Array.typ @-> Array.typ @-> Bool.typ @-> returning void))
      Bool.s x0  x1 
    end

  module PackedByteArray = struct
    include M.PackedByteArray
include BuiltinClass0.PackedByteArray

    (** Returns the byte at the given \[param index\] in the array. This is the same as using the \[code\]\[\]\[/code\] operator (\[code\]array\[index\]\[/code\]). *)
    let get x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_PACKED_BYTE_ARRAY
      "get"
      4103005248L
      (Int.typ @-> PackedByteArray.typ @-> returning Int.typ)
      Int.s x0  x1 

    (** Changes the byte at the given index. *)
    let set x0  x1  x2  = 
    foreign_builtin_method2_void
      GlobalEnum.VariantType._TYPE_PACKED_BYTE_ARRAY
      "set"
      3638975848L
      (Int.typ @-> Int.typ @-> PackedByteArray.typ @-> returning Void.typ)
      Void.s x0  x1  x2 

    (** Returns the number of elements in the array. *)
    let size x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_PACKED_BYTE_ARRAY
      "size"
      3173160232L
      (PackedByteArray.typ @-> returning Int.typ)
      Int.s x0 

    (** Returns \[code\]true\[/code\] if the array is empty. *)
    let is_empty x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_PACKED_BYTE_ARRAY
      "is_empty"
      3918633141L
      (PackedByteArray.typ @-> returning Bool.typ)
      Bool.s x0 

    (** Appends an element at the end of the array. *)
    let push_back x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_PACKED_BYTE_ARRAY
      "push_back"
      694024632L
      (Int.typ @-> PackedByteArray.typ @-> returning Bool.typ)
      Bool.s x0  x1 

    (** Appends an element at the end of the array (alias of \[method push_back\]). *)
    let append x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_PACKED_BYTE_ARRAY
      "append"
      694024632L
      (Int.typ @-> PackedByteArray.typ @-> returning Bool.typ)
      Bool.s x0  x1 

    (** Appends a \[PackedByteArray\] at the end of this array. *)
    let append_array x0  x1  = 
    foreign_builtin_method1_void
      GlobalEnum.VariantType._TYPE_PACKED_BYTE_ARRAY
      "append_array"
      791097111L
      (PackedByteArray.typ @-> PackedByteArray.typ @-> returning Void.typ)
      Void.s x0  x1 

    (** Removes an element from the array by index. *)
    let remove_at x0  x1  = 
    foreign_builtin_method1_void
      GlobalEnum.VariantType._TYPE_PACKED_BYTE_ARRAY
      "remove_at"
      2823966027L
      (Int.typ @-> PackedByteArray.typ @-> returning Void.typ)
      Void.s x0  x1 

    (** Inserts a new element at a given position in the array. The position must be valid, or at the end of the array (\[code\]idx == size()\[/code\]). *)
    let insert x0  x1  x2  = 
    foreign_builtin_method2
      GlobalEnum.VariantType._TYPE_PACKED_BYTE_ARRAY
      "insert"
      1487112728L
      (Int.typ @-> Int.typ @-> PackedByteArray.typ @-> returning Int.typ)
      Int.s x0  x1  x2 

    (** Assigns the given value to all elements in the array. This can typically be used together with \[method resize\] to create an array with a given size and initialized elements. *)
    let fill x0  x1  = 
    foreign_builtin_method1_void
      GlobalEnum.VariantType._TYPE_PACKED_BYTE_ARRAY
      "fill"
      2823966027L
      (Int.typ @-> PackedByteArray.typ @-> returning Void.typ)
      Void.s x0  x1 

    (** Sets the size of the array. If the array is grown, reserves elements at the end of the array. If the array is shrunk, truncates the array to the new size. Calling \[method resize\] once and assigning the new values is faster than adding new elements one by one. *)
    let resize x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_PACKED_BYTE_ARRAY
      "resize"
      848867239L
      (Int.typ @-> PackedByteArray.typ @-> returning Int.typ)
      Int.s x0  x1 

    (** Clears the array. This is equivalent to using \[method resize\] with a size of \[code\]0\[/code\]. *)
    let clear x0  = 
    foreign_builtin_method0_void
      GlobalEnum.VariantType._TYPE_PACKED_BYTE_ARRAY
      "clear"
      3218959716L
      (PackedByteArray.typ @-> returning Void.typ)
      Void.s x0 

    (** Returns \[code\]true\[/code\] if the array contains \[param value\]. *)
    let has x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_PACKED_BYTE_ARRAY
      "has"
      931488181L
      (Int.typ @-> PackedByteArray.typ @-> returning Bool.typ)
      Bool.s x0  x1 

    (** Reverses the order of the elements in the array. *)
    let reverse x0  = 
    foreign_builtin_method0_void
      GlobalEnum.VariantType._TYPE_PACKED_BYTE_ARRAY
      "reverse"
      3218959716L
      (PackedByteArray.typ @-> returning Void.typ)
      Void.s x0 

    (** Returns the slice of the \[PackedByteArray\], from \[param begin\] (inclusive) to \[param end\] (exclusive), as a new \[PackedByteArray\].
The absolute value of \[param begin\] and \[param end\] will be clamped to the array size, so the default value for \[param end\] makes it slice to the size of the array by default (i.e. \[code\]arr.slice(1)\[/code\] is a shorthand for \[code\]arr.slice(1, arr.size())\[/code\]).
If either \[param begin\] or \[param end\] are negative, they will be relative to the end of the array (i.e. \[code\]arr.slice(0, -2)\[/code\] is a shorthand for \[code\]arr.slice(0, arr.size() - 2)\[/code\]). *)
    let slice x0  x1  x2  = 
    foreign_builtin_method2
      GlobalEnum.VariantType._TYPE_PACKED_BYTE_ARRAY
      "slice"
      2278869132L
      (Int.typ @-> Int.typ @-> PackedByteArray.typ @-> returning PackedByteArray.typ)
      PackedByteArray.s x0  x1  x2 

    (** Sorts the elements of the array in ascending order. *)
    let sort x0  = 
    foreign_builtin_method0_void
      GlobalEnum.VariantType._TYPE_PACKED_BYTE_ARRAY
      "sort"
      3218959716L
      (PackedByteArray.typ @-> returning Void.typ)
      Void.s x0 

    (** Finds the index of an existing value (or the insertion index that maintains sorting order, if the value is not yet present in the array) using binary search. Optionally, a \[param before\] specifier can be passed. If \[code\]false\[/code\], the returned index comes after all existing entries of the value in the array.
\[b\]Note:\[/b\] Calling \[method bsearch\] on an unsorted array results in unexpected behavior. *)
    let bsearch x0  x1  x2  = 
    foreign_builtin_method2
      GlobalEnum.VariantType._TYPE_PACKED_BYTE_ARRAY
      "bsearch"
      3380005890L
      (Int.typ @-> Bool.typ @-> PackedByteArray.typ @-> returning Int.typ)
      Int.s x0  x1  x2 

    (** Creates a copy of the array, and returns it. *)
    let duplicate x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_PACKED_BYTE_ARRAY
      "duplicate"
      851781288L
      (PackedByteArray.typ @-> returning PackedByteArray.typ)
      PackedByteArray.s x0 

    (** Searches the array for a value and returns its index or \[code\]-1\[/code\] if not found. Optionally, the initial search index can be passed. *)
    let find x0  x1  x2  = 
    foreign_builtin_method2
      GlobalEnum.VariantType._TYPE_PACKED_BYTE_ARRAY
      "find"
      2984303840L
      (Int.typ @-> Int.typ @-> PackedByteArray.typ @-> returning Int.typ)
      Int.s x0  x1  x2 

    (** Searches the array in reverse order. Optionally, a start search index can be passed. If negative, the start index is considered relative to the end of the array. *)
    let rfind x0  x1  x2  = 
    foreign_builtin_method2
      GlobalEnum.VariantType._TYPE_PACKED_BYTE_ARRAY
      "rfind"
      2984303840L
      (Int.typ @-> Int.typ @-> PackedByteArray.typ @-> returning Int.typ)
      Int.s x0  x1  x2 

    (** Returns the number of times an element is in the array. *)
    let count x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_PACKED_BYTE_ARRAY
      "count"
      4103005248L
      (Int.typ @-> PackedByteArray.typ @-> returning Int.typ)
      Int.s x0  x1 

    (** Converts ASCII/Latin-1 encoded array to \[String\]. Fast alternative to \[method get_string_from_utf8\] if the content is ASCII/Latin-1 only. Unlike the UTF-8 function this function maps every byte to a character in the array. Multibyte sequences will not be interpreted correctly. For parsing user input always use \[method get_string_from_utf8\]. This is the inverse of \[method String.to_ascii_buffer\]. *)
    let get_string_from_ascii x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_PACKED_BYTE_ARRAY
      "get_string_from_ascii"
      3942272618L
      (PackedByteArray.typ @-> returning String.typ)
      String.s x0 

    (** Converts UTF-8 encoded array to \[String\]. Slower than \[method get_string_from_ascii\] but supports UTF-8 encoded data. Use this function if you are unsure about the source of the data. For user input this function should always be preferred. Returns empty string if source array is not valid UTF-8 string. This is the inverse of \[method String.to_utf8_buffer\]. *)
    let get_string_from_utf8 x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_PACKED_BYTE_ARRAY
      "get_string_from_utf8"
      3942272618L
      (PackedByteArray.typ @-> returning String.typ)
      String.s x0 

    (** Converts UTF-16 encoded array to \[String\]. If the BOM is missing, system endianness is assumed. Returns empty string if source array is not valid UTF-16 string. This is the inverse of \[method String.to_utf16_buffer\]. *)
    let get_string_from_utf16 x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_PACKED_BYTE_ARRAY
      "get_string_from_utf16"
      3942272618L
      (PackedByteArray.typ @-> returning String.typ)
      String.s x0 

    (** Converts UTF-32 encoded array to \[String\]. System endianness is assumed. Returns empty string if source array is not valid UTF-32 string. This is the inverse of \[method String.to_utf32_buffer\]. *)
    let get_string_from_utf32 x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_PACKED_BYTE_ARRAY
      "get_string_from_utf32"
      3942272618L
      (PackedByteArray.typ @-> returning String.typ)
      String.s x0 

    (** Converts wide character (\[code\]wchar_t\[/code\], UTF-16 on Windows, UTF-32 on other platforms) encoded array to \[String\]. Returns empty string if source array is not valid wide string. This is the inverse of \[method String.to_wchar_buffer\]. *)
    let get_string_from_wchar x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_PACKED_BYTE_ARRAY
      "get_string_from_wchar"
      3942272618L
      (PackedByteArray.typ @-> returning String.typ)
      String.s x0 

    (** Returns a hexadecimal representation of this array as a \[String\].
\[codeblocks\]
\[gdscript\]
var array = PackedByteArray(\[11, 46, 255\])
print(array.hex_encode()) # Prints ""0b2eff""
\[/gdscript\]
\[csharp\]
byte\[\] array = \[11, 46, 255\];
GD.Print(array.HexEncode()); // Prints ""0b2eff""
\[/csharp\]
\[/codeblocks\] *)
    let hex_encode x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_PACKED_BYTE_ARRAY
      "hex_encode"
      3942272618L
      (PackedByteArray.typ @-> returning String.typ)
      String.s x0 

    (** Returns a new \[PackedByteArray\] with the data compressed. Set the compression mode using one of \[enum FileAccess.CompressionMode\]''s constants. *)
    let compress x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_PACKED_BYTE_ARRAY
      "compress"
      1845905913L
      (Int.typ @-> PackedByteArray.typ @-> returning PackedByteArray.typ)
      PackedByteArray.s x0  x1 

    (** Returns a new \[PackedByteArray\] with the data decompressed. Set \[param buffer_size\] to the size of the uncompressed data. Set the compression mode using one of \[enum FileAccess.CompressionMode\]''s constants.
\[b\]Note:\[/b\] Decompression is not guaranteed to work with data not compressed by Godot, for example if data compressed with the deflate compression mode lacks a checksum or header. *)
    let decompress x0  x1  x2  = 
    foreign_builtin_method2
      GlobalEnum.VariantType._TYPE_PACKED_BYTE_ARRAY
      "decompress"
      2278869132L
      (Int.typ @-> Int.typ @-> PackedByteArray.typ @-> returning PackedByteArray.typ)
      PackedByteArray.s x0  x1  x2 

    (** Returns a new \[PackedByteArray\] with the data decompressed. Set the compression mode using one of \[enum FileAccess.CompressionMode\]''s constants. \[b\]This method only accepts brotli, gzip, and deflate compression modes.\[/b\]
This method is potentially slower than \[method decompress\], as it may have to re-allocate its output buffer multiple times while decompressing, whereas \[method decompress\] knows it''s output buffer size from the beginning.
GZIP has a maximal compression ratio of 1032:1, meaning it''s very possible for a small compressed payload to decompress to a potentially very large output. To guard against this, you may provide a maximum size this function is allowed to allocate in bytes via \[param max_output_size\]. Passing -1 will allow for unbounded output. If any positive value is passed, and the decompression exceeds that amount in bytes, then an error will be returned.
\[b\]Note:\[/b\] Decompression is not guaranteed to work with data not compressed by Godot, for example if data compressed with the deflate compression mode lacks a checksum or header. *)
    let decompress_dynamic x0  x1  x2  = 
    foreign_builtin_method2
      GlobalEnum.VariantType._TYPE_PACKED_BYTE_ARRAY
      "decompress_dynamic"
      2278869132L
      (Int.typ @-> Int.typ @-> PackedByteArray.typ @-> returning PackedByteArray.typ)
      PackedByteArray.s x0  x1  x2 

    (** Decodes a 8-bit unsigned integer number from the bytes starting at \[param byte_offset\]. Fails if the byte count is insufficient. Returns \[code\]0\[/code\] if a valid number can''t be decoded. *)
    let decode_u8 x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_PACKED_BYTE_ARRAY
      "decode_u8"
      4103005248L
      (Int.typ @-> PackedByteArray.typ @-> returning Int.typ)
      Int.s x0  x1 

    (** Decodes a 8-bit signed integer number from the bytes starting at \[param byte_offset\]. Fails if the byte count is insufficient. Returns \[code\]0\[/code\] if a valid number can''t be decoded. *)
    let decode_s8 x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_PACKED_BYTE_ARRAY
      "decode_s8"
      4103005248L
      (Int.typ @-> PackedByteArray.typ @-> returning Int.typ)
      Int.s x0  x1 

    (** Decodes a 16-bit unsigned integer number from the bytes starting at \[param byte_offset\]. Fails if the byte count is insufficient. Returns \[code\]0\[/code\] if a valid number can''t be decoded. *)
    let decode_u16 x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_PACKED_BYTE_ARRAY
      "decode_u16"
      4103005248L
      (Int.typ @-> PackedByteArray.typ @-> returning Int.typ)
      Int.s x0  x1 

    (** Decodes a 16-bit signed integer number from the bytes starting at \[param byte_offset\]. Fails if the byte count is insufficient. Returns \[code\]0\[/code\] if a valid number can''t be decoded. *)
    let decode_s16 x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_PACKED_BYTE_ARRAY
      "decode_s16"
      4103005248L
      (Int.typ @-> PackedByteArray.typ @-> returning Int.typ)
      Int.s x0  x1 

    (** Decodes a 32-bit unsigned integer number from the bytes starting at \[param byte_offset\]. Fails if the byte count is insufficient. Returns \[code\]0\[/code\] if a valid number can''t be decoded. *)
    let decode_u32 x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_PACKED_BYTE_ARRAY
      "decode_u32"
      4103005248L
      (Int.typ @-> PackedByteArray.typ @-> returning Int.typ)
      Int.s x0  x1 

    (** Decodes a 32-bit signed integer number from the bytes starting at \[param byte_offset\]. Fails if the byte count is insufficient. Returns \[code\]0\[/code\] if a valid number can''t be decoded. *)
    let decode_s32 x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_PACKED_BYTE_ARRAY
      "decode_s32"
      4103005248L
      (Int.typ @-> PackedByteArray.typ @-> returning Int.typ)
      Int.s x0  x1 

    (** Decodes a 64-bit unsigned integer number from the bytes starting at \[param byte_offset\]. Fails if the byte count is insufficient. Returns \[code\]0\[/code\] if a valid number can''t be decoded. *)
    let decode_u64 x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_PACKED_BYTE_ARRAY
      "decode_u64"
      4103005248L
      (Int.typ @-> PackedByteArray.typ @-> returning Int.typ)
      Int.s x0  x1 

    (** Decodes a 64-bit signed integer number from the bytes starting at \[param byte_offset\]. Fails if the byte count is insufficient. Returns \[code\]0\[/code\] if a valid number can''t be decoded. *)
    let decode_s64 x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_PACKED_BYTE_ARRAY
      "decode_s64"
      4103005248L
      (Int.typ @-> PackedByteArray.typ @-> returning Int.typ)
      Int.s x0  x1 

    (** Decodes a 16-bit floating-point number from the bytes starting at \[param byte_offset\]. Fails if the byte count is insufficient. Returns \[code\]0.0\[/code\] if a valid number can''t be decoded. *)
    let decode_half x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_PACKED_BYTE_ARRAY
      "decode_half"
      1401583798L
      (Int.typ @-> PackedByteArray.typ @-> returning Float.typ)
      Float.s x0  x1 

    (** Decodes a 32-bit floating-point number from the bytes starting at \[param byte_offset\]. Fails if the byte count is insufficient. Returns \[code\]0.0\[/code\] if a valid number can''t be decoded. *)
    let decode_float x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_PACKED_BYTE_ARRAY
      "decode_float"
      1401583798L
      (Int.typ @-> PackedByteArray.typ @-> returning Float.typ)
      Float.s x0  x1 

    (** Decodes a 64-bit floating-point number from the bytes starting at \[param byte_offset\]. Fails if the byte count is insufficient. Returns \[code\]0.0\[/code\] if a valid number can''t be decoded. *)
    let decode_double x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_PACKED_BYTE_ARRAY
      "decode_double"
      1401583798L
      (Int.typ @-> PackedByteArray.typ @-> returning Float.typ)
      Float.s x0  x1 

    (** Returns \[code\]true\[/code\] if a valid \[Variant\] value can be decoded at the \[param byte_offset\]. Returns \[code\]false\[/code\] otherwise or when the value is \[Object\]-derived and \[param allow_objects\] is \[code\]false\[/code\]. *)
    let has_encoded_var x0  x1  x2  = 
    foreign_builtin_method2
      GlobalEnum.VariantType._TYPE_PACKED_BYTE_ARRAY
      "has_encoded_var"
      2914632957L
      (Int.typ @-> Bool.typ @-> PackedByteArray.typ @-> returning Bool.typ)
      Bool.s x0  x1  x2 

    (** Decodes a \[Variant\] from the bytes starting at \[param byte_offset\]. Returns \[code\]null\[/code\] if a valid variant can''t be decoded or the value is \[Object\]-derived and \[param allow_objects\] is \[code\]false\[/code\]. *)
    let decode_var x0  x1  x2  = 
    foreign_builtin_method2
      GlobalEnum.VariantType._TYPE_PACKED_BYTE_ARRAY
      "decode_var"
      1740420038L
      (Int.typ @-> Bool.typ @-> PackedByteArray.typ @-> returning Variant.typ)
      Variant.s x0  x1  x2 

    (** Decodes a size of a \[Variant\] from the bytes starting at \[param byte_offset\]. Requires at least 4 bytes of data starting at the offset, otherwise fails. *)
    let decode_var_size x0  x1  x2  = 
    foreign_builtin_method2
      GlobalEnum.VariantType._TYPE_PACKED_BYTE_ARRAY
      "decode_var_size"
      954237325L
      (Int.typ @-> Bool.typ @-> PackedByteArray.typ @-> returning Int.typ)
      Int.s x0  x1  x2 

    (** Returns a copy of the data converted to a \[PackedInt32Array\], where each block of 4 bytes has been converted to a signed 32-bit integer (C++ \[code\]int32_t\[/code\]).
The size of the input array must be a multiple of 4 (size of 32-bit integer). The size of the new array will be \[code\]byte_array.size() / 4\[/code\].
If the original data can''t be converted to signed 32-bit integers, the resulting data is undefined. *)
    let to_int32_array x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_PACKED_BYTE_ARRAY
      "to_int32_array"
      3158844420L
      (PackedByteArray.typ @-> returning PackedInt32Array.typ)
      PackedInt32Array.s x0 

    (** Returns a copy of the data converted to a \[PackedInt64Array\], where each block of 8 bytes has been converted to a signed 64-bit integer (C++ \[code\]int64_t\[/code\], Godot \[int\]).
The size of the input array must be a multiple of 8 (size of 64-bit integer). The size of the new array will be \[code\]byte_array.size() / 8\[/code\].
If the original data can''t be converted to signed 64-bit integers, the resulting data is undefined. *)
    let to_int64_array x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_PACKED_BYTE_ARRAY
      "to_int64_array"
      1961294120L
      (PackedByteArray.typ @-> returning PackedInt64Array.typ)
      PackedInt64Array.s x0 

    (** Returns a copy of the data converted to a \[PackedFloat32Array\], where each block of 4 bytes has been converted to a 32-bit float (C++ \[code skip-lint\]float\[/code\]).
The size of the input array must be a multiple of 4 (size of 32-bit float). The size of the new array will be \[code\]byte_array.size() / 4\[/code\].
If the original data can''t be converted to 32-bit floats, the resulting data is undefined. *)
    let to_float32_array x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_PACKED_BYTE_ARRAY
      "to_float32_array"
      3575107827L
      (PackedByteArray.typ @-> returning PackedFloat32Array.typ)
      PackedFloat32Array.s x0 

    (** Returns a copy of the data converted to a \[PackedFloat64Array\], where each block of 8 bytes has been converted to a 64-bit float (C++ \[code\]double\[/code\], Godot \[float\]).
The size of the input array must be a multiple of 8 (size of 64-bit double). The size of the new array will be \[code\]byte_array.size() / 8\[/code\].
If the original data can''t be converted to 64-bit floats, the resulting data is undefined. *)
    let to_float64_array x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_PACKED_BYTE_ARRAY
      "to_float64_array"
      1627308337L
      (PackedByteArray.typ @-> returning PackedFloat64Array.typ)
      PackedFloat64Array.s x0 

    (** Encodes a 8-bit unsigned integer number (byte) at the index of \[param byte_offset\] bytes. The array must have at least 1 byte of space, starting at the offset. *)
    let encode_u8 x0  x1  x2  = 
    foreign_builtin_method2_void
      GlobalEnum.VariantType._TYPE_PACKED_BYTE_ARRAY
      "encode_u8"
      3638975848L
      (Int.typ @-> Int.typ @-> PackedByteArray.typ @-> returning Void.typ)
      Void.s x0  x1  x2 

    (** Encodes a 8-bit signed integer number (signed byte) at the index of \[param byte_offset\] bytes. The array must have at least 1 byte of space, starting at the offset. *)
    let encode_s8 x0  x1  x2  = 
    foreign_builtin_method2_void
      GlobalEnum.VariantType._TYPE_PACKED_BYTE_ARRAY
      "encode_s8"
      3638975848L
      (Int.typ @-> Int.typ @-> PackedByteArray.typ @-> returning Void.typ)
      Void.s x0  x1  x2 

    (** Encodes a 16-bit unsigned integer number as bytes at the index of \[param byte_offset\] bytes. The array must have at least 2 bytes of space, starting at the offset. *)
    let encode_u16 x0  x1  x2  = 
    foreign_builtin_method2_void
      GlobalEnum.VariantType._TYPE_PACKED_BYTE_ARRAY
      "encode_u16"
      3638975848L
      (Int.typ @-> Int.typ @-> PackedByteArray.typ @-> returning Void.typ)
      Void.s x0  x1  x2 

    (** Encodes a 16-bit signed integer number as bytes at the index of \[param byte_offset\] bytes. The array must have at least 2 bytes of space, starting at the offset. *)
    let encode_s16 x0  x1  x2  = 
    foreign_builtin_method2_void
      GlobalEnum.VariantType._TYPE_PACKED_BYTE_ARRAY
      "encode_s16"
      3638975848L
      (Int.typ @-> Int.typ @-> PackedByteArray.typ @-> returning Void.typ)
      Void.s x0  x1  x2 

    (** Encodes a 32-bit unsigned integer number as bytes at the index of \[param byte_offset\] bytes. The array must have at least 4 bytes of space, starting at the offset. *)
    let encode_u32 x0  x1  x2  = 
    foreign_builtin_method2_void
      GlobalEnum.VariantType._TYPE_PACKED_BYTE_ARRAY
      "encode_u32"
      3638975848L
      (Int.typ @-> Int.typ @-> PackedByteArray.typ @-> returning Void.typ)
      Void.s x0  x1  x2 

    (** Encodes a 32-bit signed integer number as bytes at the index of \[param byte_offset\] bytes. The array must have at least 4 bytes of space, starting at the offset. *)
    let encode_s32 x0  x1  x2  = 
    foreign_builtin_method2_void
      GlobalEnum.VariantType._TYPE_PACKED_BYTE_ARRAY
      "encode_s32"
      3638975848L
      (Int.typ @-> Int.typ @-> PackedByteArray.typ @-> returning Void.typ)
      Void.s x0  x1  x2 

    (** Encodes a 64-bit unsigned integer number as bytes at the index of \[param byte_offset\] bytes. The array must have at least 8 bytes of space, starting at the offset. *)
    let encode_u64 x0  x1  x2  = 
    foreign_builtin_method2_void
      GlobalEnum.VariantType._TYPE_PACKED_BYTE_ARRAY
      "encode_u64"
      3638975848L
      (Int.typ @-> Int.typ @-> PackedByteArray.typ @-> returning Void.typ)
      Void.s x0  x1  x2 

    (** Encodes a 64-bit signed integer number as bytes at the index of \[param byte_offset\] bytes. The array must have at least 8 bytes of space, starting at the offset. *)
    let encode_s64 x0  x1  x2  = 
    foreign_builtin_method2_void
      GlobalEnum.VariantType._TYPE_PACKED_BYTE_ARRAY
      "encode_s64"
      3638975848L
      (Int.typ @-> Int.typ @-> PackedByteArray.typ @-> returning Void.typ)
      Void.s x0  x1  x2 

    (** Encodes a 16-bit floating-point number as bytes at the index of \[param byte_offset\] bytes. The array must have at least 2 bytes of space, starting at the offset. *)
    let encode_half x0  x1  x2  = 
    foreign_builtin_method2_void
      GlobalEnum.VariantType._TYPE_PACKED_BYTE_ARRAY
      "encode_half"
      1113000516L
      (Int.typ @-> Float.typ @-> PackedByteArray.typ @-> returning Void.typ)
      Void.s x0  x1  x2 

    (** Encodes a 32-bit floating-point number as bytes at the index of \[param byte_offset\] bytes. The array must have at least 4 bytes of space, starting at the offset. *)
    let encode_float x0  x1  x2  = 
    foreign_builtin_method2_void
      GlobalEnum.VariantType._TYPE_PACKED_BYTE_ARRAY
      "encode_float"
      1113000516L
      (Int.typ @-> Float.typ @-> PackedByteArray.typ @-> returning Void.typ)
      Void.s x0  x1  x2 

    (** Encodes a 64-bit floating-point number as bytes at the index of \[param byte_offset\] bytes. The array must have at least 8 bytes of allocated space, starting at the offset. *)
    let encode_double x0  x1  x2  = 
    foreign_builtin_method2_void
      GlobalEnum.VariantType._TYPE_PACKED_BYTE_ARRAY
      "encode_double"
      1113000516L
      (Int.typ @-> Float.typ @-> PackedByteArray.typ @-> returning Void.typ)
      Void.s x0  x1  x2 

    (** Encodes a \[Variant\] at the index of \[param byte_offset\] bytes. A sufficient space must be allocated, depending on the encoded variant''s size. If \[param allow_objects\] is \[code\]false\[/code\], \[Object\]-derived values are not permitted and will instead be serialized as ID-only. *)
    let encode_var x0  x1  x2  x3  = 
    foreign_builtin_method3
      GlobalEnum.VariantType._TYPE_PACKED_BYTE_ARRAY
      "encode_var"
      2604460497L
      (Int.typ @-> Variant.typ @-> Bool.typ @-> PackedByteArray.typ @-> returning Int.typ)
      Int.s x0  x1  x2  x3 






    let not x0  = 
    foreign_builtin_operator1 GlobalEnum.VariantType._TYPE_PACKED_BYTE_ARRAY None  GlobalEnum.VariantOperator._OP_NOT
      (funptr (PackedByteArray.typ @-> Bool.typ @-> returning void))
      Bool.s x0 


    let mem_Dictionary x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_PACKED_BYTE_ARRAY (Some GlobalEnum.VariantType._TYPE_DICTIONARY) GlobalEnum.VariantOperator._OP_IN
      (funptr (PackedByteArray.typ @-> Dictionary.typ @-> Bool.typ @-> returning void))
      Bool.s x0  x1 


    let mem_Array x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_PACKED_BYTE_ARRAY (Some GlobalEnum.VariantType._TYPE_ARRAY) GlobalEnum.VariantOperator._OP_IN
      (funptr (PackedByteArray.typ @-> Array.typ @-> Bool.typ @-> returning void))
      Bool.s x0  x1 

    (** Returns \[code\]true\[/code\] if contents of both arrays are the same, i.e. they have all equal bytes at the corresponding indices. *)
    let (=) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_PACKED_BYTE_ARRAY (Some GlobalEnum.VariantType._TYPE_PACKED_BYTE_ARRAY) GlobalEnum.VariantOperator._OP_EQUAL
      (funptr (PackedByteArray.typ @-> PackedByteArray.typ @-> Bool.typ @-> returning void))
      Bool.s
      Conv.PackedByteArray.of_ocaml
      Conv.PackedByteArray.of_ocaml
      Conv.Bool.to_ocaml x0  x1 

    (** Returns \[code\]true\[/code\] if contents of the arrays differ. *)
    let (<>) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_PACKED_BYTE_ARRAY (Some GlobalEnum.VariantType._TYPE_PACKED_BYTE_ARRAY) GlobalEnum.VariantOperator._OP_NOT_EQUAL
      (funptr (PackedByteArray.typ @-> PackedByteArray.typ @-> Bool.typ @-> returning void))
      Bool.s
      Conv.PackedByteArray.of_ocaml
      Conv.PackedByteArray.of_ocaml
      Conv.Bool.to_ocaml x0  x1 

    (** Returns a new \[PackedByteArray\] with contents of \[param right\] added at the end of this array. For better performance, consider using \[method append_array\] instead. *)
    let (+) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_PACKED_BYTE_ARRAY (Some GlobalEnum.VariantType._TYPE_PACKED_BYTE_ARRAY) GlobalEnum.VariantOperator._OP_ADD
      (funptr (PackedByteArray.typ @-> PackedByteArray.typ @-> PackedByteArray.typ @-> returning void))
      PackedByteArray.s
      Conv.PackedByteArray.of_ocaml
      Conv.PackedByteArray.of_ocaml
      Conv.PackedByteArray.to_ocaml x0  x1 
    end

  module PackedInt32Array = struct
    include M.PackedInt32Array
include BuiltinClass0.PackedInt32Array

    (** Returns the 32-bit integer at the given \[param index\] in the array. This is the same as using the \[code\]\[\]\[/code\] operator (\[code\]array\[index\]\[/code\]). *)
    let get x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_PACKED_INT32_ARRAY
      "get"
      4103005248L
      (Int.typ @-> PackedInt32Array.typ @-> returning Int.typ)
      Int.s x0  x1 

    (** Changes the integer at the given index. *)
    let set x0  x1  x2  = 
    foreign_builtin_method2_void
      GlobalEnum.VariantType._TYPE_PACKED_INT32_ARRAY
      "set"
      3638975848L
      (Int.typ @-> Int.typ @-> PackedInt32Array.typ @-> returning Void.typ)
      Void.s x0  x1  x2 

    (** Returns the number of elements in the array. *)
    let size x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_PACKED_INT32_ARRAY
      "size"
      3173160232L
      (PackedInt32Array.typ @-> returning Int.typ)
      Int.s x0 

    (** Returns \[code\]true\[/code\] if the array is empty. *)
    let is_empty x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_PACKED_INT32_ARRAY
      "is_empty"
      3918633141L
      (PackedInt32Array.typ @-> returning Bool.typ)
      Bool.s x0 

    (** Appends a value to the array. *)
    let push_back x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_PACKED_INT32_ARRAY
      "push_back"
      694024632L
      (Int.typ @-> PackedInt32Array.typ @-> returning Bool.typ)
      Bool.s x0  x1 

    (** Appends an element at the end of the array (alias of \[method push_back\]). *)
    let append x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_PACKED_INT32_ARRAY
      "append"
      694024632L
      (Int.typ @-> PackedInt32Array.typ @-> returning Bool.typ)
      Bool.s x0  x1 

    (** Appends a \[PackedInt32Array\] at the end of this array. *)
    let append_array x0  x1  = 
    foreign_builtin_method1_void
      GlobalEnum.VariantType._TYPE_PACKED_INT32_ARRAY
      "append_array"
      1087733270L
      (PackedInt32Array.typ @-> PackedInt32Array.typ @-> returning Void.typ)
      Void.s x0  x1 

    (** Removes an element from the array by index. *)
    let remove_at x0  x1  = 
    foreign_builtin_method1_void
      GlobalEnum.VariantType._TYPE_PACKED_INT32_ARRAY
      "remove_at"
      2823966027L
      (Int.typ @-> PackedInt32Array.typ @-> returning Void.typ)
      Void.s x0  x1 

    (** Inserts a new integer at a given position in the array. The position must be valid, or at the end of the array (\[code\]idx == size()\[/code\]). *)
    let insert x0  x1  x2  = 
    foreign_builtin_method2
      GlobalEnum.VariantType._TYPE_PACKED_INT32_ARRAY
      "insert"
      1487112728L
      (Int.typ @-> Int.typ @-> PackedInt32Array.typ @-> returning Int.typ)
      Int.s x0  x1  x2 

    (** Assigns the given value to all elements in the array. This can typically be used together with \[method resize\] to create an array with a given size and initialized elements. *)
    let fill x0  x1  = 
    foreign_builtin_method1_void
      GlobalEnum.VariantType._TYPE_PACKED_INT32_ARRAY
      "fill"
      2823966027L
      (Int.typ @-> PackedInt32Array.typ @-> returning Void.typ)
      Void.s x0  x1 

    (** Sets the size of the array. If the array is grown, reserves elements at the end of the array. If the array is shrunk, truncates the array to the new size. Calling \[method resize\] once and assigning the new values is faster than adding new elements one by one. *)
    let resize x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_PACKED_INT32_ARRAY
      "resize"
      848867239L
      (Int.typ @-> PackedInt32Array.typ @-> returning Int.typ)
      Int.s x0  x1 

    (** Clears the array. This is equivalent to using \[method resize\] with a size of \[code\]0\[/code\]. *)
    let clear x0  = 
    foreign_builtin_method0_void
      GlobalEnum.VariantType._TYPE_PACKED_INT32_ARRAY
      "clear"
      3218959716L
      (PackedInt32Array.typ @-> returning Void.typ)
      Void.s x0 

    (** Returns \[code\]true\[/code\] if the array contains \[param value\]. *)
    let has x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_PACKED_INT32_ARRAY
      "has"
      931488181L
      (Int.typ @-> PackedInt32Array.typ @-> returning Bool.typ)
      Bool.s x0  x1 

    (** Reverses the order of the elements in the array. *)
    let reverse x0  = 
    foreign_builtin_method0_void
      GlobalEnum.VariantType._TYPE_PACKED_INT32_ARRAY
      "reverse"
      3218959716L
      (PackedInt32Array.typ @-> returning Void.typ)
      Void.s x0 

    (** Returns the slice of the \[PackedInt32Array\], from \[param begin\] (inclusive) to \[param end\] (exclusive), as a new \[PackedInt32Array\].
The absolute value of \[param begin\] and \[param end\] will be clamped to the array size, so the default value for \[param end\] makes it slice to the size of the array by default (i.e. \[code\]arr.slice(1)\[/code\] is a shorthand for \[code\]arr.slice(1, arr.size())\[/code\]).
If either \[param begin\] or \[param end\] are negative, they will be relative to the end of the array (i.e. \[code\]arr.slice(0, -2)\[/code\] is a shorthand for \[code\]arr.slice(0, arr.size() - 2)\[/code\]). *)
    let slice x0  x1  x2  = 
    foreign_builtin_method2
      GlobalEnum.VariantType._TYPE_PACKED_INT32_ARRAY
      "slice"
      1216021098L
      (Int.typ @-> Int.typ @-> PackedInt32Array.typ @-> returning PackedInt32Array.typ)
      PackedInt32Array.s x0  x1  x2 

    (** Returns a copy of the data converted to a \[PackedByteArray\], where each element has been encoded as 4 bytes.
The size of the new array will be \[code\]int32_array.size()  *  4\[/code\]. *)
    let to_byte_array x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_PACKED_INT32_ARRAY
      "to_byte_array"
      247621236L
      (PackedInt32Array.typ @-> returning PackedByteArray.typ)
      PackedByteArray.s x0 

    (** Sorts the elements of the array in ascending order. *)
    let sort x0  = 
    foreign_builtin_method0_void
      GlobalEnum.VariantType._TYPE_PACKED_INT32_ARRAY
      "sort"
      3218959716L
      (PackedInt32Array.typ @-> returning Void.typ)
      Void.s x0 

    (** Finds the index of an existing value (or the insertion index that maintains sorting order, if the value is not yet present in the array) using binary search. Optionally, a \[param before\] specifier can be passed. If \[code\]false\[/code\], the returned index comes after all existing entries of the value in the array.
\[b\]Note:\[/b\] Calling \[method bsearch\] on an unsorted array results in unexpected behavior. *)
    let bsearch x0  x1  x2  = 
    foreign_builtin_method2
      GlobalEnum.VariantType._TYPE_PACKED_INT32_ARRAY
      "bsearch"
      3380005890L
      (Int.typ @-> Bool.typ @-> PackedInt32Array.typ @-> returning Int.typ)
      Int.s x0  x1  x2 

    (** Creates a copy of the array, and returns it. *)
    let duplicate x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_PACKED_INT32_ARRAY
      "duplicate"
      1997843129L
      (PackedInt32Array.typ @-> returning PackedInt32Array.typ)
      PackedInt32Array.s x0 

    (** Searches the array for a value and returns its index or \[code\]-1\[/code\] if not found. Optionally, the initial search index can be passed. *)
    let find x0  x1  x2  = 
    foreign_builtin_method2
      GlobalEnum.VariantType._TYPE_PACKED_INT32_ARRAY
      "find"
      2984303840L
      (Int.typ @-> Int.typ @-> PackedInt32Array.typ @-> returning Int.typ)
      Int.s x0  x1  x2 

    (** Searches the array in reverse order. Optionally, a start search index can be passed. If negative, the start index is considered relative to the end of the array. *)
    let rfind x0  x1  x2  = 
    foreign_builtin_method2
      GlobalEnum.VariantType._TYPE_PACKED_INT32_ARRAY
      "rfind"
      2984303840L
      (Int.typ @-> Int.typ @-> PackedInt32Array.typ @-> returning Int.typ)
      Int.s x0  x1  x2 

    (** Returns the number of times an element is in the array. *)
    let count x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_PACKED_INT32_ARRAY
      "count"
      4103005248L
      (Int.typ @-> PackedInt32Array.typ @-> returning Int.typ)
      Int.s x0  x1 






    let not x0  = 
    foreign_builtin_operator1 GlobalEnum.VariantType._TYPE_PACKED_INT32_ARRAY None  GlobalEnum.VariantOperator._OP_NOT
      (funptr (PackedInt32Array.typ @-> Bool.typ @-> returning void))
      Bool.s x0 


    let mem_Dictionary x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_PACKED_INT32_ARRAY (Some GlobalEnum.VariantType._TYPE_DICTIONARY) GlobalEnum.VariantOperator._OP_IN
      (funptr (PackedInt32Array.typ @-> Dictionary.typ @-> Bool.typ @-> returning void))
      Bool.s x0  x1 


    let mem_Array x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_PACKED_INT32_ARRAY (Some GlobalEnum.VariantType._TYPE_ARRAY) GlobalEnum.VariantOperator._OP_IN
      (funptr (PackedInt32Array.typ @-> Array.typ @-> Bool.typ @-> returning void))
      Bool.s x0  x1 

    (** Returns \[code\]true\[/code\] if contents of both arrays are the same, i.e. they have all equal ints at the corresponding indices. *)
    let (=) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_PACKED_INT32_ARRAY (Some GlobalEnum.VariantType._TYPE_PACKED_INT32_ARRAY) GlobalEnum.VariantOperator._OP_EQUAL
      (funptr (PackedInt32Array.typ @-> PackedInt32Array.typ @-> Bool.typ @-> returning void))
      Bool.s
      Conv.PackedInt32Array.of_ocaml
      Conv.PackedInt32Array.of_ocaml
      Conv.Bool.to_ocaml x0  x1 

    (** Returns \[code\]true\[/code\] if contents of the arrays differ. *)
    let (<>) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_PACKED_INT32_ARRAY (Some GlobalEnum.VariantType._TYPE_PACKED_INT32_ARRAY) GlobalEnum.VariantOperator._OP_NOT_EQUAL
      (funptr (PackedInt32Array.typ @-> PackedInt32Array.typ @-> Bool.typ @-> returning void))
      Bool.s
      Conv.PackedInt32Array.of_ocaml
      Conv.PackedInt32Array.of_ocaml
      Conv.Bool.to_ocaml x0  x1 

    (** Returns a new \[PackedInt32Array\] with contents of \[param right\] added at the end of this array. For better performance, consider using \[method append_array\] instead. *)
    let (+) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_PACKED_INT32_ARRAY (Some GlobalEnum.VariantType._TYPE_PACKED_INT32_ARRAY) GlobalEnum.VariantOperator._OP_ADD
      (funptr (PackedInt32Array.typ @-> PackedInt32Array.typ @-> PackedInt32Array.typ @-> returning void))
      PackedInt32Array.s
      Conv.PackedInt32Array.of_ocaml
      Conv.PackedInt32Array.of_ocaml
      Conv.PackedInt32Array.to_ocaml x0  x1 
    end

  module PackedInt64Array = struct
    include M.PackedInt64Array
include BuiltinClass0.PackedInt64Array

    (** Returns the 64-bit integer at the given \[param index\] in the array. This is the same as using the \[code\]\[\]\[/code\] operator (\[code\]array\[index\]\[/code\]). *)
    let get x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_PACKED_INT64_ARRAY
      "get"
      4103005248L
      (Int.typ @-> PackedInt64Array.typ @-> returning Int.typ)
      Int.s x0  x1 

    (** Changes the integer at the given index. *)
    let set x0  x1  x2  = 
    foreign_builtin_method2_void
      GlobalEnum.VariantType._TYPE_PACKED_INT64_ARRAY
      "set"
      3638975848L
      (Int.typ @-> Int.typ @-> PackedInt64Array.typ @-> returning Void.typ)
      Void.s x0  x1  x2 

    (** Returns the number of elements in the array. *)
    let size x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_PACKED_INT64_ARRAY
      "size"
      3173160232L
      (PackedInt64Array.typ @-> returning Int.typ)
      Int.s x0 

    (** Returns \[code\]true\[/code\] if the array is empty. *)
    let is_empty x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_PACKED_INT64_ARRAY
      "is_empty"
      3918633141L
      (PackedInt64Array.typ @-> returning Bool.typ)
      Bool.s x0 

    (** Appends a value to the array. *)
    let push_back x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_PACKED_INT64_ARRAY
      "push_back"
      694024632L
      (Int.typ @-> PackedInt64Array.typ @-> returning Bool.typ)
      Bool.s x0  x1 

    (** Appends an element at the end of the array (alias of \[method push_back\]). *)
    let append x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_PACKED_INT64_ARRAY
      "append"
      694024632L
      (Int.typ @-> PackedInt64Array.typ @-> returning Bool.typ)
      Bool.s x0  x1 

    (** Appends a \[PackedInt64Array\] at the end of this array. *)
    let append_array x0  x1  = 
    foreign_builtin_method1_void
      GlobalEnum.VariantType._TYPE_PACKED_INT64_ARRAY
      "append_array"
      2090311302L
      (PackedInt64Array.typ @-> PackedInt64Array.typ @-> returning Void.typ)
      Void.s x0  x1 

    (** Removes an element from the array by index. *)
    let remove_at x0  x1  = 
    foreign_builtin_method1_void
      GlobalEnum.VariantType._TYPE_PACKED_INT64_ARRAY
      "remove_at"
      2823966027L
      (Int.typ @-> PackedInt64Array.typ @-> returning Void.typ)
      Void.s x0  x1 

    (** Inserts a new integer at a given position in the array. The position must be valid, or at the end of the array (\[code\]idx == size()\[/code\]). *)
    let insert x0  x1  x2  = 
    foreign_builtin_method2
      GlobalEnum.VariantType._TYPE_PACKED_INT64_ARRAY
      "insert"
      1487112728L
      (Int.typ @-> Int.typ @-> PackedInt64Array.typ @-> returning Int.typ)
      Int.s x0  x1  x2 

    (** Assigns the given value to all elements in the array. This can typically be used together with \[method resize\] to create an array with a given size and initialized elements. *)
    let fill x0  x1  = 
    foreign_builtin_method1_void
      GlobalEnum.VariantType._TYPE_PACKED_INT64_ARRAY
      "fill"
      2823966027L
      (Int.typ @-> PackedInt64Array.typ @-> returning Void.typ)
      Void.s x0  x1 

    (** Sets the size of the array. If the array is grown, reserves elements at the end of the array. If the array is shrunk, truncates the array to the new size. Calling \[method resize\] once and assigning the new values is faster than adding new elements one by one. *)
    let resize x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_PACKED_INT64_ARRAY
      "resize"
      848867239L
      (Int.typ @-> PackedInt64Array.typ @-> returning Int.typ)
      Int.s x0  x1 

    (** Clears the array. This is equivalent to using \[method resize\] with a size of \[code\]0\[/code\]. *)
    let clear x0  = 
    foreign_builtin_method0_void
      GlobalEnum.VariantType._TYPE_PACKED_INT64_ARRAY
      "clear"
      3218959716L
      (PackedInt64Array.typ @-> returning Void.typ)
      Void.s x0 

    (** Returns \[code\]true\[/code\] if the array contains \[param value\]. *)
    let has x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_PACKED_INT64_ARRAY
      "has"
      931488181L
      (Int.typ @-> PackedInt64Array.typ @-> returning Bool.typ)
      Bool.s x0  x1 

    (** Reverses the order of the elements in the array. *)
    let reverse x0  = 
    foreign_builtin_method0_void
      GlobalEnum.VariantType._TYPE_PACKED_INT64_ARRAY
      "reverse"
      3218959716L
      (PackedInt64Array.typ @-> returning Void.typ)
      Void.s x0 

    (** Returns the slice of the \[PackedInt64Array\], from \[param begin\] (inclusive) to \[param end\] (exclusive), as a new \[PackedInt64Array\].
The absolute value of \[param begin\] and \[param end\] will be clamped to the array size, so the default value for \[param end\] makes it slice to the size of the array by default (i.e. \[code\]arr.slice(1)\[/code\] is a shorthand for \[code\]arr.slice(1, arr.size())\[/code\]).
If either \[param begin\] or \[param end\] are negative, they will be relative to the end of the array (i.e. \[code\]arr.slice(0, -2)\[/code\] is a shorthand for \[code\]arr.slice(0, arr.size() - 2)\[/code\]). *)
    let slice x0  x1  x2  = 
    foreign_builtin_method2
      GlobalEnum.VariantType._TYPE_PACKED_INT64_ARRAY
      "slice"
      1726550804L
      (Int.typ @-> Int.typ @-> PackedInt64Array.typ @-> returning PackedInt64Array.typ)
      PackedInt64Array.s x0  x1  x2 

    (** Returns a copy of the data converted to a \[PackedByteArray\], where each element has been encoded as 8 bytes.
The size of the new array will be \[code\]int64_array.size()  *  8\[/code\]. *)
    let to_byte_array x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_PACKED_INT64_ARRAY
      "to_byte_array"
      247621236L
      (PackedInt64Array.typ @-> returning PackedByteArray.typ)
      PackedByteArray.s x0 

    (** Sorts the elements of the array in ascending order. *)
    let sort x0  = 
    foreign_builtin_method0_void
      GlobalEnum.VariantType._TYPE_PACKED_INT64_ARRAY
      "sort"
      3218959716L
      (PackedInt64Array.typ @-> returning Void.typ)
      Void.s x0 

    (** Finds the index of an existing value (or the insertion index that maintains sorting order, if the value is not yet present in the array) using binary search. Optionally, a \[param before\] specifier can be passed. If \[code\]false\[/code\], the returned index comes after all existing entries of the value in the array.
\[b\]Note:\[/b\] Calling \[method bsearch\] on an unsorted array results in unexpected behavior. *)
    let bsearch x0  x1  x2  = 
    foreign_builtin_method2
      GlobalEnum.VariantType._TYPE_PACKED_INT64_ARRAY
      "bsearch"
      3380005890L
      (Int.typ @-> Bool.typ @-> PackedInt64Array.typ @-> returning Int.typ)
      Int.s x0  x1  x2 

    (** Creates a copy of the array, and returns it. *)
    let duplicate x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_PACKED_INT64_ARRAY
      "duplicate"
      2376370016L
      (PackedInt64Array.typ @-> returning PackedInt64Array.typ)
      PackedInt64Array.s x0 

    (** Searches the array for a value and returns its index or \[code\]-1\[/code\] if not found. Optionally, the initial search index can be passed. *)
    let find x0  x1  x2  = 
    foreign_builtin_method2
      GlobalEnum.VariantType._TYPE_PACKED_INT64_ARRAY
      "find"
      2984303840L
      (Int.typ @-> Int.typ @-> PackedInt64Array.typ @-> returning Int.typ)
      Int.s x0  x1  x2 

    (** Searches the array in reverse order. Optionally, a start search index can be passed. If negative, the start index is considered relative to the end of the array. *)
    let rfind x0  x1  x2  = 
    foreign_builtin_method2
      GlobalEnum.VariantType._TYPE_PACKED_INT64_ARRAY
      "rfind"
      2984303840L
      (Int.typ @-> Int.typ @-> PackedInt64Array.typ @-> returning Int.typ)
      Int.s x0  x1  x2 

    (** Returns the number of times an element is in the array. *)
    let count x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_PACKED_INT64_ARRAY
      "count"
      4103005248L
      (Int.typ @-> PackedInt64Array.typ @-> returning Int.typ)
      Int.s x0  x1 






    let not x0  = 
    foreign_builtin_operator1 GlobalEnum.VariantType._TYPE_PACKED_INT64_ARRAY None  GlobalEnum.VariantOperator._OP_NOT
      (funptr (PackedInt64Array.typ @-> Bool.typ @-> returning void))
      Bool.s x0 


    let mem_Dictionary x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_PACKED_INT64_ARRAY (Some GlobalEnum.VariantType._TYPE_DICTIONARY) GlobalEnum.VariantOperator._OP_IN
      (funptr (PackedInt64Array.typ @-> Dictionary.typ @-> Bool.typ @-> returning void))
      Bool.s x0  x1 


    let mem_Array x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_PACKED_INT64_ARRAY (Some GlobalEnum.VariantType._TYPE_ARRAY) GlobalEnum.VariantOperator._OP_IN
      (funptr (PackedInt64Array.typ @-> Array.typ @-> Bool.typ @-> returning void))
      Bool.s x0  x1 

    (** Returns \[code\]true\[/code\] if contents of both arrays are the same, i.e. they have all equal ints at the corresponding indices. *)
    let (=) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_PACKED_INT64_ARRAY (Some GlobalEnum.VariantType._TYPE_PACKED_INT64_ARRAY) GlobalEnum.VariantOperator._OP_EQUAL
      (funptr (PackedInt64Array.typ @-> PackedInt64Array.typ @-> Bool.typ @-> returning void))
      Bool.s
      Conv.PackedInt64Array.of_ocaml
      Conv.PackedInt64Array.of_ocaml
      Conv.Bool.to_ocaml x0  x1 

    (** Returns \[code\]true\[/code\] if contents of the arrays differ. *)
    let (<>) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_PACKED_INT64_ARRAY (Some GlobalEnum.VariantType._TYPE_PACKED_INT64_ARRAY) GlobalEnum.VariantOperator._OP_NOT_EQUAL
      (funptr (PackedInt64Array.typ @-> PackedInt64Array.typ @-> Bool.typ @-> returning void))
      Bool.s
      Conv.PackedInt64Array.of_ocaml
      Conv.PackedInt64Array.of_ocaml
      Conv.Bool.to_ocaml x0  x1 

    (** Returns a new \[PackedInt64Array\] with contents of \[param right\] added at the end of this array. For better performance, consider using \[method append_array\] instead. *)
    let (+) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_PACKED_INT64_ARRAY (Some GlobalEnum.VariantType._TYPE_PACKED_INT64_ARRAY) GlobalEnum.VariantOperator._OP_ADD
      (funptr (PackedInt64Array.typ @-> PackedInt64Array.typ @-> PackedInt64Array.typ @-> returning void))
      PackedInt64Array.s
      Conv.PackedInt64Array.of_ocaml
      Conv.PackedInt64Array.of_ocaml
      Conv.PackedInt64Array.to_ocaml x0  x1 
    end

  module PackedFloat32Array = struct
    include M.PackedFloat32Array
include BuiltinClass0.PackedFloat32Array

    (** Returns the 32-bit float at the given \[param index\] in the array. This is the same as using the \[code\]\[\]\[/code\] operator (\[code\]array\[index\]\[/code\]). *)
    let get x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_PACKED_FLOAT32_ARRAY
      "get"
      1401583798L
      (Int.typ @-> PackedFloat32Array.typ @-> returning Float.typ)
      Float.s x0  x1 

    (** Changes the float at the given index. *)
    let set x0  x1  x2  = 
    foreign_builtin_method2_void
      GlobalEnum.VariantType._TYPE_PACKED_FLOAT32_ARRAY
      "set"
      1113000516L
      (Int.typ @-> Float.typ @-> PackedFloat32Array.typ @-> returning Void.typ)
      Void.s x0  x1  x2 

    (** Returns the number of elements in the array. *)
    let size x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_PACKED_FLOAT32_ARRAY
      "size"
      3173160232L
      (PackedFloat32Array.typ @-> returning Int.typ)
      Int.s x0 

    (** Returns \[code\]true\[/code\] if the array is empty. *)
    let is_empty x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_PACKED_FLOAT32_ARRAY
      "is_empty"
      3918633141L
      (PackedFloat32Array.typ @-> returning Bool.typ)
      Bool.s x0 

    (** Appends an element at the end of the array. *)
    let push_back x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_PACKED_FLOAT32_ARRAY
      "push_back"
      4094791666L
      (Float.typ @-> PackedFloat32Array.typ @-> returning Bool.typ)
      Bool.s x0  x1 

    (** Appends an element at the end of the array (alias of \[method push_back\]). *)
    let append x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_PACKED_FLOAT32_ARRAY
      "append"
      4094791666L
      (Float.typ @-> PackedFloat32Array.typ @-> returning Bool.typ)
      Bool.s x0  x1 

    (** Appends a \[PackedFloat32Array\] at the end of this array. *)
    let append_array x0  x1  = 
    foreign_builtin_method1_void
      GlobalEnum.VariantType._TYPE_PACKED_FLOAT32_ARRAY
      "append_array"
      2981316639L
      (PackedFloat32Array.typ @-> PackedFloat32Array.typ @-> returning Void.typ)
      Void.s x0  x1 

    (** Removes an element from the array by index. *)
    let remove_at x0  x1  = 
    foreign_builtin_method1_void
      GlobalEnum.VariantType._TYPE_PACKED_FLOAT32_ARRAY
      "remove_at"
      2823966027L
      (Int.typ @-> PackedFloat32Array.typ @-> returning Void.typ)
      Void.s x0  x1 

    (** Inserts a new element at a given position in the array. The position must be valid, or at the end of the array (\[code\]idx == size()\[/code\]). *)
    let insert x0  x1  x2  = 
    foreign_builtin_method2
      GlobalEnum.VariantType._TYPE_PACKED_FLOAT32_ARRAY
      "insert"
      1379903876L
      (Int.typ @-> Float.typ @-> PackedFloat32Array.typ @-> returning Int.typ)
      Int.s x0  x1  x2 

    (** Assigns the given value to all elements in the array. This can typically be used together with \[method resize\] to create an array with a given size and initialized elements. *)
    let fill x0  x1  = 
    foreign_builtin_method1_void
      GlobalEnum.VariantType._TYPE_PACKED_FLOAT32_ARRAY
      "fill"
      833936903L
      (Float.typ @-> PackedFloat32Array.typ @-> returning Void.typ)
      Void.s x0  x1 

    (** Sets the size of the array. If the array is grown, reserves elements at the end of the array. If the array is shrunk, truncates the array to the new size. Calling \[method resize\] once and assigning the new values is faster than adding new elements one by one. *)
    let resize x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_PACKED_FLOAT32_ARRAY
      "resize"
      848867239L
      (Int.typ @-> PackedFloat32Array.typ @-> returning Int.typ)
      Int.s x0  x1 

    (** Clears the array. This is equivalent to using \[method resize\] with a size of \[code\]0\[/code\]. *)
    let clear x0  = 
    foreign_builtin_method0_void
      GlobalEnum.VariantType._TYPE_PACKED_FLOAT32_ARRAY
      "clear"
      3218959716L
      (PackedFloat32Array.typ @-> returning Void.typ)
      Void.s x0 

    (** Returns \[code\]true\[/code\] if the array contains \[param value\].
\[b\]Note:\[/b\] \[constant \@GDScript.NAN\] doesn''t behave the same as other numbers. Therefore, the results from this method may not be accurate if NaNs are included. *)
    let has x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_PACKED_FLOAT32_ARRAY
      "has"
      1296369134L
      (Float.typ @-> PackedFloat32Array.typ @-> returning Bool.typ)
      Bool.s x0  x1 

    (** Reverses the order of the elements in the array. *)
    let reverse x0  = 
    foreign_builtin_method0_void
      GlobalEnum.VariantType._TYPE_PACKED_FLOAT32_ARRAY
      "reverse"
      3218959716L
      (PackedFloat32Array.typ @-> returning Void.typ)
      Void.s x0 

    (** Returns the slice of the \[PackedFloat32Array\], from \[param begin\] (inclusive) to \[param end\] (exclusive), as a new \[PackedFloat32Array\].
The absolute value of \[param begin\] and \[param end\] will be clamped to the array size, so the default value for \[param end\] makes it slice to the size of the array by default (i.e. \[code\]arr.slice(1)\[/code\] is a shorthand for \[code\]arr.slice(1, arr.size())\[/code\]).
If either \[param begin\] or \[param end\] are negative, they will be relative to the end of the array (i.e. \[code\]arr.slice(0, -2)\[/code\] is a shorthand for \[code\]arr.slice(0, arr.size() - 2)\[/code\]). *)
    let slice x0  x1  x2  = 
    foreign_builtin_method2
      GlobalEnum.VariantType._TYPE_PACKED_FLOAT32_ARRAY
      "slice"
      1418229160L
      (Int.typ @-> Int.typ @-> PackedFloat32Array.typ @-> returning PackedFloat32Array.typ)
      PackedFloat32Array.s x0  x1  x2 

    (** Returns a copy of the data converted to a \[PackedByteArray\], where each element has been encoded as 4 bytes.
The size of the new array will be \[code\]float32_array.size()  *  4\[/code\]. *)
    let to_byte_array x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_PACKED_FLOAT32_ARRAY
      "to_byte_array"
      247621236L
      (PackedFloat32Array.typ @-> returning PackedByteArray.typ)
      PackedByteArray.s x0 

    (** Sorts the elements of the array in ascending order.
\[b\]Note:\[/b\] \[constant \@GDScript.NAN\] doesn''t behave the same as other numbers. Therefore, the results from this method may not be accurate if NaNs are included. *)
    let sort x0  = 
    foreign_builtin_method0_void
      GlobalEnum.VariantType._TYPE_PACKED_FLOAT32_ARRAY
      "sort"
      3218959716L
      (PackedFloat32Array.typ @-> returning Void.typ)
      Void.s x0 

    (** Finds the index of an existing value (or the insertion index that maintains sorting order, if the value is not yet present in the array) using binary search. Optionally, a \[param before\] specifier can be passed. If \[code\]false\[/code\], the returned index comes after all existing entries of the value in the array.
\[b\]Note:\[/b\] Calling \[method bsearch\] on an unsorted array results in unexpected behavior.
\[b\]Note:\[/b\] \[constant \@GDScript.NAN\] doesn''t behave the same as other numbers. Therefore, the results from this method may not be accurate if NaNs are included. *)
    let bsearch x0  x1  x2  = 
    foreign_builtin_method2
      GlobalEnum.VariantType._TYPE_PACKED_FLOAT32_ARRAY
      "bsearch"
      1188816338L
      (Float.typ @-> Bool.typ @-> PackedFloat32Array.typ @-> returning Int.typ)
      Int.s x0  x1  x2 

    (** Creates a copy of the array, and returns it. *)
    let duplicate x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_PACKED_FLOAT32_ARRAY
      "duplicate"
      831114784L
      (PackedFloat32Array.typ @-> returning PackedFloat32Array.typ)
      PackedFloat32Array.s x0 

    (** Searches the array for a value and returns its index or \[code\]-1\[/code\] if not found. Optionally, the initial search index can be passed.
\[b\]Note:\[/b\] \[constant \@GDScript.NAN\] doesn''t behave the same as other numbers. Therefore, the results from this method may not be accurate if NaNs are included. *)
    let find x0  x1  x2  = 
    foreign_builtin_method2
      GlobalEnum.VariantType._TYPE_PACKED_FLOAT32_ARRAY
      "find"
      1343150241L
      (Float.typ @-> Int.typ @-> PackedFloat32Array.typ @-> returning Int.typ)
      Int.s x0  x1  x2 

    (** Searches the array in reverse order. Optionally, a start search index can be passed. If negative, the start index is considered relative to the end of the array.
\[b\]Note:\[/b\] \[constant \@GDScript.NAN\] doesn''t behave the same as other numbers. Therefore, the results from this method may not be accurate if NaNs are included. *)
    let rfind x0  x1  x2  = 
    foreign_builtin_method2
      GlobalEnum.VariantType._TYPE_PACKED_FLOAT32_ARRAY
      "rfind"
      1343150241L
      (Float.typ @-> Int.typ @-> PackedFloat32Array.typ @-> returning Int.typ)
      Int.s x0  x1  x2 

    (** Returns the number of times an element is in the array.
\[b\]Note:\[/b\] \[constant \@GDScript.NAN\] doesn''t behave the same as other numbers. Therefore, the results from this method may not be accurate if NaNs are included. *)
    let count x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_PACKED_FLOAT32_ARRAY
      "count"
      2859915090L
      (Float.typ @-> PackedFloat32Array.typ @-> returning Int.typ)
      Int.s x0  x1 






    let not x0  = 
    foreign_builtin_operator1 GlobalEnum.VariantType._TYPE_PACKED_FLOAT32_ARRAY None  GlobalEnum.VariantOperator._OP_NOT
      (funptr (PackedFloat32Array.typ @-> Bool.typ @-> returning void))
      Bool.s x0 


    let mem_Dictionary x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_PACKED_FLOAT32_ARRAY (Some GlobalEnum.VariantType._TYPE_DICTIONARY) GlobalEnum.VariantOperator._OP_IN
      (funptr (PackedFloat32Array.typ @-> Dictionary.typ @-> Bool.typ @-> returning void))
      Bool.s x0  x1 


    let mem_Array x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_PACKED_FLOAT32_ARRAY (Some GlobalEnum.VariantType._TYPE_ARRAY) GlobalEnum.VariantOperator._OP_IN
      (funptr (PackedFloat32Array.typ @-> Array.typ @-> Bool.typ @-> returning void))
      Bool.s x0  x1 

    (** Returns \[code\]true\[/code\] if contents of both arrays are the same, i.e. they have all equal floats at the corresponding indices. *)
    let (=) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_PACKED_FLOAT32_ARRAY (Some GlobalEnum.VariantType._TYPE_PACKED_FLOAT32_ARRAY) GlobalEnum.VariantOperator._OP_EQUAL
      (funptr (PackedFloat32Array.typ @-> PackedFloat32Array.typ @-> Bool.typ @-> returning void))
      Bool.s
      Conv.PackedFloat32Array.of_ocaml
      Conv.PackedFloat32Array.of_ocaml
      Conv.Bool.to_ocaml x0  x1 

    (** Returns \[code\]true\[/code\] if contents of the arrays differ. *)
    let (<>) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_PACKED_FLOAT32_ARRAY (Some GlobalEnum.VariantType._TYPE_PACKED_FLOAT32_ARRAY) GlobalEnum.VariantOperator._OP_NOT_EQUAL
      (funptr (PackedFloat32Array.typ @-> PackedFloat32Array.typ @-> Bool.typ @-> returning void))
      Bool.s
      Conv.PackedFloat32Array.of_ocaml
      Conv.PackedFloat32Array.of_ocaml
      Conv.Bool.to_ocaml x0  x1 

    (** Returns a new \[PackedFloat32Array\] with contents of \[param right\] added at the end of this array. For better performance, consider using \[method append_array\] instead. *)
    let (+) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_PACKED_FLOAT32_ARRAY (Some GlobalEnum.VariantType._TYPE_PACKED_FLOAT32_ARRAY) GlobalEnum.VariantOperator._OP_ADD
      (funptr (PackedFloat32Array.typ @-> PackedFloat32Array.typ @-> PackedFloat32Array.typ @-> returning void))
      PackedFloat32Array.s
      Conv.PackedFloat32Array.of_ocaml
      Conv.PackedFloat32Array.of_ocaml
      Conv.PackedFloat32Array.to_ocaml x0  x1 
    end

  module PackedFloat64Array = struct
    include M.PackedFloat64Array
include BuiltinClass0.PackedFloat64Array

    (** Returns the 64-bit float at the given \[param index\] in the array. This is the same as using the \[code\]\[\]\[/code\] operator (\[code\]array\[index\]\[/code\]). *)
    let get x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_PACKED_FLOAT64_ARRAY
      "get"
      1401583798L
      (Int.typ @-> PackedFloat64Array.typ @-> returning Float.typ)
      Float.s x0  x1 

    (** Changes the float at the given index. *)
    let set x0  x1  x2  = 
    foreign_builtin_method2_void
      GlobalEnum.VariantType._TYPE_PACKED_FLOAT64_ARRAY
      "set"
      1113000516L
      (Int.typ @-> Float.typ @-> PackedFloat64Array.typ @-> returning Void.typ)
      Void.s x0  x1  x2 

    (** Returns the number of elements in the array. *)
    let size x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_PACKED_FLOAT64_ARRAY
      "size"
      3173160232L
      (PackedFloat64Array.typ @-> returning Int.typ)
      Int.s x0 

    (** Returns \[code\]true\[/code\] if the array is empty. *)
    let is_empty x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_PACKED_FLOAT64_ARRAY
      "is_empty"
      3918633141L
      (PackedFloat64Array.typ @-> returning Bool.typ)
      Bool.s x0 

    (** Appends an element at the end of the array. *)
    let push_back x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_PACKED_FLOAT64_ARRAY
      "push_back"
      4094791666L
      (Float.typ @-> PackedFloat64Array.typ @-> returning Bool.typ)
      Bool.s x0  x1 

    (** Appends an element at the end of the array (alias of \[method push_back\]). *)
    let append x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_PACKED_FLOAT64_ARRAY
      "append"
      4094791666L
      (Float.typ @-> PackedFloat64Array.typ @-> returning Bool.typ)
      Bool.s x0  x1 

    (** Appends a \[PackedFloat64Array\] at the end of this array. *)
    let append_array x0  x1  = 
    foreign_builtin_method1_void
      GlobalEnum.VariantType._TYPE_PACKED_FLOAT64_ARRAY
      "append_array"
      792078629L
      (PackedFloat64Array.typ @-> PackedFloat64Array.typ @-> returning Void.typ)
      Void.s x0  x1 

    (** Removes an element from the array by index. *)
    let remove_at x0  x1  = 
    foreign_builtin_method1_void
      GlobalEnum.VariantType._TYPE_PACKED_FLOAT64_ARRAY
      "remove_at"
      2823966027L
      (Int.typ @-> PackedFloat64Array.typ @-> returning Void.typ)
      Void.s x0  x1 

    (** Inserts a new element at a given position in the array. The position must be valid, or at the end of the array (\[code\]idx == size()\[/code\]). *)
    let insert x0  x1  x2  = 
    foreign_builtin_method2
      GlobalEnum.VariantType._TYPE_PACKED_FLOAT64_ARRAY
      "insert"
      1379903876L
      (Int.typ @-> Float.typ @-> PackedFloat64Array.typ @-> returning Int.typ)
      Int.s x0  x1  x2 

    (** Assigns the given value to all elements in the array. This can typically be used together with \[method resize\] to create an array with a given size and initialized elements. *)
    let fill x0  x1  = 
    foreign_builtin_method1_void
      GlobalEnum.VariantType._TYPE_PACKED_FLOAT64_ARRAY
      "fill"
      833936903L
      (Float.typ @-> PackedFloat64Array.typ @-> returning Void.typ)
      Void.s x0  x1 

    (** Sets the size of the array. If the array is grown, reserves elements at the end of the array. If the array is shrunk, truncates the array to the new size. Calling \[method resize\] once and assigning the new values is faster than adding new elements one by one. *)
    let resize x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_PACKED_FLOAT64_ARRAY
      "resize"
      848867239L
      (Int.typ @-> PackedFloat64Array.typ @-> returning Int.typ)
      Int.s x0  x1 

    (** Clears the array. This is equivalent to using \[method resize\] with a size of \[code\]0\[/code\]. *)
    let clear x0  = 
    foreign_builtin_method0_void
      GlobalEnum.VariantType._TYPE_PACKED_FLOAT64_ARRAY
      "clear"
      3218959716L
      (PackedFloat64Array.typ @-> returning Void.typ)
      Void.s x0 

    (** Returns \[code\]true\[/code\] if the array contains \[param value\].
\[b\]Note:\[/b\] \[constant \@GDScript.NAN\] doesn''t behave the same as other numbers. Therefore, the results from this method may not be accurate if NaNs are included. *)
    let has x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_PACKED_FLOAT64_ARRAY
      "has"
      1296369134L
      (Float.typ @-> PackedFloat64Array.typ @-> returning Bool.typ)
      Bool.s x0  x1 

    (** Reverses the order of the elements in the array. *)
    let reverse x0  = 
    foreign_builtin_method0_void
      GlobalEnum.VariantType._TYPE_PACKED_FLOAT64_ARRAY
      "reverse"
      3218959716L
      (PackedFloat64Array.typ @-> returning Void.typ)
      Void.s x0 

    (** Returns the slice of the \[PackedFloat64Array\], from \[param begin\] (inclusive) to \[param end\] (exclusive), as a new \[PackedFloat64Array\].
The absolute value of \[param begin\] and \[param end\] will be clamped to the array size, so the default value for \[param end\] makes it slice to the size of the array by default (i.e. \[code\]arr.slice(1)\[/code\] is a shorthand for \[code\]arr.slice(1, arr.size())\[/code\]).
If either \[param begin\] or \[param end\] are negative, they will be relative to the end of the array (i.e. \[code\]arr.slice(0, -2)\[/code\] is a shorthand for \[code\]arr.slice(0, arr.size() - 2)\[/code\]). *)
    let slice x0  x1  x2  = 
    foreign_builtin_method2
      GlobalEnum.VariantType._TYPE_PACKED_FLOAT64_ARRAY
      "slice"
      2192974324L
      (Int.typ @-> Int.typ @-> PackedFloat64Array.typ @-> returning PackedFloat64Array.typ)
      PackedFloat64Array.s x0  x1  x2 

    (** Returns a copy of the data converted to a \[PackedByteArray\], where each element has been encoded as 8 bytes.
The size of the new array will be \[code\]float64_array.size()  *  8\[/code\]. *)
    let to_byte_array x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_PACKED_FLOAT64_ARRAY
      "to_byte_array"
      247621236L
      (PackedFloat64Array.typ @-> returning PackedByteArray.typ)
      PackedByteArray.s x0 

    (** Sorts the elements of the array in ascending order.
\[b\]Note:\[/b\] \[constant \@GDScript.NAN\] doesn''t behave the same as other numbers. Therefore, the results from this method may not be accurate if NaNs are included. *)
    let sort x0  = 
    foreign_builtin_method0_void
      GlobalEnum.VariantType._TYPE_PACKED_FLOAT64_ARRAY
      "sort"
      3218959716L
      (PackedFloat64Array.typ @-> returning Void.typ)
      Void.s x0 

    (** Finds the index of an existing value (or the insertion index that maintains sorting order, if the value is not yet present in the array) using binary search. Optionally, a \[param before\] specifier can be passed. If \[code\]false\[/code\], the returned index comes after all existing entries of the value in the array.
\[b\]Note:\[/b\] Calling \[method bsearch\] on an unsorted array results in unexpected behavior.
\[b\]Note:\[/b\] \[constant \@GDScript.NAN\] doesn''t behave the same as other numbers. Therefore, the results from this method may not be accurate if NaNs are included. *)
    let bsearch x0  x1  x2  = 
    foreign_builtin_method2
      GlobalEnum.VariantType._TYPE_PACKED_FLOAT64_ARRAY
      "bsearch"
      1188816338L
      (Float.typ @-> Bool.typ @-> PackedFloat64Array.typ @-> returning Int.typ)
      Int.s x0  x1  x2 

    (** Creates a copy of the array, and returns it. *)
    let duplicate x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_PACKED_FLOAT64_ARRAY
      "duplicate"
      949266573L
      (PackedFloat64Array.typ @-> returning PackedFloat64Array.typ)
      PackedFloat64Array.s x0 

    (** Searches the array for a value and returns its index or \[code\]-1\[/code\] if not found. Optionally, the initial search index can be passed.
\[b\]Note:\[/b\] \[constant \@GDScript.NAN\] doesn''t behave the same as other numbers. Therefore, the results from this method may not be accurate if NaNs are included. *)
    let find x0  x1  x2  = 
    foreign_builtin_method2
      GlobalEnum.VariantType._TYPE_PACKED_FLOAT64_ARRAY
      "find"
      1343150241L
      (Float.typ @-> Int.typ @-> PackedFloat64Array.typ @-> returning Int.typ)
      Int.s x0  x1  x2 

    (** Searches the array in reverse order. Optionally, a start search index can be passed. If negative, the start index is considered relative to the end of the array.
\[b\]Note:\[/b\] \[constant \@GDScript.NAN\] doesn''t behave the same as other numbers. Therefore, the results from this method may not be accurate if NaNs are included. *)
    let rfind x0  x1  x2  = 
    foreign_builtin_method2
      GlobalEnum.VariantType._TYPE_PACKED_FLOAT64_ARRAY
      "rfind"
      1343150241L
      (Float.typ @-> Int.typ @-> PackedFloat64Array.typ @-> returning Int.typ)
      Int.s x0  x1  x2 

    (** Returns the number of times an element is in the array.
\[b\]Note:\[/b\] \[constant \@GDScript.NAN\] doesn''t behave the same as other numbers. Therefore, the results from this method may not be accurate if NaNs are included. *)
    let count x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_PACKED_FLOAT64_ARRAY
      "count"
      2859915090L
      (Float.typ @-> PackedFloat64Array.typ @-> returning Int.typ)
      Int.s x0  x1 






    let not x0  = 
    foreign_builtin_operator1 GlobalEnum.VariantType._TYPE_PACKED_FLOAT64_ARRAY None  GlobalEnum.VariantOperator._OP_NOT
      (funptr (PackedFloat64Array.typ @-> Bool.typ @-> returning void))
      Bool.s x0 


    let mem_Dictionary x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_PACKED_FLOAT64_ARRAY (Some GlobalEnum.VariantType._TYPE_DICTIONARY) GlobalEnum.VariantOperator._OP_IN
      (funptr (PackedFloat64Array.typ @-> Dictionary.typ @-> Bool.typ @-> returning void))
      Bool.s x0  x1 


    let mem_Array x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_PACKED_FLOAT64_ARRAY (Some GlobalEnum.VariantType._TYPE_ARRAY) GlobalEnum.VariantOperator._OP_IN
      (funptr (PackedFloat64Array.typ @-> Array.typ @-> Bool.typ @-> returning void))
      Bool.s x0  x1 

    (** Returns \[code\]true\[/code\] if contents of both arrays are the same, i.e. they have all equal doubles at the corresponding indices. *)
    let (=) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_PACKED_FLOAT64_ARRAY (Some GlobalEnum.VariantType._TYPE_PACKED_FLOAT64_ARRAY) GlobalEnum.VariantOperator._OP_EQUAL
      (funptr (PackedFloat64Array.typ @-> PackedFloat64Array.typ @-> Bool.typ @-> returning void))
      Bool.s
      Conv.PackedFloat64Array.of_ocaml
      Conv.PackedFloat64Array.of_ocaml
      Conv.Bool.to_ocaml x0  x1 

    (** Returns \[code\]true\[/code\] if contents of the arrays differ. *)
    let (<>) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_PACKED_FLOAT64_ARRAY (Some GlobalEnum.VariantType._TYPE_PACKED_FLOAT64_ARRAY) GlobalEnum.VariantOperator._OP_NOT_EQUAL
      (funptr (PackedFloat64Array.typ @-> PackedFloat64Array.typ @-> Bool.typ @-> returning void))
      Bool.s
      Conv.PackedFloat64Array.of_ocaml
      Conv.PackedFloat64Array.of_ocaml
      Conv.Bool.to_ocaml x0  x1 

    (** Returns a new \[PackedFloat64Array\] with contents of \[param right\] added at the end of this array. For better performance, consider using \[method append_array\] instead. *)
    let (+) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_PACKED_FLOAT64_ARRAY (Some GlobalEnum.VariantType._TYPE_PACKED_FLOAT64_ARRAY) GlobalEnum.VariantOperator._OP_ADD
      (funptr (PackedFloat64Array.typ @-> PackedFloat64Array.typ @-> PackedFloat64Array.typ @-> returning void))
      PackedFloat64Array.s
      Conv.PackedFloat64Array.of_ocaml
      Conv.PackedFloat64Array.of_ocaml
      Conv.PackedFloat64Array.to_ocaml x0  x1 
    end

  module PackedStringArray = struct
    include M.PackedStringArray
include BuiltinClass0.PackedStringArray

    (** Returns the \[String\] at the given \[param index\] in the array. This is the same as using the \[code\]\[\]\[/code\] operator (\[code\]array\[index\]\[/code\]). *)
    let get x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_PACKED_STRING_ARRAY
      "get"
      2162347432L
      (Int.typ @-> PackedStringArray.typ @-> returning String.typ)
      String.s x0  x1 

    (** Changes the \[String\] at the given index. *)
    let set x0  x1  x2  = 
    foreign_builtin_method2_void
      GlobalEnum.VariantType._TYPE_PACKED_STRING_ARRAY
      "set"
      725585539L
      (Int.typ @-> String.typ @-> PackedStringArray.typ @-> returning Void.typ)
      Void.s x0  x1  x2 

    (** Returns the number of elements in the array. *)
    let size x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_PACKED_STRING_ARRAY
      "size"
      3173160232L
      (PackedStringArray.typ @-> returning Int.typ)
      Int.s x0 

    (** Returns \[code\]true\[/code\] if the array is empty. *)
    let is_empty x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_PACKED_STRING_ARRAY
      "is_empty"
      3918633141L
      (PackedStringArray.typ @-> returning Bool.typ)
      Bool.s x0 

    (** Appends a string element at end of the array. *)
    let push_back x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_PACKED_STRING_ARRAY
      "push_back"
      816187996L
      (String.typ @-> PackedStringArray.typ @-> returning Bool.typ)
      Bool.s x0  x1 

    (** Appends an element at the end of the array (alias of \[method push_back\]). *)
    let append x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_PACKED_STRING_ARRAY
      "append"
      816187996L
      (String.typ @-> PackedStringArray.typ @-> returning Bool.typ)
      Bool.s x0  x1 

    (** Appends a \[PackedStringArray\] at the end of this array. *)
    let append_array x0  x1  = 
    foreign_builtin_method1_void
      GlobalEnum.VariantType._TYPE_PACKED_STRING_ARRAY
      "append_array"
      1120103966L
      (PackedStringArray.typ @-> PackedStringArray.typ @-> returning Void.typ)
      Void.s x0  x1 

    (** Removes an element from the array by index. *)
    let remove_at x0  x1  = 
    foreign_builtin_method1_void
      GlobalEnum.VariantType._TYPE_PACKED_STRING_ARRAY
      "remove_at"
      2823966027L
      (Int.typ @-> PackedStringArray.typ @-> returning Void.typ)
      Void.s x0  x1 

    (** Inserts a new element at a given position in the array. The position must be valid, or at the end of the array (\[code\]idx == size()\[/code\]). *)
    let insert x0  x1  x2  = 
    foreign_builtin_method2
      GlobalEnum.VariantType._TYPE_PACKED_STRING_ARRAY
      "insert"
      2432393153L
      (Int.typ @-> String.typ @-> PackedStringArray.typ @-> returning Int.typ)
      Int.s x0  x1  x2 

    (** Assigns the given value to all elements in the array. This can typically be used together with \[method resize\] to create an array with a given size and initialized elements. *)
    let fill x0  x1  = 
    foreign_builtin_method1_void
      GlobalEnum.VariantType._TYPE_PACKED_STRING_ARRAY
      "fill"
      3174917410L
      (String.typ @-> PackedStringArray.typ @-> returning Void.typ)
      Void.s x0  x1 

    (** Sets the size of the array. If the array is grown, reserves elements at the end of the array. If the array is shrunk, truncates the array to the new size. Calling \[method resize\] once and assigning the new values is faster than adding new elements one by one. *)
    let resize x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_PACKED_STRING_ARRAY
      "resize"
      848867239L
      (Int.typ @-> PackedStringArray.typ @-> returning Int.typ)
      Int.s x0  x1 

    (** Clears the array. This is equivalent to using \[method resize\] with a size of \[code\]0\[/code\]. *)
    let clear x0  = 
    foreign_builtin_method0_void
      GlobalEnum.VariantType._TYPE_PACKED_STRING_ARRAY
      "clear"
      3218959716L
      (PackedStringArray.typ @-> returning Void.typ)
      Void.s x0 

    (** Returns \[code\]true\[/code\] if the array contains \[param value\]. *)
    let has x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_PACKED_STRING_ARRAY
      "has"
      2566493496L
      (String.typ @-> PackedStringArray.typ @-> returning Bool.typ)
      Bool.s x0  x1 

    (** Reverses the order of the elements in the array. *)
    let reverse x0  = 
    foreign_builtin_method0_void
      GlobalEnum.VariantType._TYPE_PACKED_STRING_ARRAY
      "reverse"
      3218959716L
      (PackedStringArray.typ @-> returning Void.typ)
      Void.s x0 

    (** Returns the slice of the \[PackedStringArray\], from \[param begin\] (inclusive) to \[param end\] (exclusive), as a new \[PackedStringArray\].
The absolute value of \[param begin\] and \[param end\] will be clamped to the array size, so the default value for \[param end\] makes it slice to the size of the array by default (i.e. \[code\]arr.slice(1)\[/code\] is a shorthand for \[code\]arr.slice(1, arr.size())\[/code\]).
If either \[param begin\] or \[param end\] are negative, they will be relative to the end of the array (i.e. \[code\]arr.slice(0, -2)\[/code\] is a shorthand for \[code\]arr.slice(0, arr.size() - 2)\[/code\]). *)
    let slice x0  x1  x2  = 
    foreign_builtin_method2
      GlobalEnum.VariantType._TYPE_PACKED_STRING_ARRAY
      "slice"
      2094601407L
      (Int.typ @-> Int.typ @-> PackedStringArray.typ @-> returning PackedStringArray.typ)
      PackedStringArray.s x0  x1  x2 

    (** Returns a \[PackedByteArray\] with each string encoded as UTF-8. Strings are \[code\]null\[/code\] terminated. *)
    let to_byte_array x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_PACKED_STRING_ARRAY
      "to_byte_array"
      247621236L
      (PackedStringArray.typ @-> returning PackedByteArray.typ)
      PackedByteArray.s x0 

    (** Sorts the elements of the array in ascending order. *)
    let sort x0  = 
    foreign_builtin_method0_void
      GlobalEnum.VariantType._TYPE_PACKED_STRING_ARRAY
      "sort"
      3218959716L
      (PackedStringArray.typ @-> returning Void.typ)
      Void.s x0 

    (** Finds the index of an existing value (or the insertion index that maintains sorting order, if the value is not yet present in the array) using binary search. Optionally, a \[param before\] specifier can be passed. If \[code\]false\[/code\], the returned index comes after all existing entries of the value in the array.
\[b\]Note:\[/b\] Calling \[method bsearch\] on an unsorted array results in unexpected behavior. *)
    let bsearch x0  x1  x2  = 
    foreign_builtin_method2
      GlobalEnum.VariantType._TYPE_PACKED_STRING_ARRAY
      "bsearch"
      328976671L
      (String.typ @-> Bool.typ @-> PackedStringArray.typ @-> returning Int.typ)
      Int.s x0  x1  x2 

    (** Creates a copy of the array, and returns it. *)
    let duplicate x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_PACKED_STRING_ARRAY
      "duplicate"
      2991231410L
      (PackedStringArray.typ @-> returning PackedStringArray.typ)
      PackedStringArray.s x0 

    (** Searches the array for a value and returns its index or \[code\]-1\[/code\] if not found. Optionally, the initial search index can be passed. *)
    let find x0  x1  x2  = 
    foreign_builtin_method2
      GlobalEnum.VariantType._TYPE_PACKED_STRING_ARRAY
      "find"
      1760645412L
      (String.typ @-> Int.typ @-> PackedStringArray.typ @-> returning Int.typ)
      Int.s x0  x1  x2 

    (** Searches the array in reverse order. Optionally, a start search index can be passed. If negative, the start index is considered relative to the end of the array. *)
    let rfind x0  x1  x2  = 
    foreign_builtin_method2
      GlobalEnum.VariantType._TYPE_PACKED_STRING_ARRAY
      "rfind"
      1760645412L
      (String.typ @-> Int.typ @-> PackedStringArray.typ @-> returning Int.typ)
      Int.s x0  x1  x2 

    (** Returns the number of times an element is in the array. *)
    let count x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_PACKED_STRING_ARRAY
      "count"
      2920860731L
      (String.typ @-> PackedStringArray.typ @-> returning Int.typ)
      Int.s x0  x1 






    let not x0  = 
    foreign_builtin_operator1 GlobalEnum.VariantType._TYPE_PACKED_STRING_ARRAY None  GlobalEnum.VariantOperator._OP_NOT
      (funptr (PackedStringArray.typ @-> Bool.typ @-> returning void))
      Bool.s x0 


    let mem_Dictionary x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_PACKED_STRING_ARRAY (Some GlobalEnum.VariantType._TYPE_DICTIONARY) GlobalEnum.VariantOperator._OP_IN
      (funptr (PackedStringArray.typ @-> Dictionary.typ @-> Bool.typ @-> returning void))
      Bool.s x0  x1 


    let mem_Array x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_PACKED_STRING_ARRAY (Some GlobalEnum.VariantType._TYPE_ARRAY) GlobalEnum.VariantOperator._OP_IN
      (funptr (PackedStringArray.typ @-> Array.typ @-> Bool.typ @-> returning void))
      Bool.s x0  x1 

    (** Returns \[code\]true\[/code\] if contents of both arrays are the same, i.e. they have all equal \[String\]s at the corresponding indices. *)
    let (=) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_PACKED_STRING_ARRAY (Some GlobalEnum.VariantType._TYPE_PACKED_STRING_ARRAY) GlobalEnum.VariantOperator._OP_EQUAL
      (funptr (PackedStringArray.typ @-> PackedStringArray.typ @-> Bool.typ @-> returning void))
      Bool.s
      Conv.PackedStringArray.of_ocaml
      Conv.PackedStringArray.of_ocaml
      Conv.Bool.to_ocaml x0  x1 

    (** Returns \[code\]true\[/code\] if contents of the arrays differ. *)
    let (<>) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_PACKED_STRING_ARRAY (Some GlobalEnum.VariantType._TYPE_PACKED_STRING_ARRAY) GlobalEnum.VariantOperator._OP_NOT_EQUAL
      (funptr (PackedStringArray.typ @-> PackedStringArray.typ @-> Bool.typ @-> returning void))
      Bool.s
      Conv.PackedStringArray.of_ocaml
      Conv.PackedStringArray.of_ocaml
      Conv.Bool.to_ocaml x0  x1 

    (** Returns a new \[PackedStringArray\] with contents of \[param right\] added at the end of this array. For better performance, consider using \[method append_array\] instead. *)
    let (+) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_PACKED_STRING_ARRAY (Some GlobalEnum.VariantType._TYPE_PACKED_STRING_ARRAY) GlobalEnum.VariantOperator._OP_ADD
      (funptr (PackedStringArray.typ @-> PackedStringArray.typ @-> PackedStringArray.typ @-> returning void))
      PackedStringArray.s
      Conv.PackedStringArray.of_ocaml
      Conv.PackedStringArray.of_ocaml
      Conv.PackedStringArray.to_ocaml x0  x1 
    end

  module PackedVector2Array = struct
    include M.PackedVector2Array
include BuiltinClass0.PackedVector2Array

    (** Returns the \[Vector2\] at the given \[param index\] in the array. This is the same as using the \[code\]\[\]\[/code\] operator (\[code\]array\[index\]\[/code\]). *)
    let get x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_PACKED_VECTOR2_ARRAY
      "get"
      2609058838L
      (Int.typ @-> PackedVector2Array.typ @-> returning Vector2.typ)
      Vector2.s x0  x1 

    (** Changes the \[Vector2\] at the given index. *)
    let set x0  x1  x2  = 
    foreign_builtin_method2_void
      GlobalEnum.VariantType._TYPE_PACKED_VECTOR2_ARRAY
      "set"
      635767250L
      (Int.typ @-> Vector2.typ @-> PackedVector2Array.typ @-> returning Void.typ)
      Void.s x0  x1  x2 

    (** Returns the number of elements in the array. *)
    let size x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_PACKED_VECTOR2_ARRAY
      "size"
      3173160232L
      (PackedVector2Array.typ @-> returning Int.typ)
      Int.s x0 

    (** Returns \[code\]true\[/code\] if the array is empty. *)
    let is_empty x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_PACKED_VECTOR2_ARRAY
      "is_empty"
      3918633141L
      (PackedVector2Array.typ @-> returning Bool.typ)
      Bool.s x0 

    (** Inserts a \[Vector2\] at the end. *)
    let push_back x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_PACKED_VECTOR2_ARRAY
      "push_back"
      4188891560L
      (Vector2.typ @-> PackedVector2Array.typ @-> returning Bool.typ)
      Bool.s x0  x1 

    (** Appends an element at the end of the array (alias of \[method push_back\]). *)
    let append x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_PACKED_VECTOR2_ARRAY
      "append"
      4188891560L
      (Vector2.typ @-> PackedVector2Array.typ @-> returning Bool.typ)
      Bool.s x0  x1 

    (** Appends a \[PackedVector2Array\] at the end of this array. *)
    let append_array x0  x1  = 
    foreign_builtin_method1_void
      GlobalEnum.VariantType._TYPE_PACKED_VECTOR2_ARRAY
      "append_array"
      3887534835L
      (PackedVector2Array.typ @-> PackedVector2Array.typ @-> returning Void.typ)
      Void.s x0  x1 

    (** Removes an element from the array by index. *)
    let remove_at x0  x1  = 
    foreign_builtin_method1_void
      GlobalEnum.VariantType._TYPE_PACKED_VECTOR2_ARRAY
      "remove_at"
      2823966027L
      (Int.typ @-> PackedVector2Array.typ @-> returning Void.typ)
      Void.s x0  x1 

    (** Inserts a new element at a given position in the array. The position must be valid, or at the end of the array (\[code\]idx == size()\[/code\]). *)
    let insert x0  x1  x2  = 
    foreign_builtin_method2
      GlobalEnum.VariantType._TYPE_PACKED_VECTOR2_ARRAY
      "insert"
      2225629369L
      (Int.typ @-> Vector2.typ @-> PackedVector2Array.typ @-> returning Int.typ)
      Int.s x0  x1  x2 

    (** Assigns the given value to all elements in the array. This can typically be used together with \[method resize\] to create an array with a given size and initialized elements. *)
    let fill x0  x1  = 
    foreign_builtin_method1_void
      GlobalEnum.VariantType._TYPE_PACKED_VECTOR2_ARRAY
      "fill"
      3790411178L
      (Vector2.typ @-> PackedVector2Array.typ @-> returning Void.typ)
      Void.s x0  x1 

    (** Sets the size of the array. If the array is grown, reserves elements at the end of the array. If the array is shrunk, truncates the array to the new size. Calling \[method resize\] once and assigning the new values is faster than adding new elements one by one. *)
    let resize x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_PACKED_VECTOR2_ARRAY
      "resize"
      848867239L
      (Int.typ @-> PackedVector2Array.typ @-> returning Int.typ)
      Int.s x0  x1 

    (** Clears the array. This is equivalent to using \[method resize\] with a size of \[code\]0\[/code\]. *)
    let clear x0  = 
    foreign_builtin_method0_void
      GlobalEnum.VariantType._TYPE_PACKED_VECTOR2_ARRAY
      "clear"
      3218959716L
      (PackedVector2Array.typ @-> returning Void.typ)
      Void.s x0 

    (** Returns \[code\]true\[/code\] if the array contains \[param value\].
\[b\]Note:\[/b\] Vectors with \[constant \@GDScript.NAN\] elements don''t behave the same as other vectors. Therefore, the results from this method may not be accurate if NaNs are included. *)
    let has x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_PACKED_VECTOR2_ARRAY
      "has"
      3190634762L
      (Vector2.typ @-> PackedVector2Array.typ @-> returning Bool.typ)
      Bool.s x0  x1 

    (** Reverses the order of the elements in the array. *)
    let reverse x0  = 
    foreign_builtin_method0_void
      GlobalEnum.VariantType._TYPE_PACKED_VECTOR2_ARRAY
      "reverse"
      3218959716L
      (PackedVector2Array.typ @-> returning Void.typ)
      Void.s x0 

    (** Returns the slice of the \[PackedVector2Array\], from \[param begin\] (inclusive) to \[param end\] (exclusive), as a new \[PackedVector2Array\].
The absolute value of \[param begin\] and \[param end\] will be clamped to the array size, so the default value for \[param end\] makes it slice to the size of the array by default (i.e. \[code\]arr.slice(1)\[/code\] is a shorthand for \[code\]arr.slice(1, arr.size())\[/code\]).
If either \[param begin\] or \[param end\] are negative, they will be relative to the end of the array (i.e. \[code\]arr.slice(0, -2)\[/code\] is a shorthand for \[code\]arr.slice(0, arr.size() - 2)\[/code\]). *)
    let slice x0  x1  x2  = 
    foreign_builtin_method2
      GlobalEnum.VariantType._TYPE_PACKED_VECTOR2_ARRAY
      "slice"
      3864005350L
      (Int.typ @-> Int.typ @-> PackedVector2Array.typ @-> returning PackedVector2Array.typ)
      PackedVector2Array.s x0  x1  x2 

    (** Returns a \[PackedByteArray\] with each vector encoded as bytes. *)
    let to_byte_array x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_PACKED_VECTOR2_ARRAY
      "to_byte_array"
      247621236L
      (PackedVector2Array.typ @-> returning PackedByteArray.typ)
      PackedByteArray.s x0 

    (** Sorts the elements of the array in ascending order.
\[b\]Note:\[/b\] Vectors with \[constant \@GDScript.NAN\] elements don''t behave the same as other vectors. Therefore, the results from this method may not be accurate if NaNs are included. *)
    let sort x0  = 
    foreign_builtin_method0_void
      GlobalEnum.VariantType._TYPE_PACKED_VECTOR2_ARRAY
      "sort"
      3218959716L
      (PackedVector2Array.typ @-> returning Void.typ)
      Void.s x0 

    (** Finds the index of an existing value (or the insertion index that maintains sorting order, if the value is not yet present in the array) using binary search. Optionally, a \[param before\] specifier can be passed. If \[code\]false\[/code\], the returned index comes after all existing entries of the value in the array.
\[b\]Note:\[/b\] Calling \[method bsearch\] on an unsorted array results in unexpected behavior.
\[b\]Note:\[/b\] Vectors with \[constant \@GDScript.NAN\] elements don''t behave the same as other vectors. Therefore, the results from this method may not be accurate if NaNs are included. *)
    let bsearch x0  x1  x2  = 
    foreign_builtin_method2
      GlobalEnum.VariantType._TYPE_PACKED_VECTOR2_ARRAY
      "bsearch"
      3778035805L
      (Vector2.typ @-> Bool.typ @-> PackedVector2Array.typ @-> returning Int.typ)
      Int.s x0  x1  x2 

    (** Creates a copy of the array, and returns it. *)
    let duplicate x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_PACKED_VECTOR2_ARRAY
      "duplicate"
      3763646812L
      (PackedVector2Array.typ @-> returning PackedVector2Array.typ)
      PackedVector2Array.s x0 

    (** Searches the array for a value and returns its index or \[code\]-1\[/code\] if not found. Optionally, the initial search index can be passed.
\[b\]Note:\[/b\] Vectors with \[constant \@GDScript.NAN\] elements don''t behave the same as other vectors. Therefore, the results from this method may not be accurate if NaNs are included. *)
    let find x0  x1  x2  = 
    foreign_builtin_method2
      GlobalEnum.VariantType._TYPE_PACKED_VECTOR2_ARRAY
      "find"
      1469606149L
      (Vector2.typ @-> Int.typ @-> PackedVector2Array.typ @-> returning Int.typ)
      Int.s x0  x1  x2 

    (** Searches the array in reverse order. Optionally, a start search index can be passed. If negative, the start index is considered relative to the end of the array.
\[b\]Note:\[/b\] Vectors with \[constant \@GDScript.NAN\] elements don''t behave the same as other vectors. Therefore, the results from this method may not be accurate if NaNs are included. *)
    let rfind x0  x1  x2  = 
    foreign_builtin_method2
      GlobalEnum.VariantType._TYPE_PACKED_VECTOR2_ARRAY
      "rfind"
      1469606149L
      (Vector2.typ @-> Int.typ @-> PackedVector2Array.typ @-> returning Int.typ)
      Int.s x0  x1  x2 

    (** Returns the number of times an element is in the array.
\[b\]Note:\[/b\] Vectors with \[constant \@GDScript.NAN\] elements don''t behave the same as other vectors. Therefore, the results from this method may not be accurate if NaNs are included. *)
    let count x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_PACKED_VECTOR2_ARRAY
      "count"
      2798848307L
      (Vector2.typ @-> PackedVector2Array.typ @-> returning Int.typ)
      Int.s x0  x1 






    let not x0  = 
    foreign_builtin_operator1 GlobalEnum.VariantType._TYPE_PACKED_VECTOR2_ARRAY None  GlobalEnum.VariantOperator._OP_NOT
      (funptr (PackedVector2Array.typ @-> Bool.typ @-> returning void))
      Bool.s x0 




    let mem_Dictionary x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_PACKED_VECTOR2_ARRAY (Some GlobalEnum.VariantType._TYPE_DICTIONARY) GlobalEnum.VariantOperator._OP_IN
      (funptr (PackedVector2Array.typ @-> Dictionary.typ @-> Bool.typ @-> returning void))
      Bool.s x0  x1 


    let mem_Array x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_PACKED_VECTOR2_ARRAY (Some GlobalEnum.VariantType._TYPE_ARRAY) GlobalEnum.VariantOperator._OP_IN
      (funptr (PackedVector2Array.typ @-> Array.typ @-> Bool.typ @-> returning void))
      Bool.s x0  x1 

    (** Returns \[code\]true\[/code\] if contents of both arrays are the same, i.e. they have all equal \[Vector2\]s at the corresponding indices. *)
    let (=) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_PACKED_VECTOR2_ARRAY (Some GlobalEnum.VariantType._TYPE_PACKED_VECTOR2_ARRAY) GlobalEnum.VariantOperator._OP_EQUAL
      (funptr (PackedVector2Array.typ @-> PackedVector2Array.typ @-> Bool.typ @-> returning void))
      Bool.s
      Conv.PackedVector2Array.of_ocaml
      Conv.PackedVector2Array.of_ocaml
      Conv.Bool.to_ocaml x0  x1 

    (** Returns \[code\]true\[/code\] if contents of the arrays differ. *)
    let (<>) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_PACKED_VECTOR2_ARRAY (Some GlobalEnum.VariantType._TYPE_PACKED_VECTOR2_ARRAY) GlobalEnum.VariantOperator._OP_NOT_EQUAL
      (funptr (PackedVector2Array.typ @-> PackedVector2Array.typ @-> Bool.typ @-> returning void))
      Bool.s
      Conv.PackedVector2Array.of_ocaml
      Conv.PackedVector2Array.of_ocaml
      Conv.Bool.to_ocaml x0  x1 

    (** Returns a new \[PackedVector2Array\] with contents of \[param right\] added at the end of this array. For better performance, consider using \[method append_array\] instead. *)
    let (+) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_PACKED_VECTOR2_ARRAY (Some GlobalEnum.VariantType._TYPE_PACKED_VECTOR2_ARRAY) GlobalEnum.VariantOperator._OP_ADD
      (funptr (PackedVector2Array.typ @-> PackedVector2Array.typ @-> PackedVector2Array.typ @-> returning void))
      PackedVector2Array.s
      Conv.PackedVector2Array.of_ocaml
      Conv.PackedVector2Array.of_ocaml
      Conv.PackedVector2Array.to_ocaml x0  x1 
    end

  module PackedVector3Array = struct
    include M.PackedVector3Array
include BuiltinClass0.PackedVector3Array

    (** Returns the \[Vector3\] at the given \[param index\] in the array. This is the same as using the \[code\]\[\]\[/code\] operator (\[code\]array\[index\]\[/code\]). *)
    let get x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_PACKED_VECTOR3_ARRAY
      "get"
      1394941017L
      (Int.typ @-> PackedVector3Array.typ @-> returning Vector3.typ)
      Vector3.s x0  x1 

    (** Changes the \[Vector3\] at the given index. *)
    let set x0  x1  x2  = 
    foreign_builtin_method2_void
      GlobalEnum.VariantType._TYPE_PACKED_VECTOR3_ARRAY
      "set"
      3975343409L
      (Int.typ @-> Vector3.typ @-> PackedVector3Array.typ @-> returning Void.typ)
      Void.s x0  x1  x2 

    (** Returns the number of elements in the array. *)
    let size x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_PACKED_VECTOR3_ARRAY
      "size"
      3173160232L
      (PackedVector3Array.typ @-> returning Int.typ)
      Int.s x0 

    (** Returns \[code\]true\[/code\] if the array is empty. *)
    let is_empty x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_PACKED_VECTOR3_ARRAY
      "is_empty"
      3918633141L
      (PackedVector3Array.typ @-> returning Bool.typ)
      Bool.s x0 

    (** Inserts a \[Vector3\] at the end. *)
    let push_back x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_PACKED_VECTOR3_ARRAY
      "push_back"
      3295363524L
      (Vector3.typ @-> PackedVector3Array.typ @-> returning Bool.typ)
      Bool.s x0  x1 

    (** Appends an element at the end of the array (alias of \[method push_back\]). *)
    let append x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_PACKED_VECTOR3_ARRAY
      "append"
      3295363524L
      (Vector3.typ @-> PackedVector3Array.typ @-> returning Bool.typ)
      Bool.s x0  x1 

    (** Appends a \[PackedVector3Array\] at the end of this array. *)
    let append_array x0  x1  = 
    foreign_builtin_method1_void
      GlobalEnum.VariantType._TYPE_PACKED_VECTOR3_ARRAY
      "append_array"
      203538016L
      (PackedVector3Array.typ @-> PackedVector3Array.typ @-> returning Void.typ)
      Void.s x0  x1 

    (** Removes an element from the array by index. *)
    let remove_at x0  x1  = 
    foreign_builtin_method1_void
      GlobalEnum.VariantType._TYPE_PACKED_VECTOR3_ARRAY
      "remove_at"
      2823966027L
      (Int.typ @-> PackedVector3Array.typ @-> returning Void.typ)
      Void.s x0  x1 

    (** Inserts a new element at a given position in the array. The position must be valid, or at the end of the array (\[code\]idx == size()\[/code\]). *)
    let insert x0  x1  x2  = 
    foreign_builtin_method2
      GlobalEnum.VariantType._TYPE_PACKED_VECTOR3_ARRAY
      "insert"
      3892262309L
      (Int.typ @-> Vector3.typ @-> PackedVector3Array.typ @-> returning Int.typ)
      Int.s x0  x1  x2 

    (** Assigns the given value to all elements in the array. This can typically be used together with \[method resize\] to create an array with a given size and initialized elements. *)
    let fill x0  x1  = 
    foreign_builtin_method1_void
      GlobalEnum.VariantType._TYPE_PACKED_VECTOR3_ARRAY
      "fill"
      3726392409L
      (Vector3.typ @-> PackedVector3Array.typ @-> returning Void.typ)
      Void.s x0  x1 

    (** Sets the size of the array. If the array is grown, reserves elements at the end of the array. If the array is shrunk, truncates the array to the new size. Calling \[method resize\] once and assigning the new values is faster than adding new elements one by one. *)
    let resize x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_PACKED_VECTOR3_ARRAY
      "resize"
      848867239L
      (Int.typ @-> PackedVector3Array.typ @-> returning Int.typ)
      Int.s x0  x1 

    (** Clears the array. This is equivalent to using \[method resize\] with a size of \[code\]0\[/code\]. *)
    let clear x0  = 
    foreign_builtin_method0_void
      GlobalEnum.VariantType._TYPE_PACKED_VECTOR3_ARRAY
      "clear"
      3218959716L
      (PackedVector3Array.typ @-> returning Void.typ)
      Void.s x0 

    (** Returns \[code\]true\[/code\] if the array contains \[param value\].
\[b\]Note:\[/b\] Vectors with \[constant \@GDScript.NAN\] elements don''t behave the same as other vectors. Therefore, the results from this method may not be accurate if NaNs are included. *)
    let has x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_PACKED_VECTOR3_ARRAY
      "has"
      1749054343L
      (Vector3.typ @-> PackedVector3Array.typ @-> returning Bool.typ)
      Bool.s x0  x1 

    (** Reverses the order of the elements in the array. *)
    let reverse x0  = 
    foreign_builtin_method0_void
      GlobalEnum.VariantType._TYPE_PACKED_VECTOR3_ARRAY
      "reverse"
      3218959716L
      (PackedVector3Array.typ @-> returning Void.typ)
      Void.s x0 

    (** Returns the slice of the \[PackedVector3Array\], from \[param begin\] (inclusive) to \[param end\] (exclusive), as a new \[PackedVector3Array\].
The absolute value of \[param begin\] and \[param end\] will be clamped to the array size, so the default value for \[param end\] makes it slice to the size of the array by default (i.e. \[code\]arr.slice(1)\[/code\] is a shorthand for \[code\]arr.slice(1, arr.size())\[/code\]).
If either \[param begin\] or \[param end\] are negative, they will be relative to the end of the array (i.e. \[code\]arr.slice(0, -2)\[/code\] is a shorthand for \[code\]arr.slice(0, arr.size() - 2)\[/code\]). *)
    let slice x0  x1  x2  = 
    foreign_builtin_method2
      GlobalEnum.VariantType._TYPE_PACKED_VECTOR3_ARRAY
      "slice"
      2086131305L
      (Int.typ @-> Int.typ @-> PackedVector3Array.typ @-> returning PackedVector3Array.typ)
      PackedVector3Array.s x0  x1  x2 

    (** Returns a \[PackedByteArray\] with each vector encoded as bytes. *)
    let to_byte_array x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_PACKED_VECTOR3_ARRAY
      "to_byte_array"
      247621236L
      (PackedVector3Array.typ @-> returning PackedByteArray.typ)
      PackedByteArray.s x0 

    (** Sorts the elements of the array in ascending order.
\[b\]Note:\[/b\] Vectors with \[constant \@GDScript.NAN\] elements don''t behave the same as other vectors. Therefore, the results from this method may not be accurate if NaNs are included. *)
    let sort x0  = 
    foreign_builtin_method0_void
      GlobalEnum.VariantType._TYPE_PACKED_VECTOR3_ARRAY
      "sort"
      3218959716L
      (PackedVector3Array.typ @-> returning Void.typ)
      Void.s x0 

    (** Finds the index of an existing value (or the insertion index that maintains sorting order, if the value is not yet present in the array) using binary search. Optionally, a \[param before\] specifier can be passed. If \[code\]false\[/code\], the returned index comes after all existing entries of the value in the array.
\[b\]Note:\[/b\] Calling \[method bsearch\] on an unsorted array results in unexpected behavior.
\[b\]Note:\[/b\] Vectors with \[constant \@GDScript.NAN\] elements don''t behave the same as other vectors. Therefore, the results from this method may not be accurate if NaNs are included. *)
    let bsearch x0  x1  x2  = 
    foreign_builtin_method2
      GlobalEnum.VariantType._TYPE_PACKED_VECTOR3_ARRAY
      "bsearch"
      219263630L
      (Vector3.typ @-> Bool.typ @-> PackedVector3Array.typ @-> returning Int.typ)
      Int.s x0  x1  x2 

    (** Creates a copy of the array, and returns it. *)
    let duplicate x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_PACKED_VECTOR3_ARRAY
      "duplicate"
      2754175465L
      (PackedVector3Array.typ @-> returning PackedVector3Array.typ)
      PackedVector3Array.s x0 

    (** Searches the array for a value and returns its index or \[code\]-1\[/code\] if not found. Optionally, the initial search index can be passed.
\[b\]Note:\[/b\] Vectors with \[constant \@GDScript.NAN\] elements don''t behave the same as other vectors. Therefore, the results from this method may not be accurate if NaNs are included. *)
    let find x0  x1  x2  = 
    foreign_builtin_method2
      GlobalEnum.VariantType._TYPE_PACKED_VECTOR3_ARRAY
      "find"
      3718155780L
      (Vector3.typ @-> Int.typ @-> PackedVector3Array.typ @-> returning Int.typ)
      Int.s x0  x1  x2 

    (** Searches the array in reverse order. Optionally, a start search index can be passed. If negative, the start index is considered relative to the end of the array.
\[b\]Note:\[/b\] Vectors with \[constant \@GDScript.NAN\] elements don''t behave the same as other vectors. Therefore, the results from this method may not be accurate if NaNs are included. *)
    let rfind x0  x1  x2  = 
    foreign_builtin_method2
      GlobalEnum.VariantType._TYPE_PACKED_VECTOR3_ARRAY
      "rfind"
      3718155780L
      (Vector3.typ @-> Int.typ @-> PackedVector3Array.typ @-> returning Int.typ)
      Int.s x0  x1  x2 

    (** Returns the number of times an element is in the array.
\[b\]Note:\[/b\] Vectors with \[constant \@GDScript.NAN\] elements don''t behave the same as other vectors. Therefore, the results from this method may not be accurate if NaNs are included. *)
    let count x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_PACKED_VECTOR3_ARRAY
      "count"
      194580386L
      (Vector3.typ @-> PackedVector3Array.typ @-> returning Int.typ)
      Int.s x0  x1 






    let not x0  = 
    foreign_builtin_operator1 GlobalEnum.VariantType._TYPE_PACKED_VECTOR3_ARRAY None  GlobalEnum.VariantOperator._OP_NOT
      (funptr (PackedVector3Array.typ @-> Bool.typ @-> returning void))
      Bool.s x0 




    let mem_Dictionary x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_PACKED_VECTOR3_ARRAY (Some GlobalEnum.VariantType._TYPE_DICTIONARY) GlobalEnum.VariantOperator._OP_IN
      (funptr (PackedVector3Array.typ @-> Dictionary.typ @-> Bool.typ @-> returning void))
      Bool.s x0  x1 


    let mem_Array x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_PACKED_VECTOR3_ARRAY (Some GlobalEnum.VariantType._TYPE_ARRAY) GlobalEnum.VariantOperator._OP_IN
      (funptr (PackedVector3Array.typ @-> Array.typ @-> Bool.typ @-> returning void))
      Bool.s x0  x1 

    (** Returns \[code\]true\[/code\] if contents of both arrays are the same, i.e. they have all equal \[Vector3\]s at the corresponding indices. *)
    let (=) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_PACKED_VECTOR3_ARRAY (Some GlobalEnum.VariantType._TYPE_PACKED_VECTOR3_ARRAY) GlobalEnum.VariantOperator._OP_EQUAL
      (funptr (PackedVector3Array.typ @-> PackedVector3Array.typ @-> Bool.typ @-> returning void))
      Bool.s
      Conv.PackedVector3Array.of_ocaml
      Conv.PackedVector3Array.of_ocaml
      Conv.Bool.to_ocaml x0  x1 

    (** Returns \[code\]true\[/code\] if contents of the arrays differ. *)
    let (<>) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_PACKED_VECTOR3_ARRAY (Some GlobalEnum.VariantType._TYPE_PACKED_VECTOR3_ARRAY) GlobalEnum.VariantOperator._OP_NOT_EQUAL
      (funptr (PackedVector3Array.typ @-> PackedVector3Array.typ @-> Bool.typ @-> returning void))
      Bool.s
      Conv.PackedVector3Array.of_ocaml
      Conv.PackedVector3Array.of_ocaml
      Conv.Bool.to_ocaml x0  x1 

    (** Returns a new \[PackedVector3Array\] with contents of \[param right\] added at the end of this array. For better performance, consider using \[method append_array\] instead. *)
    let (+) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_PACKED_VECTOR3_ARRAY (Some GlobalEnum.VariantType._TYPE_PACKED_VECTOR3_ARRAY) GlobalEnum.VariantOperator._OP_ADD
      (funptr (PackedVector3Array.typ @-> PackedVector3Array.typ @-> PackedVector3Array.typ @-> returning void))
      PackedVector3Array.s
      Conv.PackedVector3Array.of_ocaml
      Conv.PackedVector3Array.of_ocaml
      Conv.PackedVector3Array.to_ocaml x0  x1 
    end

  module PackedColorArray = struct
    include M.PackedColorArray
include BuiltinClass0.PackedColorArray

    (** Returns the \[Color\] at the given \[param index\] in the array. This is the same as using the \[code\]\[\]\[/code\] operator (\[code\]array\[index\]\[/code\]). *)
    let get x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_PACKED_COLOR_ARRAY
      "get"
      2972831132L
      (Int.typ @-> PackedColorArray.typ @-> returning Color.typ)
      Color.s x0  x1 

    (** Changes the \[Color\] at the given index. *)
    let set x0  x1  x2  = 
    foreign_builtin_method2_void
      GlobalEnum.VariantType._TYPE_PACKED_COLOR_ARRAY
      "set"
      1444096570L
      (Int.typ @-> Color.typ @-> PackedColorArray.typ @-> returning Void.typ)
      Void.s x0  x1  x2 

    (** Returns the number of elements in the array. *)
    let size x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_PACKED_COLOR_ARRAY
      "size"
      3173160232L
      (PackedColorArray.typ @-> returning Int.typ)
      Int.s x0 

    (** Returns \[code\]true\[/code\] if the array is empty. *)
    let is_empty x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_PACKED_COLOR_ARRAY
      "is_empty"
      3918633141L
      (PackedColorArray.typ @-> returning Bool.typ)
      Bool.s x0 

    (** Appends a value to the array. *)
    let push_back x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_PACKED_COLOR_ARRAY
      "push_back"
      1007858200L
      (Color.typ @-> PackedColorArray.typ @-> returning Bool.typ)
      Bool.s x0  x1 

    (** Appends an element at the end of the array (alias of \[method push_back\]). *)
    let append x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_PACKED_COLOR_ARRAY
      "append"
      1007858200L
      (Color.typ @-> PackedColorArray.typ @-> returning Bool.typ)
      Bool.s x0  x1 

    (** Appends a \[PackedColorArray\] at the end of this array. *)
    let append_array x0  x1  = 
    foreign_builtin_method1_void
      GlobalEnum.VariantType._TYPE_PACKED_COLOR_ARRAY
      "append_array"
      798822497L
      (PackedColorArray.typ @-> PackedColorArray.typ @-> returning Void.typ)
      Void.s x0  x1 

    (** Removes an element from the array by index. *)
    let remove_at x0  x1  = 
    foreign_builtin_method1_void
      GlobalEnum.VariantType._TYPE_PACKED_COLOR_ARRAY
      "remove_at"
      2823966027L
      (Int.typ @-> PackedColorArray.typ @-> returning Void.typ)
      Void.s x0  x1 

    (** Inserts a new element at a given position in the array. The position must be valid, or at the end of the array (\[code\]idx == size()\[/code\]). *)
    let insert x0  x1  x2  = 
    foreign_builtin_method2
      GlobalEnum.VariantType._TYPE_PACKED_COLOR_ARRAY
      "insert"
      785289703L
      (Int.typ @-> Color.typ @-> PackedColorArray.typ @-> returning Int.typ)
      Int.s x0  x1  x2 

    (** Assigns the given value to all elements in the array. This can typically be used together with \[method resize\] to create an array with a given size and initialized elements. *)
    let fill x0  x1  = 
    foreign_builtin_method1_void
      GlobalEnum.VariantType._TYPE_PACKED_COLOR_ARRAY
      "fill"
      3730314301L
      (Color.typ @-> PackedColorArray.typ @-> returning Void.typ)
      Void.s x0  x1 

    (** Sets the size of the array. If the array is grown, reserves elements at the end of the array. If the array is shrunk, truncates the array to the new size. Calling \[method resize\] once and assigning the new values is faster than adding new elements one by one. *)
    let resize x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_PACKED_COLOR_ARRAY
      "resize"
      848867239L
      (Int.typ @-> PackedColorArray.typ @-> returning Int.typ)
      Int.s x0  x1 

    (** Clears the array. This is equivalent to using \[method resize\] with a size of \[code\]0\[/code\]. *)
    let clear x0  = 
    foreign_builtin_method0_void
      GlobalEnum.VariantType._TYPE_PACKED_COLOR_ARRAY
      "clear"
      3218959716L
      (PackedColorArray.typ @-> returning Void.typ)
      Void.s x0 

    (** Returns \[code\]true\[/code\] if the array contains \[param value\]. *)
    let has x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_PACKED_COLOR_ARRAY
      "has"
      3167426256L
      (Color.typ @-> PackedColorArray.typ @-> returning Bool.typ)
      Bool.s x0  x1 

    (** Reverses the order of the elements in the array. *)
    let reverse x0  = 
    foreign_builtin_method0_void
      GlobalEnum.VariantType._TYPE_PACKED_COLOR_ARRAY
      "reverse"
      3218959716L
      (PackedColorArray.typ @-> returning Void.typ)
      Void.s x0 

    (** Returns the slice of the \[PackedColorArray\], from \[param begin\] (inclusive) to \[param end\] (exclusive), as a new \[PackedColorArray\].
The absolute value of \[param begin\] and \[param end\] will be clamped to the array size, so the default value for \[param end\] makes it slice to the size of the array by default (i.e. \[code\]arr.slice(1)\[/code\] is a shorthand for \[code\]arr.slice(1, arr.size())\[/code\]).
If either \[param begin\] or \[param end\] are negative, they will be relative to the end of the array (i.e. \[code\]arr.slice(0, -2)\[/code\] is a shorthand for \[code\]arr.slice(0, arr.size() - 2)\[/code\]). *)
    let slice x0  x1  x2  = 
    foreign_builtin_method2
      GlobalEnum.VariantType._TYPE_PACKED_COLOR_ARRAY
      "slice"
      2451797139L
      (Int.typ @-> Int.typ @-> PackedColorArray.typ @-> returning PackedColorArray.typ)
      PackedColorArray.s x0  x1  x2 

    (** Returns a \[PackedByteArray\] with each color encoded as bytes. *)
    let to_byte_array x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_PACKED_COLOR_ARRAY
      "to_byte_array"
      247621236L
      (PackedColorArray.typ @-> returning PackedByteArray.typ)
      PackedByteArray.s x0 

    (** Sorts the elements of the array in ascending order. *)
    let sort x0  = 
    foreign_builtin_method0_void
      GlobalEnum.VariantType._TYPE_PACKED_COLOR_ARRAY
      "sort"
      3218959716L
      (PackedColorArray.typ @-> returning Void.typ)
      Void.s x0 

    (** Finds the index of an existing value (or the insertion index that maintains sorting order, if the value is not yet present in the array) using binary search. Optionally, a \[param before\] specifier can be passed. If \[code\]false\[/code\], the returned index comes after all existing entries of the value in the array.
\[b\]Note:\[/b\] Calling \[method bsearch\] on an unsorted array results in unexpected behavior. *)
    let bsearch x0  x1  x2  = 
    foreign_builtin_method2
      GlobalEnum.VariantType._TYPE_PACKED_COLOR_ARRAY
      "bsearch"
      314143821L
      (Color.typ @-> Bool.typ @-> PackedColorArray.typ @-> returning Int.typ)
      Int.s x0  x1  x2 

    (** Creates a copy of the array, and returns it. *)
    let duplicate x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_PACKED_COLOR_ARRAY
      "duplicate"
      1011903421L
      (PackedColorArray.typ @-> returning PackedColorArray.typ)
      PackedColorArray.s x0 

    (** Searches the array for a value and returns its index or \[code\]-1\[/code\] if not found. Optionally, the initial search index can be passed. *)
    let find x0  x1  x2  = 
    foreign_builtin_method2
      GlobalEnum.VariantType._TYPE_PACKED_COLOR_ARRAY
      "find"
      3156095363L
      (Color.typ @-> Int.typ @-> PackedColorArray.typ @-> returning Int.typ)
      Int.s x0  x1  x2 

    (** Searches the array in reverse order. Optionally, a start search index can be passed. If negative, the start index is considered relative to the end of the array. *)
    let rfind x0  x1  x2  = 
    foreign_builtin_method2
      GlobalEnum.VariantType._TYPE_PACKED_COLOR_ARRAY
      "rfind"
      3156095363L
      (Color.typ @-> Int.typ @-> PackedColorArray.typ @-> returning Int.typ)
      Int.s x0  x1  x2 

    (** Returns the number of times an element is in the array. *)
    let count x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_PACKED_COLOR_ARRAY
      "count"
      1682108616L
      (Color.typ @-> PackedColorArray.typ @-> returning Int.typ)
      Int.s x0  x1 






    let not x0  = 
    foreign_builtin_operator1 GlobalEnum.VariantType._TYPE_PACKED_COLOR_ARRAY None  GlobalEnum.VariantOperator._OP_NOT
      (funptr (PackedColorArray.typ @-> Bool.typ @-> returning void))
      Bool.s x0 


    let mem_Dictionary x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_PACKED_COLOR_ARRAY (Some GlobalEnum.VariantType._TYPE_DICTIONARY) GlobalEnum.VariantOperator._OP_IN
      (funptr (PackedColorArray.typ @-> Dictionary.typ @-> Bool.typ @-> returning void))
      Bool.s x0  x1 


    let mem_Array x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_PACKED_COLOR_ARRAY (Some GlobalEnum.VariantType._TYPE_ARRAY) GlobalEnum.VariantOperator._OP_IN
      (funptr (PackedColorArray.typ @-> Array.typ @-> Bool.typ @-> returning void))
      Bool.s x0  x1 

    (** Returns \[code\]true\[/code\] if contents of both arrays are the same, i.e. they have all equal \[Color\]s at the corresponding indices. *)
    let (=) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_PACKED_COLOR_ARRAY (Some GlobalEnum.VariantType._TYPE_PACKED_COLOR_ARRAY) GlobalEnum.VariantOperator._OP_EQUAL
      (funptr (PackedColorArray.typ @-> PackedColorArray.typ @-> Bool.typ @-> returning void))
      Bool.s
      Conv.PackedColorArray.of_ocaml
      Conv.PackedColorArray.of_ocaml
      Conv.Bool.to_ocaml x0  x1 

    (** Returns \[code\]true\[/code\] if contents of the arrays differ. *)
    let (<>) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_PACKED_COLOR_ARRAY (Some GlobalEnum.VariantType._TYPE_PACKED_COLOR_ARRAY) GlobalEnum.VariantOperator._OP_NOT_EQUAL
      (funptr (PackedColorArray.typ @-> PackedColorArray.typ @-> Bool.typ @-> returning void))
      Bool.s
      Conv.PackedColorArray.of_ocaml
      Conv.PackedColorArray.of_ocaml
      Conv.Bool.to_ocaml x0  x1 

    (** Returns a new \[PackedColorArray\] with contents of \[param right\] added at the end of this array. For better performance, consider using \[method append_array\] instead. *)
    let (+) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_PACKED_COLOR_ARRAY (Some GlobalEnum.VariantType._TYPE_PACKED_COLOR_ARRAY) GlobalEnum.VariantOperator._OP_ADD
      (funptr (PackedColorArray.typ @-> PackedColorArray.typ @-> PackedColorArray.typ @-> returning void))
      PackedColorArray.s
      Conv.PackedColorArray.of_ocaml
      Conv.PackedColorArray.of_ocaml
      Conv.PackedColorArray.to_ocaml x0  x1 
    end

  module PackedVector4Array = struct
    include M.PackedVector4Array
include BuiltinClass0.PackedVector4Array

    (** Returns the \[Vector4\] at the given \[param index\] in the array. This is the same as using the \[code\]\[\]\[/code\] operator (\[code\]array\[index\]\[/code\]). *)
    let get x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_PACKED_VECTOR4_ARRAY
      "get"
      1227817084L
      (Int.typ @-> PackedVector4Array.typ @-> returning Vector4.typ)
      Vector4.s x0  x1 

    (** Changes the \[Vector4\] at the given index. *)
    let set x0  x1  x2  = 
    foreign_builtin_method2_void
      GlobalEnum.VariantType._TYPE_PACKED_VECTOR4_ARRAY
      "set"
      1350366223L
      (Int.typ @-> Vector4.typ @-> PackedVector4Array.typ @-> returning Void.typ)
      Void.s x0  x1  x2 

    (** Returns the number of elements in the array. *)
    let size x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_PACKED_VECTOR4_ARRAY
      "size"
      3173160232L
      (PackedVector4Array.typ @-> returning Int.typ)
      Int.s x0 

    (** Returns \[code\]true\[/code\] if the array is empty. *)
    let is_empty x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_PACKED_VECTOR4_ARRAY
      "is_empty"
      3918633141L
      (PackedVector4Array.typ @-> returning Bool.typ)
      Bool.s x0 

    (** Inserts a \[Vector4\] at the end. *)
    let push_back x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_PACKED_VECTOR4_ARRAY
      "push_back"
      3289167688L
      (Vector4.typ @-> PackedVector4Array.typ @-> returning Bool.typ)
      Bool.s x0  x1 

    (** Appends an element at the end of the array (alias of \[method push_back\]). *)
    let append x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_PACKED_VECTOR4_ARRAY
      "append"
      3289167688L
      (Vector4.typ @-> PackedVector4Array.typ @-> returning Bool.typ)
      Bool.s x0  x1 

    (** Appends a \[PackedVector4Array\] at the end of this array. *)
    let append_array x0  x1  = 
    foreign_builtin_method1_void
      GlobalEnum.VariantType._TYPE_PACKED_VECTOR4_ARRAY
      "append_array"
      537428395L
      (PackedVector4Array.typ @-> PackedVector4Array.typ @-> returning Void.typ)
      Void.s x0  x1 

    (** Removes an element from the array by index. *)
    let remove_at x0  x1  = 
    foreign_builtin_method1_void
      GlobalEnum.VariantType._TYPE_PACKED_VECTOR4_ARRAY
      "remove_at"
      2823966027L
      (Int.typ @-> PackedVector4Array.typ @-> returning Void.typ)
      Void.s x0  x1 

    (** Inserts a new element at a given position in the array. The position must be valid, or at the end of the array (\[code\]idx == size()\[/code\]). *)
    let insert x0  x1  x2  = 
    foreign_builtin_method2
      GlobalEnum.VariantType._TYPE_PACKED_VECTOR4_ARRAY
      "insert"
      11085009L
      (Int.typ @-> Vector4.typ @-> PackedVector4Array.typ @-> returning Int.typ)
      Int.s x0  x1  x2 

    (** Assigns the given value to all elements in the array. This can typically be used together with \[method resize\] to create an array with a given size and initialized elements. *)
    let fill x0  x1  = 
    foreign_builtin_method1_void
      GlobalEnum.VariantType._TYPE_PACKED_VECTOR4_ARRAY
      "fill"
      3761353134L
      (Vector4.typ @-> PackedVector4Array.typ @-> returning Void.typ)
      Void.s x0  x1 

    (** Sets the size of the array. If the array is grown, reserves elements at the end of the array. If the array is shrunk, truncates the array to the new size. *)
    let resize x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_PACKED_VECTOR4_ARRAY
      "resize"
      848867239L
      (Int.typ @-> PackedVector4Array.typ @-> returning Int.typ)
      Int.s x0  x1 

    (** Clears the array. This is equivalent to using \[method resize\] with a size of \[code\]0\[/code\]. *)
    let clear x0  = 
    foreign_builtin_method0_void
      GlobalEnum.VariantType._TYPE_PACKED_VECTOR4_ARRAY
      "clear"
      3218959716L
      (PackedVector4Array.typ @-> returning Void.typ)
      Void.s x0 

    (** Returns \[code\]true\[/code\] if the array contains \[param value\].
\[b\]Note:\[/b\] Vectors with \[constant \@GDScript.NAN\] elements don''t behave the same as other vectors. Therefore, the results from this method may not be accurate if NaNs are included. *)
    let has x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_PACKED_VECTOR4_ARRAY
      "has"
      88913544L
      (Vector4.typ @-> PackedVector4Array.typ @-> returning Bool.typ)
      Bool.s x0  x1 

    (** Reverses the order of the elements in the array. *)
    let reverse x0  = 
    foreign_builtin_method0_void
      GlobalEnum.VariantType._TYPE_PACKED_VECTOR4_ARRAY
      "reverse"
      3218959716L
      (PackedVector4Array.typ @-> returning Void.typ)
      Void.s x0 

    (** Returns the slice of the \[PackedVector4Array\], from \[param begin\] (inclusive) to \[param end\] (exclusive), as a new \[PackedVector4Array\].
The absolute value of \[param begin\] and \[param end\] will be clamped to the array size, so the default value for \[param end\] makes it slice to the size of the array by default (i.e. \[code\]arr.slice(1)\[/code\] is a shorthand for \[code\]arr.slice(1, arr.size())\[/code\]).
If either \[param begin\] or \[param end\] are negative, they will be relative to the end of the array (i.e. \[code\]arr.slice(0, -2)\[/code\] is a shorthand for \[code\]arr.slice(0, arr.size() - 2)\[/code\]). *)
    let slice x0  x1  x2  = 
    foreign_builtin_method2
      GlobalEnum.VariantType._TYPE_PACKED_VECTOR4_ARRAY
      "slice"
      2942803855L
      (Int.typ @-> Int.typ @-> PackedVector4Array.typ @-> returning PackedVector4Array.typ)
      PackedVector4Array.s x0  x1  x2 

    (** Returns a \[PackedByteArray\] with each vector encoded as bytes. *)
    let to_byte_array x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_PACKED_VECTOR4_ARRAY
      "to_byte_array"
      247621236L
      (PackedVector4Array.typ @-> returning PackedByteArray.typ)
      PackedByteArray.s x0 

    (** Sorts the elements of the array in ascending order.
\[b\]Note:\[/b\] Vectors with \[constant \@GDScript.NAN\] elements don''t behave the same as other vectors. Therefore, the results from this method may not be accurate if NaNs are included. *)
    let sort x0  = 
    foreign_builtin_method0_void
      GlobalEnum.VariantType._TYPE_PACKED_VECTOR4_ARRAY
      "sort"
      3218959716L
      (PackedVector4Array.typ @-> returning Void.typ)
      Void.s x0 

    (** Finds the index of an existing value (or the insertion index that maintains sorting order, if the value is not yet present in the array) using binary search. Optionally, a \[param before\] specifier can be passed. If \[code\]false\[/code\], the returned index comes after all existing entries of the value in the array.
\[b\]Note:\[/b\] Calling \[method bsearch\] on an unsorted array results in unexpected behavior.
\[b\]Note:\[/b\] Vectors with \[constant \@GDScript.NAN\] elements don''t behave the same as other vectors. Therefore, the results from this method may not be accurate if NaNs are included. *)
    let bsearch x0  x1  x2  = 
    foreign_builtin_method2
      GlobalEnum.VariantType._TYPE_PACKED_VECTOR4_ARRAY
      "bsearch"
      735671678L
      (Vector4.typ @-> Bool.typ @-> PackedVector4Array.typ @-> returning Int.typ)
      Int.s x0  x1  x2 

    (** Creates a copy of the array, and returns it. *)
    let duplicate x0  = 
    foreign_builtin_method0
      GlobalEnum.VariantType._TYPE_PACKED_VECTOR4_ARRAY
      "duplicate"
      3186305013L
      (PackedVector4Array.typ @-> returning PackedVector4Array.typ)
      PackedVector4Array.s x0 

    (** Searches the array for a value and returns its index or \[code\]-1\[/code\] if not found. Optionally, the initial search index can be passed.
\[b\]Note:\[/b\] Vectors with \[constant \@GDScript.NAN\] elements don''t behave the same as other vectors. Therefore, the results from this method may not be accurate if NaNs are included. *)
    let find x0  x1  x2  = 
    foreign_builtin_method2
      GlobalEnum.VariantType._TYPE_PACKED_VECTOR4_ARRAY
      "find"
      3091171314L
      (Vector4.typ @-> Int.typ @-> PackedVector4Array.typ @-> returning Int.typ)
      Int.s x0  x1  x2 

    (** Searches the array in reverse order. Optionally, a start search index can be passed. If negative, the start index is considered relative to the end of the array.
\[b\]Note:\[/b\] Vectors with \[constant \@GDScript.NAN\] elements don''t behave the same as other vectors. Therefore, the results from this method may not be accurate if NaNs are included. *)
    let rfind x0  x1  x2  = 
    foreign_builtin_method2
      GlobalEnum.VariantType._TYPE_PACKED_VECTOR4_ARRAY
      "rfind"
      3091171314L
      (Vector4.typ @-> Int.typ @-> PackedVector4Array.typ @-> returning Int.typ)
      Int.s x0  x1  x2 

    (** Returns the number of times an element is in the array.
\[b\]Note:\[/b\] Vectors with \[constant \@GDScript.NAN\] elements don''t behave the same as other vectors. Therefore, the results from this method may not be accurate if NaNs are included. *)
    let count x0  x1  = 
    foreign_builtin_method1
      GlobalEnum.VariantType._TYPE_PACKED_VECTOR4_ARRAY
      "count"
      3956594488L
      (Vector4.typ @-> PackedVector4Array.typ @-> returning Int.typ)
      Int.s x0  x1 






    let not x0  = 
    foreign_builtin_operator1 GlobalEnum.VariantType._TYPE_PACKED_VECTOR4_ARRAY None  GlobalEnum.VariantOperator._OP_NOT
      (funptr (PackedVector4Array.typ @-> Bool.typ @-> returning void))
      Bool.s x0 


    let mem_Dictionary x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_PACKED_VECTOR4_ARRAY (Some GlobalEnum.VariantType._TYPE_DICTIONARY) GlobalEnum.VariantOperator._OP_IN
      (funptr (PackedVector4Array.typ @-> Dictionary.typ @-> Bool.typ @-> returning void))
      Bool.s x0  x1 


    let mem_Array x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_PACKED_VECTOR4_ARRAY (Some GlobalEnum.VariantType._TYPE_ARRAY) GlobalEnum.VariantOperator._OP_IN
      (funptr (PackedVector4Array.typ @-> Array.typ @-> Bool.typ @-> returning void))
      Bool.s x0  x1 

    (** Returns \[code\]true\[/code\] if contents of both arrays are the same, i.e. they have all equal \[Vector4\]s at the corresponding indices. *)
    let (=) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_PACKED_VECTOR4_ARRAY (Some GlobalEnum.VariantType._TYPE_PACKED_VECTOR4_ARRAY) GlobalEnum.VariantOperator._OP_EQUAL
      (funptr (PackedVector4Array.typ @-> PackedVector4Array.typ @-> Bool.typ @-> returning void))
      Bool.s
      Conv.PackedVector4Array.of_ocaml
      Conv.PackedVector4Array.of_ocaml
      Conv.Bool.to_ocaml x0  x1 

    (** Returns \[code\]true\[/code\] if contents of the arrays differ. *)
    let (<>) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_PACKED_VECTOR4_ARRAY (Some GlobalEnum.VariantType._TYPE_PACKED_VECTOR4_ARRAY) GlobalEnum.VariantOperator._OP_NOT_EQUAL
      (funptr (PackedVector4Array.typ @-> PackedVector4Array.typ @-> Bool.typ @-> returning void))
      Bool.s
      Conv.PackedVector4Array.of_ocaml
      Conv.PackedVector4Array.of_ocaml
      Conv.Bool.to_ocaml x0  x1 

    (** Returns a new \[PackedVector4Array\] with contents of \[param right\] added at the end of this array. For better performance, consider using \[method append_array\] instead. *)
    let (+) x0  x1  = 
    foreign_builtin_operator2 GlobalEnum.VariantType._TYPE_PACKED_VECTOR4_ARRAY (Some GlobalEnum.VariantType._TYPE_PACKED_VECTOR4_ARRAY) GlobalEnum.VariantOperator._OP_ADD
      (funptr (PackedVector4Array.typ @-> PackedVector4Array.typ @-> PackedVector4Array.typ @-> returning void))
      PackedVector4Array.s
      Conv.PackedVector4Array.of_ocaml
      Conv.PackedVector4Array.of_ocaml
      Conv.PackedVector4Array.to_ocaml x0  x1 
    end
  end

