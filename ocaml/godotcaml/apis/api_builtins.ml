open! Base
open Foreign_api
open Foreign_api.Godotcaml
open Ctypes
module M = Foreign_api.Make (Api_types.ClassSizes)
open M

let funptr = Foreign.funptr

module ApiTypes = struct
  module Void = struct
    include M.Void
  end

  module type NIL = sig
    include Api_types.API_TYPE

    val to_variant : t structure ptr -> C.variant_ptr structure ptr
    val of_variant : C.variant_ptr structure ptr -> t structure ptr
  end

  module Nil = struct
    include Nil
    include Conv.Nil

    let to_variantizer = get_variant_from_type_constructor type_enum typ
    let of_variantizer = get_variant_to_type_constructor type_enum typ

    let to_variant : t structure ptr -> C.variant_ptr structure ptr =
     fun x ->
      let new_variant_ptr =
        coerce_ptr C.variant_ptr.uninit (gc_alloc Variant.s ~count:1)
      in
      let () = to_variantizer new_variant_ptr (coerce_ptr typ x) in
      let inited_variant_ptr = coerce_ptr C.variant_ptr.plain new_variant_ptr in
      inited_variant_ptr

    let of_variant : C.variant_ptr structure ptr -> t structure ptr =
     fun x ->
      let new_type_ptr = gc_alloc s ~count:1 in
      let () = of_variantizer (coerce_ptr typ new_type_ptr) x in
      let inited_type_ptr = coerce_ptr (ptr s) new_type_ptr in
      inited_type_ptr
  end

  module type BOOL = sig
    include Api_types.API_TYPE

    val to_variant : t structure ptr -> C.variant_ptr structure ptr
    val of_variant : C.variant_ptr structure ptr -> t structure ptr
  end

  module Bool = struct
    include Bool
    include Conv.Bool

    let to_variantizer = get_variant_from_type_constructor type_enum typ
    let of_variantizer = get_variant_to_type_constructor type_enum typ

    let to_variant : t structure ptr -> C.variant_ptr structure ptr =
     fun x ->
      let new_variant_ptr =
        coerce_ptr C.variant_ptr.uninit (gc_alloc Variant.s ~count:1)
      in
      let () = to_variantizer new_variant_ptr (coerce_ptr typ x) in
      let inited_variant_ptr = coerce_ptr C.variant_ptr.plain new_variant_ptr in
      inited_variant_ptr

    let of_variant : C.variant_ptr structure ptr -> t structure ptr =
     fun x ->
      let new_type_ptr = gc_alloc s ~count:1 in
      let () = of_variantizer (coerce_ptr typ new_type_ptr) x in
      let inited_type_ptr = coerce_ptr (ptr s) new_type_ptr in
      inited_type_ptr
  end

  module type INT = sig
    include Api_types.API_TYPE

    val to_variant : t structure ptr -> C.variant_ptr structure ptr
    val of_variant : C.variant_ptr structure ptr -> t structure ptr
  end

  module Int = struct
    include Int
    include Conv.Int

    let to_variantizer = get_variant_from_type_constructor type_enum typ
    let of_variantizer = get_variant_to_type_constructor type_enum typ

    let to_variant : t structure ptr -> C.variant_ptr structure ptr =
     fun x ->
      let new_variant_ptr =
        coerce_ptr C.variant_ptr.uninit (gc_alloc Variant.s ~count:1)
      in
      let () = to_variantizer new_variant_ptr (coerce_ptr typ x) in
      let inited_variant_ptr = coerce_ptr C.variant_ptr.plain new_variant_ptr in
      inited_variant_ptr

    let of_variant : C.variant_ptr structure ptr -> t structure ptr =
     fun x ->
      let new_type_ptr = gc_alloc s ~count:1 in
      let () = of_variantizer (coerce_ptr typ new_type_ptr) x in
      let inited_type_ptr = coerce_ptr (ptr s) new_type_ptr in
      inited_type_ptr
  end

  module type FLOAT = sig
    include Api_types.API_TYPE

    val to_variant : t structure ptr -> C.variant_ptr structure ptr
    val of_variant : C.variant_ptr structure ptr -> t structure ptr
  end

  module Float = struct
    include Float
    include Conv.Float

    let to_variantizer = get_variant_from_type_constructor type_enum typ
    let of_variantizer = get_variant_to_type_constructor type_enum typ

    let to_variant : t structure ptr -> C.variant_ptr structure ptr =
     fun x ->
      let new_variant_ptr =
        coerce_ptr C.variant_ptr.uninit (gc_alloc Variant.s ~count:1)
      in
      let () = to_variantizer new_variant_ptr (coerce_ptr typ x) in
      let inited_variant_ptr = coerce_ptr C.variant_ptr.plain new_variant_ptr in
      inited_variant_ptr

    let of_variant : C.variant_ptr structure ptr -> t structure ptr =
     fun x ->
      let new_type_ptr = gc_alloc s ~count:1 in
      let () = of_variantizer (coerce_ptr typ new_type_ptr) x in
      let inited_type_ptr = coerce_ptr (ptr s) new_type_ptr in
      inited_type_ptr
  end

  module type STRING = sig
    include Api_types.API_TYPE

    val to_variant : t structure ptr -> C.variant_ptr structure ptr
    val of_variant : C.variant_ptr structure ptr -> t structure ptr
  end

  module String = struct
    include String
    include Conv.String

    let to_variantizer = get_variant_from_type_constructor type_enum typ
    let of_variantizer = get_variant_to_type_constructor type_enum typ

    let to_variant : t structure ptr -> C.variant_ptr structure ptr =
     fun x ->
      let new_variant_ptr =
        coerce_ptr C.variant_ptr.uninit (gc_alloc Variant.s ~count:1)
      in
      let () = to_variantizer new_variant_ptr (coerce_ptr typ x) in
      let inited_variant_ptr = coerce_ptr C.variant_ptr.plain new_variant_ptr in
      inited_variant_ptr

    let of_variant : C.variant_ptr structure ptr -> t structure ptr =
     fun x ->
      let new_type_ptr = gc_alloc s ~count:1 in
      let () = of_variantizer (coerce_ptr typ new_type_ptr) x in
      let inited_type_ptr = coerce_ptr (ptr s) new_type_ptr in
      inited_type_ptr
  end

  module type VECTOR2 = sig
    include Api_types.API_TYPE

    val to_variant : t structure ptr -> C.variant_ptr structure ptr
    val of_variant : C.variant_ptr structure ptr -> t structure ptr
  end

  module Vector2 = struct
    include Vector2
    include Conv.Vector2

    let to_variantizer = get_variant_from_type_constructor type_enum typ
    let of_variantizer = get_variant_to_type_constructor type_enum typ

    let to_variant : t structure ptr -> C.variant_ptr structure ptr =
     fun x ->
      let new_variant_ptr =
        coerce_ptr C.variant_ptr.uninit (gc_alloc Variant.s ~count:1)
      in
      let () = to_variantizer new_variant_ptr (coerce_ptr typ x) in
      let inited_variant_ptr = coerce_ptr C.variant_ptr.plain new_variant_ptr in
      inited_variant_ptr

    let of_variant : C.variant_ptr structure ptr -> t structure ptr =
     fun x ->
      let new_type_ptr = gc_alloc s ~count:1 in
      let () = of_variantizer (coerce_ptr typ new_type_ptr) x in
      let inited_type_ptr = coerce_ptr (ptr s) new_type_ptr in
      inited_type_ptr
  end

  module type VECTOR2I = sig
    include Api_types.API_TYPE

    val to_variant : t structure ptr -> C.variant_ptr structure ptr
    val of_variant : C.variant_ptr structure ptr -> t structure ptr
  end

  module Vector2i = struct
    include Vector2i
    include Conv.Vector2i

    let to_variantizer = get_variant_from_type_constructor type_enum typ
    let of_variantizer = get_variant_to_type_constructor type_enum typ

    let to_variant : t structure ptr -> C.variant_ptr structure ptr =
     fun x ->
      let new_variant_ptr =
        coerce_ptr C.variant_ptr.uninit (gc_alloc Variant.s ~count:1)
      in
      let () = to_variantizer new_variant_ptr (coerce_ptr typ x) in
      let inited_variant_ptr = coerce_ptr C.variant_ptr.plain new_variant_ptr in
      inited_variant_ptr

    let of_variant : C.variant_ptr structure ptr -> t structure ptr =
     fun x ->
      let new_type_ptr = gc_alloc s ~count:1 in
      let () = of_variantizer (coerce_ptr typ new_type_ptr) x in
      let inited_type_ptr = coerce_ptr (ptr s) new_type_ptr in
      inited_type_ptr
  end

  module type RECT2 = sig
    include Api_types.API_TYPE

    val to_variant : t structure ptr -> C.variant_ptr structure ptr
    val of_variant : C.variant_ptr structure ptr -> t structure ptr
  end

  module Rect2 = struct
    include Rect2
    include Conv.Rect2

    let to_variantizer = get_variant_from_type_constructor type_enum typ
    let of_variantizer = get_variant_to_type_constructor type_enum typ

    let to_variant : t structure ptr -> C.variant_ptr structure ptr =
     fun x ->
      let new_variant_ptr =
        coerce_ptr C.variant_ptr.uninit (gc_alloc Variant.s ~count:1)
      in
      let () = to_variantizer new_variant_ptr (coerce_ptr typ x) in
      let inited_variant_ptr = coerce_ptr C.variant_ptr.plain new_variant_ptr in
      inited_variant_ptr

    let of_variant : C.variant_ptr structure ptr -> t structure ptr =
     fun x ->
      let new_type_ptr = gc_alloc s ~count:1 in
      let () = of_variantizer (coerce_ptr typ new_type_ptr) x in
      let inited_type_ptr = coerce_ptr (ptr s) new_type_ptr in
      inited_type_ptr
  end

  module type RECT2I = sig
    include Api_types.API_TYPE

    val to_variant : t structure ptr -> C.variant_ptr structure ptr
    val of_variant : C.variant_ptr structure ptr -> t structure ptr
  end

  module Rect2i = struct
    include Rect2i
    include Conv.Rect2i

    let to_variantizer = get_variant_from_type_constructor type_enum typ
    let of_variantizer = get_variant_to_type_constructor type_enum typ

    let to_variant : t structure ptr -> C.variant_ptr structure ptr =
     fun x ->
      let new_variant_ptr =
        coerce_ptr C.variant_ptr.uninit (gc_alloc Variant.s ~count:1)
      in
      let () = to_variantizer new_variant_ptr (coerce_ptr typ x) in
      let inited_variant_ptr = coerce_ptr C.variant_ptr.plain new_variant_ptr in
      inited_variant_ptr

    let of_variant : C.variant_ptr structure ptr -> t structure ptr =
     fun x ->
      let new_type_ptr = gc_alloc s ~count:1 in
      let () = of_variantizer (coerce_ptr typ new_type_ptr) x in
      let inited_type_ptr = coerce_ptr (ptr s) new_type_ptr in
      inited_type_ptr
  end

  module type VECTOR3 = sig
    include Api_types.API_TYPE

    val to_variant : t structure ptr -> C.variant_ptr structure ptr
    val of_variant : C.variant_ptr structure ptr -> t structure ptr
  end

  module Vector3 = struct
    include Vector3
    include Conv.Vector3

    let to_variantizer = get_variant_from_type_constructor type_enum typ
    let of_variantizer = get_variant_to_type_constructor type_enum typ

    let to_variant : t structure ptr -> C.variant_ptr structure ptr =
     fun x ->
      let new_variant_ptr =
        coerce_ptr C.variant_ptr.uninit (gc_alloc Variant.s ~count:1)
      in
      let () = to_variantizer new_variant_ptr (coerce_ptr typ x) in
      let inited_variant_ptr = coerce_ptr C.variant_ptr.plain new_variant_ptr in
      inited_variant_ptr

    let of_variant : C.variant_ptr structure ptr -> t structure ptr =
     fun x ->
      let new_type_ptr = gc_alloc s ~count:1 in
      let () = of_variantizer (coerce_ptr typ new_type_ptr) x in
      let inited_type_ptr = coerce_ptr (ptr s) new_type_ptr in
      inited_type_ptr
  end

  module type VECTOR3I = sig
    include Api_types.API_TYPE

    val to_variant : t structure ptr -> C.variant_ptr structure ptr
    val of_variant : C.variant_ptr structure ptr -> t structure ptr
  end

  module Vector3i = struct
    include Vector3i
    include Conv.Vector3i

    let to_variantizer = get_variant_from_type_constructor type_enum typ
    let of_variantizer = get_variant_to_type_constructor type_enum typ

    let to_variant : t structure ptr -> C.variant_ptr structure ptr =
     fun x ->
      let new_variant_ptr =
        coerce_ptr C.variant_ptr.uninit (gc_alloc Variant.s ~count:1)
      in
      let () = to_variantizer new_variant_ptr (coerce_ptr typ x) in
      let inited_variant_ptr = coerce_ptr C.variant_ptr.plain new_variant_ptr in
      inited_variant_ptr

    let of_variant : C.variant_ptr structure ptr -> t structure ptr =
     fun x ->
      let new_type_ptr = gc_alloc s ~count:1 in
      let () = of_variantizer (coerce_ptr typ new_type_ptr) x in
      let inited_type_ptr = coerce_ptr (ptr s) new_type_ptr in
      inited_type_ptr
  end

  module type TRANSFORM2D = sig
    include Api_types.API_TYPE

    val to_variant : t structure ptr -> C.variant_ptr structure ptr
    val of_variant : C.variant_ptr structure ptr -> t structure ptr
  end

  module Transform2D = struct
    include Transform2D
    include Conv.Transform2D

    let to_variantizer = get_variant_from_type_constructor type_enum typ
    let of_variantizer = get_variant_to_type_constructor type_enum typ

    let to_variant : t structure ptr -> C.variant_ptr structure ptr =
     fun x ->
      let new_variant_ptr =
        coerce_ptr C.variant_ptr.uninit (gc_alloc Variant.s ~count:1)
      in
      let () = to_variantizer new_variant_ptr (coerce_ptr typ x) in
      let inited_variant_ptr = coerce_ptr C.variant_ptr.plain new_variant_ptr in
      inited_variant_ptr

    let of_variant : C.variant_ptr structure ptr -> t structure ptr =
     fun x ->
      let new_type_ptr = gc_alloc s ~count:1 in
      let () = of_variantizer (coerce_ptr typ new_type_ptr) x in
      let inited_type_ptr = coerce_ptr (ptr s) new_type_ptr in
      inited_type_ptr
  end

  module type VECTOR4 = sig
    include Api_types.API_TYPE

    val to_variant : t structure ptr -> C.variant_ptr structure ptr
    val of_variant : C.variant_ptr structure ptr -> t structure ptr
  end

  module Vector4 = struct
    include Vector4
    include Conv.Vector4

    let to_variantizer = get_variant_from_type_constructor type_enum typ
    let of_variantizer = get_variant_to_type_constructor type_enum typ

    let to_variant : t structure ptr -> C.variant_ptr structure ptr =
     fun x ->
      let new_variant_ptr =
        coerce_ptr C.variant_ptr.uninit (gc_alloc Variant.s ~count:1)
      in
      let () = to_variantizer new_variant_ptr (coerce_ptr typ x) in
      let inited_variant_ptr = coerce_ptr C.variant_ptr.plain new_variant_ptr in
      inited_variant_ptr

    let of_variant : C.variant_ptr structure ptr -> t structure ptr =
     fun x ->
      let new_type_ptr = gc_alloc s ~count:1 in
      let () = of_variantizer (coerce_ptr typ new_type_ptr) x in
      let inited_type_ptr = coerce_ptr (ptr s) new_type_ptr in
      inited_type_ptr
  end

  module type VECTOR4I = sig
    include Api_types.API_TYPE

    val to_variant : t structure ptr -> C.variant_ptr structure ptr
    val of_variant : C.variant_ptr structure ptr -> t structure ptr
  end

  module Vector4i = struct
    include Vector4i
    include Conv.Vector4i

    let to_variantizer = get_variant_from_type_constructor type_enum typ
    let of_variantizer = get_variant_to_type_constructor type_enum typ

    let to_variant : t structure ptr -> C.variant_ptr structure ptr =
     fun x ->
      let new_variant_ptr =
        coerce_ptr C.variant_ptr.uninit (gc_alloc Variant.s ~count:1)
      in
      let () = to_variantizer new_variant_ptr (coerce_ptr typ x) in
      let inited_variant_ptr = coerce_ptr C.variant_ptr.plain new_variant_ptr in
      inited_variant_ptr

    let of_variant : C.variant_ptr structure ptr -> t structure ptr =
     fun x ->
      let new_type_ptr = gc_alloc s ~count:1 in
      let () = of_variantizer (coerce_ptr typ new_type_ptr) x in
      let inited_type_ptr = coerce_ptr (ptr s) new_type_ptr in
      inited_type_ptr
  end

  module type PLANE = sig
    include Api_types.API_TYPE

    val to_variant : t structure ptr -> C.variant_ptr structure ptr
    val of_variant : C.variant_ptr structure ptr -> t structure ptr
  end

  module Plane = struct
    include Plane
    include Conv.Plane

    let to_variantizer = get_variant_from_type_constructor type_enum typ
    let of_variantizer = get_variant_to_type_constructor type_enum typ

    let to_variant : t structure ptr -> C.variant_ptr structure ptr =
     fun x ->
      let new_variant_ptr =
        coerce_ptr C.variant_ptr.uninit (gc_alloc Variant.s ~count:1)
      in
      let () = to_variantizer new_variant_ptr (coerce_ptr typ x) in
      let inited_variant_ptr = coerce_ptr C.variant_ptr.plain new_variant_ptr in
      inited_variant_ptr

    let of_variant : C.variant_ptr structure ptr -> t structure ptr =
     fun x ->
      let new_type_ptr = gc_alloc s ~count:1 in
      let () = of_variantizer (coerce_ptr typ new_type_ptr) x in
      let inited_type_ptr = coerce_ptr (ptr s) new_type_ptr in
      inited_type_ptr
  end

  module type QUATERNION = sig
    include Api_types.API_TYPE

    val to_variant : t structure ptr -> C.variant_ptr structure ptr
    val of_variant : C.variant_ptr structure ptr -> t structure ptr
  end

  module Quaternion = struct
    include Quaternion
    include Conv.Quaternion

    let to_variantizer = get_variant_from_type_constructor type_enum typ
    let of_variantizer = get_variant_to_type_constructor type_enum typ

    let to_variant : t structure ptr -> C.variant_ptr structure ptr =
     fun x ->
      let new_variant_ptr =
        coerce_ptr C.variant_ptr.uninit (gc_alloc Variant.s ~count:1)
      in
      let () = to_variantizer new_variant_ptr (coerce_ptr typ x) in
      let inited_variant_ptr = coerce_ptr C.variant_ptr.plain new_variant_ptr in
      inited_variant_ptr

    let of_variant : C.variant_ptr structure ptr -> t structure ptr =
     fun x ->
      let new_type_ptr = gc_alloc s ~count:1 in
      let () = of_variantizer (coerce_ptr typ new_type_ptr) x in
      let inited_type_ptr = coerce_ptr (ptr s) new_type_ptr in
      inited_type_ptr
  end

  module type AABB = sig
    include Api_types.API_TYPE

    val to_variant : t structure ptr -> C.variant_ptr structure ptr
    val of_variant : C.variant_ptr structure ptr -> t structure ptr
  end

  module AABB = struct
    include AABB
    include Conv.AABB

    let to_variantizer = get_variant_from_type_constructor type_enum typ
    let of_variantizer = get_variant_to_type_constructor type_enum typ

    let to_variant : t structure ptr -> C.variant_ptr structure ptr =
     fun x ->
      let new_variant_ptr =
        coerce_ptr C.variant_ptr.uninit (gc_alloc Variant.s ~count:1)
      in
      let () = to_variantizer new_variant_ptr (coerce_ptr typ x) in
      let inited_variant_ptr = coerce_ptr C.variant_ptr.plain new_variant_ptr in
      inited_variant_ptr

    let of_variant : C.variant_ptr structure ptr -> t structure ptr =
     fun x ->
      let new_type_ptr = gc_alloc s ~count:1 in
      let () = of_variantizer (coerce_ptr typ new_type_ptr) x in
      let inited_type_ptr = coerce_ptr (ptr s) new_type_ptr in
      inited_type_ptr
  end

  module type BASIS = sig
    include Api_types.API_TYPE

    val to_variant : t structure ptr -> C.variant_ptr structure ptr
    val of_variant : C.variant_ptr structure ptr -> t structure ptr
  end

  module Basis = struct
    include Basis
    include Conv.Basis

    let to_variantizer = get_variant_from_type_constructor type_enum typ
    let of_variantizer = get_variant_to_type_constructor type_enum typ

    let to_variant : t structure ptr -> C.variant_ptr structure ptr =
     fun x ->
      let new_variant_ptr =
        coerce_ptr C.variant_ptr.uninit (gc_alloc Variant.s ~count:1)
      in
      let () = to_variantizer new_variant_ptr (coerce_ptr typ x) in
      let inited_variant_ptr = coerce_ptr C.variant_ptr.plain new_variant_ptr in
      inited_variant_ptr

    let of_variant : C.variant_ptr structure ptr -> t structure ptr =
     fun x ->
      let new_type_ptr = gc_alloc s ~count:1 in
      let () = of_variantizer (coerce_ptr typ new_type_ptr) x in
      let inited_type_ptr = coerce_ptr (ptr s) new_type_ptr in
      inited_type_ptr
  end

  module type TRANSFORM3D = sig
    include Api_types.API_TYPE

    val to_variant : t structure ptr -> C.variant_ptr structure ptr
    val of_variant : C.variant_ptr structure ptr -> t structure ptr
  end

  module Transform3D = struct
    include Transform3D
    include Conv.Transform3D

    let to_variantizer = get_variant_from_type_constructor type_enum typ
    let of_variantizer = get_variant_to_type_constructor type_enum typ

    let to_variant : t structure ptr -> C.variant_ptr structure ptr =
     fun x ->
      let new_variant_ptr =
        coerce_ptr C.variant_ptr.uninit (gc_alloc Variant.s ~count:1)
      in
      let () = to_variantizer new_variant_ptr (coerce_ptr typ x) in
      let inited_variant_ptr = coerce_ptr C.variant_ptr.plain new_variant_ptr in
      inited_variant_ptr

    let of_variant : C.variant_ptr structure ptr -> t structure ptr =
     fun x ->
      let new_type_ptr = gc_alloc s ~count:1 in
      let () = of_variantizer (coerce_ptr typ new_type_ptr) x in
      let inited_type_ptr = coerce_ptr (ptr s) new_type_ptr in
      inited_type_ptr
  end

  module type PROJECTION = sig
    include Api_types.API_TYPE

    val to_variant : t structure ptr -> C.variant_ptr structure ptr
    val of_variant : C.variant_ptr structure ptr -> t structure ptr
  end

  module Projection = struct
    include Projection
    include Conv.Projection

    let to_variantizer = get_variant_from_type_constructor type_enum typ
    let of_variantizer = get_variant_to_type_constructor type_enum typ

    let to_variant : t structure ptr -> C.variant_ptr structure ptr =
     fun x ->
      let new_variant_ptr =
        coerce_ptr C.variant_ptr.uninit (gc_alloc Variant.s ~count:1)
      in
      let () = to_variantizer new_variant_ptr (coerce_ptr typ x) in
      let inited_variant_ptr = coerce_ptr C.variant_ptr.plain new_variant_ptr in
      inited_variant_ptr

    let of_variant : C.variant_ptr structure ptr -> t structure ptr =
     fun x ->
      let new_type_ptr = gc_alloc s ~count:1 in
      let () = of_variantizer (coerce_ptr typ new_type_ptr) x in
      let inited_type_ptr = coerce_ptr (ptr s) new_type_ptr in
      inited_type_ptr
  end

  module type COLOR = sig
    include Api_types.API_TYPE

    val to_variant : t structure ptr -> C.variant_ptr structure ptr
    val of_variant : C.variant_ptr structure ptr -> t structure ptr
  end

  module Color = struct
    include Color
    include Conv.Color

    let to_variantizer = get_variant_from_type_constructor type_enum typ
    let of_variantizer = get_variant_to_type_constructor type_enum typ

    let to_variant : t structure ptr -> C.variant_ptr structure ptr =
     fun x ->
      let new_variant_ptr =
        coerce_ptr C.variant_ptr.uninit (gc_alloc Variant.s ~count:1)
      in
      let () = to_variantizer new_variant_ptr (coerce_ptr typ x) in
      let inited_variant_ptr = coerce_ptr C.variant_ptr.plain new_variant_ptr in
      inited_variant_ptr

    let of_variant : C.variant_ptr structure ptr -> t structure ptr =
     fun x ->
      let new_type_ptr = gc_alloc s ~count:1 in
      let () = of_variantizer (coerce_ptr typ new_type_ptr) x in
      let inited_type_ptr = coerce_ptr (ptr s) new_type_ptr in
      inited_type_ptr
  end

  module type STRINGNAME = sig
    include Api_types.API_TYPE

    val to_variant : t structure ptr -> C.variant_ptr structure ptr
    val of_variant : C.variant_ptr structure ptr -> t structure ptr
  end

  module StringName = struct
    include StringName
    include Conv.StringName

    let to_variantizer = get_variant_from_type_constructor type_enum typ
    let of_variantizer = get_variant_to_type_constructor type_enum typ

    let to_variant : t structure ptr -> C.variant_ptr structure ptr =
     fun x ->
      let new_variant_ptr =
        coerce_ptr C.variant_ptr.uninit (gc_alloc Variant.s ~count:1)
      in
      let () = to_variantizer new_variant_ptr (coerce_ptr typ x) in
      let inited_variant_ptr = coerce_ptr C.variant_ptr.plain new_variant_ptr in
      inited_variant_ptr

    let of_variant : C.variant_ptr structure ptr -> t structure ptr =
     fun x ->
      let new_type_ptr = gc_alloc s ~count:1 in
      let () = of_variantizer (coerce_ptr typ new_type_ptr) x in
      let inited_type_ptr = coerce_ptr (ptr s) new_type_ptr in
      inited_type_ptr
  end

  module type NODEPATH = sig
    include Api_types.API_TYPE

    val to_variant : t structure ptr -> C.variant_ptr structure ptr
    val of_variant : C.variant_ptr structure ptr -> t structure ptr
  end

  module NodePath = struct
    include NodePath
    include Conv.NodePath

    let to_variantizer = get_variant_from_type_constructor type_enum typ
    let of_variantizer = get_variant_to_type_constructor type_enum typ

    let to_variant : t structure ptr -> C.variant_ptr structure ptr =
     fun x ->
      let new_variant_ptr =
        coerce_ptr C.variant_ptr.uninit (gc_alloc Variant.s ~count:1)
      in
      let () = to_variantizer new_variant_ptr (coerce_ptr typ x) in
      let inited_variant_ptr = coerce_ptr C.variant_ptr.plain new_variant_ptr in
      inited_variant_ptr

    let of_variant : C.variant_ptr structure ptr -> t structure ptr =
     fun x ->
      let new_type_ptr = gc_alloc s ~count:1 in
      let () = of_variantizer (coerce_ptr typ new_type_ptr) x in
      let inited_type_ptr = coerce_ptr (ptr s) new_type_ptr in
      inited_type_ptr
  end

  module type RID = sig
    include Api_types.API_TYPE

    val to_variant : t structure ptr -> C.variant_ptr structure ptr
    val of_variant : C.variant_ptr structure ptr -> t structure ptr
  end

  module RID = struct
    include RID
    include Conv.RID

    let to_variantizer = get_variant_from_type_constructor type_enum typ
    let of_variantizer = get_variant_to_type_constructor type_enum typ

    let to_variant : t structure ptr -> C.variant_ptr structure ptr =
     fun x ->
      let new_variant_ptr =
        coerce_ptr C.variant_ptr.uninit (gc_alloc Variant.s ~count:1)
      in
      let () = to_variantizer new_variant_ptr (coerce_ptr typ x) in
      let inited_variant_ptr = coerce_ptr C.variant_ptr.plain new_variant_ptr in
      inited_variant_ptr

    let of_variant : C.variant_ptr structure ptr -> t structure ptr =
     fun x ->
      let new_type_ptr = gc_alloc s ~count:1 in
      let () = of_variantizer (coerce_ptr typ new_type_ptr) x in
      let inited_type_ptr = coerce_ptr (ptr s) new_type_ptr in
      inited_type_ptr
  end

  module type OBJECT = sig
    include Api_types.API_TYPE

    val to_variant : t structure ptr -> C.variant_ptr structure ptr
    val of_variant : C.variant_ptr structure ptr -> t structure ptr
  end

  module Object = struct
    include Object
    include Conv.Object

    let to_variantizer = get_variant_from_type_constructor type_enum typ
    let of_variantizer = get_variant_to_type_constructor type_enum typ

    let to_variant : t structure ptr -> C.variant_ptr structure ptr =
     fun x ->
      let new_variant_ptr =
        coerce_ptr C.variant_ptr.uninit (gc_alloc Variant.s ~count:1)
      in
      let () = to_variantizer new_variant_ptr (coerce_ptr typ x) in
      let inited_variant_ptr = coerce_ptr C.variant_ptr.plain new_variant_ptr in
      inited_variant_ptr

    let of_variant : C.variant_ptr structure ptr -> t structure ptr =
     fun x ->
      let new_type_ptr = gc_alloc s ~count:1 in
      let () = of_variantizer (coerce_ptr typ new_type_ptr) x in
      let inited_type_ptr = coerce_ptr (ptr s) new_type_ptr in
      inited_type_ptr
  end

  module type CALLABLE = sig
    include Api_types.API_TYPE

    val to_variant : t structure ptr -> C.variant_ptr structure ptr
    val of_variant : C.variant_ptr structure ptr -> t structure ptr
  end

  module Callable = struct
    include Callable
    include Conv.Callable

    let to_variantizer = get_variant_from_type_constructor type_enum typ
    let of_variantizer = get_variant_to_type_constructor type_enum typ

    let to_variant : t structure ptr -> C.variant_ptr structure ptr =
     fun x ->
      let new_variant_ptr =
        coerce_ptr C.variant_ptr.uninit (gc_alloc Variant.s ~count:1)
      in
      let () = to_variantizer new_variant_ptr (coerce_ptr typ x) in
      let inited_variant_ptr = coerce_ptr C.variant_ptr.plain new_variant_ptr in
      inited_variant_ptr

    let of_variant : C.variant_ptr structure ptr -> t structure ptr =
     fun x ->
      let new_type_ptr = gc_alloc s ~count:1 in
      let () = of_variantizer (coerce_ptr typ new_type_ptr) x in
      let inited_type_ptr = coerce_ptr (ptr s) new_type_ptr in
      inited_type_ptr
  end

  module type SIGNAL = sig
    include Api_types.API_TYPE

    val to_variant : t structure ptr -> C.variant_ptr structure ptr
    val of_variant : C.variant_ptr structure ptr -> t structure ptr
  end

  module Signal = struct
    include Signal
    include Conv.Signal

    let to_variantizer = get_variant_from_type_constructor type_enum typ
    let of_variantizer = get_variant_to_type_constructor type_enum typ

    let to_variant : t structure ptr -> C.variant_ptr structure ptr =
     fun x ->
      let new_variant_ptr =
        coerce_ptr C.variant_ptr.uninit (gc_alloc Variant.s ~count:1)
      in
      let () = to_variantizer new_variant_ptr (coerce_ptr typ x) in
      let inited_variant_ptr = coerce_ptr C.variant_ptr.plain new_variant_ptr in
      inited_variant_ptr

    let of_variant : C.variant_ptr structure ptr -> t structure ptr =
     fun x ->
      let new_type_ptr = gc_alloc s ~count:1 in
      let () = of_variantizer (coerce_ptr typ new_type_ptr) x in
      let inited_type_ptr = coerce_ptr (ptr s) new_type_ptr in
      inited_type_ptr
  end

  module type DICTIONARY = sig
    include Api_types.API_TYPE

    val to_variant : t structure ptr -> C.variant_ptr structure ptr
    val of_variant : C.variant_ptr structure ptr -> t structure ptr
  end

  module Dictionary = struct
    include Dictionary
    include Conv.Dictionary

    let to_variantizer = get_variant_from_type_constructor type_enum typ
    let of_variantizer = get_variant_to_type_constructor type_enum typ

    let to_variant : t structure ptr -> C.variant_ptr structure ptr =
     fun x ->
      let new_variant_ptr =
        coerce_ptr C.variant_ptr.uninit (gc_alloc Variant.s ~count:1)
      in
      let () = to_variantizer new_variant_ptr (coerce_ptr typ x) in
      let inited_variant_ptr = coerce_ptr C.variant_ptr.plain new_variant_ptr in
      inited_variant_ptr

    let of_variant : C.variant_ptr structure ptr -> t structure ptr =
     fun x ->
      let new_type_ptr = gc_alloc s ~count:1 in
      let () = of_variantizer (coerce_ptr typ new_type_ptr) x in
      let inited_type_ptr = coerce_ptr (ptr s) new_type_ptr in
      inited_type_ptr
  end

  module type ARRAY = sig
    include Api_types.API_TYPE

    val to_variant : t structure ptr -> C.variant_ptr structure ptr
    val of_variant : C.variant_ptr structure ptr -> t structure ptr
  end

  module Array = struct
    include Array
    include Conv.Array

    let to_variantizer = get_variant_from_type_constructor type_enum typ
    let of_variantizer = get_variant_to_type_constructor type_enum typ

    let to_variant : t structure ptr -> C.variant_ptr structure ptr =
     fun x ->
      let new_variant_ptr =
        coerce_ptr C.variant_ptr.uninit (gc_alloc Variant.s ~count:1)
      in
      let () = to_variantizer new_variant_ptr (coerce_ptr typ x) in
      let inited_variant_ptr = coerce_ptr C.variant_ptr.plain new_variant_ptr in
      inited_variant_ptr

    let of_variant : C.variant_ptr structure ptr -> t structure ptr =
     fun x ->
      let new_type_ptr = gc_alloc s ~count:1 in
      let () = of_variantizer (coerce_ptr typ new_type_ptr) x in
      let inited_type_ptr = coerce_ptr (ptr s) new_type_ptr in
      inited_type_ptr
  end

  module type PACKEDBYTEARRAY = sig
    include Api_types.API_TYPE

    val to_variant : t structure ptr -> C.variant_ptr structure ptr
    val of_variant : C.variant_ptr structure ptr -> t structure ptr
  end

  module PackedByteArray = struct
    include PackedByteArray
    include Conv.PackedByteArray

    let to_variantizer = get_variant_from_type_constructor type_enum typ
    let of_variantizer = get_variant_to_type_constructor type_enum typ

    let to_variant : t structure ptr -> C.variant_ptr structure ptr =
     fun x ->
      let new_variant_ptr =
        coerce_ptr C.variant_ptr.uninit (gc_alloc Variant.s ~count:1)
      in
      let () = to_variantizer new_variant_ptr (coerce_ptr typ x) in
      let inited_variant_ptr = coerce_ptr C.variant_ptr.plain new_variant_ptr in
      inited_variant_ptr

    let of_variant : C.variant_ptr structure ptr -> t structure ptr =
     fun x ->
      let new_type_ptr = gc_alloc s ~count:1 in
      let () = of_variantizer (coerce_ptr typ new_type_ptr) x in
      let inited_type_ptr = coerce_ptr (ptr s) new_type_ptr in
      inited_type_ptr
  end

  module type PACKEDINT32ARRAY = sig
    include Api_types.API_TYPE

    val to_variant : t structure ptr -> C.variant_ptr structure ptr
    val of_variant : C.variant_ptr structure ptr -> t structure ptr
  end

  module PackedInt32Array = struct
    include PackedInt32Array
    include Conv.PackedInt32Array

    let to_variantizer = get_variant_from_type_constructor type_enum typ
    let of_variantizer = get_variant_to_type_constructor type_enum typ

    let to_variant : t structure ptr -> C.variant_ptr structure ptr =
     fun x ->
      let new_variant_ptr =
        coerce_ptr C.variant_ptr.uninit (gc_alloc Variant.s ~count:1)
      in
      let () = to_variantizer new_variant_ptr (coerce_ptr typ x) in
      let inited_variant_ptr = coerce_ptr C.variant_ptr.plain new_variant_ptr in
      inited_variant_ptr

    let of_variant : C.variant_ptr structure ptr -> t structure ptr =
     fun x ->
      let new_type_ptr = gc_alloc s ~count:1 in
      let () = of_variantizer (coerce_ptr typ new_type_ptr) x in
      let inited_type_ptr = coerce_ptr (ptr s) new_type_ptr in
      inited_type_ptr
  end

  module type PACKEDINT64ARRAY = sig
    include Api_types.API_TYPE

    val to_variant : t structure ptr -> C.variant_ptr structure ptr
    val of_variant : C.variant_ptr structure ptr -> t structure ptr
  end

  module PackedInt64Array = struct
    include PackedInt64Array
    include Conv.PackedInt64Array

    let to_variantizer = get_variant_from_type_constructor type_enum typ
    let of_variantizer = get_variant_to_type_constructor type_enum typ

    let to_variant : t structure ptr -> C.variant_ptr structure ptr =
     fun x ->
      let new_variant_ptr =
        coerce_ptr C.variant_ptr.uninit (gc_alloc Variant.s ~count:1)
      in
      let () = to_variantizer new_variant_ptr (coerce_ptr typ x) in
      let inited_variant_ptr = coerce_ptr C.variant_ptr.plain new_variant_ptr in
      inited_variant_ptr

    let of_variant : C.variant_ptr structure ptr -> t structure ptr =
     fun x ->
      let new_type_ptr = gc_alloc s ~count:1 in
      let () = of_variantizer (coerce_ptr typ new_type_ptr) x in
      let inited_type_ptr = coerce_ptr (ptr s) new_type_ptr in
      inited_type_ptr
  end

  module type PACKEDFLOAT32ARRAY = sig
    include Api_types.API_TYPE

    val to_variant : t structure ptr -> C.variant_ptr structure ptr
    val of_variant : C.variant_ptr structure ptr -> t structure ptr
  end

  module PackedFloat32Array = struct
    include PackedFloat32Array
    include Conv.PackedFloat32Array

    let to_variantizer = get_variant_from_type_constructor type_enum typ
    let of_variantizer = get_variant_to_type_constructor type_enum typ

    let to_variant : t structure ptr -> C.variant_ptr structure ptr =
     fun x ->
      let new_variant_ptr =
        coerce_ptr C.variant_ptr.uninit (gc_alloc Variant.s ~count:1)
      in
      let () = to_variantizer new_variant_ptr (coerce_ptr typ x) in
      let inited_variant_ptr = coerce_ptr C.variant_ptr.plain new_variant_ptr in
      inited_variant_ptr

    let of_variant : C.variant_ptr structure ptr -> t structure ptr =
     fun x ->
      let new_type_ptr = gc_alloc s ~count:1 in
      let () = of_variantizer (coerce_ptr typ new_type_ptr) x in
      let inited_type_ptr = coerce_ptr (ptr s) new_type_ptr in
      inited_type_ptr
  end

  module type PACKEDFLOAT64ARRAY = sig
    include Api_types.API_TYPE

    val to_variant : t structure ptr -> C.variant_ptr structure ptr
    val of_variant : C.variant_ptr structure ptr -> t structure ptr
  end

  module PackedFloat64Array = struct
    include PackedFloat64Array
    include Conv.PackedFloat64Array

    let to_variantizer = get_variant_from_type_constructor type_enum typ
    let of_variantizer = get_variant_to_type_constructor type_enum typ

    let to_variant : t structure ptr -> C.variant_ptr structure ptr =
     fun x ->
      let new_variant_ptr =
        coerce_ptr C.variant_ptr.uninit (gc_alloc Variant.s ~count:1)
      in
      let () = to_variantizer new_variant_ptr (coerce_ptr typ x) in
      let inited_variant_ptr = coerce_ptr C.variant_ptr.plain new_variant_ptr in
      inited_variant_ptr

    let of_variant : C.variant_ptr structure ptr -> t structure ptr =
     fun x ->
      let new_type_ptr = gc_alloc s ~count:1 in
      let () = of_variantizer (coerce_ptr typ new_type_ptr) x in
      let inited_type_ptr = coerce_ptr (ptr s) new_type_ptr in
      inited_type_ptr
  end

  module type PACKEDSTRINGARRAY = sig
    include Api_types.API_TYPE

    val to_variant : t structure ptr -> C.variant_ptr structure ptr
    val of_variant : C.variant_ptr structure ptr -> t structure ptr
  end

  module PackedStringArray = struct
    include PackedStringArray
    include Conv.PackedStringArray

    let to_variantizer = get_variant_from_type_constructor type_enum typ
    let of_variantizer = get_variant_to_type_constructor type_enum typ

    let to_variant : t structure ptr -> C.variant_ptr structure ptr =
     fun x ->
      let new_variant_ptr =
        coerce_ptr C.variant_ptr.uninit (gc_alloc Variant.s ~count:1)
      in
      let () = to_variantizer new_variant_ptr (coerce_ptr typ x) in
      let inited_variant_ptr = coerce_ptr C.variant_ptr.plain new_variant_ptr in
      inited_variant_ptr

    let of_variant : C.variant_ptr structure ptr -> t structure ptr =
     fun x ->
      let new_type_ptr = gc_alloc s ~count:1 in
      let () = of_variantizer (coerce_ptr typ new_type_ptr) x in
      let inited_type_ptr = coerce_ptr (ptr s) new_type_ptr in
      inited_type_ptr
  end

  module type PACKEDVECTOR2ARRAY = sig
    include Api_types.API_TYPE

    val to_variant : t structure ptr -> C.variant_ptr structure ptr
    val of_variant : C.variant_ptr structure ptr -> t structure ptr
  end

  module PackedVector2Array = struct
    include PackedVector2Array
    include Conv.PackedVector2Array

    let to_variantizer = get_variant_from_type_constructor type_enum typ
    let of_variantizer = get_variant_to_type_constructor type_enum typ

    let to_variant : t structure ptr -> C.variant_ptr structure ptr =
     fun x ->
      let new_variant_ptr =
        coerce_ptr C.variant_ptr.uninit (gc_alloc Variant.s ~count:1)
      in
      let () = to_variantizer new_variant_ptr (coerce_ptr typ x) in
      let inited_variant_ptr = coerce_ptr C.variant_ptr.plain new_variant_ptr in
      inited_variant_ptr

    let of_variant : C.variant_ptr structure ptr -> t structure ptr =
     fun x ->
      let new_type_ptr = gc_alloc s ~count:1 in
      let () = of_variantizer (coerce_ptr typ new_type_ptr) x in
      let inited_type_ptr = coerce_ptr (ptr s) new_type_ptr in
      inited_type_ptr
  end

  module type PACKEDVECTOR3ARRAY = sig
    include Api_types.API_TYPE

    val to_variant : t structure ptr -> C.variant_ptr structure ptr
    val of_variant : C.variant_ptr structure ptr -> t structure ptr
  end

  module PackedVector3Array = struct
    include PackedVector3Array
    include Conv.PackedVector3Array

    let to_variantizer = get_variant_from_type_constructor type_enum typ
    let of_variantizer = get_variant_to_type_constructor type_enum typ

    let to_variant : t structure ptr -> C.variant_ptr structure ptr =
     fun x ->
      let new_variant_ptr =
        coerce_ptr C.variant_ptr.uninit (gc_alloc Variant.s ~count:1)
      in
      let () = to_variantizer new_variant_ptr (coerce_ptr typ x) in
      let inited_variant_ptr = coerce_ptr C.variant_ptr.plain new_variant_ptr in
      inited_variant_ptr

    let of_variant : C.variant_ptr structure ptr -> t structure ptr =
     fun x ->
      let new_type_ptr = gc_alloc s ~count:1 in
      let () = of_variantizer (coerce_ptr typ new_type_ptr) x in
      let inited_type_ptr = coerce_ptr (ptr s) new_type_ptr in
      inited_type_ptr
  end

  module type PACKEDCOLORARRAY = sig
    include Api_types.API_TYPE

    val to_variant : t structure ptr -> C.variant_ptr structure ptr
    val of_variant : C.variant_ptr structure ptr -> t structure ptr
  end

  module PackedColorArray = struct
    include PackedColorArray
    include Conv.PackedColorArray

    let to_variantizer = get_variant_from_type_constructor type_enum typ
    let of_variantizer = get_variant_to_type_constructor type_enum typ

    let to_variant : t structure ptr -> C.variant_ptr structure ptr =
     fun x ->
      let new_variant_ptr =
        coerce_ptr C.variant_ptr.uninit (gc_alloc Variant.s ~count:1)
      in
      let () = to_variantizer new_variant_ptr (coerce_ptr typ x) in
      let inited_variant_ptr = coerce_ptr C.variant_ptr.plain new_variant_ptr in
      inited_variant_ptr

    let of_variant : C.variant_ptr structure ptr -> t structure ptr =
     fun x ->
      let new_type_ptr = gc_alloc s ~count:1 in
      let () = of_variantizer (coerce_ptr typ new_type_ptr) x in
      let inited_type_ptr = coerce_ptr (ptr s) new_type_ptr in
      inited_type_ptr
  end

  module type VARIANT = sig
    include Api_types.SUB_API_TYPE

    val to_variant : t structure ptr -> C.variant_ptr structure ptr
    val of_variant : C.variant_ptr structure ptr -> t structure ptr
  end

  module Variant = struct
    include Variant

    let to_variant : t structure ptr -> C.variant_ptr structure ptr =
      coerce_ptr C.variant_ptr.plain

    let of_variant : C.variant_ptr structure ptr -> t structure ptr =
      coerce_ptr (ptr s)
  end
end

module GlobalEnum0 = struct
  module Side = struct
    let is_bitfield = false

    type t = int

    (** Left side, usually used for [Control] or [StyleBox]-derived classes. *)
    let _SIDE_LEFT = 0

    (** Top side, usually used for [Control] or [StyleBox]-derived classes. *)
    let _SIDE_TOP = 1

    (** Right side, usually used for [Control] or [StyleBox]-derived classes. *)
    let _SIDE_RIGHT = 2

    (** Bottom side, usually used for [Control] or [StyleBox]-derived classes. *)
    let _SIDE_BOTTOM = 3
  end

  module Corner = struct
    let is_bitfield = false

    type t = int

    (** Top-left corner. *)
    let _CORNER_TOP_LEFT = 0

    (** Top-right corner. *)
    let _CORNER_TOP_RIGHT = 1

    (** Bottom-right corner. *)
    let _CORNER_BOTTOM_RIGHT = 2

    (** Bottom-left corner. *)
    let _CORNER_BOTTOM_LEFT = 3
  end

  module Orientation = struct
    let is_bitfield = false

    type t = int

    (** General vertical alignment, usually used for [Separator], [ScrollBar], [Slider], etc. *)
    let _VERTICAL = 1

    (** General horizontal alignment, usually used for [Separator], [ScrollBar], [Slider], etc. *)
    let _HORIZONTAL = 0
  end

  module ClockDirection = struct
    let is_bitfield = false

    type t = int

    (** Clockwise rotation. Used by some methods (e.g. [method Image.rotate_90]). *)
    let _CLOCKWISE = 0

    (** Counter-clockwise rotation. Used by some methods (e.g. [method Image.rotate_90]). *)
    let _COUNTERCLOCKWISE = 1
  end

  module HorizontalAlignment = struct
    let is_bitfield = false

    type t = int

    (** Horizontal left alignment, usually for text-derived classes. *)
    let _HORIZONTAL_ALIGNMENT_LEFT = 0

    (** Horizontal center alignment, usually for text-derived classes. *)
    let _HORIZONTAL_ALIGNMENT_CENTER = 1

    (** Horizontal right alignment, usually for text-derived classes. *)
    let _HORIZONTAL_ALIGNMENT_RIGHT = 2

    (** Expand row to fit width, usually for text-derived classes. *)
    let _HORIZONTAL_ALIGNMENT_FILL = 3
  end

  module VerticalAlignment = struct
    let is_bitfield = false

    type t = int

    (** Vertical top alignment, usually for text-derived classes. *)
    let _VERTICAL_ALIGNMENT_TOP = 0

    (** Vertical center alignment, usually for text-derived classes. *)
    let _VERTICAL_ALIGNMENT_CENTER = 1

    (** Vertical bottom alignment, usually for text-derived classes. *)
    let _VERTICAL_ALIGNMENT_BOTTOM = 2

    (** Expand rows to fit height, usually for text-derived classes. *)
    let _VERTICAL_ALIGNMENT_FILL = 3
  end

  module InlineAlignment = struct
    let is_bitfield = false

    type t = int

    (** Aligns the top of the inline object (e.g. image, table) to the position of the text specified by [code]INLINE_ALIGNMENT_TO_ * [/code] constant. *)
    let _INLINE_ALIGNMENT_TOP_TO = 0

    (** Aligns the center of the inline object (e.g. image, table) to the position of the text specified by [code]INLINE_ALIGNMENT_TO_ * [/code] constant. *)
    let _INLINE_ALIGNMENT_CENTER_TO = 1

    (** Aligns the baseline (user defined) of the inline object (e.g. image, table) to the position of the text specified by [code]INLINE_ALIGNMENT_TO_ * [/code] constant. *)
    let _INLINE_ALIGNMENT_BASELINE_TO = 3

    (** Aligns the bottom of the inline object (e.g. image, table) to the position of the text specified by [code]INLINE_ALIGNMENT_TO_ * [/code] constant. *)
    let _INLINE_ALIGNMENT_BOTTOM_TO = 2

    (** Aligns the position of the inline object (e.g. image, table) specified by [code]INLINE_ALIGNMENT_ * _TO[/code] constant to the top of the text. *)
    let _INLINE_ALIGNMENT_TO_TOP = 0

    (** Aligns the position of the inline object (e.g. image, table) specified by [code]INLINE_ALIGNMENT_ * _TO[/code] constant to the center of the text. *)
    let _INLINE_ALIGNMENT_TO_CENTER = 4

    (** Aligns the position of the inline object (e.g. image, table) specified by [code]INLINE_ALIGNMENT_ * _TO[/code] constant to the baseline of the text. *)
    let _INLINE_ALIGNMENT_TO_BASELINE = 8

    (** Aligns inline object (e.g. image, table) to the bottom of the text. *)
    let _INLINE_ALIGNMENT_TO_BOTTOM = 12

    (** Aligns top of the inline object (e.g. image, table) to the top of the text. Equivalent to [code]INLINE_ALIGNMENT_TOP_TO | INLINE_ALIGNMENT_TO_TOP[/code]. *)
    let _INLINE_ALIGNMENT_TOP = 0

    (** Aligns center of the inline object (e.g. image, table) to the center of the text. Equivalent to [code]INLINE_ALIGNMENT_CENTER_TO | INLINE_ALIGNMENT_TO_CENTER[/code]. *)
    let _INLINE_ALIGNMENT_CENTER = 5

    (** Aligns bottom of the inline object (e.g. image, table) to the bottom of the text. Equivalent to [code]INLINE_ALIGNMENT_BOTTOM_TO | INLINE_ALIGNMENT_TO_BOTTOM[/code]. *)
    let _INLINE_ALIGNMENT_BOTTOM = 14

    (** A bit mask for [code]INLINE_ALIGNMENT_ * _TO[/code] alignment constants. *)
    let _INLINE_ALIGNMENT_IMAGE_MASK = 3

    (** A bit mask for [code]INLINE_ALIGNMENT_TO_ * [/code] alignment constants. *)
    let _INLINE_ALIGNMENT_TEXT_MASK = 12
  end

  module EulerOrder = struct
    let is_bitfield = false

    type t = int

    (** Specifies that Euler angles should be in XYZ order. When composing, the order is X, Y, Z. When decomposing, the order is reversed, first Z, then Y, and X last. *)
    let _EULER_ORDER_XYZ = 0

    (** Specifies that Euler angles should be in XZY order. When composing, the order is X, Z, Y. When decomposing, the order is reversed, first Y, then Z, and X last. *)
    let _EULER_ORDER_XZY = 1

    (** Specifies that Euler angles should be in YXZ order. When composing, the order is Y, X, Z. When decomposing, the order is reversed, first Z, then X, and Y last. *)
    let _EULER_ORDER_YXZ = 2

    (** Specifies that Euler angles should be in YZX order. When composing, the order is Y, Z, X. When decomposing, the order is reversed, first X, then Z, and Y last. *)
    let _EULER_ORDER_YZX = 3

    (** Specifies that Euler angles should be in ZXY order. When composing, the order is Z, X, Y. When decomposing, the order is reversed, first Y, then X, and Z last. *)
    let _EULER_ORDER_ZXY = 4

    (** Specifies that Euler angles should be in ZYX order. When composing, the order is Z, Y, X. When decomposing, the order is reversed, first X, then Y, and Z last. *)
    let _EULER_ORDER_ZYX = 5
  end

  module Key = struct
    let is_bitfield = false

    type t = int

    (** Enum value which doesn't correspond to any key. This is used to initialize [enum Key] properties with a generic state. *)
    let _KEY_NONE = 0

    (** Keycodes with this bit applied are non-printable. *)
    let _KEY_SPECIAL = 4194304

    (** Escape key. *)
    let _KEY_ESCAPE = 4194305

    (** Tab key. *)
    let _KEY_TAB = 4194306

    (** Shift + Tab key. *)
    let _KEY_BACKTAB = 4194307

    (** Backspace key. *)
    let _KEY_BACKSPACE = 4194308

    (** Return key (on the main keyboard). *)
    let _KEY_ENTER = 4194309

    (** Enter key on the numeric keypad. *)
    let _KEY_KP_ENTER = 4194310

    (** Insert key. *)
    let _KEY_INSERT = 4194311

    (** Delete key. *)
    let _KEY_DELETE = 4194312

    (** Pause key. *)
    let _KEY_PAUSE = 4194313

    (** Print Screen key. *)
    let _KEY_PRINT = 4194314

    (** System Request key. *)
    let _KEY_SYSREQ = 4194315

    (** Clear key. *)
    let _KEY_CLEAR = 4194316

    (** Home key. *)
    let _KEY_HOME = 4194317

    (** End key. *)
    let _KEY_END = 4194318

    (** Left arrow key. *)
    let _KEY_LEFT = 4194319

    (** Up arrow key. *)
    let _KEY_UP = 4194320

    (** Right arrow key. *)
    let _KEY_RIGHT = 4194321

    (** Down arrow key. *)
    let _KEY_DOWN = 4194322

    (** Page Up key. *)
    let _KEY_PAGEUP = 4194323

    (** Page Down key. *)
    let _KEY_PAGEDOWN = 4194324

    (** Shift key. *)
    let _KEY_SHIFT = 4194325

    (** Control key. *)
    let _KEY_CTRL = 4194326

    (** Meta key. *)
    let _KEY_META = 4194327

    (** Alt key. *)
    let _KEY_ALT = 4194328

    (** Caps Lock key. *)
    let _KEY_CAPSLOCK = 4194329

    (** Num Lock key. *)
    let _KEY_NUMLOCK = 4194330

    (** Scroll Lock key. *)
    let _KEY_SCROLLLOCK = 4194331

    (** F1 key. *)
    let _KEY_F1 = 4194332

    (** F2 key. *)
    let _KEY_F2 = 4194333

    (** F3 key. *)
    let _KEY_F3 = 4194334

    (** F4 key. *)
    let _KEY_F4 = 4194335

    (** F5 key. *)
    let _KEY_F5 = 4194336

    (** F6 key. *)
    let _KEY_F6 = 4194337

    (** F7 key. *)
    let _KEY_F7 = 4194338

    (** F8 key. *)
    let _KEY_F8 = 4194339

    (** F9 key. *)
    let _KEY_F9 = 4194340

    (** F10 key. *)
    let _KEY_F10 = 4194341

    (** F11 key. *)
    let _KEY_F11 = 4194342

    (** F12 key. *)
    let _KEY_F12 = 4194343

    (** F13 key. *)
    let _KEY_F13 = 4194344

    (** F14 key. *)
    let _KEY_F14 = 4194345

    (** F15 key. *)
    let _KEY_F15 = 4194346

    (** F16 key. *)
    let _KEY_F16 = 4194347

    (** F17 key. *)
    let _KEY_F17 = 4194348

    (** F18 key. *)
    let _KEY_F18 = 4194349

    (** F19 key. *)
    let _KEY_F19 = 4194350

    (** F20 key. *)
    let _KEY_F20 = 4194351

    (** F21 key. *)
    let _KEY_F21 = 4194352

    (** F22 key. *)
    let _KEY_F22 = 4194353

    (** F23 key. *)
    let _KEY_F23 = 4194354

    (** F24 key. *)
    let _KEY_F24 = 4194355

    (** F25 key. Only supported on macOS and Linux due to a Windows limitation. *)
    let _KEY_F25 = 4194356

    (** F26 key. Only supported on macOS and Linux due to a Windows limitation. *)
    let _KEY_F26 = 4194357

    (** F27 key. Only supported on macOS and Linux due to a Windows limitation. *)
    let _KEY_F27 = 4194358

    (** F28 key. Only supported on macOS and Linux due to a Windows limitation. *)
    let _KEY_F28 = 4194359

    (** F29 key. Only supported on macOS and Linux due to a Windows limitation. *)
    let _KEY_F29 = 4194360

    (** F30 key. Only supported on macOS and Linux due to a Windows limitation. *)
    let _KEY_F30 = 4194361

    (** F31 key. Only supported on macOS and Linux due to a Windows limitation. *)
    let _KEY_F31 = 4194362

    (** F32 key. Only supported on macOS and Linux due to a Windows limitation. *)
    let _KEY_F32 = 4194363

    (** F33 key. Only supported on macOS and Linux due to a Windows limitation. *)
    let _KEY_F33 = 4194364

    (** F34 key. Only supported on macOS and Linux due to a Windows limitation. *)
    let _KEY_F34 = 4194365

    (** F35 key. Only supported on macOS and Linux due to a Windows limitation. *)
    let _KEY_F35 = 4194366

    (** Multiply ( * ) key on the numeric keypad. *)
    let _KEY_KP_MULTIPLY = 4194433

    (** Divide (/) key on the numeric keypad. *)
    let _KEY_KP_DIVIDE = 4194434

    (** Subtract (-) key on the numeric keypad. *)
    let _KEY_KP_SUBTRACT = 4194435

    (** Period (.) key on the numeric keypad. *)
    let _KEY_KP_PERIOD = 4194436

    (** Add (+) key on the numeric keypad. *)
    let _KEY_KP_ADD = 4194437

    (** Number 0 on the numeric keypad. *)
    let _KEY_KP_0 = 4194438

    (** Number 1 on the numeric keypad. *)
    let _KEY_KP_1 = 4194439

    (** Number 2 on the numeric keypad. *)
    let _KEY_KP_2 = 4194440

    (** Number 3 on the numeric keypad. *)
    let _KEY_KP_3 = 4194441

    (** Number 4 on the numeric keypad. *)
    let _KEY_KP_4 = 4194442

    (** Number 5 on the numeric keypad. *)
    let _KEY_KP_5 = 4194443

    (** Number 6 on the numeric keypad. *)
    let _KEY_KP_6 = 4194444

    (** Number 7 on the numeric keypad. *)
    let _KEY_KP_7 = 4194445

    (** Number 8 on the numeric keypad. *)
    let _KEY_KP_8 = 4194446

    (** Number 9 on the numeric keypad. *)
    let _KEY_KP_9 = 4194447

    (** Context menu key. *)
    let _KEY_MENU = 4194370

    (** Hyper key. (On Linux/X11 only). *)
    let _KEY_HYPER = 4194371

    (** Help key. *)
    let _KEY_HELP = 4194373

    (** Media back key. Not to be confused with the Back button on an Android device. *)
    let _KEY_BACK = 4194376

    (** Media forward key. *)
    let _KEY_FORWARD = 4194377

    (** Media stop key. *)
    let _KEY_STOP = 4194378

    (** Media refresh key. *)
    let _KEY_REFRESH = 4194379

    (** Volume down key. *)
    let _KEY_VOLUMEDOWN = 4194380

    (** Mute volume key. *)
    let _KEY_VOLUMEMUTE = 4194381

    (** Volume up key. *)
    let _KEY_VOLUMEUP = 4194382

    (** Media play key. *)
    let _KEY_MEDIAPLAY = 4194388

    (** Media stop key. *)
    let _KEY_MEDIASTOP = 4194389

    (** Previous song key. *)
    let _KEY_MEDIAPREVIOUS = 4194390

    (** Next song key. *)
    let _KEY_MEDIANEXT = 4194391

    (** Media record key. *)
    let _KEY_MEDIARECORD = 4194392

    (** Home page key. *)
    let _KEY_HOMEPAGE = 4194393

    (** Favorites key. *)
    let _KEY_FAVORITES = 4194394

    (** Search key. *)
    let _KEY_SEARCH = 4194395

    (** Standby key. *)
    let _KEY_STANDBY = 4194396

    (** Open URL / Launch Browser key. *)
    let _KEY_OPENURL = 4194397

    (** Launch Mail key. *)
    let _KEY_LAUNCHMAIL = 4194398

    (** Launch Media key. *)
    let _KEY_LAUNCHMEDIA = 4194399

    (** Launch Shortcut 0 key. *)
    let _KEY_LAUNCH0 = 4194400

    (** Launch Shortcut 1 key. *)
    let _KEY_LAUNCH1 = 4194401

    (** Launch Shortcut 2 key. *)
    let _KEY_LAUNCH2 = 4194402

    (** Launch Shortcut 3 key. *)
    let _KEY_LAUNCH3 = 4194403

    (** Launch Shortcut 4 key. *)
    let _KEY_LAUNCH4 = 4194404

    (** Launch Shortcut 5 key. *)
    let _KEY_LAUNCH5 = 4194405

    (** Launch Shortcut 6 key. *)
    let _KEY_LAUNCH6 = 4194406

    (** Launch Shortcut 7 key. *)
    let _KEY_LAUNCH7 = 4194407

    (** Launch Shortcut 8 key. *)
    let _KEY_LAUNCH8 = 4194408

    (** Launch Shortcut 9 key. *)
    let _KEY_LAUNCH9 = 4194409

    (** Launch Shortcut A key. *)
    let _KEY_LAUNCHA = 4194410

    (** Launch Shortcut B key. *)
    let _KEY_LAUNCHB = 4194411

    (** Launch Shortcut C key. *)
    let _KEY_LAUNCHC = 4194412

    (** Launch Shortcut D key. *)
    let _KEY_LAUNCHD = 4194413

    (** Launch Shortcut E key. *)
    let _KEY_LAUNCHE = 4194414

    (** Launch Shortcut F key. *)
    let _KEY_LAUNCHF = 4194415

    (** ""Globe"" key on Mac / iPad keyboard. *)
    let _KEY_GLOBE = 4194416

    (** ""On-screen keyboard"" key on iPad keyboard. *)
    let _KEY_KEYBOARD = 4194417

    (** 英数 key on Mac keyboard. *)
    let _KEY_JIS_EISU = 4194418

    (** かな key on Mac keyboard. *)
    let _KEY_JIS_KANA = 4194419

    (** Unknown key. *)
    let _KEY_UNKNOWN = 8388607

    (** Space key. *)
    let _KEY_SPACE = 32

    (** ! key. *)
    let _KEY_EXCLAM = 33

    (** "" key. *)
    let _KEY_QUOTEDBL = 34

    (** # key. *)
    let _KEY_NUMBERSIGN = 35

    (** $ key. *)
    let _KEY_DOLLAR = 36

    (** % key. *)
    let _KEY_PERCENT = 37

    (** & key. *)
    let _KEY_AMPERSAND = 38

    (** ' key. *)
    let _KEY_APOSTROPHE = 39

    (** ( key. *)
    let _KEY_PARENLEFT = 40

    (** ) key. *)
    let _KEY_PARENRIGHT = 41

    (**  *  key. *)
    let _KEY_ASTERISK = 42

    (** + key. *)
    let _KEY_PLUS = 43

    (** , key. *)
    let _KEY_COMMA = 44

    (** - key. *)
    let _KEY_MINUS = 45

    (** . key. *)
    let _KEY_PERIOD = 46

    (** / key. *)
    let _KEY_SLASH = 47

    (** Number 0 key. *)
    let _KEY_0 = 48

    (** Number 1 key. *)
    let _KEY_1 = 49

    (** Number 2 key. *)
    let _KEY_2 = 50

    (** Number 3 key. *)
    let _KEY_3 = 51

    (** Number 4 key. *)
    let _KEY_4 = 52

    (** Number 5 key. *)
    let _KEY_5 = 53

    (** Number 6 key. *)
    let _KEY_6 = 54

    (** Number 7 key. *)
    let _KEY_7 = 55

    (** Number 8 key. *)
    let _KEY_8 = 56

    (** Number 9 key. *)
    let _KEY_9 = 57

    (** : key. *)
    let _KEY_COLON = 58

    (** ; key. *)
    let _KEY_SEMICOLON = 59

    (** < key. *)
    let _KEY_LESS = 60

    (** = key. *)
    let _KEY_EQUAL = 61

    (** > key. *)
    let _KEY_GREATER = 62

    (** ? key. *)
    let _KEY_QUESTION = 63

    (** @ key. *)
    let _KEY_AT = 64

    (** A key. *)
    let _KEY_A = 65

    (** B key. *)
    let _KEY_B = 66

    (** C key. *)
    let _KEY_C = 67

    (** D key. *)
    let _KEY_D = 68

    (** E key. *)
    let _KEY_E = 69

    (** F key. *)
    let _KEY_F = 70

    (** G key. *)
    let _KEY_G = 71

    (** H key. *)
    let _KEY_H = 72

    (** I key. *)
    let _KEY_I = 73

    (** J key. *)
    let _KEY_J = 74

    (** K key. *)
    let _KEY_K = 75

    (** L key. *)
    let _KEY_L = 76

    (** M key. *)
    let _KEY_M = 77

    (** N key. *)
    let _KEY_N = 78

    (** O key. *)
    let _KEY_O = 79

    (** P key. *)
    let _KEY_P = 80

    (** Q key. *)
    let _KEY_Q = 81

    (** R key. *)
    let _KEY_R = 82

    (** S key. *)
    let _KEY_S = 83

    (** T key. *)
    let _KEY_T = 84

    (** U key. *)
    let _KEY_U = 85

    (** V key. *)
    let _KEY_V = 86

    (** W key. *)
    let _KEY_W = 87

    (** X key. *)
    let _KEY_X = 88

    (** Y key. *)
    let _KEY_Y = 89

    (** Z key. *)
    let _KEY_Z = 90

    (** [ key. *)
    let _KEY_BRACKETLEFT = 91

    (** \ key. *)
    let _KEY_BACKSLASH = 92

    (** ] key. *)
    let _KEY_BRACKETRIGHT = 93

    (** ^ key. *)
    let _KEY_ASCIICIRCUM = 94

    (** _ key. *)
    let _KEY_UNDERSCORE = 95

    (** ` key. *)
    let _KEY_QUOTELEFT = 96

    (** { key. *)
    let _KEY_BRACELEFT = 123

    (** | key. *)
    let _KEY_BAR = 124

    (** } key. *)
    let _KEY_BRACERIGHT = 125

    (** ~ key. *)
    let _KEY_ASCIITILDE = 126

    (** ¥ key. *)
    let _KEY_YEN = 165

    (** § key. *)
    let _KEY_SECTION = 167
  end

  module KeyModifierMask = struct
    let is_bitfield = true

    type t = int

    (** Key Code mask. *)
    let _KEY_CODE_MASK = 8388607

    (** Modifier key mask. *)
    let _KEY_MODIFIER_MASK = 532676608

    (** Automatically remapped to [constant KEY_META] on macOS and [constant KEY_CTRL] on other platforms, this mask is never set in the actual events, and should be used for key mapping only. *)
    let _KEY_MASK_CMD_OR_CTRL = 16777216

    (** Shift key mask. *)
    let _KEY_MASK_SHIFT = 33554432

    (** Alt or Option (on macOS) key mask. *)
    let _KEY_MASK_ALT = 67108864

    (** Command (on macOS) or Meta/Windows key mask. *)
    let _KEY_MASK_META = 134217728

    (** Control key mask. *)
    let _KEY_MASK_CTRL = 268435456

    (** Keypad key mask. *)
    let _KEY_MASK_KPAD = 536870912

    (** Group Switch key mask. *)
    let _KEY_MASK_GROUP_SWITCH = 1073741824
  end

  module MouseButton = struct
    let is_bitfield = false

    type t = int

    (** Enum value which doesn't correspond to any mouse button. This is used to initialize [enum MouseButton] properties with a generic state. *)
    let _MOUSE_BUTTON_NONE = 0

    (** Primary mouse button, usually assigned to the left button. *)
    let _MOUSE_BUTTON_LEFT = 1

    (** Secondary mouse button, usually assigned to the right button. *)
    let _MOUSE_BUTTON_RIGHT = 2

    (** Middle mouse button. *)
    let _MOUSE_BUTTON_MIDDLE = 3

    (** Mouse wheel scrolling up. *)
    let _MOUSE_BUTTON_WHEEL_UP = 4

    (** Mouse wheel scrolling down. *)
    let _MOUSE_BUTTON_WHEEL_DOWN = 5

    (** Mouse wheel left button (only present on some mice). *)
    let _MOUSE_BUTTON_WHEEL_LEFT = 6

    (** Mouse wheel right button (only present on some mice). *)
    let _MOUSE_BUTTON_WHEEL_RIGHT = 7

    (** Extra mouse button 1. This is sometimes present, usually to the sides of the mouse. *)
    let _MOUSE_BUTTON_XBUTTON1 = 8

    (** Extra mouse button 2. This is sometimes present, usually to the sides of the mouse. *)
    let _MOUSE_BUTTON_XBUTTON2 = 9
  end

  module MouseButtonMask = struct
    let is_bitfield = true

    type t = int

    (** Primary mouse button mask, usually for the left button. *)
    let _MOUSE_BUTTON_MASK_LEFT = 1

    (** Secondary mouse button mask, usually for the right button. *)
    let _MOUSE_BUTTON_MASK_RIGHT = 2

    (** Middle mouse button mask. *)
    let _MOUSE_BUTTON_MASK_MIDDLE = 4

    (** Extra mouse button 1 mask. *)
    let _MOUSE_BUTTON_MASK_MB_XBUTTON1 = 128

    (** Extra mouse button 2 mask. *)
    let _MOUSE_BUTTON_MASK_MB_XBUTTON2 = 256
  end

  module JoyButton = struct
    let is_bitfield = false

    type t = int

    (** An invalid game controller button. *)
    let _JOY_BUTTON_INVALID = -1

    (** Game controller SDL button A. Corresponds to the bottom action button: Sony Cross, Xbox A, Nintendo B. *)
    let _JOY_BUTTON_A = 0

    (** Game controller SDL button B. Corresponds to the right action button: Sony Circle, Xbox B, Nintendo A. *)
    let _JOY_BUTTON_B = 1

    (** Game controller SDL button X. Corresponds to the left action button: Sony Square, Xbox X, Nintendo Y. *)
    let _JOY_BUTTON_X = 2

    (** Game controller SDL button Y. Corresponds to the top action button: Sony Triangle, Xbox Y, Nintendo X. *)
    let _JOY_BUTTON_Y = 3

    (** Game controller SDL back button. Corresponds to the Sony Select, Xbox Back, Nintendo - button. *)
    let _JOY_BUTTON_BACK = 4

    (** Game controller SDL guide button. Corresponds to the Sony PS, Xbox Home button. *)
    let _JOY_BUTTON_GUIDE = 5

    (** Game controller SDL start button. Corresponds to the Sony Options, Xbox Menu, Nintendo + button. *)
    let _JOY_BUTTON_START = 6

    (** Game controller SDL left stick button. Corresponds to the Sony L3, Xbox L/LS button. *)
    let _JOY_BUTTON_LEFT_STICK = 7

    (** Game controller SDL right stick button. Corresponds to the Sony R3, Xbox R/RS button. *)
    let _JOY_BUTTON_RIGHT_STICK = 8

    (** Game controller SDL left shoulder button. Corresponds to the Sony L1, Xbox LB button. *)
    let _JOY_BUTTON_LEFT_SHOULDER = 9

    (** Game controller SDL right shoulder button. Corresponds to the Sony R1, Xbox RB button. *)
    let _JOY_BUTTON_RIGHT_SHOULDER = 10

    (** Game controller D-pad up button. *)
    let _JOY_BUTTON_DPAD_UP = 11

    (** Game controller D-pad down button. *)
    let _JOY_BUTTON_DPAD_DOWN = 12

    (** Game controller D-pad left button. *)
    let _JOY_BUTTON_DPAD_LEFT = 13

    (** Game controller D-pad right button. *)
    let _JOY_BUTTON_DPAD_RIGHT = 14

    (** Game controller SDL miscellaneous button. Corresponds to Xbox share button, PS5 microphone button, Nintendo Switch capture button. *)
    let _JOY_BUTTON_MISC1 = 15

    (** Game controller SDL paddle 1 button. *)
    let _JOY_BUTTON_PADDLE1 = 16

    (** Game controller SDL paddle 2 button. *)
    let _JOY_BUTTON_PADDLE2 = 17

    (** Game controller SDL paddle 3 button. *)
    let _JOY_BUTTON_PADDLE3 = 18

    (** Game controller SDL paddle 4 button. *)
    let _JOY_BUTTON_PADDLE4 = 19

    (** Game controller SDL touchpad button. *)
    let _JOY_BUTTON_TOUCHPAD = 20

    (** The number of SDL game controller buttons. *)
    let _JOY_BUTTON_SDL_MAX = 21

    (** The maximum number of game controller buttons supported by the engine. The actual limit may be lower on specific platforms:
- [b]Android:[/b] Up to 36 buttons.
- [b]Linux:[/b] Up to 80 buttons.
- [b]Windows[/b] and [b]macOS:[/b] Up to 128 buttons. *)
    let _JOY_BUTTON_MAX = 128
  end

  module JoyAxis = struct
    let is_bitfield = false

    type t = int

    (** An invalid game controller axis. *)
    let _JOY_AXIS_INVALID = -1

    (** Game controller left joystick x-axis. *)
    let _JOY_AXIS_LEFT_X = 0

    (** Game controller left joystick y-axis. *)
    let _JOY_AXIS_LEFT_Y = 1

    (** Game controller right joystick x-axis. *)
    let _JOY_AXIS_RIGHT_X = 2

    (** Game controller right joystick y-axis. *)
    let _JOY_AXIS_RIGHT_Y = 3

    (** Game controller left trigger axis. *)
    let _JOY_AXIS_TRIGGER_LEFT = 4

    (** Game controller right trigger axis. *)
    let _JOY_AXIS_TRIGGER_RIGHT = 5

    (** The number of SDL game controller axes. *)
    let _JOY_AXIS_SDL_MAX = 6

    (** The maximum number of game controller axes: OpenVR supports up to 5 Joysticks making a total of 10 axes. *)
    let _JOY_AXIS_MAX = 10
  end

  module MIDIMessage = struct
    let is_bitfield = false

    type t = int

    (** Does not correspond to any MIDI message. This is the default value of [member InputEventMIDI.message]. *)
    let _MIDI_MESSAGE_NONE = 0

    (** MIDI message sent when a note is released.
[b]Note:[/b] Not all MIDI devices send this message; some may send [constant MIDI_MESSAGE_NOTE_ON] with [member InputEventMIDI.velocity] set to [code]0[/code]. *)
    let _MIDI_MESSAGE_NOTE_OFF = 8

    (** MIDI message sent when a note is pressed. *)
    let _MIDI_MESSAGE_NOTE_ON = 9

    (** MIDI message sent to indicate a change in pressure while a note is being pressed down, also called aftertouch. *)
    let _MIDI_MESSAGE_AFTERTOUCH = 10

    (** MIDI message sent when a controller value changes. In a MIDI device, a controller is any input that doesn't play notes. These may include sliders for volume, balance, and panning, as well as switches and pedals. See the [url=https://en.wikipedia.org/wiki/General_MIDI#Controller_events]General MIDI specification[/url] for a small list. *)
    let _MIDI_MESSAGE_CONTROL_CHANGE = 11

    (** MIDI message sent when the MIDI device changes its current instrument (also called [i]program[/i] or [i]preset[/i]). *)
    let _MIDI_MESSAGE_PROGRAM_CHANGE = 12

    (** MIDI message sent to indicate a change in pressure for the whole channel. Some MIDI devices may send this instead of [constant MIDI_MESSAGE_AFTERTOUCH]. *)
    let _MIDI_MESSAGE_CHANNEL_PRESSURE = 13

    (** MIDI message sent when the value of the pitch bender changes, usually a wheel on the MIDI device. *)
    let _MIDI_MESSAGE_PITCH_BEND = 14

    (** MIDI system exclusive (SysEx) message. This type of message is not standardized and it's highly dependent on the MIDI device sending it.
[b]Note:[/b] Getting this message's data from [InputEventMIDI] is not implemented. *)
    let _MIDI_MESSAGE_SYSTEM_EXCLUSIVE = 240

    (** MIDI message sent every quarter frame to keep connected MIDI devices synchronized. Related to [constant MIDI_MESSAGE_TIMING_CLOCK].
[b]Note:[/b] Getting this message's data from [InputEventMIDI] is not implemented. *)
    let _MIDI_MESSAGE_QUARTER_FRAME = 241

    (** MIDI message sent to jump onto a new position in the current sequence or song.
[b]Note:[/b] Getting this message's data from [InputEventMIDI] is not implemented. *)
    let _MIDI_MESSAGE_SONG_POSITION_POINTER = 242

    (** MIDI message sent to select a sequence or song to play.
[b]Note:[/b] Getting this message's data from [InputEventMIDI] is not implemented. *)
    let _MIDI_MESSAGE_SONG_SELECT = 243

    (** MIDI message sent to request a tuning calibration. Used on analog synthesizers. Most modern MIDI devices do not need this message. *)
    let _MIDI_MESSAGE_TUNE_REQUEST = 246

    (** MIDI message sent 24 times after [constant MIDI_MESSAGE_QUARTER_FRAME], to keep connected MIDI devices synchronized. *)
    let _MIDI_MESSAGE_TIMING_CLOCK = 248

    (** MIDI message sent to start the current sequence or song from the beginning. *)
    let _MIDI_MESSAGE_START = 250

    (** MIDI message sent to resume from the point the current sequence or song was paused. *)
    let _MIDI_MESSAGE_CONTINUE = 251

    (** MIDI message sent to pause the current sequence or song. *)
    let _MIDI_MESSAGE_STOP = 252

    (** MIDI message sent repeatedly while the MIDI device is idle, to tell the receiver that the connection is alive. Most MIDI devices do not send this message. *)
    let _MIDI_MESSAGE_ACTIVE_SENSING = 254

    (** MIDI message sent to reset a MIDI device to its default state, as if it was just turned on. It should not be sent when the MIDI device is being turned on. *)
    let _MIDI_MESSAGE_SYSTEM_RESET = 255
  end

  module Error = struct
    let is_bitfield = false

    type t = int

    (** Methods that return [enum Error] return [constant OK] when no error occurred.
Since [constant OK] has value 0, and all other error constants are positive integers, it can also be used in boolean checks.
[b]Example:[/b]
[codeblock]
var error = method_that_returns_error()
if error != OK:
    printerr(""Failure!"")

# Or, alternatively:
if error:
    printerr(""Still failing!"")
[/codeblock]
[b]Note:[/b] Many functions do not return an error code, but will print error messages to standard output. *)
    let _OK = 0

    (** Generic error. *)
    let _FAILED = 1

    (** Unavailable error. *)
    let _ERR_UNAVAILABLE = 2

    (** Unconfigured error. *)
    let _ERR_UNCONFIGURED = 3

    (** Unauthorized error. *)
    let _ERR_UNAUTHORIZED = 4

    (** Parameter range error. *)
    let _ERR_PARAMETER_RANGE_ERROR = 5

    (** Out of memory (OOM) error. *)
    let _ERR_OUT_OF_MEMORY = 6

    (** File: Not found error. *)
    let _ERR_FILE_NOT_FOUND = 7

    (** File: Bad drive error. *)
    let _ERR_FILE_BAD_DRIVE = 8

    (** File: Bad path error. *)
    let _ERR_FILE_BAD_PATH = 9

    (** File: No permission error. *)
    let _ERR_FILE_NO_PERMISSION = 10

    (** File: Already in use error. *)
    let _ERR_FILE_ALREADY_IN_USE = 11

    (** File: Can't open error. *)
    let _ERR_FILE_CANT_OPEN = 12

    (** File: Can't write error. *)
    let _ERR_FILE_CANT_WRITE = 13

    (** File: Can't read error. *)
    let _ERR_FILE_CANT_READ = 14

    (** File: Unrecognized error. *)
    let _ERR_FILE_UNRECOGNIZED = 15

    (** File: Corrupt error. *)
    let _ERR_FILE_CORRUPT = 16

    (** File: Missing dependencies error. *)
    let _ERR_FILE_MISSING_DEPENDENCIES = 17

    (** File: End of file (EOF) error. *)
    let _ERR_FILE_EOF = 18

    (** Can't open error. *)
    let _ERR_CANT_OPEN = 19

    (** Can't create error. *)
    let _ERR_CANT_CREATE = 20

    (** Query failed error. *)
    let _ERR_QUERY_FAILED = 21

    (** Already in use error. *)
    let _ERR_ALREADY_IN_USE = 22

    (** Locked error. *)
    let _ERR_LOCKED = 23

    (** Timeout error. *)
    let _ERR_TIMEOUT = 24

    (** Can't connect error. *)
    let _ERR_CANT_CONNECT = 25

    (** Can't resolve error. *)
    let _ERR_CANT_RESOLVE = 26

    (** Connection error. *)
    let _ERR_CONNECTION_ERROR = 27

    (** Can't acquire resource error. *)
    let _ERR_CANT_ACQUIRE_RESOURCE = 28

    (** Can't fork process error. *)
    let _ERR_CANT_FORK = 29

    (** Invalid data error. *)
    let _ERR_INVALID_DATA = 30

    (** Invalid parameter error. *)
    let _ERR_INVALID_PARAMETER = 31

    (** Already exists error. *)
    let _ERR_ALREADY_EXISTS = 32

    (** Does not exist error. *)
    let _ERR_DOES_NOT_EXIST = 33

    (** Database: Read error. *)
    let _ERR_DATABASE_CANT_READ = 34

    (** Database: Write error. *)
    let _ERR_DATABASE_CANT_WRITE = 35

    (** Compilation failed error. *)
    let _ERR_COMPILATION_FAILED = 36

    (** Method not found error. *)
    let _ERR_METHOD_NOT_FOUND = 37

    (** Linking failed error. *)
    let _ERR_LINK_FAILED = 38

    (** Script failed error. *)
    let _ERR_SCRIPT_FAILED = 39

    (** Cycling link (import cycle) error. *)
    let _ERR_CYCLIC_LINK = 40

    (** Invalid declaration error. *)
    let _ERR_INVALID_DECLARATION = 41

    (** Duplicate symbol error. *)
    let _ERR_DUPLICATE_SYMBOL = 42

    (** Parse error. *)
    let _ERR_PARSE_ERROR = 43

    (** Busy error. *)
    let _ERR_BUSY = 44

    (** Skip error. *)
    let _ERR_SKIP = 45

    (** Help error. Used internally when passing [code]--version[/code] or [code]--help[/code] as executable options. *)
    let _ERR_HELP = 46

    (** Bug error, caused by an implementation issue in the method.
[b]Note:[/b] If a built-in method returns this code, please open an issue on [url=https://github.com/godotengine/godot/issues]the GitHub Issue Tracker[/url]. *)
    let _ERR_BUG = 47

    (** Printer on fire error (This is an easter egg, no built-in methods return this error code). *)
    let _ERR_PRINTER_ON_FIRE = 48
  end

  module PropertyHint = struct
    let is_bitfield = false

    type t = int

    (** The property has no hint for the editor. *)
    let _PROPERTY_HINT_NONE = 0

    (** Hints that an [int] or [float] property should be within a range specified via the hint string [code]""min,max""[/code] or [code]""min,max,step""[/code]. The hint string can optionally include [code]""or_greater""[/code] and/or [code]""or_less""[/code] to allow manual input going respectively above the max or below the min values.
[b]Example:[/b] [code]""-360,360,1,or_greater,or_less""[/code].
Additionally, other keywords can be included: [code]""exp""[/code] for exponential range editing, [code]""radians_as_degrees""[/code] for editing radian angles in degrees (the range values are also in degrees), [code]""degrees""[/code] to hint at an angle and [code]""hide_slider""[/code] to hide the slider. *)
    let _PROPERTY_HINT_RANGE = 1

    (** Hints that an [int] or [String] property is an enumerated value to pick in a list specified via a hint string.
The hint string is a comma separated list of names such as [code]""Hello,Something,Else""[/code]. Whitespaces are [b]not[/b] removed from either end of a name. For integer properties, the first name in the list has value 0, the next 1, and so on. Explicit values can also be specified by appending [code]:integer[/code] to the name, e.g. [code]""Zero,One,Three:3,Four,Six:6""[/code]. *)
    let _PROPERTY_HINT_ENUM = 2

    (** Hints that a [String] property can be an enumerated value to pick in a list specified via a hint string such as [code]""Hello,Something,Else""[/code].
Unlike [constant PROPERTY_HINT_ENUM], a property with this hint still accepts arbitrary values and can be empty. The list of values serves to suggest possible values. *)
    let _PROPERTY_HINT_ENUM_SUGGESTION = 3

    (** Hints that a [float] property should be edited via an exponential easing function. The hint string can include [code]""attenuation""[/code] to flip the curve horizontally and/or [code]""positive_only""[/code] to exclude in/out easing and limit values to be greater than or equal to zero. *)
    let _PROPERTY_HINT_EXP_EASING = 4

    (** Hints that a vector property should allow its components to be linked. For example, this allows [member Vector2.x] and [member Vector2.y] to be edited together. *)
    let _PROPERTY_HINT_LINK = 5

    (** Hints that an [int] property is a bitmask with named bit flags.
The hint string is a comma separated list of names such as [code]""Bit0,Bit1,Bit2,Bit3""[/code]. Whitespaces are [b]not[/b] removed from either end of a name. The first name in the list has value 1, the next 2, then 4, 8, 16 and so on. Explicit values can also be specified by appending [code]:integer[/code] to the name, e.g. [code]""A:4,B:8,C:16""[/code]. You can also combine several flags ([code]""A:4,B:8,AB:12,C:16""[/code]).
[b]Note:[/b] A flag value must be at least [code]1[/code] and at most [code]2  *  *  32 - 1[/code].
[b]Note:[/b] Unlike [constant PROPERTY_HINT_ENUM], the previous explicit value is not taken into account. For the hint [code]""A:16,B,C""[/code], A is 16, B is 2, C is 4. *)
    let _PROPERTY_HINT_FLAGS = 6

    (** Hints that an [int] property is a bitmask using the optionally named 2D render layers. *)
    let _PROPERTY_HINT_LAYERS_2D_RENDER = 7

    (** Hints that an [int] property is a bitmask using the optionally named 2D physics layers. *)
    let _PROPERTY_HINT_LAYERS_2D_PHYSICS = 8

    (** Hints that an [int] property is a bitmask using the optionally named 2D navigation layers. *)
    let _PROPERTY_HINT_LAYERS_2D_NAVIGATION = 9

    (** Hints that an [int] property is a bitmask using the optionally named 3D render layers. *)
    let _PROPERTY_HINT_LAYERS_3D_RENDER = 10

    (** Hints that an [int] property is a bitmask using the optionally named 3D physics layers. *)
    let _PROPERTY_HINT_LAYERS_3D_PHYSICS = 11

    (** Hints that an [int] property is a bitmask using the optionally named 3D navigation layers. *)
    let _PROPERTY_HINT_LAYERS_3D_NAVIGATION = 12

    (** Hints that an integer property is a bitmask using the optionally named avoidance layers. *)
    let _PROPERTY_HINT_LAYERS_AVOIDANCE = 37

    (** Hints that a [String] property is a path to a file. Editing it will show a file dialog for picking the path. The hint string can be a set of filters with wildcards like [code]"" * .png, * .jpg""[/code]. *)
    let _PROPERTY_HINT_FILE = 13

    (** Hints that a [String] property is a path to a directory. Editing it will show a file dialog for picking the path. *)
    let _PROPERTY_HINT_DIR = 14

    (** Hints that a [String] property is an absolute path to a file outside the project folder. Editing it will show a file dialog for picking the path. The hint string can be a set of filters with wildcards, like [code]"" * .png, * .jpg""[/code]. *)
    let _PROPERTY_HINT_GLOBAL_FILE = 15

    (** Hints that a [String] property is an absolute path to a directory outside the project folder. Editing it will show a file dialog for picking the path. *)
    let _PROPERTY_HINT_GLOBAL_DIR = 16

    (** Hints that a property is an instance of a [Resource]-derived type, optionally specified via the hint string (e.g. [code]""Texture2D""[/code]). Editing it will show a popup menu of valid resource types to instantiate. *)
    let _PROPERTY_HINT_RESOURCE_TYPE = 17

    (** Hints that a [String] property is text with line breaks. Editing it will show a text input field where line breaks can be typed. *)
    let _PROPERTY_HINT_MULTILINE_TEXT = 18

    (** Hints that a [String] property is an [Expression]. *)
    let _PROPERTY_HINT_EXPRESSION = 19

    (** Hints that a [String] property should show a placeholder text on its input field, if empty. The hint string is the placeholder text to use. *)
    let _PROPERTY_HINT_PLACEHOLDER_TEXT = 20

    (** Hints that a [Color] property should be edited without affecting its transparency ([member Color.a] is not editable). *)
    let _PROPERTY_HINT_COLOR_NO_ALPHA = 21

    (** Hints that the property's value is an object encoded as object ID, with its type specified in the hint string. Used by the debugger. *)
    let _PROPERTY_HINT_OBJECT_ID = 22

    (** If a property is [String], hints that the property represents a particular type (class). This allows to select a type from the create dialog. The property will store the selected type as a string.
If a property is [Array], hints the editor how to show elements. The [code]hint_string[/code] must encode nested types using [code]"":""[/code] and [code]""/""[/code].
[codeblocks]
[gdscript]
# Array of elem_type.
hint_string = ""%d:"" % [elem_type]
hint_string = ""%d/%d:%s"" % [elem_type, elem_hint, elem_hint_string]
# Two-dimensional array of elem_type (array of arrays of elem_type).
hint_string = ""%d:%d:"" % [TYPE_ARRAY, elem_type]
hint_string = ""%d:%d/%d:%s"" % [TYPE_ARRAY, elem_type, elem_hint, elem_hint_string]
# Three-dimensional array of elem_type (array of arrays of arrays of elem_type).
hint_string = ""%d:%d:%d:"" % [TYPE_ARRAY, TYPE_ARRAY, elem_type]
hint_string = ""%d:%d:%d/%d:%s"" % [TYPE_ARRAY, TYPE_ARRAY, elem_type, elem_hint, elem_hint_string]
[/gdscript]
[csharp]
// Array of elemType.
hintString = $""{elemType:D}:"";
hintString = $""{elemType:}/{elemHint:D}:{elemHintString}"";
// Two-dimensional array of elemType (array of arrays of elemType).
hintString = $""{Variant.Type.Array:D}:{elemType:D}:"";
hintString = $""{Variant.Type.Array:D}:{elemType:D}/{elemHint:D}:{elemHintString}"";
// Three-dimensional array of elemType (array of arrays of arrays of elemType).
hintString = $""{Variant.Type.Array:D}:{Variant.Type.Array:D}:{elemType:D}:"";
hintString = $""{Variant.Type.Array:D}:{Variant.Type.Array:D}:{elemType:D}/{elemHint:D}:{elemHintString}"";
[/csharp]
[/codeblocks]
Examples:
[codeblocks]
[gdscript]
hint_string = ""%d:"" % [TYPE_INT] # Array of integers.
hint_string = ""%d/%d:1,10,1"" % [TYPE_INT, PROPERTY_HINT_RANGE] # Array of integers (in range from 1 to 10).
hint_string = ""%d/%d:Zero,One,Two"" % [TYPE_INT, PROPERTY_HINT_ENUM] # Array of integers (an enum).
hint_string = ""%d/%d:Zero,One,Three:3,Six:6"" % [TYPE_INT, PROPERTY_HINT_ENUM] # Array of integers (an enum).
hint_string = ""%d/%d: * .png"" % [TYPE_STRING, PROPERTY_HINT_FILE] # Array of strings (file paths).
hint_string = ""%d/%d:Texture2D"" % [TYPE_OBJECT, PROPERTY_HINT_RESOURCE_TYPE] # Array of textures.

hint_string = ""%d:%d:"" % [TYPE_ARRAY, TYPE_FLOAT] # Two-dimensional array of floats.
hint_string = ""%d:%d/%d:"" % [TYPE_ARRAY, TYPE_STRING, PROPERTY_HINT_MULTILINE_TEXT] # Two-dimensional array of multiline strings.
hint_string = ""%d:%d/%d:-1,1,0.1"" % [TYPE_ARRAY, TYPE_FLOAT, PROPERTY_HINT_RANGE] # Two-dimensional array of floats (in range from -1 to 1).
hint_string = ""%d:%d/%d:Texture2D"" % [TYPE_ARRAY, TYPE_OBJECT, PROPERTY_HINT_RESOURCE_TYPE] # Two-dimensional array of textures.
[/gdscript]
[csharp]
hintString = $""{Variant.Type.Int:D}/{PropertyHint.Range:D}:1,10,1""; // Array of integers (in range from 1 to 10).
hintString = $""{Variant.Type.Int:D}/{PropertyHint.Enum:D}:Zero,One,Two""; // Array of integers (an enum).
hintString = $""{Variant.Type.Int:D}/{PropertyHint.Enum:D}:Zero,One,Three:3,Six:6""; // Array of integers (an enum).
hintString = $""{Variant.Type.String:D}/{PropertyHint.File:D}: * .png""; // Array of strings (file paths).
hintString = $""{Variant.Type.Object:D}/{PropertyHint.ResourceType:D}:Texture2D""; // Array of textures.

hintString = $""{Variant.Type.Array:D}:{Variant.Type.Float:D}:""; // Two-dimensional array of floats.
hintString = $""{Variant.Type.Array:D}:{Variant.Type.String:D}/{PropertyHint.MultilineText:D}:""; // Two-dimensional array of multiline strings.
hintString = $""{Variant.Type.Array:D}:{Variant.Type.Float:D}/{PropertyHint.Range:D}:-1,1,0.1""; // Two-dimensional array of floats (in range from -1 to 1).
hintString = $""{Variant.Type.Array:D}:{Variant.Type.Object:D}/{PropertyHint.ResourceType:D}:Texture2D""; // Two-dimensional array of textures.
[/csharp]
[/codeblocks]
[b]Note:[/b] The trailing colon is required for properly detecting built-in types. *)
    let _PROPERTY_HINT_TYPE_STRING = 23

    (** [i]Deprecated.[/i] This hint is not used anywhere and will be removed in the future. *)
    let _PROPERTY_HINT_NODE_PATH_TO_EDITED_NODE = 24

    (** Hints that an object is too big to be sent via the debugger. *)
    let _PROPERTY_HINT_OBJECT_TOO_BIG = 25

    (** Hints that the hint string specifies valid node types for property of type [NodePath]. *)
    let _PROPERTY_HINT_NODE_PATH_VALID_TYPES = 26

    (** Hints that a [String] property is a path to a file. Editing it will show a file dialog for picking the path for the file to be saved at. The dialog has access to the project's directory. The hint string can be a set of filters with wildcards like [code]"" * .png, * .jpg""[/code]. See also [member FileDialog.filters]. *)
    let _PROPERTY_HINT_SAVE_FILE = 27

    (** Hints that a [String] property is a path to a file. Editing it will show a file dialog for picking the path for the file to be saved at. The dialog has access to the entire filesystem. The hint string can be a set of filters with wildcards like [code]"" * .png, * .jpg""[/code]. See also [member FileDialog.filters]. *)
    let _PROPERTY_HINT_GLOBAL_SAVE_FILE = 28

    (** Hints that an [int] property is an object ID.
[i]Deprecated.[/i] This hint is not used anywhere and will be removed in the future. *)
    let _PROPERTY_HINT_INT_IS_OBJECTID = 29

    (** Hints that an [int] property is a pointer. Used by GDExtension. *)
    let _PROPERTY_HINT_INT_IS_POINTER = 30

    (** Hints that a property is an [Array] with the stored type specified in the hint string. *)
    let _PROPERTY_HINT_ARRAY_TYPE = 31

    (** Hints that a string property is a locale code. Editing it will show a locale dialog for picking language and country. *)
    let _PROPERTY_HINT_LOCALE_ID = 32

    (** Hints that a dictionary property is string translation map. Dictionary keys are locale codes and, values are translated strings. *)
    let _PROPERTY_HINT_LOCALIZABLE_STRING = 33

    (** Hints that a property is an instance of a [Node]-derived type, optionally specified via the hint string (e.g. [code]""Node2D""[/code]). Editing it will show a dialog for picking a node from the scene. *)
    let _PROPERTY_HINT_NODE_TYPE = 34

    (** Hints that a quaternion property should disable the temporary euler editor. *)
    let _PROPERTY_HINT_HIDE_QUATERNION_EDIT = 35

    (** Hints that a string property is a password, and every character is replaced with the secret character. *)
    let _PROPERTY_HINT_PASSWORD = 36

    (** Represents the size of the [enum PropertyHint] enum. *)
    let _PROPERTY_HINT_MAX = 38
  end

  module PropertyUsageFlags = struct
    let is_bitfield = true

    type t = int

    (** The property is not stored, and does not display in the editor. This is the default for non-exported properties. *)
    let _PROPERTY_USAGE_NONE = 0

    (** The property is serialized and saved in the scene file (default). *)
    let _PROPERTY_USAGE_STORAGE = 2

    (** The property is shown in the [EditorInspector] (default). *)
    let _PROPERTY_USAGE_EDITOR = 4

    (** The property is excluded from the class reference. *)
    let _PROPERTY_USAGE_INTERNAL = 8

    (** The property can be checked in the [EditorInspector]. *)
    let _PROPERTY_USAGE_CHECKABLE = 16

    (** The property is checked in the [EditorInspector]. *)
    let _PROPERTY_USAGE_CHECKED = 32

    (** Used to group properties together in the editor. See [EditorInspector]. *)
    let _PROPERTY_USAGE_GROUP = 64

    (** Used to categorize properties together in the editor. *)
    let _PROPERTY_USAGE_CATEGORY = 128

    (** Used to group properties together in the editor in a subgroup (under a group). See [EditorInspector]. *)
    let _PROPERTY_USAGE_SUBGROUP = 256

    (** The property is a bitfield, i.e. it contains multiple flags represented as bits. *)
    let _PROPERTY_USAGE_CLASS_IS_BITFIELD = 512

    (** The property does not save its state in [PackedScene]. *)
    let _PROPERTY_USAGE_NO_INSTANCE_STATE = 1024

    (** Editing the property prompts the user for restarting the editor. *)
    let _PROPERTY_USAGE_RESTART_IF_CHANGED = 2048

    (** The property is a script variable which should be serialized and saved in the scene file. *)
    let _PROPERTY_USAGE_SCRIPT_VARIABLE = 4096

    (** The property value of type [Object] will be stored even if its value is [code]null[/code]. *)
    let _PROPERTY_USAGE_STORE_IF_NULL = 8192

    (** If this property is modified, all inspector fields will be refreshed. *)
    let _PROPERTY_USAGE_UPDATE_ALL_IF_MODIFIED = 16384

    (** Signifies a default value from a placeholder script instance.
[i]Deprecated.[/i] This hint is not used anywhere and will be removed in the future. *)
    let _PROPERTY_USAGE_SCRIPT_DEFAULT_VALUE = 32768

    (** The property is an enum, i.e. it only takes named integer constants from its associated enumeration. *)
    let _PROPERTY_USAGE_CLASS_IS_ENUM = 65536

    (** If property has [code]nil[/code] as default value, its type will be [Variant]. *)
    let _PROPERTY_USAGE_NIL_IS_VARIANT = 131072

    (** The property is an array. *)
    let _PROPERTY_USAGE_ARRAY = 262144

    (** When duplicating a resource with [method Resource.duplicate], and this flag is set on a property of that resource, the property should always be duplicated, regardless of the [code]subresources[/code] bool parameter. *)
    let _PROPERTY_USAGE_ALWAYS_DUPLICATE = 524288

    (** When duplicating a resource with [method Resource.duplicate], and this flag is set on a property of that resource, the property should never be duplicated, regardless of the [code]subresources[/code] bool parameter. *)
    let _PROPERTY_USAGE_NEVER_DUPLICATE = 1048576

    (** The property is only shown in the editor if modern renderers are supported (the Compatibility rendering method is excluded). *)
    let _PROPERTY_USAGE_HIGH_END_GFX = 2097152

    (** The [NodePath] property will always be relative to the scene's root. Mostly useful for local resources. *)
    let _PROPERTY_USAGE_NODE_PATH_FROM_SCENE_ROOT = 4194304

    (** Use when a resource is created on the fly, i.e. the getter will always return a different instance. [ResourceSaver] needs this information to properly save such resources. *)
    let _PROPERTY_USAGE_RESOURCE_NOT_PERSISTENT = 8388608

    (** Inserting an animation key frame of this property will automatically increment the value, allowing to easily keyframe multiple values in a row. *)
    let _PROPERTY_USAGE_KEYING_INCREMENTS = 16777216

    (** When loading, the resource for this property can be set at the end of loading.
[i]Deprecated.[/i] This hint is not used anywhere and will be removed in the future. *)
    let _PROPERTY_USAGE_DEFERRED_SET_RESOURCE = 33554432

    (** When this property is a [Resource] and base object is a [Node], a resource instance will be automatically created whenever the node is created in the editor. *)
    let _PROPERTY_USAGE_EDITOR_INSTANTIATE_OBJECT = 67108864

    (** The property is considered a basic setting and will appear even when advanced mode is disabled. Used for project settings. *)
    let _PROPERTY_USAGE_EDITOR_BASIC_SETTING = 134217728

    (** The property is read-only in the [EditorInspector]. *)
    let _PROPERTY_USAGE_READ_ONLY = 268435456

    (** An export preset property with this flag contains confidential information and is stored separately from the rest of the export preset configuration. *)
    let _PROPERTY_USAGE_SECRET = 536870912

    (** Default usage (storage and editor). *)
    let _PROPERTY_USAGE_DEFAULT = 6

    (** Default usage but without showing the property in the editor (storage). *)
    let _PROPERTY_USAGE_NO_EDITOR = 2
  end

  module MethodFlags = struct
    let is_bitfield = true

    type t = int

    (** Flag for a normal method. *)
    let _METHOD_FLAG_NORMAL = 1

    (** Flag for an editor method. *)
    let _METHOD_FLAG_EDITOR = 2

    (** Flag for a constant method. *)
    let _METHOD_FLAG_CONST = 4

    (** Flag for a virtual method. *)
    let _METHOD_FLAG_VIRTUAL = 8

    (** Flag for a method with a variable number of arguments. *)
    let _METHOD_FLAG_VARARG = 16

    (** Flag for a static method. *)
    let _METHOD_FLAG_STATIC = 32

    (** Used internally. Allows to not dump core virtual methods (such as [method Object._notification]) to the JSON API. *)
    let _METHOD_FLAG_OBJECT_CORE = 64

    (** Default method flags (normal). *)
    let _METHOD_FLAGS_DEFAULT = 1
  end

  module VariantType = struct
    let is_bitfield = false

    type t = int

    (** Variable is [code]null[/code]. *)
    let _TYPE_NIL = 0

    (** Variable is of type [bool]. *)
    let _TYPE_BOOL = 1

    (** Variable is of type [int]. *)
    let _TYPE_INT = 2

    (** Variable is of type [float]. *)
    let _TYPE_FLOAT = 3

    (** Variable is of type [String]. *)
    let _TYPE_STRING = 4

    (** Variable is of type [Vector2]. *)
    let _TYPE_VECTOR2 = 5

    (** Variable is of type [Vector2i]. *)
    let _TYPE_VECTOR2I = 6

    (** Variable is of type [Rect2]. *)
    let _TYPE_RECT2 = 7

    (** Variable is of type [Rect2i]. *)
    let _TYPE_RECT2I = 8

    (** Variable is of type [Vector3]. *)
    let _TYPE_VECTOR3 = 9

    (** Variable is of type [Vector3i]. *)
    let _TYPE_VECTOR3I = 10

    (** Variable is of type [Transform2D]. *)
    let _TYPE_TRANSFORM2D = 11

    (** Variable is of type [Vector4]. *)
    let _TYPE_VECTOR4 = 12

    (** Variable is of type [Vector4i]. *)
    let _TYPE_VECTOR4I = 13

    (** Variable is of type [Plane]. *)
    let _TYPE_PLANE = 14

    (** Variable is of type [Quaternion]. *)
    let _TYPE_QUATERNION = 15

    (** Variable is of type [AABB]. *)
    let _TYPE_AABB = 16

    (** Variable is of type [Basis]. *)
    let _TYPE_BASIS = 17

    (** Variable is of type [Transform3D]. *)
    let _TYPE_TRANSFORM3D = 18

    (** Variable is of type [Projection]. *)
    let _TYPE_PROJECTION = 19

    (** Variable is of type [Color]. *)
    let _TYPE_COLOR = 20

    (** Variable is of type [StringName]. *)
    let _TYPE_STRING_NAME = 21

    (** Variable is of type [NodePath]. *)
    let _TYPE_NODE_PATH = 22

    (** Variable is of type [RID]. *)
    let _TYPE_RID = 23

    (** Variable is of type [Object]. *)
    let _TYPE_OBJECT = 24

    (** Variable is of type [Callable]. *)
    let _TYPE_CALLABLE = 25

    (** Variable is of type [Signal]. *)
    let _TYPE_SIGNAL = 26

    (** Variable is of type [Dictionary]. *)
    let _TYPE_DICTIONARY = 27

    (** Variable is of type [Array]. *)
    let _TYPE_ARRAY = 28

    (** Variable is of type [PackedByteArray]. *)
    let _TYPE_PACKED_BYTE_ARRAY = 29

    (** Variable is of type [PackedInt32Array]. *)
    let _TYPE_PACKED_INT32_ARRAY = 30

    (** Variable is of type [PackedInt64Array]. *)
    let _TYPE_PACKED_INT64_ARRAY = 31

    (** Variable is of type [PackedFloat32Array]. *)
    let _TYPE_PACKED_FLOAT32_ARRAY = 32

    (** Variable is of type [PackedFloat64Array]. *)
    let _TYPE_PACKED_FLOAT64_ARRAY = 33

    (** Variable is of type [PackedStringArray]. *)
    let _TYPE_PACKED_STRING_ARRAY = 34

    (** Variable is of type [PackedVector2Array]. *)
    let _TYPE_PACKED_VECTOR2_ARRAY = 35

    (** Variable is of type [PackedVector3Array]. *)
    let _TYPE_PACKED_VECTOR3_ARRAY = 36

    (** Variable is of type [PackedColorArray]. *)
    let _TYPE_PACKED_COLOR_ARRAY = 37

    (** Represents the size of the [enum Variant.Type] enum. *)
    let _TYPE_MAX = 38
  end

  module VariantOperator = struct
    let is_bitfield = false

    type t = int

    (** Equality operator ([code]==[/code]). *)
    let _OP_EQUAL = 0

    (** Inequality operator ([code]!=[/code]). *)
    let _OP_NOT_EQUAL = 1

    (** Less than operator ([code]<[/code]). *)
    let _OP_LESS = 2

    (** Less than or equal operator ([code]<=[/code]). *)
    let _OP_LESS_EQUAL = 3

    (** Greater than operator ([code]>[/code]). *)
    let _OP_GREATER = 4

    (** Greater than or equal operator ([code]>=[/code]). *)
    let _OP_GREATER_EQUAL = 5

    (** Addition operator ([code]+[/code]). *)
    let _OP_ADD = 6

    (** Subtraction operator ([code]-[/code]). *)
    let _OP_SUBTRACT = 7

    (** Multiplication operator ([code] * [/code]). *)
    let _OP_MULTIPLY = 8

    (** Division operator ([code]/[/code]). *)
    let _OP_DIVIDE = 9

    (** Unary negation operator ([code]-[/code]). *)
    let _OP_NEGATE = 10

    (** Unary plus operator ([code]+[/code]). *)
    let _OP_POSITIVE = 11

    (** Remainder/modulo operator ([code]%[/code]). *)
    let _OP_MODULE = 12

    (** Power operator ([code] *  * [/code]). *)
    let _OP_POWER = 13

    (** Left shift operator ([code]<<[/code]). *)
    let _OP_SHIFT_LEFT = 14

    (** Right shift operator ([code]>>[/code]). *)
    let _OP_SHIFT_RIGHT = 15

    (** Bitwise AND operator ([code]&[/code]). *)
    let _OP_BIT_AND = 16

    (** Bitwise OR operator ([code]|[/code]). *)
    let _OP_BIT_OR = 17

    (** Bitwise XOR operator ([code]^[/code]). *)
    let _OP_BIT_XOR = 18

    (** Bitwise NOT operator ([code]~[/code]). *)
    let _OP_BIT_NEGATE = 19

    (** Logical AND operator ([code]and[/code] or [code]&&[/code]). *)
    let _OP_AND = 20

    (** Logical OR operator ([code]or[/code] or [code]||[/code]). *)
    let _OP_OR = 21

    (** Logical XOR operator (not implemented in GDScript). *)
    let _OP_XOR = 22

    (** Logical NOT operator ([code]not[/code] or [code]![/code]). *)
    let _OP_NOT = 23

    (** Logical IN operator ([code]in[/code]). *)
    let _OP_IN = 24

    (** Represents the size of the [enum Variant.Operator] enum. *)
    let _OP_MAX = 25
  end
end

module GlobalEnum = struct
  module Side = struct
    include GlobalEnum0.Side

    let to_ocaml = Conv.Int.to_ocaml
    let of_ocaml = Conv.Int.of_ocaml
    let to_variant = ApiTypes.Int.to_variant
    let of_variant = ApiTypes.Int.of_variant

    type t = ApiTypes.Int.t structure ptr

    let s = ApiTypes.Int.s
    let typ = ApiTypes.Int.typ
  end

  module Corner = struct
    include GlobalEnum0.Corner

    let to_ocaml = Conv.Int.to_ocaml
    let of_ocaml = Conv.Int.of_ocaml
    let to_variant = ApiTypes.Int.to_variant
    let of_variant = ApiTypes.Int.of_variant

    type t = ApiTypes.Int.t structure ptr

    let s = ApiTypes.Int.s
    let typ = ApiTypes.Int.typ
  end

  module Orientation = struct
    include GlobalEnum0.Orientation

    let to_ocaml = Conv.Int.to_ocaml
    let of_ocaml = Conv.Int.of_ocaml
    let to_variant = ApiTypes.Int.to_variant
    let of_variant = ApiTypes.Int.of_variant

    type t = ApiTypes.Int.t structure ptr

    let s = ApiTypes.Int.s
    let typ = ApiTypes.Int.typ
  end

  module ClockDirection = struct
    include GlobalEnum0.ClockDirection

    let to_ocaml = Conv.Int.to_ocaml
    let of_ocaml = Conv.Int.of_ocaml
    let to_variant = ApiTypes.Int.to_variant
    let of_variant = ApiTypes.Int.of_variant

    type t = ApiTypes.Int.t structure ptr

    let s = ApiTypes.Int.s
    let typ = ApiTypes.Int.typ
  end

  module HorizontalAlignment = struct
    include GlobalEnum0.HorizontalAlignment

    let to_ocaml = Conv.Int.to_ocaml
    let of_ocaml = Conv.Int.of_ocaml
    let to_variant = ApiTypes.Int.to_variant
    let of_variant = ApiTypes.Int.of_variant

    type t = ApiTypes.Int.t structure ptr

    let s = ApiTypes.Int.s
    let typ = ApiTypes.Int.typ
  end

  module VerticalAlignment = struct
    include GlobalEnum0.VerticalAlignment

    let to_ocaml = Conv.Int.to_ocaml
    let of_ocaml = Conv.Int.of_ocaml
    let to_variant = ApiTypes.Int.to_variant
    let of_variant = ApiTypes.Int.of_variant

    type t = ApiTypes.Int.t structure ptr

    let s = ApiTypes.Int.s
    let typ = ApiTypes.Int.typ
  end

  module InlineAlignment = struct
    include GlobalEnum0.InlineAlignment

    let to_ocaml = Conv.Int.to_ocaml
    let of_ocaml = Conv.Int.of_ocaml
    let to_variant = ApiTypes.Int.to_variant
    let of_variant = ApiTypes.Int.of_variant

    type t = ApiTypes.Int.t structure ptr

    let s = ApiTypes.Int.s
    let typ = ApiTypes.Int.typ
  end

  module EulerOrder = struct
    include GlobalEnum0.EulerOrder

    let to_ocaml = Conv.Int.to_ocaml
    let of_ocaml = Conv.Int.of_ocaml
    let to_variant = ApiTypes.Int.to_variant
    let of_variant = ApiTypes.Int.of_variant

    type t = ApiTypes.Int.t structure ptr

    let s = ApiTypes.Int.s
    let typ = ApiTypes.Int.typ
  end

  module Key = struct
    include GlobalEnum0.Key

    let to_ocaml = Conv.Int.to_ocaml
    let of_ocaml = Conv.Int.of_ocaml
    let to_variant = ApiTypes.Int.to_variant
    let of_variant = ApiTypes.Int.of_variant

    type t = ApiTypes.Int.t structure ptr

    let s = ApiTypes.Int.s
    let typ = ApiTypes.Int.typ
  end

  module KeyModifierMask = struct
    include GlobalEnum0.KeyModifierMask

    let to_ocaml = Conv.Int.to_ocaml
    let of_ocaml = Conv.Int.of_ocaml
    let to_variant = ApiTypes.Int.to_variant
    let of_variant = ApiTypes.Int.of_variant

    type t = ApiTypes.Int.t structure ptr

    let s = ApiTypes.Int.s
    let typ = ApiTypes.Int.typ
  end

  module MouseButton = struct
    include GlobalEnum0.MouseButton

    let to_ocaml = Conv.Int.to_ocaml
    let of_ocaml = Conv.Int.of_ocaml
    let to_variant = ApiTypes.Int.to_variant
    let of_variant = ApiTypes.Int.of_variant

    type t = ApiTypes.Int.t structure ptr

    let s = ApiTypes.Int.s
    let typ = ApiTypes.Int.typ
  end

  module MouseButtonMask = struct
    include GlobalEnum0.MouseButtonMask

    let to_ocaml = Conv.Int.to_ocaml
    let of_ocaml = Conv.Int.of_ocaml
    let to_variant = ApiTypes.Int.to_variant
    let of_variant = ApiTypes.Int.of_variant

    type t = ApiTypes.Int.t structure ptr

    let s = ApiTypes.Int.s
    let typ = ApiTypes.Int.typ
  end

  module JoyButton = struct
    include GlobalEnum0.JoyButton

    let to_ocaml = Conv.Int.to_ocaml
    let of_ocaml = Conv.Int.of_ocaml
    let to_variant = ApiTypes.Int.to_variant
    let of_variant = ApiTypes.Int.of_variant

    type t = ApiTypes.Int.t structure ptr

    let s = ApiTypes.Int.s
    let typ = ApiTypes.Int.typ
  end

  module JoyAxis = struct
    include GlobalEnum0.JoyAxis

    let to_ocaml = Conv.Int.to_ocaml
    let of_ocaml = Conv.Int.of_ocaml
    let to_variant = ApiTypes.Int.to_variant
    let of_variant = ApiTypes.Int.of_variant

    type t = ApiTypes.Int.t structure ptr

    let s = ApiTypes.Int.s
    let typ = ApiTypes.Int.typ
  end

  module MIDIMessage = struct
    include GlobalEnum0.MIDIMessage

    let to_ocaml = Conv.Int.to_ocaml
    let of_ocaml = Conv.Int.of_ocaml
    let to_variant = ApiTypes.Int.to_variant
    let of_variant = ApiTypes.Int.of_variant

    type t = ApiTypes.Int.t structure ptr

    let s = ApiTypes.Int.s
    let typ = ApiTypes.Int.typ
  end

  module Error = struct
    include GlobalEnum0.Error

    let to_ocaml = Conv.Int.to_ocaml
    let of_ocaml = Conv.Int.of_ocaml
    let to_variant = ApiTypes.Int.to_variant
    let of_variant = ApiTypes.Int.of_variant

    type t = ApiTypes.Int.t structure ptr

    let s = ApiTypes.Int.s
    let typ = ApiTypes.Int.typ
  end

  module PropertyHint = struct
    include GlobalEnum0.PropertyHint

    let to_ocaml = Conv.Int.to_ocaml
    let of_ocaml = Conv.Int.of_ocaml
    let to_variant = ApiTypes.Int.to_variant
    let of_variant = ApiTypes.Int.of_variant

    type t = ApiTypes.Int.t structure ptr

    let s = ApiTypes.Int.s
    let typ = ApiTypes.Int.typ
  end

  module PropertyUsageFlags = struct
    include GlobalEnum0.PropertyUsageFlags

    let to_ocaml = Conv.Int.to_ocaml
    let of_ocaml = Conv.Int.of_ocaml
    let to_variant = ApiTypes.Int.to_variant
    let of_variant = ApiTypes.Int.of_variant

    type t = ApiTypes.Int.t structure ptr

    let s = ApiTypes.Int.s
    let typ = ApiTypes.Int.typ
  end

  module MethodFlags = struct
    include GlobalEnum0.MethodFlags

    let to_ocaml = Conv.Int.to_ocaml
    let of_ocaml = Conv.Int.of_ocaml
    let to_variant = ApiTypes.Int.to_variant
    let of_variant = ApiTypes.Int.of_variant

    type t = ApiTypes.Int.t structure ptr

    let s = ApiTypes.Int.s
    let typ = ApiTypes.Int.typ
  end

  module VariantType = struct
    include GlobalEnum0.VariantType

    let to_ocaml = Conv.Int.to_ocaml
    let of_ocaml = Conv.Int.of_ocaml
    let to_variant = ApiTypes.Int.to_variant
    let of_variant = ApiTypes.Int.of_variant

    type t = ApiTypes.Int.t structure ptr

    let s = ApiTypes.Int.s
    let typ = ApiTypes.Int.typ
  end

  module VariantOperator = struct
    include GlobalEnum0.VariantOperator

    let to_ocaml = Conv.Int.to_ocaml
    let of_ocaml = Conv.Int.of_ocaml
    let to_variant = ApiTypes.Int.to_variant
    let of_variant = ApiTypes.Int.of_variant

    type t = ApiTypes.Int.t structure ptr

    let s = ApiTypes.Int.s
    let typ = ApiTypes.Int.typ
  end
end

module UtilityFunction = struct
  (** Returns the sine of angle [param angle_rad] in radians.
[codeblock]
sin(0.523599)       # Returns 0.5
sin(deg_to_rad(90)) # Returns 1.0
[/codeblock] *)
  let sin =
    foreign_utility_function1 "sin"
      (Base.Int64.of_string "2140049587")
      (Float.typ @-> returning Float.typ)
      Float.s

  (** Returns the cosine of angle [param angle_rad] in radians.
[codeblock]
cos(PI  *  2)         # Returns 1.0
cos(PI)             # Returns -1.0
cos(deg_to_rad(90)) # Returns 0.0
[/codeblock] *)
  let cos =
    foreign_utility_function1 "cos"
      (Base.Int64.of_string "2140049587")
      (Float.typ @-> returning Float.typ)
      Float.s

  (** Returns the tangent of angle [param angle_rad] in radians.
[codeblock]
tan(deg_to_rad(45)) # Returns 1
[/codeblock] *)
  let tan =
    foreign_utility_function1 "tan"
      (Base.Int64.of_string "2140049587")
      (Float.typ @-> returning Float.typ)
      Float.s

  (** Returns the hyperbolic sine of [param x].
[codeblock]
var a = log(2.0) # Returns 0.693147
sinh(a) # Returns 0.75
[/codeblock] *)
  let sinh =
    foreign_utility_function1 "sinh"
      (Base.Int64.of_string "2140049587")
      (Float.typ @-> returning Float.typ)
      Float.s

  (** Returns the hyperbolic cosine of [param x] in radians.
[codeblock]
print(cosh(1)) # Prints 1.543081
[/codeblock] *)
  let cosh =
    foreign_utility_function1 "cosh"
      (Base.Int64.of_string "2140049587")
      (Float.typ @-> returning Float.typ)
      Float.s

  (** Returns the hyperbolic tangent of [param x].
[codeblock]
var a = log(2.0) # Returns 0.693147
tanh(a)          # Returns 0.6
[/codeblock] *)
  let tanh =
    foreign_utility_function1 "tanh"
      (Base.Int64.of_string "2140049587")
      (Float.typ @-> returning Float.typ)
      Float.s

  (** Returns the arc sine of [param x] in radians. Use to get the angle of sine [param x]. [param x] will be clamped between [code]-1.0[/code] and [code]1.0[/code] (inclusive), in order to prevent [method asin] from returning [constant @GDScript.NAN].
[codeblock]
# s is 0.523599 or 30 degrees if converted with rad_to_deg(s)
var s = asin(0.5)
[/codeblock] *)
  let asin =
    foreign_utility_function1 "asin"
      (Base.Int64.of_string "2140049587")
      (Float.typ @-> returning Float.typ)
      Float.s

  (** Returns the arc cosine of [param x] in radians. Use to get the angle of cosine [param x]. [param x] will be clamped between [code]-1.0[/code] and [code]1.0[/code] (inclusive), in order to prevent [method acos] from returning [constant @GDScript.NAN].
[codeblock]
# c is 0.523599 or 30 degrees if converted with rad_to_deg(c)
var c = acos(0.866025)
[/codeblock] *)
  let acos =
    foreign_utility_function1 "acos"
      (Base.Int64.of_string "2140049587")
      (Float.typ @-> returning Float.typ)
      Float.s

  (** Returns the arc tangent of [param x] in radians. Use it to get the angle from an angle's tangent in trigonometry.
The method cannot know in which quadrant the angle should fall. See [method atan2] if you have both [code]y[/code] and [code skip-lint]x[/code].
[codeblock]
var a = atan(0.5) # a is 0.463648
[/codeblock]
If [param x] is between [code]-PI / 2[/code] and [code]PI / 2[/code] (inclusive), [code]atan(tan(x))[/code] is equal to [param x]. *)
  let atan =
    foreign_utility_function1 "atan"
      (Base.Int64.of_string "2140049587")
      (Float.typ @-> returning Float.typ)
      Float.s

  (** Returns the arc tangent of [code]y/x[/code] in radians. Use to get the angle of tangent [code]y/x[/code]. To compute the value, the method takes into account the sign of both arguments in order to determine the quadrant.
Important note: The Y coordinate comes first, by convention.
[codeblock]
var a = atan2(0, -1) # a is 3.141593
[/codeblock] *)
  let atan2 =
    foreign_utility_function2 "atan2"
      (Base.Int64.of_string "92296394")
      (Float.typ @-> Float.typ @-> returning Float.typ)
      Float.s

  (** Returns the hyperbolic arc (also called inverse) sine of [param x], returning a value in radians. Use it to get the angle from an angle's sine in hyperbolic space.
[codeblock]
var a = asinh(0.9) # Returns 0.8088669356527824
sinh(a) # Returns 0.9
[/codeblock] *)
  let asinh =
    foreign_utility_function1 "asinh"
      (Base.Int64.of_string "2140049587")
      (Float.typ @-> returning Float.typ)
      Float.s

  (** Returns the hyperbolic arc (also called inverse) cosine of [param x], returning a value in radians. Use it to get the angle from an angle's cosine in hyperbolic space if [param x] is larger or equal to 1. For values of [param x] lower than 1, it will return 0, in order to prevent [method acosh] from returning [constant @GDScript.NAN].
[codeblock]
var a = acosh(2) # Returns 1.31695789692482
cosh(a) # Returns 2

var b = acosh(-1) # Returns 0
[/codeblock] *)
  let acosh =
    foreign_utility_function1 "acosh"
      (Base.Int64.of_string "2140049587")
      (Float.typ @-> returning Float.typ)
      Float.s

  (** Returns the hyperbolic arc (also called inverse) tangent of [param x], returning a value in radians. Use it to get the angle from an angle's tangent in hyperbolic space if [param x] is between -1 and 1 (non-inclusive).
In mathematics, the inverse hyperbolic tangent is only defined for -1 < [param x] < 1 in the real set, so values equal or lower to -1 for [param x] return negative [constant @GDScript.INF] and values equal or higher than 1 return positive [constant @GDScript.INF] in order to prevent [method atanh] from returning [constant @GDScript.NAN].
[codeblock]
var a = atanh(0.9) # Returns 1.47221948958322
tanh(a) # Returns 0.9

var b = atanh(-2) # Returns -inf
tanh(b) # Returns -1
[/codeblock] *)
  let atanh =
    foreign_utility_function1 "atanh"
      (Base.Int64.of_string "2140049587")
      (Float.typ @-> returning Float.typ)
      Float.s

  (** Returns the square root of [param x], where [param x] is a non-negative number.
[codeblock]
sqrt(9)     # Returns 3
sqrt(10.24) # Returns 3.2
sqrt(-1)    # Returns NaN
[/codeblock]
[b]Note:[/b] Negative values of [param x] return NaN (""Not a Number""). in C#, if you need negative inputs, use [code]System.Numerics.Complex[/code]. *)
  let sqrt =
    foreign_utility_function1 "sqrt"
      (Base.Int64.of_string "2140049587")
      (Float.typ @-> returning Float.typ)
      Float.s

  (** Returns the floating-point remainder of [param x] divided by [param y], keeping the sign of [param x].
[codeblock]
var remainder = fmod(7, 5.5) # remainder is 1.5
[/codeblock]
For the integer remainder operation, use the [code]%[/code] operator. *)
  let fmod =
    foreign_utility_function2 "fmod"
      (Base.Int64.of_string "92296394")
      (Float.typ @-> Float.typ @-> returning Float.typ)
      Float.s

  (** Returns the floating-point modulus of [param x] divided by [param y], wrapping equally in positive and negative.
[codeblock]
print("" (x)  (fmod(x, 1.5))   (fposmod(x, 1.5))"")
for i in 7:
    var x = i  *  0.5 - 1.5
    print(""%4.1f           %4.1f  | %4.1f"" % [x, fmod(x, 1.5), fposmod(x, 1.5)])
[/codeblock]
Produces:
[codeblock]
 (x)  (fmod(x, 1.5))   (fposmod(x, 1.5))
-1.5           -0.0  |  0.0
-1.0           -1.0  |  0.5
-0.5           -0.5  |  1.0
 0.0            0.0  |  0.0
 0.5            0.5  |  0.5
 1.0            1.0  |  1.0
 1.5            0.0  |  0.0
[/codeblock] *)
  let fposmod =
    foreign_utility_function2 "fposmod"
      (Base.Int64.of_string "92296394")
      (Float.typ @-> Float.typ @-> returning Float.typ)
      Float.s

  (** Returns the integer modulus of [param x] divided by [param y] that wraps equally in positive and negative.
[codeblock]
print(""#(i)  (i % 3)   (posmod(i, 3))"")
for i in range(-3, 4):
    print(""%2d       %2d  | %2d"" % [i, i % 3, posmod(i, 3)])
[/codeblock]
Produces:
[codeblock]
(i)  (i % 3)   (posmod(i, 3))
-3        0  |  0
-2       -2  |  1
-1       -1  |  2
 0        0  |  0
 1        1  |  1
 2        2  |  2
 3        0  |  0
[/codeblock] *)
  let posmod =
    foreign_utility_function2 "posmod"
      (Base.Int64.of_string "3133453818")
      (Int.typ @-> Int.typ @-> returning Int.typ)
      Int.s

  (** Rounds [param x] downward (towards negative infinity), returning the largest whole number that is not more than [param x]. Supported types: [int], [float], [Vector2], [Vector2i], [Vector3], [Vector3i], [Vector4], [Vector4i].
[codeblock]
var a = floor(2.99) # a is 2.0
a = floor(-2.99)    # a is -3.0
[/codeblock]
See also [method ceil], [method round], and [method snapped].
[b]Note:[/b] For better type safety, use [method floorf], [method floori], [method Vector2.floor], [method Vector3.floor], or [method Vector4.floor]. *)
  let floor =
    foreign_utility_function1 "floor"
      (Base.Int64.of_string "4776452")
      (Variant.typ @-> returning Variant.typ)
      Variant.s

  (** Rounds [param x] downward (towards negative infinity), returning the largest whole number that is not more than [param x].
A type-safe version of [method floor], returning a [float]. *)
  let floorf =
    foreign_utility_function1 "floorf"
      (Base.Int64.of_string "2140049587")
      (Float.typ @-> returning Float.typ)
      Float.s

  (** Rounds [param x] downward (towards negative infinity), returning the largest whole number that is not more than [param x].
A type-safe version of [method floor], returning an [int].
[b]Note:[/b] This function is [i]not[/i] the same as [code]int(x)[/code], which rounds towards 0. *)
  let floori =
    foreign_utility_function1 "floori"
      (Base.Int64.of_string "2780425386")
      (Float.typ @-> returning Int.typ)
      Int.s

  (** Rounds [param x] upward (towards positive infinity), returning the smallest whole number that is not less than [param x]. Supported types: [int], [float], [Vector2], [Vector2i], [Vector3], [Vector3i], [Vector4], [Vector4i].
[codeblock]
var i = ceil(1.45) # i is 2.0
i = ceil(1.001)    # i is 2.0
[/codeblock]
See also [method floor], [method round], and [method snapped].
[b]Note:[/b] For better type safety, use [method ceilf], [method ceili], [method Vector2.ceil], [method Vector3.ceil], or [method Vector4.ceil]. *)
  let ceil =
    foreign_utility_function1 "ceil"
      (Base.Int64.of_string "4776452")
      (Variant.typ @-> returning Variant.typ)
      Variant.s

  (** Rounds [param x] upward (towards positive infinity), returning the smallest whole number that is not less than [param x].
A type-safe version of [method ceil], returning a [float]. *)
  let ceilf =
    foreign_utility_function1 "ceilf"
      (Base.Int64.of_string "2140049587")
      (Float.typ @-> returning Float.typ)
      Float.s

  (** Rounds [param x] upward (towards positive infinity), returning the smallest whole number that is not less than [param x].
A type-safe version of [method ceil], returning an [int]. *)
  let ceili =
    foreign_utility_function1 "ceili"
      (Base.Int64.of_string "2780425386")
      (Float.typ @-> returning Int.typ)
      Int.s

  (** Rounds [param x] to the nearest whole number, with halfway cases rounded away from 0. Supported types: [int], [float], [Vector2], [Vector2i], [Vector3], [Vector3i], [Vector4], [Vector4i].
[codeblock]
round(2.4) # Returns 2
round(2.5) # Returns 3
round(2.6) # Returns 3
[/codeblock]
See also [method floor], [method ceil], and [method snapped].
[b]Note:[/b] For better type safety, use [method roundf], [method roundi], [method Vector2.round], [method Vector3.round], or [method Vector4.round]. *)
  let round =
    foreign_utility_function1 "round"
      (Base.Int64.of_string "4776452")
      (Variant.typ @-> returning Variant.typ)
      Variant.s

  (** Rounds [param x] to the nearest whole number, with halfway cases rounded away from 0.
A type-safe version of [method round], returning a [float]. *)
  let roundf =
    foreign_utility_function1 "roundf"
      (Base.Int64.of_string "2140049587")
      (Float.typ @-> returning Float.typ)
      Float.s

  (** Rounds [param x] to the nearest whole number, with halfway cases rounded away from 0.
A type-safe version of [method round], returning an [int]. *)
  let roundi =
    foreign_utility_function1 "roundi"
      (Base.Int64.of_string "2780425386")
      (Float.typ @-> returning Int.typ)
      Int.s

  (** Returns the absolute value of a [Variant] parameter [param x] (i.e. non-negative value). Supported types: [int], [float], [Vector2], [Vector2i], [Vector3], [Vector3i], [Vector4], [Vector4i].
[codeblock]
var a = abs(-1)
# a is 1

var b = abs(-1.2)
# b is 1.2

var c = abs(Vector2(-3.5, -4))
# c is (3.5, 4)

var d = abs(Vector2i(-5, -6))
# d is (5, 6)

var e = abs(Vector3(-7, 8.5, -3.8))
# e is (7, 8.5, 3.8)

var f = abs(Vector3i(-7, -8, -9))
# f is (7, 8, 9)
[/codeblock]
[b]Note:[/b] For better type safety, use [method absf], [method absi], [method Vector2.abs], [method Vector2i.abs], [method Vector3.abs], [method Vector3i.abs], [method Vector4.abs], or [method Vector4i.abs]. *)
  let abs =
    foreign_utility_function1 "abs"
      (Base.Int64.of_string "4776452")
      (Variant.typ @-> returning Variant.typ)
      Variant.s

  (** Returns the absolute value of float parameter [param x] (i.e. positive value).
[codeblock]
# a is 1.2
var a = absf(-1.2)
[/codeblock] *)
  let absf =
    foreign_utility_function1 "absf"
      (Base.Int64.of_string "2140049587")
      (Float.typ @-> returning Float.typ)
      Float.s

  (** Returns the absolute value of int parameter [param x] (i.e. positive value).
[codeblock]
# a is 1
var a = absi(-1)
[/codeblock] *)
  let absi =
    foreign_utility_function1 "absi"
      (Base.Int64.of_string "2157319888")
      (Int.typ @-> returning Int.typ)
      Int.s

  (** Returns the same type of [Variant] as [param x], with [code]-1[/code] for negative values, [code]1[/code] for positive values, and [code]0[/code] for zeros. For [code]nan[/code] values it returns 0.
Supported types: [int], [float], [Vector2], [Vector2i], [Vector3], [Vector3i], [Vector4], [Vector4i].
[codeblock]
sign(-6.0) # Returns -1
sign(0.0)  # Returns 0
sign(6.0)  # Returns 1
sign(NAN)  # Returns 0

sign(Vector3(-6.0, 0.0, 6.0)) # Returns (-1, 0, 1)
[/codeblock]
[b]Note:[/b] For better type safety, use [method signf], [method signi], [method Vector2.sign], [method Vector2i.sign], [method Vector3.sign], [method Vector3i.sign], [method Vector4.sign], or [method Vector4i.sign]. *)
  let sign =
    foreign_utility_function1 "sign"
      (Base.Int64.of_string "4776452")
      (Variant.typ @-> returning Variant.typ)
      Variant.s

  (** Returns [code]-1.0[/code] if [param x] is negative, [code]1.0[/code] if [param x] is positive, and [code]0.0[/code] if [param x] is zero. For [code]nan[/code] values of [param x] it returns 0.0.
[codeblock]
signf(-6.5) # Returns -1.0
signf(0.0)  # Returns 0.0
signf(6.5)  # Returns 1.0
signf(NAN)  # Returns 0.0
[/codeblock] *)
  let signf =
    foreign_utility_function1 "signf"
      (Base.Int64.of_string "2140049587")
      (Float.typ @-> returning Float.typ)
      Float.s

  (** Returns [code]-1[/code] if [param x] is negative, [code]1[/code] if [param x] is positive, and [code]0[/code] if if [param x] is zero.
[codeblock]
signi(-6) # Returns -1
signi(0)  # Returns 0
signi(6)  # Returns 1
[/codeblock] *)
  let signi =
    foreign_utility_function1 "signi"
      (Base.Int64.of_string "2157319888")
      (Int.typ @-> returning Int.typ)
      Int.s

  (** Returns the multiple of [param step] that is the closest to [param x]. This can also be used to round a floating point number to an arbitrary number of decimals.
The returned value is the same type of [Variant] as [param step]. Supported types: [int], [float], [Vector2], [Vector2i], [Vector3], [Vector3i], [Vector4], [Vector4i].
[codeblock]
snapped(100, 32)  # Returns 96
snapped(3.14159, 0.01)  # Returns 3.14

snapped(Vector2(34, 70), Vector2(8, 8))  # Returns (32, 72)
[/codeblock]
See also [method ceil], [method floor], and [method round].
[b]Note:[/b] For better type safety, use [method snappedf], [method snappedi], [method Vector2.snapped], [method Vector2i.snapped], [method Vector3.snapped], [method Vector3i.snapped], [method Vector4.snapped], or [method Vector4i.snapped]. *)
  let snapped =
    foreign_utility_function2 "snapped"
      (Base.Int64.of_string "459914704")
      (Variant.typ @-> Variant.typ @-> returning Variant.typ)
      Variant.s

  (** Returns the multiple of [param step] that is the closest to [param x]. This can also be used to round a floating point number to an arbitrary number of decimals.
A type-safe version of [method snapped], returning a [float].
[codeblock]
snappedf(32.0, 2.5)  # Returns 32.5
snappedf(3.14159, 0.01)  # Returns 3.14
[/codeblock] *)
  let snappedf =
    foreign_utility_function2 "snappedf"
      (Base.Int64.of_string "92296394")
      (Float.typ @-> Float.typ @-> returning Float.typ)
      Float.s

  (** Returns the multiple of [param step] that is the closest to [param x].
A type-safe version of [method snapped], returning an [int].
[codeblock]
snappedi(53, 16)  # Returns 48
snappedi(4096, 100)  # Returns 4100
[/codeblock] *)
  let snappedi =
    foreign_utility_function2 "snappedi"
      (Base.Int64.of_string "3570758393")
      (Float.typ @-> Int.typ @-> returning Int.typ)
      Int.s

  (** Returns the result of [param base] raised to the power of [param exp].
In GDScript, this is the equivalent of the [code] *  * [/code] operator.
[codeblock]
pow(2, 5)   # Returns 32.0
pow(4, 1.5) # Returns 8.0
[/codeblock] *)
  let pow =
    foreign_utility_function2 "pow"
      (Base.Int64.of_string "92296394")
      (Float.typ @-> Float.typ @-> returning Float.typ)
      Float.s

  (** Returns the [url=https://en.wikipedia.org/wiki/Natural_logarithm]natural logarithm[/url] of [param x] (base [url=https://en.wikipedia.org/wiki/E_(mathematical_constant)][i]e[/i][/url], with [i]e[/i] being approximately 2.71828). This is the amount of time needed to reach a certain level of continuous growth.
[b]Note:[/b] This is not the same as the ""log"" function on most calculators, which uses a base 10 logarithm. To use base 10 logarithm, use [code]log(x) / log(10)[/code].
[codeblock]
log(10) # Returns 2.302585
[/codeblock]
[b]Note:[/b] The logarithm of [code]0[/code] returns [code]-inf[/code], while negative values return [code]-nan[/code]. *)
  let log =
    foreign_utility_function1 "log"
      (Base.Int64.of_string "2140049587")
      (Float.typ @-> returning Float.typ)
      Float.s

  (** The natural exponential function. It raises the mathematical constant [i]e[/i] to the power of [param x] and returns it.
[i]e[/i] has an approximate value of 2.71828, and can be obtained with [code]exp(1)[/code].
For exponents to other bases use the method [method pow].
[codeblock]
var a = exp(2) # Approximately 7.39
[/codeblock] *)
  let exp =
    foreign_utility_function1 "exp"
      (Base.Int64.of_string "2140049587")
      (Float.typ @-> returning Float.typ)
      Float.s

  (** Returns [code]true[/code] if [param x] is a NaN (""Not a Number"" or invalid) value. *)
  let is_nan =
    foreign_utility_function1 "is_nan"
      (Base.Int64.of_string "3569215213")
      (Float.typ @-> returning Bool.typ)
      Bool.s

  (** Returns [code]true[/code] if [param x] is either positive infinity or negative infinity. *)
  let is_inf =
    foreign_utility_function1 "is_inf"
      (Base.Int64.of_string "3569215213")
      (Float.typ @-> returning Bool.typ)
      Bool.s

  (** Returns [code]true[/code] if [param a] and [param b] are approximately equal to each other.
Here, ""approximately equal"" means that [param a] and [param b] are within a small internal epsilon of each other, which scales with the magnitude of the numbers.
Infinity values of the same sign are considered equal. *)
  let is_equal_approx =
    foreign_utility_function2 "is_equal_approx"
      (Base.Int64.of_string "1400789633")
      (Float.typ @-> Float.typ @-> returning Bool.typ)
      Bool.s

  (** Returns [code]true[/code] if [param x] is zero or almost zero. The comparison is done using a tolerance calculation with a small internal epsilon.
This function is faster than using [method is_equal_approx] with one value as zero. *)
  let is_zero_approx =
    foreign_utility_function1 "is_zero_approx"
      (Base.Int64.of_string "3569215213")
      (Float.typ @-> returning Bool.typ)
      Bool.s

  (** Returns whether [param x] is a finite value, i.e. it is not [constant @GDScript.NAN], positive infinity, or negative infinity. *)
  let is_finite =
    foreign_utility_function1 "is_finite"
      (Base.Int64.of_string "3569215213")
      (Float.typ @-> returning Bool.typ)
      Bool.s

  (** Returns an ""eased"" value of [param x] based on an easing function defined with [param curve]. This easing function is based on an exponent. The [param curve] can be any floating-point number, with specific values leading to the following behaviors:
[codeblock]
- Lower than -1.0 (exclusive): Ease in-out
- 1.0: Linear
- Between -1.0 and 0.0 (exclusive): Ease out-in
- 0.0: Constant
- Between 0.0 to 1.0 (exclusive): Ease out
- 1.0: Linear
- Greater than 1.0 (exclusive): Ease in
[/codeblock]
[url=https://raw.githubusercontent.com/godotengine/godot-docs/master/img/ease_cheatsheet.png]ease() curve values cheatsheet[/url]
See also [method smoothstep]. If you need to perform more advanced transitions, use [method Tween.interpolate_value]. *)
  let ease =
    foreign_utility_function2 "ease"
      (Base.Int64.of_string "92296394")
      (Float.typ @-> Float.typ @-> returning Float.typ)
      Float.s

  (** Returns the position of the first non-zero digit, after the decimal point. Note that the maximum return value is 10, which is a design decision in the implementation.
[codeblock]
var n = step_decimals(5)       # n is 0
n = step_decimals(1.0005)      # n is 4
n = step_decimals(0.000000005) # n is 9
[/codeblock] *)
  let step_decimals =
    foreign_utility_function1 "step_decimals"
      (Base.Int64.of_string "2780425386")
      (Float.typ @-> returning Int.typ)
      Int.s

  (** Linearly interpolates between two values by the factor defined in [param weight]. To perform interpolation, [param weight] should be between [code]0.0[/code] and [code]1.0[/code] (inclusive). However, values outside this range are allowed and can be used to perform [i]extrapolation[/i]. If this is not desired, use [method clamp] on the result of this function.
Both [param from] and [param to] must be the same type. Supported types: [int], [float], [Vector2], [Vector3], [Vector4], [Color], [Quaternion], [Basis].
[codeblock]
lerp(0, 4, 0.75) # Returns 3.0
[/codeblock]
See also [method inverse_lerp] which performs the reverse of this operation. To perform eased interpolation with [method lerp], combine it with [method ease] or [method smoothstep]. See also [method remap] to map a continuous series of values to another.
[b]Note:[/b] For better type safety, use [method lerpf], [method Vector2.lerp], [method Vector3.lerp], [method Vector4.lerp], [method Color.lerp], [method Quaternion.slerp] or [method Basis.slerp]. *)
  let lerp =
    foreign_utility_function3 "lerp"
      (Base.Int64.of_string "3389874542")
      (Variant.typ @-> Variant.typ @-> Variant.typ @-> returning Variant.typ)
      Variant.s

  (** Linearly interpolates between two values by the factor defined in [param weight]. To perform interpolation, [param weight] should be between [code]0.0[/code] and [code]1.0[/code] (inclusive). However, values outside this range are allowed and can be used to perform [i]extrapolation[/i]. If this is not desired, use [method clampf] on the result of this function.
[codeblock]
lerpf(0, 4, 0.75) # Returns 3.0
[/codeblock]
See also [method inverse_lerp] which performs the reverse of this operation. To perform eased interpolation with [method lerp], combine it with [method ease] or [method smoothstep]. *)
  let lerpf =
    foreign_utility_function3 "lerpf"
      (Base.Int64.of_string "998901048")
      (Float.typ @-> Float.typ @-> Float.typ @-> returning Float.typ)
      Float.s

  (** Cubic interpolates between two values by the factor defined in [param weight] with [param pre] and [param post] values. *)
  let cubic_interpolate =
    foreign_utility_function5 "cubic_interpolate"
      (Base.Int64.of_string "1090965791")
      (Float.typ @-> Float.typ @-> Float.typ @-> Float.typ @-> Float.typ
     @-> returning Float.typ)
      Float.s

  (** Cubic interpolates between two rotation values with shortest path by the factor defined in [param weight] with [param pre] and [param post] values. See also [method lerp_angle]. *)
  let cubic_interpolate_angle =
    foreign_utility_function5 "cubic_interpolate_angle"
      (Base.Int64.of_string "1090965791")
      (Float.typ @-> Float.typ @-> Float.typ @-> Float.typ @-> Float.typ
     @-> returning Float.typ)
      Float.s

  (** Cubic interpolates between two values by the factor defined in [param weight] with [param pre] and [param post] values.
It can perform smoother interpolation than [method cubic_interpolate] by the time values. *)
  let cubic_interpolate_in_time =
    foreign_utility_function8 "cubic_interpolate_in_time"
      (Base.Int64.of_string "388121036")
      (Float.typ @-> Float.typ @-> Float.typ @-> Float.typ @-> Float.typ
     @-> Float.typ @-> Float.typ @-> Float.typ @-> returning Float.typ)
      Float.s

  (** Cubic interpolates between two rotation values with shortest path by the factor defined in [param weight] with [param pre] and [param post] values. See also [method lerp_angle].
It can perform smoother interpolation than [method cubic_interpolate] by the time values. *)
  let cubic_interpolate_angle_in_time =
    foreign_utility_function8 "cubic_interpolate_angle_in_time"
      (Base.Int64.of_string "388121036")
      (Float.typ @-> Float.typ @-> Float.typ @-> Float.typ @-> Float.typ
     @-> Float.typ @-> Float.typ @-> Float.typ @-> returning Float.typ)
      Float.s

  (** Returns the point at the given [param t] on a one-dimensional [url=https://en.wikipedia.org/wiki/B%C3%A9zier_curve]Bézier curve[/url] defined by the given [param control_1], [param control_2], and [param end] points. *)
  let bezier_interpolate =
    foreign_utility_function5 "bezier_interpolate"
      (Base.Int64.of_string "1090965791")
      (Float.typ @-> Float.typ @-> Float.typ @-> Float.typ @-> Float.typ
     @-> returning Float.typ)
      Float.s

  (** Returns the derivative at the given [param t] on a one-dimensional [url=https://en.wikipedia.org/wiki/B%C3%A9zier_curve]Bézier curve[/url] defined by the given [param control_1], [param control_2], and [param end] points. *)
  let bezier_derivative =
    foreign_utility_function5 "bezier_derivative"
      (Base.Int64.of_string "1090965791")
      (Float.typ @-> Float.typ @-> Float.typ @-> Float.typ @-> Float.typ
     @-> returning Float.typ)
      Float.s

  (** Returns the difference between the two angles, in the range of [code][-PI, +PI][/code]. When [param from] and [param to] are opposite, returns [code]-PI[/code] if [param from] is smaller than [param to], or [code]PI[/code] otherwise. *)
  let angle_difference =
    foreign_utility_function2 "angle_difference"
      (Base.Int64.of_string "92296394")
      (Float.typ @-> Float.typ @-> returning Float.typ)
      Float.s

  (** Linearly interpolates between two angles (in radians) by a [param weight] value between 0.0 and 1.0.
Similar to [method lerp], but interpolates correctly when the angles wrap around [constant @GDScript.TAU]. To perform eased interpolation with [method lerp_angle], combine it with [method ease] or [method smoothstep].
[codeblock]
extends Sprite
var elapsed = 0.0
func _process(delta):
    var min_angle = deg_to_rad(0.0)
    var max_angle = deg_to_rad(90.0)
    rotation = lerp_angle(min_angle, max_angle, elapsed)
    elapsed += delta
[/codeblock]
[b]Note:[/b] This function lerps through the shortest path between [param from] and [param to]. However, when these two angles are approximately [code]PI + k  *  TAU[/code] apart for any integer [code]k[/code], it's not obvious which way they lerp due to floating-point precision errors. For example, [code]lerp_angle(0, PI, weight)[/code] lerps counter-clockwise, while [code]lerp_angle(0, PI + 5  *  TAU, weight)[/code] lerps clockwise. *)
  let lerp_angle =
    foreign_utility_function3 "lerp_angle"
      (Base.Int64.of_string "998901048")
      (Float.typ @-> Float.typ @-> Float.typ @-> returning Float.typ)
      Float.s

  (** Returns an interpolation or extrapolation factor considering the range specified in [param from] and [param to], and the interpolated value specified in [param weight]. The returned value will be between [code]0.0[/code] and [code]1.0[/code] if [param weight] is between [param from] and [param to] (inclusive). If [param weight] is located outside this range, then an extrapolation factor will be returned (return value lower than [code]0.0[/code] or greater than [code]1.0[/code]). Use [method clamp] on the result of [method inverse_lerp] if this is not desired.
[codeblock]
# The interpolation ratio in the `lerp()` call below is 0.75.
var middle = lerp(20, 30, 0.75)
# middle is now 27.5.

# Now, we pretend to have forgotten the original ratio and want to get it back.
var ratio = inverse_lerp(20, 30, 27.5)
# ratio is now 0.75.
[/codeblock]
See also [method lerp], which performs the reverse of this operation, and [method remap] to map a continuous series of values to another. *)
  let inverse_lerp =
    foreign_utility_function3 "inverse_lerp"
      (Base.Int64.of_string "998901048")
      (Float.typ @-> Float.typ @-> Float.typ @-> returning Float.typ)
      Float.s

  (** Maps a [param value] from range [code][istart, istop][/code] to [code][ostart, ostop][/code]. See also [method lerp] and [method inverse_lerp]. If [param value] is outside [code][istart, istop][/code], then the resulting value will also be outside [code][ostart, ostop][/code]. If this is not desired, use [method clamp] on the result of this function.
[codeblock]
remap(75, 0, 100, -1, 1) # Returns 0.5
[/codeblock]
For complex use cases where multiple ranges are needed, consider using [Curve] or [Gradient] instead. *)
  let remap =
    foreign_utility_function5 "remap"
      (Base.Int64.of_string "1090965791")
      (Float.typ @-> Float.typ @-> Float.typ @-> Float.typ @-> Float.typ
     @-> returning Float.typ)
      Float.s

  (** Returns the result of smoothly interpolating the value of [param x] between [code]0[/code] and [code]1[/code], based on the where [param x] lies with respect to the edges [param from] and [param to].
The return value is [code]0[/code] if [code]x <= from[/code], and [code]1[/code] if [code]x >= to[/code]. If [param x] lies between [param from] and [param to], the returned value follows an S-shaped curve that maps [param x] between [code]0[/code] and [code]1[/code].
This S-shaped curve is the cubic Hermite interpolator, given by [code]f(y) = 3 * y^2 - 2 * y^3[/code] where [code]y = (x-from) / (to-from)[/code].
[codeblock]
smoothstep(0, 2, -5.0) # Returns 0.0
smoothstep(0, 2, 0.5) # Returns 0.15625
smoothstep(0, 2, 1.0) # Returns 0.5
smoothstep(0, 2, 2.0) # Returns 1.0
[/codeblock]
Compared to [method ease] with a curve value of [code]-1.6521[/code], [method smoothstep] returns the smoothest possible curve with no sudden changes in the derivative. If you need to perform more advanced transitions, use [Tween] or [AnimationPlayer].
[url=https://raw.githubusercontent.com/godotengine/godot-docs/master/img/smoothstep_ease_comparison.png]Comparison between smoothstep() and ease(x, -1.6521) return values[/url] *)
  let smoothstep =
    foreign_utility_function3 "smoothstep"
      (Base.Int64.of_string "998901048")
      (Float.typ @-> Float.typ @-> Float.typ @-> returning Float.typ)
      Float.s

  (** Moves [param from] toward [param to] by the [param delta] amount. Will not go past [param to].
Use a negative [param delta] value to move away.
[codeblock]
move_toward(5, 10, 4)    # Returns 9
move_toward(10, 5, 4)    # Returns 6
move_toward(5, 10, 9)    # Returns 10
move_toward(10, 5, -1.5) # Returns 11.5
[/codeblock] *)
  let move_toward =
    foreign_utility_function3 "move_toward"
      (Base.Int64.of_string "998901048")
      (Float.typ @-> Float.typ @-> Float.typ @-> returning Float.typ)
      Float.s

  (** Rotates [param from] toward [param to] by the [param delta] amount. Will not go past [param to].
Similar to [method move_toward], but interpolates correctly when the angles wrap around [constant @GDScript.TAU].
If [param delta] is negative, this function will rotate away from [param to], toward the opposite angle, and will not go past the opposite angle. *)
  let rotate_toward =
    foreign_utility_function3 "rotate_toward"
      (Base.Int64.of_string "998901048")
      (Float.typ @-> Float.typ @-> Float.typ @-> returning Float.typ)
      Float.s

  (** Converts an angle expressed in degrees to radians.
[codeblock]
var r = deg_to_rad(180) # r is 3.141593
[/codeblock] *)
  let deg_to_rad =
    foreign_utility_function1 "deg_to_rad"
      (Base.Int64.of_string "2140049587")
      (Float.typ @-> returning Float.typ)
      Float.s

  (** Converts an angle expressed in radians to degrees.
[codeblock]
rad_to_deg(0.523599) # Returns 30
rad_to_deg(PI)       # Returns 180
rad_to_deg(PI  *  2)   # Returns 360
[/codeblock] *)
  let rad_to_deg =
    foreign_utility_function1 "rad_to_deg"
      (Base.Int64.of_string "2140049587")
      (Float.typ @-> returning Float.typ)
      Float.s

  (** Converts from linear energy to decibels (audio). This can be used to implement volume sliders that behave as expected (since volume isn't linear).
[b]Example:[/b]
[codeblock]
# ""Slider"" refers to a node that inherits Range such as HSlider or VSlider.
# Its range must be configured to go from 0 to 1.
# Change the bus name if you'd like to change the volume of a specific bus only.
AudioServer.set_bus_volume_db(AudioServer.get_bus_index(""Master""), linear_to_db($Slider.value))
[/codeblock] *)
  let linear_to_db =
    foreign_utility_function1 "linear_to_db"
      (Base.Int64.of_string "2140049587")
      (Float.typ @-> returning Float.typ)
      Float.s

  (** Converts from decibels to linear energy (audio). *)
  let db_to_linear =
    foreign_utility_function1 "db_to_linear"
      (Base.Int64.of_string "2140049587")
      (Float.typ @-> returning Float.typ)
      Float.s

  (** Wraps the [Variant] [param value] between [param min] and [param max]. Can be used for creating loop-alike behavior or infinite surfaces.
Variant types [int] and [float] are supported. If any of the arguments is [float] this function returns a [float], otherwise it returns an [int].
[codeblock]
var a = wrap(4, 5, 10)
# a is 9 (int)

var a = wrap(7, 5, 10)
# a is 7 (int)

var a = wrap(10.5, 5, 10)
# a is 5.5 (float)
[/codeblock] *)
  let wrap =
    foreign_utility_function3 "wrap"
      (Base.Int64.of_string "3389874542")
      (Variant.typ @-> Variant.typ @-> Variant.typ @-> returning Variant.typ)
      Variant.s

  (** Wraps the integer [param value] between [param min] and [param max]. Can be used for creating loop-alike behavior or infinite surfaces.
[codeblock]
# Infinite loop between 5 and 9
frame = wrapi(frame + 1, 5, 10)
[/codeblock]
[codeblock]
# result is -2
var result = wrapi(-6, -5, -1)
[/codeblock] *)
  let wrapi =
    foreign_utility_function3 "wrapi"
      (Base.Int64.of_string "650295447")
      (Int.typ @-> Int.typ @-> Int.typ @-> returning Int.typ)
      Int.s

  (** Wraps the float [param value] between [param min] and [param max]. Can be used for creating loop-alike behavior or infinite surfaces.
[codeblock]
# Infinite loop between 5.0 and 9.9
value = wrapf(value + 0.1, 5.0, 10.0)
[/codeblock]
[codeblock]
# Infinite rotation (in radians)
angle = wrapf(angle + 0.1, 0.0, TAU)
[/codeblock]
[codeblock]
# Infinite rotation (in radians)
angle = wrapf(angle + 0.1, -PI, PI)
[/codeblock]
[b]Note:[/b] If [param min] is [code]0[/code], this is equivalent to [method fposmod], so prefer using that instead.
[method wrapf] is more flexible than using the [method fposmod] approach by giving the user control over the minimum value. *)
  let wrapf =
    foreign_utility_function3 "wrapf"
      (Base.Int64.of_string "998901048")
      (Float.typ @-> Float.typ @-> Float.typ @-> returning Float.typ)
      Float.s

  (** Returns the maximum of the given numeric values. This function can take any number of arguments.
[codeblock]
max(1, 7, 3, -6, 5) # Returns 7
[/codeblock] *)
  let max =
    foreign_utility_function2 "max"
      (Base.Int64.of_string "3896050336")
      (Variant.typ @-> Variant.typ @-> returning Variant.typ)
      Variant.s

  (** Returns the maximum of two [int] values.
[codeblock]
maxi(1, 2)   # Returns 2
maxi(-3, -4) # Returns -3
[/codeblock] *)
  let maxi =
    foreign_utility_function2 "maxi"
      (Base.Int64.of_string "3133453818")
      (Int.typ @-> Int.typ @-> returning Int.typ)
      Int.s

  (** Returns the maximum of two [float] values.
[codeblock]
maxf(3.6, 24)   # Returns 24.0
maxf(-3.99, -4) # Returns -3.99
[/codeblock] *)
  let maxf =
    foreign_utility_function2 "maxf"
      (Base.Int64.of_string "92296394")
      (Float.typ @-> Float.typ @-> returning Float.typ)
      Float.s

  (** Returns the minimum of the given numeric values. This function can take any number of arguments.
[codeblock]
min(1, 7, 3, -6, 5) # Returns -6
[/codeblock] *)
  let min =
    foreign_utility_function2 "min"
      (Base.Int64.of_string "3896050336")
      (Variant.typ @-> Variant.typ @-> returning Variant.typ)
      Variant.s

  (** Returns the minimum of two [int] values.
[codeblock]
mini(1, 2)   # Returns 1
mini(-3, -4) # Returns -4
[/codeblock] *)
  let mini =
    foreign_utility_function2 "mini"
      (Base.Int64.of_string "3133453818")
      (Int.typ @-> Int.typ @-> returning Int.typ)
      Int.s

  (** Returns the minimum of two [float] values.
[codeblock]
minf(3.6, 24)   # Returns 3.6
minf(-3.99, -4) # Returns -4.0
[/codeblock] *)
  let minf =
    foreign_utility_function2 "minf"
      (Base.Int64.of_string "92296394")
      (Float.typ @-> Float.typ @-> returning Float.typ)
      Float.s

  (** Clamps the [param value], returning a [Variant] not less than [param min] and not more than [param max]. Any values that can be compared with the less than and greater than operators will work.
[codeblock]
var a = clamp(-10, -1, 5)
# a is -1

var b = clamp(8.1, 0.9, 5.5)
# b is 5.5
[/codeblock]
[b]Note:[/b] For better type safety, use [method clampf], [method clampi], [method Vector2.clamp], [method Vector2i.clamp], [method Vector3.clamp], [method Vector3i.clamp], [method Vector4.clamp], [method Vector4i.clamp], or [method Color.clamp] (not currently supported by this method).
[b]Note:[/b] When using this on vectors it will [i]not[/i] perform component-wise clamping, and will pick [param min] if [code]value < min[/code] or [param max] if [code]value > max[/code]. To perform component-wise clamping use the methods listed above. *)
  let clamp =
    foreign_utility_function3 "clamp"
      (Base.Int64.of_string "3389874542")
      (Variant.typ @-> Variant.typ @-> Variant.typ @-> returning Variant.typ)
      Variant.s

  (** Clamps the [param value], returning an [int] not less than [param min] and not more than [param max].
[codeblock]
var speed = 42
var a = clampi(speed, 1, 20) # a is 20

speed = -10
var b = clampi(speed, -1, 1) # b is -1
[/codeblock] *)
  let clampi =
    foreign_utility_function3 "clampi"
      (Base.Int64.of_string "650295447")
      (Int.typ @-> Int.typ @-> Int.typ @-> returning Int.typ)
      Int.s

  (** Clamps the [param value], returning a [float] not less than [param min] and not more than [param max].
[codeblock]
var speed = 42.1
var a = clampf(speed, 1.0, 20.5) # a is 20.5

speed = -10.0
var b = clampf(speed, -1.0, 1.0) # b is -1.0
[/codeblock] *)
  let clampf =
    foreign_utility_function3 "clampf"
      (Base.Int64.of_string "998901048")
      (Float.typ @-> Float.typ @-> Float.typ @-> returning Float.typ)
      Float.s

  (** Returns the smallest integer power of 2 that is greater than or equal to [param value].
[codeblock]
nearest_po2(3) # Returns 4
nearest_po2(4) # Returns 4
nearest_po2(5) # Returns 8

nearest_po2(0)  # Returns 0 (this may not be expected)
nearest_po2(-1) # Returns 0 (this may not be expected)
[/codeblock]
[b]Warning:[/b] Due to its implementation, this method returns [code]0[/code] rather than [code]1[/code] for values less than or equal to [code]0[/code], with an exception for [param value] being the smallest negative 64-bit integer ([code]-9223372036854775808[/code]) in which case the [param value] is returned unchanged. *)
  let nearest_po2 =
    foreign_utility_function1 "nearest_po2"
      (Base.Int64.of_string "2157319888")
      (Int.typ @-> returning Int.typ)
      Int.s

  (** Wraps [param value] between [code]0[/code] and the [param length]. If the limit is reached, the next value the function returns is decreased to the [code]0[/code] side or increased to the [param length] side (like a triangle wave). If [param length] is less than zero, it becomes positive.
[codeblock]
pingpong(-3.0, 3.0) # Returns 3.0
pingpong(-2.0, 3.0) # Returns 2.0
pingpong(-1.0, 3.0) # Returns 1.0
pingpong(0.0, 3.0)  # Returns 0.0
pingpong(1.0, 3.0)  # Returns 1.0
pingpong(2.0, 3.0)  # Returns 2.0
pingpong(3.0, 3.0)  # Returns 3.0
pingpong(4.0, 3.0)  # Returns 2.0
pingpong(5.0, 3.0)  # Returns 1.0
pingpong(6.0, 3.0)  # Returns 0.0
[/codeblock] *)
  let pingpong =
    foreign_utility_function2 "pingpong"
      (Base.Int64.of_string "92296394")
      (Float.typ @-> Float.typ @-> returning Float.typ)
      Float.s

  (** Randomizes the seed (or the internal state) of the random number generator. The current implementation uses a number based on the device's time.
[b]Note:[/b] This function is called automatically when the project is run. If you need to fix the seed to have consistent, reproducible results, use [method seed] to initialize the random number generator. *)
  let randomize = foreign_utility_function0

  (** Returns a random unsigned 32-bit integer. Use remainder to obtain a random value in the interval [code][0, N - 1][/code] (where N is smaller than 2^32).
[codeblocks]
[gdscript]
randi()           # Returns random integer between 0 and 2^32 - 1
randi() % 20      # Returns random integer between 0 and 19
randi() % 100     # Returns random integer between 0 and 99
randi() % 100 + 1 # Returns random integer between 1 and 100
[/gdscript]
[csharp]
GD.Randi();           // Returns random integer between 0 and 2^32 - 1
GD.Randi() % 20;      // Returns random integer between 0 and 19
GD.Randi() % 100;     // Returns random integer between 0 and 99
GD.Randi() % 100 + 1; // Returns random integer between 1 and 100
[/csharp]
[/codeblocks] *)
  let randi = foreign_utility_function0

  (** Returns a random floating point value between [code]0.0[/code] and [code]1.0[/code] (inclusive).
[codeblocks]
[gdscript]
randf() # Returns e.g. 0.375671
[/gdscript]
[csharp]
GD.Randf(); // Returns e.g. 0.375671
[/csharp]
[/codeblocks] *)
  let randf = foreign_utility_function0

  (** Returns a random signed 32-bit integer between [param from] and [param to] (inclusive). If [param to] is lesser than [param from], they are swapped.
[codeblocks]
[gdscript]
randi_range(0, 1)      # Returns either 0 or 1
randi_range(-10, 1000) # Returns random integer between -10 and 1000
[/gdscript]
[csharp]
GD.RandRange(0, 1);      // Returns either 0 or 1
GD.RandRange(-10, 1000); // Returns random integer between -10 and 1000
[/csharp]
[/codeblocks] *)
  let randi_range =
    foreign_utility_function2 "randi_range"
      (Base.Int64.of_string "3133453818")
      (Int.typ @-> Int.typ @-> returning Int.typ)
      Int.s

  (** Returns a random floating point value between [param from] and [param to] (inclusive).
[codeblocks]
[gdscript]
randf_range(0, 20.5) # Returns e.g. 7.45315
randf_range(-10, 10) # Returns e.g. -3.844535
[/gdscript]
[csharp]
GD.RandRange(0.0, 20.5);   // Returns e.g. 7.45315
GD.RandRange(-10.0, 10.0); // Returns e.g. -3.844535
[/csharp]
[/codeblocks] *)
  let randf_range =
    foreign_utility_function2 "randf_range"
      (Base.Int64.of_string "92296394")
      (Float.typ @-> Float.typ @-> returning Float.typ)
      Float.s

  (** Returns a normally-distributed pseudo-random floating point value using Box-Muller transform with the specified [param mean] and a standard [param deviation]. This is also called Gaussian distribution. *)
  let randfn =
    foreign_utility_function2 "randfn"
      (Base.Int64.of_string "92296394")
      (Float.typ @-> Float.typ @-> returning Float.typ)
      Float.s

  (** Sets the seed for the random number generator to [param base]. Setting the seed manually can ensure consistent, repeatable results for most random functions.
[codeblocks]
[gdscript]
var my_seed = ""Godot Rocks"".hash()
seed(my_seed)
var a = randf() + randi()
seed(my_seed)
var b = randf() + randi()
# a and b are now identical
[/gdscript]
[csharp]
ulong mySeed = (ulong)GD.Hash(""Godot Rocks"");
GD.Seed(mySeed);
var a = GD.Randf() + GD.Randi();
GD.Seed(mySeed);
var b = GD.Randf() + GD.Randi();
// a and b are now identical
[/csharp]
[/codeblocks] *)
  let seed =
    foreign_utility_function1_void "seed"
      (Base.Int64.of_string "382931173")
      (Int.typ @-> returning Void.typ)
      Void.s

  (** Given a [param seed], returns a [PackedInt64Array] of size [code]2[/code], where its first element is the randomized [int] value, and the second element is the same as [param seed]. Passing the same [param seed] consistently returns the same array.
[b]Note:[/b] ""Seed"" here refers to the internal state of the pseudo random number generator, currently implemented as a 64 bit integer.
[codeblock]
var a = rand_from_seed(4)

print(a[0])# Prints 2879024997
print(a[1])# Prints 4
[/codeblock] *)
  let rand_from_seed =
    foreign_utility_function1 "rand_from_seed"
      (Base.Int64.of_string "1391063685")
      (Int.typ @-> returning PackedInt64Array.typ)
      PackedInt64Array.s

  (** Returns a [WeakRef] instance holding a weak reference to [param obj]. Returns an empty [WeakRef] instance if [param obj] is [code]null[/code]. Prints an error and returns [code]null[/code] if [param obj] is neither [Object]-derived nor [code]null[/code].
A weak reference to an object is not enough to keep the object alive: when the only remaining references to a referent are weak references, garbage collection is free to destroy the referent and reuse its memory for something else. However, until the object is actually destroyed the weak reference may return the object even if there are no strong references to it. *)
  let weakref =
    foreign_utility_function1 "weakref"
      (Base.Int64.of_string "4776452")
      (Variant.typ @-> returning Variant.typ)
      Variant.s

  (** Returns the internal type of the given [param variable], using the [enum Variant.Type] values.
[codeblock]
var json = JSON.new()
json.parse('[""a"", ""b"", ""c""]')
var result = json.get_data()
if typeof(result) == TYPE_ARRAY:
    print(result[0]) # Prints a
else:
    print(""Unexpected result"")
[/codeblock]
See also [method type_string]. *)
  let typeof =
    foreign_utility_function1 "typeof"
      (Base.Int64.of_string "326422594")
      (Variant.typ @-> returning Int.typ)
      Int.s

  (** Converts the given [param variant] to the given [param type], using the [enum Variant.Type] values. This method is generous with how it handles types, it can automatically convert between array types, convert numeric [String]s to [int], and converting most things to [String].
If the type conversion cannot be done, this method will return the default value for that type, for example converting [Rect2] to [Vector2] will always return [constant Vector2.ZERO]. This method will never show error messages as long as [param type] is a valid Variant type.
The returned value is a [Variant], but the data inside and the [enum Variant.Type] will be the same as the requested type.
[codeblock]
type_convert(""Hi!"", TYPE_INT) # Returns 0
type_convert(""123"", TYPE_INT) # Returns 123
type_convert(123.4, TYPE_INT) # Returns 123
type_convert(5, TYPE_VECTOR2) # Returns (0, 0)
type_convert(""Hi!"", TYPE_NIL) # Returns null
[/codeblock] *)
  let type_convert =
    foreign_utility_function2 "type_convert"
      (Base.Int64.of_string "2453062746")
      (Variant.typ @-> Int.typ @-> returning Variant.typ)
      Variant.s

  (** Converts one or more arguments of any [Variant] type to a [String] in the best way possible.
[codeblock]
var a = [10, 20, 30]
var b = str(a)
print(len(a)) # Prints 3 (the number of elements in the array).
print(len(b)) # Prints 12 (the length of the string ""[10, 20, 30]"").
[/codeblock] *)
  let str =
    foreign_utility_function1 "str"
      (Base.Int64.of_string "32569176")
      (Variant.typ @-> returning String.typ)
      String.s

  (** Returns a human-readable name for the given [enum Error] code.
[codeblock]
print(OK)                              # Prints 0
print(error_string(OK))                # Prints OK
print(error_string(ERR_BUSY))          # Prints Busy
print(error_string(ERR_OUT_OF_MEMORY)) # Prints Out of memory
[/codeblock] *)
  let error_string =
    foreign_utility_function1 "error_string"
      (Base.Int64.of_string "942708242")
      (Int.typ @-> returning String.typ)
      String.s

  (** Returns a human-readable name of the given [param type], using the [enum Variant.Type] values.
[codeblock]
print(TYPE_INT) # Prints 2.
print(type_string(TYPE_INT)) # Prints ""int"".
print(type_string(TYPE_STRING)) # Prints ""String"".
[/codeblock]
See also [method typeof]. *)
  let type_string =
    foreign_utility_function1 "type_string"
      (Base.Int64.of_string "942708242")
      (Int.typ @-> returning String.typ)
      String.s

  (** Converts one or more arguments of any type to string in the best way possible and prints them to the console.
[codeblocks]
[gdscript]
var a = [1, 2, 3]
print(""a"", ""b"", a) # Prints ab[1, 2, 3]
[/gdscript]
[csharp]
var a = new Godot.Collections.Array { 1, 2, 3 };
GD.Print(""a"", ""b"", a); // Prints ab[1, 2, 3]
[/csharp]
[/codeblocks]
[b]Note:[/b] Consider using [method push_error] and [method push_warning] to print error and warning messages instead of [method print] or [method print_rich]. This distinguishes them from print messages used for debugging purposes, while also displaying a stack trace when an error or warning is printed. *)
  let print =
    foreign_utility_function1_void "print"
      (Base.Int64.of_string "2648703342")
      (Variant.typ @-> returning Void.typ)
      Void.s

  (** Converts one or more arguments of any type to string in the best way possible and prints them to the console.
The following BBCode tags are supported: [code]b[/code], [code]i[/code], [code]u[/code], [code]s[/code], [code]indent[/code], [code]code[/code], [code]url[/code], [code]center[/code], [code]right[/code], [code]color[/code], [code]bgcolor[/code], [code]fgcolor[/code].
Color tags only support the following named colors: [code]black[/code], [code]red[/code], [code]green[/code], [code]yellow[/code], [code]blue[/code], [code]magenta[/code], [code]pink[/code], [code]purple[/code], [code]cyan[/code], [code]white[/code], [code]orange[/code], [code]gray[/code]. Hexadecimal color codes are not supported.
URL tags only support URLs wrapped by a URL tag, not URLs with a different title.
When printing to standard output, the supported subset of BBCode is converted to ANSI escape codes for the terminal emulator to display. Support for ANSI escape codes varies across terminal emulators, especially for italic and strikethrough. In standard output, [code]code[/code] is represented with faint text but without any font change. Unsupported tags are left as-is in standard output.
[codeblocks]
[gdscript skip-lint]
print_rich(""[color=green][b]Hello world![/b][/color]"") # Prints out ""Hello world!"" in green with a bold font
[/gdscript]
[csharp skip-lint]
GD.PrintRich(""[color=green][b]Hello world![/b][/color]""); // Prints out ""Hello world!"" in green with a bold font
[/csharp]
[/codeblocks]
[b]Note:[/b] Consider using [method push_error] and [method push_warning] to print error and warning messages instead of [method print] or [method print_rich]. This distinguishes them from print messages used for debugging purposes, while also displaying a stack trace when an error or warning is printed.
[b]Note:[/b] On Windows, only Windows 10 and later correctly displays ANSI escape codes in standard output. *)
  let print_rich =
    foreign_utility_function1_void "print_rich"
      (Base.Int64.of_string "2648703342")
      (Variant.typ @-> returning Void.typ)
      Void.s

  (** Prints one or more arguments to strings in the best way possible to standard error line.
[codeblocks]
[gdscript]
printerr(""prints to stderr"")
[/gdscript]
[csharp]
GD.PrintErr(""prints to stderr"");
[/csharp]
[/codeblocks] *)
  let printerr =
    foreign_utility_function1_void "printerr"
      (Base.Int64.of_string "2648703342")
      (Variant.typ @-> returning Void.typ)
      Void.s

  (** Prints one or more arguments to the console with a tab between each argument.
[codeblocks]
[gdscript]
printt(""A"", ""B"", ""C"") # Prints A       B       C
[/gdscript]
[csharp]
GD.PrintT(""A"", ""B"", ""C""); // Prints A       B       C
[/csharp]
[/codeblocks] *)
  let printt =
    foreign_utility_function1_void "printt"
      (Base.Int64.of_string "2648703342")
      (Variant.typ @-> returning Void.typ)
      Void.s

  (** Prints one or more arguments to the console with a space between each argument.
[codeblocks]
[gdscript]
prints(""A"", ""B"", ""C"") # Prints A B C
[/gdscript]
[csharp]
GD.PrintS(""A"", ""B"", ""C""); // Prints A B C
[/csharp]
[/codeblocks] *)
  let prints =
    foreign_utility_function1_void "prints"
      (Base.Int64.of_string "2648703342")
      (Variant.typ @-> returning Void.typ)
      Void.s

  (** Prints one or more arguments to strings in the best way possible to the OS terminal. Unlike [method print], no newline is automatically added at the end.
[codeblocks]
[gdscript]
printraw(""A"")
printraw(""B"")
printraw(""C"")
# Prints ABC to terminal
[/gdscript]
[csharp]
GD.PrintRaw(""A"");
GD.PrintRaw(""B"");
GD.PrintRaw(""C"");
// Prints ABC to terminal
[/csharp]
[/codeblocks] *)
  let printraw =
    foreign_utility_function1_void "printraw"
      (Base.Int64.of_string "2648703342")
      (Variant.typ @-> returning Void.typ)
      Void.s

  (** If verbose mode is enabled ([method OS.is_stdout_verbose] returning [code]true[/code]), converts one or more arguments of any type to string in the best way possible and prints them to the console. *)
  let print_verbose =
    foreign_utility_function1_void "print_verbose"
      (Base.Int64.of_string "2648703342")
      (Variant.typ @-> returning Void.typ)
      Void.s

  (** Pushes an error message to Godot's built-in debugger and to the OS terminal.
[codeblocks]
[gdscript]
push_error(""test error"") # Prints ""test error"" to debugger and terminal as error call
[/gdscript]
[csharp]
GD.PushError(""test error""); // Prints ""test error"" to debugger and terminal as error call
[/csharp]
[/codeblocks]
[b]Note:[/b] This function does not pause project execution. To print an error message and pause project execution in debug builds, use [code]assert(false, ""test error"")[/code] instead. *)
  let push_error =
    foreign_utility_function1_void "push_error"
      (Base.Int64.of_string "2648703342")
      (Variant.typ @-> returning Void.typ)
      Void.s

  (** Pushes a warning message to Godot's built-in debugger and to the OS terminal.
[codeblocks]
[gdscript]
push_warning(""test warning"") # Prints ""test warning"" to debugger and terminal as warning call
[/gdscript]
[csharp]
GD.PushWarning(""test warning""); // Prints ""test warning"" to debugger and terminal as warning call
[/csharp]
[/codeblocks] *)
  let push_warning =
    foreign_utility_function1_void "push_warning"
      (Base.Int64.of_string "2648703342")
      (Variant.typ @-> returning Void.typ)
      Void.s

  (** Converts a [Variant] [param variable] to a formatted [String] that can then be parsed using [method str_to_var].
[codeblocks]
[gdscript]
var a = { ""a"": 1, ""b"": 2 }
print(var_to_str(a))
[/gdscript]
[csharp]
var a = new Godot.Collections.Dictionary { [""a""] = 1, [""b""] = 2 };
GD.Print(GD.VarToStr(a));
[/csharp]
[/codeblocks]
Prints:
[codeblock]
{
    ""a"": 1,
    ""b"": 2
}
[/codeblock]
[b]Note:[/b] Converting [Signal] or [Callable] is not supported and will result in an empty value for these types, regardless of their data. *)
  let var_to_str =
    foreign_utility_function1 "var_to_str"
      (Base.Int64.of_string "866625479")
      (Variant.typ @-> returning String.typ)
      String.s

  (** Converts a formatted [param string] that was returned by [method var_to_str] to the original [Variant].
[codeblocks]
[gdscript]
var data = '{ ""a"": 1, ""b"": 2 }' # data is a String
var dict = str_to_var(data)     # dict is a Dictionary
print(dict[""a""])                # Prints 1
[/gdscript]
[csharp]
string data = ""{ \""a\"": 1, \""b\"": 2 }"";           // data is a string
var dict = GD.StrToVar(data).AsGodotDictionary(); // dict is a Dictionary
GD.Print(dict[""a""]);                              // Prints 1
[/csharp]
[/codeblocks] *)
  let str_to_var =
    foreign_utility_function1 "str_to_var"
      (Base.Int64.of_string "1891498491")
      (String.typ @-> returning Variant.typ)
      Variant.s

  (** Encodes a [Variant] value to a byte array, without encoding objects. Deserialization can be done with [method bytes_to_var].
[b]Note:[/b] If you need object serialization, see [method var_to_bytes_with_objects].
[b]Note:[/b] Encoding [Callable] is not supported and will result in an empty value, regardless of the data. *)
  let var_to_bytes =
    foreign_utility_function1 "var_to_bytes"
      (Base.Int64.of_string "2947269930")
      (Variant.typ @-> returning PackedByteArray.typ)
      PackedByteArray.s

  (** Decodes a byte array back to a [Variant] value, without decoding objects.
[b]Note:[/b] If you need object deserialization, see [method bytes_to_var_with_objects]. *)
  let bytes_to_var =
    foreign_utility_function1 "bytes_to_var"
      (Base.Int64.of_string "4249819452")
      (PackedByteArray.typ @-> returning Variant.typ)
      Variant.s

  (** Encodes a [Variant] value to a byte array. Encoding objects is allowed (and can potentially include executable code). Deserialization can be done with [method bytes_to_var_with_objects].
[b]Note:[/b] Encoding [Callable] is not supported and will result in an empty value, regardless of the data. *)
  let var_to_bytes_with_objects =
    foreign_utility_function1 "var_to_bytes_with_objects"
      (Base.Int64.of_string "2947269930")
      (Variant.typ @-> returning PackedByteArray.typ)
      PackedByteArray.s

  (** Decodes a byte array back to a [Variant] value. Decoding objects is allowed.
[b]Warning:[/b] Deserialized object can contain code which gets executed. Do not use this option if the serialized object comes from untrusted sources to avoid potential security threats (remote code execution). *)
  let bytes_to_var_with_objects =
    foreign_utility_function1 "bytes_to_var_with_objects"
      (Base.Int64.of_string "4249819452")
      (PackedByteArray.typ @-> returning Variant.typ)
      Variant.s

  (** Returns the integer hash of the passed [param variable].
[codeblocks]
[gdscript]
print(hash(""a"")) # Prints 177670
[/gdscript]
[csharp]
GD.Print(GD.Hash(""a"")); // Prints 177670
[/csharp]
[/codeblocks] *)
  let hash =
    foreign_utility_function1 "hash"
      (Base.Int64.of_string "326422594")
      (Variant.typ @-> returning Int.typ)
      Int.s

  (** Returns the [Object] that corresponds to [param instance_id]. All Objects have a unique instance ID. See also [method Object.get_instance_id].
[codeblocks]
[gdscript]
var foo = ""bar""

func _ready():
    var id = get_instance_id()
    var inst = instance_from_id(id)
    print(inst.foo) # Prints bar
[/gdscript]
[csharp]
public partial class MyNode : Node
{
    public string Foo { get; set; } = ""bar"";

    public override void _Ready()
    {
        ulong id = GetInstanceId();
        var inst = (MyNode)InstanceFromId(Id);
        GD.Print(inst.Foo); // Prints bar
    }
}
[/csharp]
[/codeblocks] *)
  let instance_from_id =
    foreign_utility_function1 "instance_from_id"
      (Base.Int64.of_string "1156694636")
      (Int.typ @-> returning Object.typ)
      Object.s

  (** Returns [code]true[/code] if the Object that corresponds to [param id] is a valid object (e.g. has not been deleted from memory). All Objects have a unique instance ID. *)
  let is_instance_id_valid =
    foreign_utility_function1 "is_instance_id_valid"
      (Base.Int64.of_string "2232439758")
      (Int.typ @-> returning Bool.typ)
      Bool.s

  (** Returns [code]true[/code] if [param instance] is a valid Object (e.g. has not been deleted from memory). *)
  let is_instance_valid =
    foreign_utility_function1 "is_instance_valid"
      (Base.Int64.of_string "996128841")
      (Variant.typ @-> returning Bool.typ)
      Bool.s

  (** Allocates a unique ID which can be used by the implementation to construct a RID. This is used mainly from native extensions to implement servers. *)
  let rid_allocate_id = foreign_utility_function0

  (** Creates a RID from a [param base]. This is used mainly from native extensions to build servers. *)
  let rid_from_int64 =
    foreign_utility_function1 "rid_from_int64"
      (Base.Int64.of_string "3426892196")
      (Int.typ @-> returning RID.typ)
      RID.s

  (** Returns [code]true[/code], for value types, if [param a] and [param b] share the same value. Returns [code]true[/code], for reference types, if the references of [param a] and [param b] are the same.
[codeblock]
# Vector2 is a value type
var vec2_a = Vector2(0, 0)
var vec2_b = Vector2(0, 0)
var vec2_c = Vector2(1, 1)
is_same(vec2_a, vec2_a)  # true
is_same(vec2_a, vec2_b)  # true
is_same(vec2_a, vec2_c)  # false

# Array is a reference type
var arr_a = []
var arr_b = []
is_same(arr_a, arr_a)  # true
is_same(arr_a, arr_b)  # false
[/codeblock]
These are [Variant] value types: [code]null[/code], [bool], [int], [float], [String], [StringName], [Vector2], [Vector2i], [Vector3], [Vector3i], [Vector4], [Vector4i], [Rect2], [Rect2i], [Transform2D], [Transform3D], [Plane], [Quaternion], [AABB], [Basis], [Projection], [Color], [NodePath], [RID], [Callable] and [Signal].
These are [Variant] reference types: [Object], [Dictionary], [Array], [PackedByteArray], [PackedInt32Array], [PackedInt64Array], [PackedFloat32Array], [PackedFloat64Array], [PackedStringArray], [PackedVector2Array], [PackedVector3Array] and [PackedColorArray]. *)
  let is_same =
    foreign_utility_function2 "is_same"
      (Base.Int64.of_string "1409423524")
      (Variant.typ @-> Variant.typ @-> returning Bool.typ)
      Bool.s
end

module BuiltinClass0 = struct
  module Object = struct
    include ApiTypes.Object
  end

  module Variant = struct
    include ApiTypes.Variant
  end

  module Nil = struct
    include ApiTypes.Nil
  end

  module Bool = struct
    include ApiTypes.Bool
  end

  module Int = struct
    include ApiTypes.Int
  end

  module Float = struct
    include ApiTypes.Float
  end

  module String = struct
    include ApiTypes.String
  end

  module Vector2 = struct
    include ApiTypes.Vector2

    module Axis = struct
      include ApiTypes.Int
    end
  end

  module Vector2i = struct
    include ApiTypes.Vector2i

    module Axis = struct
      include ApiTypes.Int
    end
  end

  module Rect2 = struct
    include ApiTypes.Rect2
  end

  module Rect2i = struct
    include ApiTypes.Rect2i
  end

  module Vector3 = struct
    include ApiTypes.Vector3

    module Axis = struct
      include ApiTypes.Int
    end
  end

  module Vector3i = struct
    include ApiTypes.Vector3i

    module Axis = struct
      include ApiTypes.Int
    end
  end

  module Transform2D = struct
    include ApiTypes.Transform2D
  end

  module Vector4 = struct
    include ApiTypes.Vector4

    module Axis = struct
      include ApiTypes.Int
    end
  end

  module Vector4i = struct
    include ApiTypes.Vector4i

    module Axis = struct
      include ApiTypes.Int
    end
  end

  module Plane = struct
    include ApiTypes.Plane
  end

  module Quaternion = struct
    include ApiTypes.Quaternion
  end

  module AABB = struct
    include ApiTypes.AABB
  end

  module Basis = struct
    include ApiTypes.Basis
  end

  module Transform3D = struct
    include ApiTypes.Transform3D
  end

  module Projection = struct
    include ApiTypes.Projection

    module Planes = struct
      include ApiTypes.Int
    end
  end

  module Color = struct
    include ApiTypes.Color
  end

  module StringName = struct
    include ApiTypes.StringName
  end

  module NodePath = struct
    include ApiTypes.NodePath
  end

  module RID = struct
    include ApiTypes.RID
  end

  module Callable = struct
    include ApiTypes.Callable
  end

  module Signal = struct
    include ApiTypes.Signal
  end

  module Dictionary = struct
    include ApiTypes.Dictionary
  end

  module Array = struct
    include ApiTypes.Array
  end

  module PackedByteArray = struct
    include ApiTypes.PackedByteArray
  end

  module PackedInt32Array = struct
    include ApiTypes.PackedInt32Array
  end

  module PackedInt64Array = struct
    include ApiTypes.PackedInt64Array
  end

  module PackedFloat32Array = struct
    include ApiTypes.PackedFloat32Array
  end

  module PackedFloat64Array = struct
    include ApiTypes.PackedFloat64Array
  end

  module PackedStringArray = struct
    include ApiTypes.PackedStringArray
  end

  module PackedVector2Array = struct
    include ApiTypes.PackedVector2Array
  end

  module PackedVector3Array = struct
    include ApiTypes.PackedVector3Array
  end

  module PackedColorArray = struct
    include ApiTypes.PackedColorArray
  end
end

module BuiltinClass = struct
  module type NIL = sig
    type t

    include Api_types.API_TYPE with type t := t

    val not :
      Nil.t structure ptr -> Nil.t structure ptr -> Bool.t structure ptr -> unit

    val _Nil_elem_Dictionary :
      Nil.t structure ptr ->
      Dictionary.t structure ptr ->
      Bool.t structure ptr ->
      unit

    val _Nil_elem_Array :
      Nil.t structure ptr ->
      Array.t structure ptr ->
      Bool.t structure ptr ->
      unit
  end

  module type BOOL = sig
    type t

    include Api_types.API_TYPE with type t := t

    val not :
      Bool.t structure ptr ->
      Bool.t structure ptr ->
      Bool.t structure ptr ->
      unit

    val ( = ) :
      Bool.t structure ptr ->
      Bool.t structure ptr ->
      Bool.t structure ptr ->
      unit
    (** Returns [code]true[/code] if the two booleans are equal. That is, both are [code]true[/code] or both are [code]false[/code]. This operation can be seen as a logical EQ or XNOR. *)

    val ( <> ) :
      Bool.t structure ptr ->
      Bool.t structure ptr ->
      Bool.t structure ptr ->
      unit
    (** Returns [code]true[/code] if the two booleans are not equal. That is, one is [code]true[/code] and the other is [code]false[/code]. This operation can be seen as a logical XOR. *)

    val ( < ) :
      Bool.t structure ptr ->
      Bool.t structure ptr ->
      Bool.t structure ptr ->
      unit
    (** Returns [code]true[/code] if the left operand is [code]false[/code] and the right operand is [code]true[/code]. *)

    val ( > ) :
      Bool.t structure ptr ->
      Bool.t structure ptr ->
      Bool.t structure ptr ->
      unit
    (** Returns [code]true[/code] if the left operand is [code]true[/code] and the right operand is [code]false[/code]. *)

    val ( && ) :
      Bool.t structure ptr ->
      Bool.t structure ptr ->
      Bool.t structure ptr ->
      unit

    val ( || ) :
      Bool.t structure ptr ->
      Bool.t structure ptr ->
      Bool.t structure ptr ->
      unit

    val ( ~^^ ) :
      Bool.t structure ptr ->
      Bool.t structure ptr ->
      Bool.t structure ptr ->
      unit

    val bool_elem_Dictionary :
      Bool.t structure ptr ->
      Dictionary.t structure ptr ->
      Bool.t structure ptr ->
      unit

    val bool_elem_Array :
      Bool.t structure ptr ->
      Array.t structure ptr ->
      Bool.t structure ptr ->
      unit
  end

  module type INT = sig
    type t

    include Api_types.API_TYPE with type t := t

    val ( ~- ) :
      Int.t structure ptr -> Int.t structure ptr -> Int.t structure ptr -> unit
    (** Returns the negated value of the [int]. If positive, turns the number negative. If negative, turns the number positive. If zero, does nothing. *)

    val ( ~+ ) :
      Int.t structure ptr -> Int.t structure ptr -> Int.t structure ptr -> unit
    (** Returns the same value as if the [code]+[/code] was not there. Unary [code]+[/code] does nothing, but sometimes it can make your code more readable. *)

    val ( ~~~ ) :
      Int.t structure ptr -> Int.t structure ptr -> Int.t structure ptr -> unit
    (** Performs the bitwise [code]NOT[/code] operation on the [int]. Due to [url=https://en.wikipedia.org/wiki/Two%27s_complement]2's complement[/url], it's effectively equal to [code]-(int + 1)[/code].
[codeblock]
print(~4) # Prints -5
print(~(-7)) # Prints 6
[/codeblock] *)

    val not :
      Int.t structure ptr -> Int.t structure ptr -> Bool.t structure ptr -> unit

    val ( = ) :
      Int.t structure ptr -> Int.t structure ptr -> Bool.t structure ptr -> unit
    (** Returns [code]true[/code] if the two [int]s are equal. *)

    val ( <> ) :
      Int.t structure ptr -> Int.t structure ptr -> Bool.t structure ptr -> unit
    (** Returns [code]true[/code] if the [int]s are not equal. *)

    val ( < ) :
      Int.t structure ptr -> Int.t structure ptr -> Bool.t structure ptr -> unit
    (** Returns [code]true[/code] if the left [int] is less than the right [int]. *)

    val ( <= ) :
      Int.t structure ptr -> Int.t structure ptr -> Bool.t structure ptr -> unit
    (** Returns [code]true[/code] if the left [int] is less than or equal to the right [int]. *)

    val ( > ) :
      Int.t structure ptr -> Int.t structure ptr -> Bool.t structure ptr -> unit
    (** Returns [code]true[/code] if the left [int] is greater than the right [int]. *)

    val ( >= ) :
      Int.t structure ptr -> Int.t structure ptr -> Bool.t structure ptr -> unit
    (** Returns [code]true[/code] if the left [int] is greater than or equal to the right [int]. *)

    val ( + ) :
      Int.t structure ptr -> Int.t structure ptr -> Int.t structure ptr -> unit
    (** Adds the two [int]s. *)

    val ( - ) :
      Int.t structure ptr -> Int.t structure ptr -> Int.t structure ptr -> unit
    (** Subtracts the two [int]s. *)

    val ( * ) :
      Int.t structure ptr -> Int.t structure ptr -> Int.t structure ptr -> unit
    (** Multiplies the two [int]s. *)

    val ( / ) :
      Int.t structure ptr -> Int.t structure ptr -> Int.t structure ptr -> unit
    (** Divides the two [int]s. The result is an [int]. This will truncate the [float], discarding anything after the floating point.
[codeblock]
print(6 / 2) # Prints 3
print(5 / 3) # Prints 1
[/codeblock] *)

    val ( % ) :
      Int.t structure ptr -> Int.t structure ptr -> Int.t structure ptr -> unit
    (** Returns the remainder after dividing two [int]s. Uses truncated division, which returns a negative number if the dividend is negative. If this is not desired, consider using [method @GlobalScope.posmod].
[codeblock]
print(6 % 2) # Prints 0
print(11 % 4) # Prints 3
print(-5 % 3) # Prints -2
[/codeblock] *)

    val ( ** ) :
      Int.t structure ptr -> Int.t structure ptr -> Int.t structure ptr -> unit
    (** Raises the left [int] to a power of the right [int].
[codeblock]
print(3  *  *  4) # Prints 81
[/codeblock] *)

    val ( <<< ) :
      Int.t structure ptr -> Int.t structure ptr -> Int.t structure ptr -> unit
    (** Performs the bitwise shift left operation. Effectively the same as multiplying by a power of 2.
[codeblock]
print(0b1010 << 1) # Prints 20 (binary 10100)
print(0b1010 << 3) # Prints 80 (binary 1010000)
[/codeblock] *)

    val ( >>> ) :
      Int.t structure ptr -> Int.t structure ptr -> Int.t structure ptr -> unit
    (** Performs the bitwise shift right operation. Effectively the same as dividing by a power of 2.
[codeblock]
print(0b1010 >> 1) # Prints 5 (binary 101)
print(0b1010 >> 2) # Prints 2 (binary 10)
[/codeblock] *)

    val ( &&& ) :
      Int.t structure ptr -> Int.t structure ptr -> Int.t structure ptr -> unit
    (** Performs the bitwise [code]AND[/code] operation.
[codeblock]
print(0b1100 & 0b1010) # Prints 8 (binary 1000)
[/codeblock]
This is useful for retrieving binary flags from a variable.
[codeblock]
var flags = 0b101
# Check if the first or second bit are enabled.
if flags & 0b011:
    do_stuff() # This line will run.
[/codeblock] *)

    val ( ||| ) :
      Int.t structure ptr -> Int.t structure ptr -> Int.t structure ptr -> unit
    (** Performs the bitwise [code]OR[/code] operation.
[codeblock]
print(0b1100 | 0b1010) # Prints 14 (binary 1110)
[/codeblock]
This is useful for storing binary flags in a variable.
[codeblock]
var flags = 0
flags |= 0b101 # Turn the first and third bits on.
[/codeblock] *)

    val ( ^^^ ) :
      Int.t structure ptr -> Int.t structure ptr -> Int.t structure ptr -> unit
    (** Performs the bitwise [code]XOR[/code] operation.
[codeblock]
print(0b1100 ^ 0b1010) # Prints 6 (binary 110)
[/codeblock] *)

    val ( && ) :
      Int.t structure ptr -> Int.t structure ptr -> Bool.t structure ptr -> unit

    val ( || ) :
      Int.t structure ptr -> Int.t structure ptr -> Bool.t structure ptr -> unit

    val ( ~^^ ) :
      Int.t structure ptr -> Int.t structure ptr -> Bool.t structure ptr -> unit

    val int_elem_Dictionary :
      Int.t structure ptr ->
      Dictionary.t structure ptr ->
      Bool.t structure ptr ->
      unit

    val int_elem_Array :
      Int.t structure ptr ->
      Array.t structure ptr ->
      Bool.t structure ptr ->
      unit

    val int_elem_PackedByteArray :
      Int.t structure ptr ->
      PackedByteArray.t structure ptr ->
      Bool.t structure ptr ->
      unit

    val int_elem_PackedInt32Array :
      Int.t structure ptr ->
      PackedInt32Array.t structure ptr ->
      Bool.t structure ptr ->
      unit

    val int_elem_PackedInt64Array :
      Int.t structure ptr ->
      PackedInt64Array.t structure ptr ->
      Bool.t structure ptr ->
      unit

    val int_elem_PackedFloat32Array :
      Int.t structure ptr ->
      PackedFloat32Array.t structure ptr ->
      Bool.t structure ptr ->
      unit

    val int_elem_PackedFloat64Array :
      Int.t structure ptr ->
      PackedFloat64Array.t structure ptr ->
      Bool.t structure ptr ->
      unit
  end

  module type FLOAT = sig
    type t

    include Api_types.API_TYPE with type t := t

    val ( ~- ) :
      Float.t structure ptr ->
      Float.t structure ptr ->
      Float.t structure ptr ->
      unit
    (** Returns the negative value of the [float]. If positive, turns the number negative. If negative, turns the number positive. With floats, the number zero can be either positive or negative. *)

    val ( ~+ ) :
      Float.t structure ptr ->
      Float.t structure ptr ->
      Float.t structure ptr ->
      unit
    (** Returns the same value as if the [code]+[/code] was not there. Unary [code]+[/code] does nothing, but sometimes it can make your code more readable. *)

    val not :
      Float.t structure ptr ->
      Float.t structure ptr ->
      Bool.t structure ptr ->
      unit

    val ( = ) :
      Float.t structure ptr ->
      Float.t structure ptr ->
      Bool.t structure ptr ->
      unit
    (** Returns [code]true[/code] if both floats are exactly equal.
[b]Note:[/b] Due to floating-point precision errors, consider using [method @GlobalScope.is_equal_approx] or [method @GlobalScope.is_zero_approx] instead, which are more reliable.
[b]Note:[/b] [constant @GDScript.NAN] doesn't behave the same as other numbers. Therefore, the results from this operator may not be accurate if NaNs are included. *)

    val ( <> ) :
      Float.t structure ptr ->
      Float.t structure ptr ->
      Bool.t structure ptr ->
      unit
    (** Returns [code]true[/code] if two floats are different from each other.
[b]Note:[/b] [constant @GDScript.NAN] doesn't behave the same as other numbers. Therefore, the results from this operator may not be accurate if NaNs are included. *)

    val ( < ) :
      Float.t structure ptr ->
      Float.t structure ptr ->
      Bool.t structure ptr ->
      unit
    (** Returns [code]true[/code] if the left float is less than the right one.
[b]Note:[/b] [constant @GDScript.NAN] doesn't behave the same as other numbers. Therefore, the results from this operator may not be accurate if NaNs are included. *)

    val ( <= ) :
      Float.t structure ptr ->
      Float.t structure ptr ->
      Bool.t structure ptr ->
      unit
    (** Returns [code]true[/code] if the left float is less than or equal to the right one.
[b]Note:[/b] [constant @GDScript.NAN] doesn't behave the same as other numbers. Therefore, the results from this operator may not be accurate if NaNs are included. *)

    val ( > ) :
      Float.t structure ptr ->
      Float.t structure ptr ->
      Bool.t structure ptr ->
      unit
    (** Returns [code]true[/code] if the left float is greater than the right one.
[b]Note:[/b] [constant @GDScript.NAN] doesn't behave the same as other numbers. Therefore, the results from this operator may not be accurate if NaNs are included. *)

    val ( >= ) :
      Float.t structure ptr ->
      Float.t structure ptr ->
      Bool.t structure ptr ->
      unit
    (** Returns [code]true[/code] if the left float is greater than or equal to the right one.
[b]Note:[/b] [constant @GDScript.NAN] doesn't behave the same as other numbers. Therefore, the results from this operator may not be accurate if NaNs are included. *)

    val ( + ) :
      Float.t structure ptr ->
      Float.t structure ptr ->
      Float.t structure ptr ->
      unit
    (** Adds two floats. *)

    val ( - ) :
      Float.t structure ptr ->
      Float.t structure ptr ->
      Float.t structure ptr ->
      unit
    (** Subtracts a float from a float. *)

    val ( * ) :
      Float.t structure ptr ->
      Float.t structure ptr ->
      Float.t structure ptr ->
      unit
    (** Multiplies two [float]s. *)

    val ( / ) :
      Float.t structure ptr ->
      Float.t structure ptr ->
      Float.t structure ptr ->
      unit
    (** Divides two floats. *)

    val ( ** ) :
      Float.t structure ptr ->
      Float.t structure ptr ->
      Float.t structure ptr ->
      unit
    (** Raises a [float] to a power of a [float].
[codeblock]
print(39.0625 *  * 0.25) # 2.5
[/codeblock] *)

    val ( && ) :
      Float.t structure ptr ->
      Float.t structure ptr ->
      Bool.t structure ptr ->
      unit

    val ( || ) :
      Float.t structure ptr ->
      Float.t structure ptr ->
      Bool.t structure ptr ->
      unit

    val ( ~^^ ) :
      Float.t structure ptr ->
      Float.t structure ptr ->
      Bool.t structure ptr ->
      unit

    val float_elem_Dictionary :
      Float.t structure ptr ->
      Dictionary.t structure ptr ->
      Bool.t structure ptr ->
      unit

    val float_elem_Array :
      Float.t structure ptr ->
      Array.t structure ptr ->
      Bool.t structure ptr ->
      unit

    val float_elem_PackedByteArray :
      Float.t structure ptr ->
      PackedByteArray.t structure ptr ->
      Bool.t structure ptr ->
      unit

    val float_elem_PackedInt32Array :
      Float.t structure ptr ->
      PackedInt32Array.t structure ptr ->
      Bool.t structure ptr ->
      unit

    val float_elem_PackedInt64Array :
      Float.t structure ptr ->
      PackedInt64Array.t structure ptr ->
      Bool.t structure ptr ->
      unit

    val float_elem_PackedFloat32Array :
      Float.t structure ptr ->
      PackedFloat32Array.t structure ptr ->
      Bool.t structure ptr ->
      unit

    val float_elem_PackedFloat64Array :
      Float.t structure ptr ->
      PackedFloat64Array.t structure ptr ->
      Bool.t structure ptr ->
      unit
  end

  module type STRING = sig
    type t

    include Api_types.API_TYPE with type t := t

    val casecmp_to :
      BuiltinClass0.String.t structure ptr ->
      BuiltinClass0.String.t structure ptr ->
      BuiltinClass0.Int.t structure ptr
    (** Performs a case-sensitive comparison to another string. Returns [code]-1[/code] if less than, [code]1[/code] if greater than, or [code]0[/code] if equal. ""Less than"" and ""greater than"" are determined by the [url=https://en.wikipedia.org/wiki/List_of_Unicode_characters]Unicode code points[/url] of each string, which roughly matches the alphabetical order.
With different string lengths, returns [code]1[/code] if this string is longer than the [param to] string, or [code]-1[/code] if shorter. Note that the length of empty strings is [i]always[/i] [code]0[/code].
To get a [bool] result from a string comparison, use the [code]==[/code] operator instead. See also [method nocasecmp_to], [method naturalcasecmp_to], and [method naturalnocasecmp_to]. *)

    val nocasecmp_to :
      BuiltinClass0.String.t structure ptr ->
      BuiltinClass0.String.t structure ptr ->
      BuiltinClass0.Int.t structure ptr
    (** Performs a [b]case-insensitive[/b] comparison to another string. Returns [code]-1[/code] if less than, [code]1[/code] if greater than, or [code]0[/code] if equal. ""Less than"" or ""greater than"" are determined by the [url=https://en.wikipedia.org/wiki/List_of_Unicode_characters]Unicode code points[/url] of each string, which roughly matches the alphabetical order. Internally, lowercase characters are converted to uppercase for the comparison.
With different string lengths, returns [code]1[/code] if this string is longer than the [param to] string, or [code]-1[/code] if shorter. Note that the length of empty strings is [i]always[/i] [code]0[/code].
To get a [bool] result from a string comparison, use the [code]==[/code] operator instead. See also [method casecmp_to], [method naturalcasecmp_to], and [method naturalnocasecmp_to]. *)

    val naturalcasecmp_to :
      BuiltinClass0.String.t structure ptr ->
      BuiltinClass0.String.t structure ptr ->
      BuiltinClass0.Int.t structure ptr
    (** Performs a [b]case-sensitive[/b], [i]natural order[/i] comparison to another string. Returns [code]-1[/code] if less than, [code]1[/code] if greater than, or [code]0[/code] if equal. ""Less than"" or ""greater than"" are determined by the [url=https://en.wikipedia.org/wiki/List_of_Unicode_characters]Unicode code points[/url] of each string, which roughly matches the alphabetical order.
When used for sorting, natural order comparison orders sequences of numbers by the combined value of each digit as is often expected, instead of the single digit's value. A sorted sequence of numbered strings will be [code][""1"", ""2"", ""3"", ...][/code], not [code][""1"", ""10"", ""2"", ""3"", ...][/code].
With different string lengths, returns [code]1[/code] if this string is longer than the [param to] string, or [code]-1[/code] if shorter. Note that the length of empty strings is [i]always[/i] [code]0[/code].
To get a [bool] result from a string comparison, use the [code]==[/code] operator instead. See also [method naturalnocasecmp_to], [method nocasecmp_to], and [method casecmp_to]. *)

    val naturalnocasecmp_to :
      BuiltinClass0.String.t structure ptr ->
      BuiltinClass0.String.t structure ptr ->
      BuiltinClass0.Int.t structure ptr
    (** Performs a [b]case-insensitive[/b], [i]natural order[/i] comparison to another string. Returns [code]-1[/code] if less than, [code]1[/code] if greater than, or [code]0[/code] if equal. ""Less than"" or ""greater than"" are determined by the [url=https://en.wikipedia.org/wiki/List_of_Unicode_characters]Unicode code points[/url] of each string, which roughly matches the alphabetical order. Internally, lowercase characters are converted to uppercase for the comparison.
When used for sorting, natural order comparison orders sequences of numbers by the combined value of each digit as is often expected, instead of the single digit's value. A sorted sequence of numbered strings will be [code][""1"", ""2"", ""3"", ...][/code], not [code][""1"", ""10"", ""2"", ""3"", ...][/code].
With different string lengths, returns [code]1[/code] if this string is longer than the [param to] string, or [code]-1[/code] if shorter. Note that the length of empty strings is [i]always[/i] [code]0[/code].
To get a [bool] result from a string comparison, use the [code]==[/code] operator instead. See also [method naturalcasecmp_to], [method nocasecmp_to], and [method casecmp_to]. *)

    val length :
      BuiltinClass0.String.t structure ptr -> BuiltinClass0.Int.t structure ptr
    (** Returns the number of characters in the string. Empty strings ([code]""""[/code]) always return [code]0[/code]. See also [method is_empty]. *)

    val substr :
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.String.t structure ptr ->
      BuiltinClass0.String.t structure ptr
    (** Returns part of the string from the position [param from] with length [param len]. If [param len] is [code]-1[/code] (as by default), returns the rest of the string starting from the given position. *)

    val get_slice :
      BuiltinClass0.String.t structure ptr ->
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.String.t structure ptr ->
      BuiltinClass0.String.t structure ptr
    (** Splits the string using a [param delimiter] and returns the substring at index [param slice]. Returns the original string if [param delimiter] does not occur in the string. Returns an empty string if the [param slice] does not exist.
This is faster than [method split], if you only need one substring.
[b]Example:[/b]
[codeblock]
print(""i/am/example/hi"".get_slice(""/"", 2)) # Prints ""example""
[/codeblock] *)

    val get_slicec :
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.String.t structure ptr ->
      BuiltinClass0.String.t structure ptr
    (** Splits the string using a Unicode character with code [param delimiter] and returns the substring at index [param slice]. Returns an empty string if the [param slice] does not exist.
This is faster than [method split], if you only need one substring. *)

    val get_slice_count :
      BuiltinClass0.String.t structure ptr ->
      BuiltinClass0.String.t structure ptr ->
      BuiltinClass0.Int.t structure ptr
    (** Returns the total number of slices when the string is split with the given [param delimiter] (see [method split]). *)

    val find :
      BuiltinClass0.String.t structure ptr ->
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.String.t structure ptr ->
      BuiltinClass0.Int.t structure ptr
    (** Returns the index of the [b]first[/b] occurrence of [param what] in this string, or [code]-1[/code] if there are none. The search's start can be specified with [param from], continuing to the end of the string.
[codeblocks]
[gdscript]
print(""Team"".find(""I"")) # Prints -1

print(""Potato"".find(""t""))    # Prints 2
print(""Potato"".find(""t"", 3)) # Prints 4
print(""Potato"".find(""t"", 5)) # Prints -1
[/gdscript]
[csharp]
GD.Print(""Team"".Find(""I"")); // Prints -1

GD.Print(""Potato"".Find(""t""));    // Prints 2
GD.Print(""Potato"".Find(""t"", 3)); // Prints 4
GD.Print(""Potato"".Find(""t"", 5)); // Prints -1
[/csharp]
[/codeblocks]
[b]Note:[/b] If you just want to know whether the string contains [param what], use [method contains]. In GDScript, you may also use the [code]in[/code] operator. *)

    val count :
      BuiltinClass0.String.t structure ptr ->
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.String.t structure ptr ->
      BuiltinClass0.Int.t structure ptr
    (** Returns the number of occurrences of the substring [param what] between [param from] and [param to] positions. If [param to] is 0, the search continues until the end of the string. *)

    val countn :
      BuiltinClass0.String.t structure ptr ->
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.String.t structure ptr ->
      BuiltinClass0.Int.t structure ptr
    (** Returns the number of occurrences of the substring [param what] between [param from] and [param to] positions, [b]ignoring case[/b]. If [param to] is 0, the search continues until the end of the string. *)

    val findn :
      BuiltinClass0.String.t structure ptr ->
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.String.t structure ptr ->
      BuiltinClass0.Int.t structure ptr
    (** Returns the index of the [b]first[/b] [b]case-insensitive[/b] occurrence of [param what] in this string, or [code]-1[/code] if there are none. The starting search index can be specified with [param from], continuing to the end of the string. *)

    val rfind :
      BuiltinClass0.String.t structure ptr ->
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.String.t structure ptr ->
      BuiltinClass0.Int.t structure ptr
    (** Returns the index of the [b]last[/b] occurrence of [param what] in this string, or [code]-1[/code] if there are none. The search's start can be specified with [param from], continuing to the beginning of the string. This method is the reverse of [method find]. *)

    val rfindn :
      BuiltinClass0.String.t structure ptr ->
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.String.t structure ptr ->
      BuiltinClass0.Int.t structure ptr
    (** Returns the index of the [b]last[/b] [b]case-insensitive[/b] occurrence of [param what] in this string, or [code]-1[/code] if there are none. The starting search index can be specified with [param from], continuing to the beginning of the string. This method is the reverse of [method findn]. *)

    val match_ :
      BuiltinClass0.String.t structure ptr ->
      BuiltinClass0.String.t structure ptr ->
      BuiltinClass0.Bool.t structure ptr
    (** Does a simple expression match (also called ""glob"" or ""globbing""), where [code] * [/code] matches zero or more arbitrary characters and [code]?[/code] matches any single character except a period ([code].[/code]). An empty string or empty expression always evaluates to [code]false[/code]. *)

    val matchn :
      BuiltinClass0.String.t structure ptr ->
      BuiltinClass0.String.t structure ptr ->
      BuiltinClass0.Bool.t structure ptr
    (** Does a simple [b]case-insensitive[/b] expression match, where [code] * [/code] matches zero or more arbitrary characters and [code]?[/code] matches any single character except a period ([code].[/code]). An empty string or empty expression always evaluates to [code]false[/code]. *)

    val begins_with :
      BuiltinClass0.String.t structure ptr ->
      BuiltinClass0.String.t structure ptr ->
      BuiltinClass0.Bool.t structure ptr
    (** Returns [code]true[/code] if the string begins with the given [param text]. See also [method ends_with]. *)

    val ends_with :
      BuiltinClass0.String.t structure ptr ->
      BuiltinClass0.String.t structure ptr ->
      BuiltinClass0.Bool.t structure ptr
    (** Returns [code]true[/code] if the string ends with the given [param text]. See also [method begins_with]. *)

    val is_subsequence_of :
      BuiltinClass0.String.t structure ptr ->
      BuiltinClass0.String.t structure ptr ->
      BuiltinClass0.Bool.t structure ptr
    (** Returns [code]true[/code] if all characters of this string can be found in [param text] in their original order.
[codeblock]
var text = ""Wow, incredible!""

print(""inedible"".is_subsequence_of(text)) # Prints true
print(""Word!"".is_subsequence_of(text))    # Prints true
print(""Window"".is_subsequence_of(text))   # Prints false
print("""".is_subsequence_of(text))         # Prints true
[/codeblock] *)

    val is_subsequence_ofn :
      BuiltinClass0.String.t structure ptr ->
      BuiltinClass0.String.t structure ptr ->
      BuiltinClass0.Bool.t structure ptr
    (** Returns [code]true[/code] if all characters of this string can be found in [param text] in their original order, [b]ignoring case[/b]. *)

    val bigrams :
      BuiltinClass0.String.t structure ptr ->
      BuiltinClass0.PackedStringArray.t structure ptr
    (** Returns an array containing the bigrams (pairs of consecutive characters) of this string.
[codeblock]
print(""Get up!"".bigrams()) # Prints [""Ge"", ""et"", ""t "", "" u"", ""up"", ""p!""]
[/codeblock] *)

    val similarity :
      BuiltinClass0.String.t structure ptr ->
      BuiltinClass0.String.t structure ptr ->
      BuiltinClass0.Float.t structure ptr
    (** Returns the similarity index ([url=https://en.wikipedia.org/wiki/S%C3%B8rensen%E2%80%93Dice_coefficient]Sorensen-Dice coefficient[/url]) of this string compared to another. A result of [code]1.0[/code] means totally similar, while [code]0.0[/code] means totally dissimilar.
[codeblock]
print(""ABC123"".similarity(""ABC123"")) # Prints 1.0
print(""ABC123"".similarity(""XYZ456"")) # Prints 0.0
print(""ABC123"".similarity(""123ABC"")) # Prints 0.8
print(""ABC123"".similarity(""abc123"")) # Prints 0.4
[/codeblock] *)

    val format :
      BuiltinClass0.Variant.t structure ptr ->
      BuiltinClass0.String.t structure ptr ->
      BuiltinClass0.String.t structure ptr ->
      BuiltinClass0.String.t structure ptr
    (** Formats the string by replacing all occurrences of [param placeholder] with the elements of [param values].
[param values] can be a [Dictionary] or an [Array]. Any underscores in [param placeholder] will be replaced with the corresponding keys in advance. Array elements use their index as keys.
[codeblock]
# Prints ""Waiting for Godot is a play by Samuel Beckett, and Godot Engine is named after it.""
var use_array_values = ""Waiting for {0} is a play by {1}, and {0} Engine is named after it.""
print(use_array_values.format([""Godot"", ""Samuel Beckett""]))

# Prints ""User 42 is Godot.""
print(""User {id} is {name}."".format({""id"": 42, ""name"": ""Godot""}))
[/codeblock]
Some additional handling is performed when [param values] is an [Array]. If [param placeholder] does not contain an underscore, the elements of the [param values] array will be used to replace one occurrence of the placeholder in order; If an element of [param values] is another 2-element array, it'll be interpreted as a key-value pair.
[codeblock]
# Prints ""User 42 is Godot.""
print(""User {} is {}."".format([42, ""Godot""], ""{}""))
print(""User {id} is {name}."".format([[""id"", 42], [""name"", ""Godot""]]))
[/codeblock]
See also the [url=$DOCS_URL/tutorials/scripting/gdscript/gdscript_format_string.html]GDScript format string[/url] tutorial.
[b]Note:[/b] The replacement of placeholders is not done all at once, instead each placeholder is replaced in the order they are passed, this means that if one of the replacement strings contains a key it will also be replaced. This can be very powerful, but can also cause unexpected results if you are not careful. If you do not need to perform replacement in the replacement strings, make sure your replacements do not contain placeholders to ensure reliable results.
[codeblock]
print(""{0} {1}"".format([""{1}"", ""x""]))                       # Prints ""x x"".
print(""{0} {1}"".format([""x"", ""{0}""]))                       # Prints ""x {0}"".
print(""{foo} {bar}"".format({""foo"": ""{bar}"", ""bar"": ""baz""})) # Prints ""baz baz"".
print(""{foo} {bar}"".format({""bar"": ""baz"", ""foo"": ""{bar}""})) # Prints ""{bar} baz"".
[/codeblock]
[b]Note:[/b] In C#, it's recommended to [url=https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/tokens/interpolated]interpolate strings with ""$""[/url], instead. *)

    val replace :
      BuiltinClass0.String.t structure ptr ->
      BuiltinClass0.String.t structure ptr ->
      BuiltinClass0.String.t structure ptr ->
      BuiltinClass0.String.t structure ptr
    (** Replaces all occurrences of [param what] inside the string with the given [param forwhat]. *)

    val replacen :
      BuiltinClass0.String.t structure ptr ->
      BuiltinClass0.String.t structure ptr ->
      BuiltinClass0.String.t structure ptr ->
      BuiltinClass0.String.t structure ptr
    (** Replaces all [b]case-insensitive[/b] occurrences of [param what] inside the string with the given [param forwhat]. *)

    val repeat :
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.String.t structure ptr ->
      BuiltinClass0.String.t structure ptr
    (** Repeats this string a number of times. [param count] needs to be greater than [code]0[/code]. Otherwise, returns an empty string. *)

    val reverse :
      BuiltinClass0.String.t structure ptr ->
      BuiltinClass0.String.t structure ptr
    (** Returns the copy of this string in reverse order. *)

    val insert :
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.String.t structure ptr ->
      BuiltinClass0.String.t structure ptr ->
      BuiltinClass0.String.t structure ptr
    (** Inserts [param what] at the given [param position] in the string. *)

    val erase :
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.String.t structure ptr ->
      BuiltinClass0.String.t structure ptr
    (** Returns a string with [param chars] characters erased starting from [param position]. If [param chars] goes beyond the string's length given the specified [param position], fewer characters will be erased from the returned string. Returns an empty string if either [param position] or [param chars] is negative. Returns the original string unmodified if [param chars] is [code]0[/code]. *)

    val capitalize :
      BuiltinClass0.String.t structure ptr ->
      BuiltinClass0.String.t structure ptr
    (** Changes the appearance of the string: replaces underscores ([code]_[/code]) with spaces, adds spaces before uppercase letters in the middle of a word, converts all letters to lowercase, then converts the first one and each one following a space to uppercase.
[codeblocks]
[gdscript]
""move_local_x"".capitalize()   # Returns ""Move Local X""
""sceneFile_path"".capitalize() # Returns ""Scene File Path""
""2D, FPS, PNG"".capitalize()   # Returns ""2d, Fps, Png""
[/gdscript]
[csharp]
""move_local_x"".Capitalize();   // Returns ""Move Local X""
""sceneFile_path"".Capitalize(); // Returns ""Scene File Path""
""2D, FPS, PNG"".Capitalize();   // Returns ""2d, Fps, Png""
[/csharp]
[/codeblocks] *)

    val to_camel_case :
      BuiltinClass0.String.t structure ptr ->
      BuiltinClass0.String.t structure ptr
    (** Returns the string converted to [code]camelCase[/code]. *)

    val to_pascal_case :
      BuiltinClass0.String.t structure ptr ->
      BuiltinClass0.String.t structure ptr
    (** Returns the string converted to [code]PascalCase[/code]. *)

    val to_snake_case :
      BuiltinClass0.String.t structure ptr ->
      BuiltinClass0.String.t structure ptr
    (** Returns the string converted to [code]snake_case[/code].
[b]Note:[/b] Numbers followed by a [i]single[/i] letter are not separated in the conversion to keep some words (such as ""2D"") together.
[codeblocks]
[gdscript]
""Node2D"".to_snake_case()               # Returns ""node_2d""
""2nd place"".to_snake_case()            # Returns ""2_nd_place""
""Texture3DAssetFolder"".to_snake_case() # Returns ""texture_3d_asset_folder""
[/gdscript]
[csharp]
""Node2D"".ToSnakeCase();               // Returns ""node_2d""
""2nd place"".ToSnakeCase();            // Returns ""2_nd_place""
""Texture3DAssetFolder"".ToSnakeCase(); // Returns ""texture_3d_asset_folder""
[/csharp]
[/codeblocks] *)

    val split :
      BuiltinClass0.String.t structure ptr ->
      BuiltinClass0.Bool.t structure ptr ->
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.String.t structure ptr ->
      BuiltinClass0.PackedStringArray.t structure ptr
    (** Splits the string using a [param delimiter] and returns an array of the substrings. If [param delimiter] is an empty string, each substring will be a single character. This method is the opposite of [method join].
If [param allow_empty] is [code]false[/code], empty strings between adjacent delimiters are excluded from the array.
If [param maxsplit] is greater than [code]0[/code], the number of splits may not exceed [param maxsplit]. By default, the entire string is split.
[b]Example:[/b]
[codeblocks]
[gdscript]
var some_array = ""One,Two,Three,Four"".split("","", true, 2)

print(some_array.size()) # Prints 3
print(some_array[0])     # Prints ""One""
print(some_array[1])     # Prints ""Two""
print(some_array[2])     # Prints ""Three,Four""
[/gdscript]
[csharp]
// C#'s `Split()` does not support the `maxsplit` parameter.
var someArray = ""One,Two,Three"".Split("","");

GD.Print(someArray[0]); // Prints ""One""
GD.Print(someArray[1]); // Prints ""Two""
GD.Print(someArray[2]); // Prints ""Three""
[/csharp]
[/codeblocks]
[b]Note:[/b] If you only need one substring from the array, consider using [method get_slice] which is faster. If you need to split strings with more complex rules, use the [RegEx] class instead. *)

    val rsplit :
      BuiltinClass0.String.t structure ptr ->
      BuiltinClass0.Bool.t structure ptr ->
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.String.t structure ptr ->
      BuiltinClass0.PackedStringArray.t structure ptr
    (** Splits the string using a [param delimiter] and returns an array of the substrings, starting from the end of the string. The splits in the returned array appear in the same order as the original string. If [param delimiter] is an empty string, each substring will be a single character.
If [param allow_empty] is [code]false[/code], empty strings between adjacent delimiters are excluded from the array.
If [param maxsplit] is greater than [code]0[/code], the number of splits may not exceed [param maxsplit]. By default, the entire string is split, which is mostly identical to [method split].
[b]Example:[/b]
[codeblocks]
[gdscript]
var some_string = ""One,Two,Three,Four""
var some_array = some_string.rsplit("","", true, 1)

print(some_array.size()) # Prints 2
print(some_array[0])     # Prints ""One,Two,Three""
print(some_array[1])     # Prints ""Four""
[/gdscript]
[csharp]
// In C#, there is no String.RSplit() method.
[/csharp]
[/codeblocks] *)

    val split_floats :
      BuiltinClass0.String.t structure ptr ->
      BuiltinClass0.Bool.t structure ptr ->
      BuiltinClass0.String.t structure ptr ->
      BuiltinClass0.PackedFloat64Array.t structure ptr
    (** Splits the string into floats by using a [param delimiter] and returns a [PackedFloat64Array].
If [param allow_empty] is [code]false[/code], empty or invalid [float] conversions between adjacent delimiters are excluded.
[codeblock]
var a = ""1,2,4.5"".split_floats("","")         # a is [1.0, 2.0, 4.5]
var c = ""1| ||4.5"".split_floats(""|"")        # c is [1.0, 0.0, 0.0, 4.5]
var b = ""1| ||4.5"".split_floats(""|"", false) # b is [1.0, 4.5]
[/codeblock] *)

    val join :
      BuiltinClass0.PackedStringArray.t structure ptr ->
      BuiltinClass0.String.t structure ptr ->
      BuiltinClass0.String.t structure ptr
    (** Returns the concatenation of [param parts]' elements, with each element separated by the string calling this method. This method is the opposite of [method split].
[b]Example:[/b]
[codeblocks]
[gdscript]
var fruits = [""Apple"", ""Orange"", ""Pear"", ""Kiwi""]

print("", "".join(fruits))  # Prints ""Apple, Orange, Pear, Kiwi""
print(""---"".join(fruits)) # Prints ""Apple---Orange---Pear---Kiwi""
[/gdscript]
[csharp]
var fruits = new string[] {""Apple"", ""Orange"", ""Pear"", ""Kiwi""};

// In C#, this method is static.
GD.Print(string.Join("", "", fruits));  // Prints ""Apple, Orange, Pear, Kiwi""
GD.Print(string.Join(""---"", fruits)); // Prints ""Apple---Orange---Pear---Kiwi""
[/csharp]
[/codeblocks] *)

    val to_upper :
      BuiltinClass0.String.t structure ptr ->
      BuiltinClass0.String.t structure ptr
    (** Returns the string converted to [code]UPPERCASE[/code]. *)

    val to_lower :
      BuiltinClass0.String.t structure ptr ->
      BuiltinClass0.String.t structure ptr
    (** Returns the string converted to [code]lowercase[/code]. *)

    val left :
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.String.t structure ptr ->
      BuiltinClass0.String.t structure ptr
    (** Returns the first [param length] characters from the beginning of the string. If [param length] is negative, strips the last [param length] characters from the string's end.
[codeblock]
print(""Hello World!"".left(3))  # Prints ""Hel""
print(""Hello World!"".left(-4)) # Prints ""Hello Wo""
[/codeblock] *)

    val right :
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.String.t structure ptr ->
      BuiltinClass0.String.t structure ptr
    (** Returns the last [param length] characters from the end of the string. If [param length] is negative, strips the first [param length] characters from the string's beginning.
[codeblock]
print(""Hello World!"".right(3))  # Prints ""ld!""
print(""Hello World!"".right(-4)) # Prints ""o World!""
[/codeblock] *)

    val strip_edges :
      BuiltinClass0.Bool.t structure ptr ->
      BuiltinClass0.Bool.t structure ptr ->
      BuiltinClass0.String.t structure ptr ->
      BuiltinClass0.String.t structure ptr
    (** Strips all non-printable characters from the beginning and the end of the string. These include spaces, tabulations ([code]\t[/code]), and newlines ([code]\n[/code] [code]\r[/code]).
If [param left] is [code]false[/code], ignores the string's beginning. Likewise, if [param right] is [code]false[/code], ignores the string's end. *)

    val strip_escapes :
      BuiltinClass0.String.t structure ptr ->
      BuiltinClass0.String.t structure ptr
    (** Strips all escape characters from the string. These include all non-printable control characters of the first page of the ASCII table (values from 0 to 31), such as tabulation ([code]\t[/code]) and newline ([code]\n[/code], [code]\r[/code]) characters, but [i]not[/i] spaces. *)

    val lstrip :
      BuiltinClass0.String.t structure ptr ->
      BuiltinClass0.String.t structure ptr ->
      BuiltinClass0.String.t structure ptr
    (** Removes a set of characters defined in [param chars] from the string's beginning. See also [method rstrip].
[b]Note:[/b] [param chars] is not a prefix. Use [method trim_prefix] to remove a single prefix, rather than a set of characters. *)

    val rstrip :
      BuiltinClass0.String.t structure ptr ->
      BuiltinClass0.String.t structure ptr ->
      BuiltinClass0.String.t structure ptr
    (** Removes a set of characters defined in [param chars] from the string's end. See also [method lstrip].
[b]Note:[/b] [param chars] is not a suffix. Use [method trim_suffix] to remove a single suffix, rather than a set of characters. *)

    val get_extension :
      BuiltinClass0.String.t structure ptr ->
      BuiltinClass0.String.t structure ptr
    (** If the string is a valid file name or path, returns the file extension without the leading period ([code].[/code]). Otherwise, returns an empty string.
[codeblock]
var a = ""/path/to/file.txt"".get_extension() # a is ""txt""
var b = ""cool.txt"".get_extension()          # b is ""txt""
var c = ""cool.font.tres"".get_extension()    # c is ""tres""
var d = "".pack1"".get_extension()            # d is ""pack1""

var e = ""file.txt."".get_extension()  # e is """"
var f = ""file.txt.."".get_extension() # f is """"
var g = ""txt"".get_extension()        # g is """"
var h = """".get_extension()           # h is """"
[/codeblock] *)

    val get_basename :
      BuiltinClass0.String.t structure ptr ->
      BuiltinClass0.String.t structure ptr
    (** If the string is a valid file path, returns the full file path, without the extension.
[codeblock]
var base = ""/path/to/file.txt"".get_basename() # base is ""/path/to/file""
[/codeblock] *)

    val path_join :
      BuiltinClass0.String.t structure ptr ->
      BuiltinClass0.String.t structure ptr ->
      BuiltinClass0.String.t structure ptr
    (** Concatenates [param file] at the end of the string as a subpath, adding [code]/[/code] if necessary.
[b]Example:[/b] [code]""this/is"".path_join(""path"") == ""this/is/path""[/code]. *)

    val unicode_at :
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.String.t structure ptr ->
      BuiltinClass0.Int.t structure ptr
    (** Returns the character code at position [param at]. *)

    val indent :
      BuiltinClass0.String.t structure ptr ->
      BuiltinClass0.String.t structure ptr ->
      BuiltinClass0.String.t structure ptr
    (** Indents every line of the string with the given [param prefix]. Empty lines are not indented. See also [method dedent] to remove indentation.
For example, the string can be indented with two tabulations using [code]""\t\t""[/code], or four spaces using [code]""    ""[/code]. *)

    val dedent :
      BuiltinClass0.String.t structure ptr ->
      BuiltinClass0.String.t structure ptr
    (** Returns a copy of the string with indentation (leading tabs and spaces) removed. See also [method indent] to add indentation. *)

    val hash :
      BuiltinClass0.String.t structure ptr -> BuiltinClass0.Int.t structure ptr
    (** Returns the 32-bit hash value representing the string's contents.
[b]Note:[/b] Strings with equal hash values are [i]not[/i] guaranteed to be the same, as a result of hash collisions. On the contrary, strings with different hash values are guaranteed to be different. *)

    val md5_text :
      BuiltinClass0.String.t structure ptr ->
      BuiltinClass0.String.t structure ptr
    (** Returns the [url=https://en.wikipedia.org/wiki/MD5]MD5 hash[/url] of the string as another [String]. *)

    val sha1_text :
      BuiltinClass0.String.t structure ptr ->
      BuiltinClass0.String.t structure ptr
    (** Returns the [url=https://en.wikipedia.org/wiki/SHA-1]SHA-1[/url] hash of the string as another [String]. *)

    val sha256_text :
      BuiltinClass0.String.t structure ptr ->
      BuiltinClass0.String.t structure ptr
    (** Returns the [url=https://en.wikipedia.org/wiki/SHA-2]SHA-256[/url] hash of the string as another [String]. *)

    val md5_buffer :
      BuiltinClass0.String.t structure ptr ->
      BuiltinClass0.PackedByteArray.t structure ptr
    (** Returns the [url=https://en.wikipedia.org/wiki/MD5]MD5 hash[/url] of the string as a [PackedByteArray]. *)

    val sha1_buffer :
      BuiltinClass0.String.t structure ptr ->
      BuiltinClass0.PackedByteArray.t structure ptr
    (** Returns the [url=https://en.wikipedia.org/wiki/SHA-1]SHA-1[/url] hash of the string as a [PackedByteArray]. *)

    val sha256_buffer :
      BuiltinClass0.String.t structure ptr ->
      BuiltinClass0.PackedByteArray.t structure ptr
    (** Returns the [url=https://en.wikipedia.org/wiki/SHA-2]SHA-256[/url] hash of the string as a [PackedByteArray]. *)

    val is_empty :
      BuiltinClass0.String.t structure ptr -> BuiltinClass0.Bool.t structure ptr
    (** Returns [code]true[/code] if the string's length is [code]0[/code] ([code]""""[/code]). See also [method length]. *)

    val contains :
      BuiltinClass0.String.t structure ptr ->
      BuiltinClass0.String.t structure ptr ->
      BuiltinClass0.Bool.t structure ptr
    (** Returns [code]true[/code] if the string contains [param what]. In GDScript, this corresponds to the [code]in[/code] operator.
[codeblocks]
[gdscript]
print(""Node"".contains(""de"")) # Prints true
print(""team"".contains(""I""))  # Prints false
print(""I"" in ""team"")         # Prints false
[/gdscript]
[csharp]
GD.Print(""Node"".Contains(""de"")); // Prints true
GD.Print(""team"".Contains(""I""));  // Prints false
[/csharp]
[/codeblocks]
If you need to know where [param what] is within the string, use [method find]. *)

    val is_absolute_path :
      BuiltinClass0.String.t structure ptr -> BuiltinClass0.Bool.t structure ptr
    (** Returns [code]true[/code] if the string is a path to a file or directory, and its starting point is explicitly defined. This method is the opposite of [method is_relative_path].
This includes all paths starting with [code]""res://""[/code], [code]""user://""[/code], [code]""C:\""[/code], [code]""/""[/code], etc. *)

    val is_relative_path :
      BuiltinClass0.String.t structure ptr -> BuiltinClass0.Bool.t structure ptr
    (** Returns [code]true[/code] if the string is a path, and its starting point is dependent on context. The path could begin from the current directory, or the current [Node] (if the string is derived from a [NodePath]), and may sometimes be prefixed with [code]""./""[/code]. This method is the opposite of [method is_absolute_path]. *)

    val simplify_path :
      BuiltinClass0.String.t structure ptr ->
      BuiltinClass0.String.t structure ptr
    (** If the string is a valid file path, converts the string into a canonical path. This is the shortest possible path, without [code]""./""[/code], and all the unnecessary [code]""..""[/code] and [code]""/""[/code].
[codeblock]
var simple_path = ""./path/to///../file"".simplify_path()
print(simple_path) # Prints ""path/file""
[/codeblock] *)

    val get_base_dir :
      BuiltinClass0.String.t structure ptr ->
      BuiltinClass0.String.t structure ptr
    (** If the string is a valid file path, returns the base directory name.
[codeblock]
var dir_path = ""/path/to/file.txt"".get_base_dir() # dir_path is ""/path/to""
[/codeblock] *)

    val get_file :
      BuiltinClass0.String.t structure ptr ->
      BuiltinClass0.String.t structure ptr
    (** If the string is a valid file path, returns the file name, including the extension.
[codeblock]
var file = ""/path/to/icon.png"".get_file() # file is ""icon.png""
[/codeblock] *)

    val xml_escape :
      BuiltinClass0.Bool.t structure ptr ->
      BuiltinClass0.String.t structure ptr ->
      BuiltinClass0.String.t structure ptr
    (** Returns a copy of the string with special characters escaped using the XML standard. If [param escape_quotes] is [code]true[/code], the single quote ([code]'[/code]) and double quote ([code]""[/code]) characters are also escaped. *)

    val xml_unescape :
      BuiltinClass0.String.t structure ptr ->
      BuiltinClass0.String.t structure ptr
    (** Returns a copy of the string with escaped characters replaced by their meanings according to the XML standard. *)

    val uri_encode :
      BuiltinClass0.String.t structure ptr ->
      BuiltinClass0.String.t structure ptr
    (** Encodes the string to URL-friendly format. This method is meant to properly encode the parameters in a URL when sending an HTTP request. See also [method uri_decode].
[codeblocks]
[gdscript]
var prefix = ""$DOCS_URL/?highlight=""
var url = prefix + ""Godot Engine:docs"".uri_encode()

print(url) # Prints ""$DOCS_URL/?highlight=Godot%20Engine%3%docs""
[/gdscript]
[csharp]
var prefix = ""$DOCS_URL/?highlight="";
var url = prefix + ""Godot Engine:docs"".URIEncode();

GD.Print(url); // Prints ""$DOCS_URL/?highlight=Godot%20Engine%3%docs""
[/csharp]
[/codeblocks] *)

    val uri_decode :
      BuiltinClass0.String.t structure ptr ->
      BuiltinClass0.String.t structure ptr
    (** Decodes the string from its URL-encoded format. This method is meant to properly decode the parameters in a URL when receiving an HTTP request. See also [method uri_encode].
[codeblocks]
[gdscript]
var url = ""$DOCS_URL/?highlight=Godot%20Engine%3%docs""
print(url.uri_decode()) # Prints ""$DOCS_URL/?highlight=Godot Engine:docs""
[/gdscript]
[csharp]
var url = ""$DOCS_URL/?highlight=Godot%20Engine%3%docs""
GD.Print(url.URIDecode()) // Prints ""$DOCS_URL/?highlight=Godot Engine:docs""
[/csharp]
[/codeblocks] *)

    val c_escape :
      BuiltinClass0.String.t structure ptr ->
      BuiltinClass0.String.t structure ptr
    (** Returns a copy of the string with special characters escaped using the C language standard. *)

    val c_unescape :
      BuiltinClass0.String.t structure ptr ->
      BuiltinClass0.String.t structure ptr
    (** Returns a copy of the string with escaped characters replaced by their meanings. Supported escape sequences are [code]\'[/code], [code]\""[/code], [code]\\[/code], [code]\a[/code], [code]\b[/code], [code]\f[/code], [code]\n[/code], [code]\r[/code], [code]\t[/code], [code]\v[/code].
[b]Note:[/b] Unlike the GDScript parser, this method doesn't support the [code]\uXXXX[/code] escape sequence. *)

    val json_escape :
      BuiltinClass0.String.t structure ptr ->
      BuiltinClass0.String.t structure ptr
    (** Returns a copy of the string with special characters escaped using the JSON standard. Because it closely matches the C standard, it is possible to use [method c_unescape] to unescape the string, if necessary. *)

    val validate_node_name :
      BuiltinClass0.String.t structure ptr ->
      BuiltinClass0.String.t structure ptr
    (** Returns a copy of the string with all characters that are not allowed in [member Node.name] ([code].[/code] [code]:[/code] [code]@[/code] [code]/[/code] [code]""[/code] [code]%[/code]) replaced with underscores. *)

    val validate_filename :
      BuiltinClass0.String.t structure ptr ->
      BuiltinClass0.String.t structure ptr
    (** Returns a copy of the string with all characters that are not allowed in [method is_valid_filename] replaced with underscores. *)

    val is_valid_identifier :
      BuiltinClass0.String.t structure ptr -> BuiltinClass0.Bool.t structure ptr
    (** Returns [code]true[/code] if this string is a valid identifier. A valid identifier may contain only letters, digits and underscores ([code]_[/code]), and the first character may not be a digit.
[codeblock]
print(""node_2d"".is_valid_identifier())    # Prints true
print(""TYPE_FLOAT"".is_valid_identifier()) # Prints true
print(""1st_method"".is_valid_identifier()) # Prints false
print(""MyMethod#2"".is_valid_identifier()) # Prints false
[/codeblock] *)

    val is_valid_int :
      BuiltinClass0.String.t structure ptr -> BuiltinClass0.Bool.t structure ptr
    (** Returns [code]true[/code] if this string represents a valid integer. A valid integer only contains digits, and may be prefixed with a positive ([code]+[/code]) or negative ([code]-[/code]) sign. See also [method to_int].
[codeblock]
print(""7"".is_valid_int())    # Prints true
print(""1.65"".is_valid_int()) # Prints false
print(""Hi"".is_valid_int())   # Prints false
print(""+3"".is_valid_int())   # Prints true
print(""-12"".is_valid_int())  # Prints true
[/codeblock] *)

    val is_valid_float :
      BuiltinClass0.String.t structure ptr -> BuiltinClass0.Bool.t structure ptr
    (** Returns [code]true[/code] if this string represents a valid floating-point number. A valid float may contain only digits, one decimal point ([code].[/code]), and the exponent letter ([code]e[/code]). It may also be prefixed with a positive ([code]+[/code]) or negative ([code]-[/code]) sign. Any valid integer is also a valid float (see [method is_valid_int]). See also [method to_float].
[codeblock]
print(""1.7"".is_valid_float())   # Prints true
print(""24"".is_valid_float())    # Prints true
print(""7e3"".is_valid_float())   # Prints true
print(""Hello"".is_valid_float()) # Prints false
[/codeblock] *)

    val is_valid_hex_number :
      BuiltinClass0.Bool.t structure ptr ->
      BuiltinClass0.String.t structure ptr ->
      BuiltinClass0.Bool.t structure ptr
    (** Returns [code]true[/code] if this string is a valid hexadecimal number. A valid hexadecimal number only contains digits or letters [code]A[/code] to [code]F[/code] (either uppercase or lowercase), and may be prefixed with a positive ([code]+[/code]) or negative ([code]-[/code]) sign.
If [param with_prefix] is [code]true[/code], the hexadecimal number needs to prefixed by [code]""0x""[/code] to be considered valid.
[codeblock]
print(""A08E"".is_valid_hex_number())    # Prints true
print(""-AbCdEf"".is_valid_hex_number()) # Prints true
print(""2.5"".is_valid_hex_number())     # Prints false

print(""0xDEADC0DE"".is_valid_hex_number(true)) # Prints true
[/codeblock] *)

    val is_valid_html_color :
      BuiltinClass0.String.t structure ptr -> BuiltinClass0.Bool.t structure ptr
    (** Returns [code]true[/code] if this string is a valid color in hexadecimal HTML notation. The string must be a hexadecimal value (see [method is_valid_hex_number]) of either 3, 4, 6 or 8 digits, and may be prefixed by a hash sign ([code]#[/code]). Other HTML notations for colors, such as names or [code]hsl()[/code], are not considered valid. See also [method Color.html]. *)

    val is_valid_ip_address :
      BuiltinClass0.String.t structure ptr -> BuiltinClass0.Bool.t structure ptr
    (** Returns [code]true[/code] if this string represents a well-formatted IPv4 or IPv6 address. This method considers [url=https://en.wikipedia.org/wiki/Reserved_IP_addresses]reserved IP addresses[/url] such as [code]""0.0.0.0""[/code] and [code]""ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff""[/code] as valid. *)

    val is_valid_filename :
      BuiltinClass0.String.t structure ptr -> BuiltinClass0.Bool.t structure ptr
    (** Returns [code]true[/code] if this string does not contain characters that are not allowed in file names ([code]:[/code] [code]/[/code] [code]\[/code] [code]?[/code] [code] * [/code] [code]""[/code] [code]|[/code] [code]%[/code] [code]<[/code] [code]>[/code]). *)

    val to_int :
      BuiltinClass0.String.t structure ptr -> BuiltinClass0.Int.t structure ptr
    (** Converts the string representing an integer number into an [int]. This method removes any non-number character and stops at the first decimal point ([code].[/code]). See also [method is_valid_int].
[codeblock]
var a = ""123"".to_int()    # a is 123
var b = ""x1y2z3"".to_int() # b is 123
var c = ""-1.2.3"".to_int() # c is -1
var d = ""Hello!"".to_int() # d is 0
[/codeblock] *)

    val to_float :
      BuiltinClass0.String.t structure ptr ->
      BuiltinClass0.Float.t structure ptr
    (** Converts the string representing a decimal number into a [float]. This method stops on the first non-number character, except the first decimal point ([code].[/code]) and the exponent letter ([code]e[/code]). See also [method is_valid_float].
[codeblock]
var a = ""12.35"".to_float()  # a is 12.35
var b = ""1.2.3"".to_float()  # b is 1.2
var c = ""12xy3"".to_float()  # c is 12.0
var d = ""1e3"".to_float()    # d is 1000.0
var e = ""Hello!"".to_float() # e is 0.0
[/codeblock] *)

    val hex_to_int :
      BuiltinClass0.String.t structure ptr -> BuiltinClass0.Int.t structure ptr
    (** Converts the string representing a hexadecimal number into an [int]. The string may be optionally prefixed with [code]""0x""[/code], and an additional [code]-[/code] prefix for negative numbers.
[codeblocks]
[gdscript]
print(""0xff"".hex_to_int()) # Prints 255
print(""ab"".hex_to_int())   # Prints 171
[/gdscript]
[csharp]
GD.Print(""0xff"".HexToInt()); // Prints 255
GD.Print(""ab"".HexToInt());   // Prints 171
[/csharp]
[/codeblocks] *)

    val bin_to_int :
      BuiltinClass0.String.t structure ptr -> BuiltinClass0.Int.t structure ptr
    (** Converts the string representing a binary number into an [int]. The string may optionally be prefixed with [code]""0b""[/code], and an additional [code]-[/code] prefix for negative numbers.
[codeblocks]
[gdscript]
print(""101"".bin_to_int())   # Prints 5
print(""0b101"".bin_to_int()) # Prints 5
print(""-0b10"".bin_to_int()) # Prints -2
[/gdscript]
[csharp]
GD.Print(""101"".BinToInt());   // Prints 5
GD.Print(""0b101"".BinToInt()); // Prints 5
GD.Print(""-0b10"".BinToInt()); // Prints -2
[/csharp]
[/codeblocks] *)

    val lpad :
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.String.t structure ptr ->
      BuiltinClass0.String.t structure ptr ->
      BuiltinClass0.String.t structure ptr
    (** Formats the string to be at least [param min_length] long by adding [param character]s to the left of the string, if necessary. See also [method rpad]. *)

    val rpad :
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.String.t structure ptr ->
      BuiltinClass0.String.t structure ptr ->
      BuiltinClass0.String.t structure ptr
    (** Formats the string to be at least [param min_length] long, by adding [param character]s to the right of the string, if necessary. See also [method lpad]. *)

    val pad_decimals :
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.String.t structure ptr ->
      BuiltinClass0.String.t structure ptr
    (** Formats the string representing a number to have an exact number of [param digits] [i]after[/i] the decimal point. *)

    val pad_zeros :
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.String.t structure ptr ->
      BuiltinClass0.String.t structure ptr
    (** Formats the string representing a number to have an exact number of [param digits] [i]before[/i] the decimal point. *)

    val trim_prefix :
      BuiltinClass0.String.t structure ptr ->
      BuiltinClass0.String.t structure ptr ->
      BuiltinClass0.String.t structure ptr
    (** Removes the given [param prefix] from the start of the string, or returns the string unchanged. *)

    val trim_suffix :
      BuiltinClass0.String.t structure ptr ->
      BuiltinClass0.String.t structure ptr ->
      BuiltinClass0.String.t structure ptr
    (** Removes the given [param suffix] from the end of the string, or returns the string unchanged. *)

    val to_ascii_buffer :
      BuiltinClass0.String.t structure ptr ->
      BuiltinClass0.PackedByteArray.t structure ptr
    (** Converts the string to an [url=https://en.wikipedia.org/wiki/ASCII]ASCII[/url]/Latin-1 encoded [PackedByteArray]. This method is slightly faster than [method to_utf8_buffer], but replaces all unsupported characters with spaces. This is the inverse of [method PackedByteArray.get_string_from_ascii]. *)

    val to_utf8_buffer :
      BuiltinClass0.String.t structure ptr ->
      BuiltinClass0.PackedByteArray.t structure ptr
    (** Converts the string to a [url=https://en.wikipedia.org/wiki/UTF-8]UTF-8[/url] encoded [PackedByteArray]. This method is slightly slower than [method to_ascii_buffer], but supports all UTF-8 characters. For most cases, prefer using this method. This is the inverse of [method PackedByteArray.get_string_from_utf8]. *)

    val to_utf16_buffer :
      BuiltinClass0.String.t structure ptr ->
      BuiltinClass0.PackedByteArray.t structure ptr
    (** Converts the string to a [url=https://en.wikipedia.org/wiki/UTF-16]UTF-16[/url] encoded [PackedByteArray]. This is the inverse of [method PackedByteArray.get_string_from_utf16]. *)

    val to_utf32_buffer :
      BuiltinClass0.String.t structure ptr ->
      BuiltinClass0.PackedByteArray.t structure ptr
    (** Converts the string to a [url=https://en.wikipedia.org/wiki/UTF-32]UTF-32[/url] encoded [PackedByteArray]. This is the inverse of [method PackedByteArray.get_string_from_utf32]. *)

    val hex_decode :
      BuiltinClass0.String.t structure ptr ->
      BuiltinClass0.PackedByteArray.t structure ptr
    (** Decodes a hexadecimal string as a [PackedByteArray].
[codeblocks]
[gdscript]
var text = ""hello world""
var encoded = text.to_utf8_buffer().hex_encode() # outputs ""68656c6c6f20776f726c64""
print(buf.hex_decode().get_string_from_utf8())
[/gdscript]
[csharp]
var text = ""hello world"";
var encoded = text.ToUtf8Buffer().HexEncode(); // outputs ""68656c6c6f20776f726c64""
GD.Print(buf.HexDecode().GetStringFromUtf8());
[/csharp]
[/codeblocks] *)

    val to_wchar_buffer :
      BuiltinClass0.String.t structure ptr ->
      BuiltinClass0.PackedByteArray.t structure ptr
    (** Converts the string to a [url=https://en.wikipedia.org/wiki/Wide_character]wide character[/url] ([code]wchar_t[/code], UTF-16 on Windows, UTF-32 on other platforms) encoded [PackedByteArray]. This is the inverse of [method PackedByteArray.get_string_from_wchar]. *)

    val num_scientific :
      BuiltinClass0.Float.t structure ptr ->
      BuiltinClass0.String.t structure ptr
    (** Converts the given [param number] to a string representation, in scientific notation.
[codeblocks]
[gdscript]
var n = -5.2e8
print(n)                        # Prints -520000000
print(String.num_scientific(n)) # Prints -5.2e+08
[/gdscript]
[csharp]
// This method is not implemented in C#.
// Use `string.ToString()` with ""e"" to achieve similar results.
var n = -5.2e8f;
GD.Print(n);                // Prints -520000000
GD.Print(n.ToString(""e1"")); // Prints -5.2e+008
[/csharp]
[/codeblocks]
[b]Note:[/b] In C#, this method is not implemented. To achieve similar results, see C#'s [url=https://learn.microsoft.com/en-us/dotnet/standard/base-types/standard-numeric-format-strings]Standard numeric format strings[/url] *)

    val num :
      BuiltinClass0.Float.t structure ptr ->
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.String.t structure ptr
    (** Converts a [float] to a string representation of a decimal number, with the number of decimal places specified in [param decimals].
If [param decimals] is [code]-1[/code] as by default, the string representation may only have up to 14 significant digits, with digits before the decimal point having priority over digits after.
Trailing zeros are not included in the string. The last digit is rounded, not truncated.
[b]Example:[/b]
[codeblock]
String.num(3.141593)     # Returns ""3.141593""
String.num(3.141593, 3)  # Returns ""3.142""
String.num(3.14159300)   # Returns ""3.141593""

# Here, the last digit will be rounded up,
# which reduces the total digit count, since trailing zeros are removed:
String.num(42.129999, 5) # Returns ""42.13""

# If `decimals` is not specified, the maximum number of significant digits is 14:
String.num(-0.0000012345432123454321)     # Returns ""-0.00000123454321""
String.num(-10000.0000012345432123454321) # Returns ""-10000.0000012345""
[/codeblock] *)

    val num_int64 :
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.Bool.t structure ptr ->
      BuiltinClass0.String.t structure ptr
    (** Converts the given [param number] to a string representation, with the given [param base].
By default, [param base] is set to decimal ([code]10[/code]). Other common bases in programming include binary ([code]2[/code]), [url=https://en.wikipedia.org/wiki/Octal]octal[/url] ([code]8[/code]), hexadecimal ([code]16[/code]).
If [param capitalize_hex] is [code]true[/code], digits higher than 9 are represented in uppercase. *)

    val num_uint64 :
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.Bool.t structure ptr ->
      BuiltinClass0.String.t structure ptr
    (** Converts the given unsigned [int] to a string representation, with the given [param base].
By default, [param base] is set to decimal ([code]10[/code]). Other common bases in programming include binary ([code]2[/code]), [url=https://en.wikipedia.org/wiki/Octal]octal[/url] ([code]8[/code]), hexadecimal ([code]16[/code]).
If [param capitalize_hex] is [code]true[/code], digits higher than 9 are represented in uppercase. *)

    val chr :
      BuiltinClass0.Int.t structure ptr -> BuiltinClass0.String.t structure ptr
    (** Returns a single Unicode character from the decimal [param char]. You may use [url=https://unicodelookup.com/]unicodelookup.com[/url] or [url=https://www.unicode.org/charts/]unicode.org[/url] as points of reference.
[codeblock]
print(String.chr(65))     # Prints ""A""
print(String.chr(129302)) # Prints ""🤖"" (robot face emoji)
[/codeblock] *)

    val humanize_size :
      BuiltinClass0.Int.t structure ptr -> BuiltinClass0.String.t structure ptr
    (** Converts [param size] which represents a number of bytes into a human-readable form.
The result is in [url=https://en.wikipedia.org/wiki/Binary_prefix#IEC_prefixes]IEC prefix format[/url], which may end in either [code]""B""[/code], [code]""KiB""[/code], [code]""MiB""[/code], [code]""GiB""[/code], [code]""TiB""[/code], [code]""PiB""[/code], or [code]""EiB""[/code]. *)

    val not :
      String.t structure ptr ->
      String.t structure ptr ->
      Bool.t structure ptr ->
      unit

    val ( = ) :
      String.t structure ptr ->
      String.t structure ptr ->
      Bool.t structure ptr ->
      unit
    (** Returns [code]true[/code] if both strings contain the same sequence of characters. *)

    val ( <> ) :
      String.t structure ptr ->
      String.t structure ptr ->
      Bool.t structure ptr ->
      unit
    (** Returns [code]true[/code] if both strings do not contain the same sequence of characters. *)

    val ( < ) :
      String.t structure ptr ->
      String.t structure ptr ->
      Bool.t structure ptr ->
      unit
    (** Returns [code]true[/code] if the left [String] comes before [param right] in [url=https://en.wikipedia.org/wiki/List_of_Unicode_characters]Unicode order[/url], which roughly matches the alphabetical order. Useful for sorting. *)

    val ( <= ) :
      String.t structure ptr ->
      String.t structure ptr ->
      Bool.t structure ptr ->
      unit
    (** Returns [code]true[/code] if the left [String] comes before [param right] in [url=https://en.wikipedia.org/wiki/List_of_Unicode_characters]Unicode order[/url], which roughly matches the alphabetical order, or if both are equal. *)

    val ( > ) :
      String.t structure ptr ->
      String.t structure ptr ->
      Bool.t structure ptr ->
      unit
    (** Returns [code]true[/code] if the left [String] comes after [param right] in [url=https://en.wikipedia.org/wiki/List_of_Unicode_characters]Unicode order[/url], which roughly matches the alphabetical order. Useful for sorting. *)

    val ( >= ) :
      String.t structure ptr ->
      String.t structure ptr ->
      Bool.t structure ptr ->
      unit
    (** Returns [code]true[/code] if the left [String] comes after [param right] in [url=https://en.wikipedia.org/wiki/List_of_Unicode_characters]Unicode order[/url], which roughly matches the alphabetical order, or if both are equal. *)

    val ( + ) :
      String.t structure ptr ->
      String.t structure ptr ->
      String.t structure ptr ->
      unit
    (** Appends [param right] at the end of this [String], also known as a string concatenation. *)

    val ( % ) :
      String.t structure ptr ->
      String.t structure ptr ->
      String.t structure ptr ->
      unit

    val _String_elem_String :
      String.t structure ptr ->
      String.t structure ptr ->
      Bool.t structure ptr ->
      unit

    val _String_elem_StringName :
      String.t structure ptr ->
      StringName.t structure ptr ->
      Bool.t structure ptr ->
      unit

    val _String_elem_Object :
      String.t structure ptr ->
      Object.t structure ptr ->
      Bool.t structure ptr ->
      unit

    val _String_elem_Dictionary :
      String.t structure ptr ->
      Dictionary.t structure ptr ->
      Bool.t structure ptr ->
      unit

    val _String_elem_Array :
      String.t structure ptr ->
      Array.t structure ptr ->
      Bool.t structure ptr ->
      unit

    val _String_elem_PackedStringArray :
      String.t structure ptr ->
      PackedStringArray.t structure ptr ->
      Bool.t structure ptr ->
      unit
  end

  module type VECTOR2 = sig
    type t

    include Api_types.API_TYPE with type t := t

    val angle :
      BuiltinClass0.Vector2.t structure ptr ->
      BuiltinClass0.Float.t structure ptr
    (** Returns this vector's angle with respect to the positive X axis, or [code](1, 0)[/code] vector, in radians.
For example, [code]Vector2.RIGHT.angle()[/code] will return zero, [code]Vector2.DOWN.angle()[/code] will return [code]PI / 2[/code] (a quarter turn, or 90 degrees), and [code]Vector2(1, -1).angle()[/code] will return [code]-PI / 4[/code] (a negative eighth turn, or -45 degrees).
[url=https://raw.githubusercontent.com/godotengine/godot-docs/master/img/vector2_angle.png]Illustration of the returned angle.[/url]
Equivalent to the result of [method @GlobalScope.atan2] when called with the vector's [member y] and [member x] as parameters: [code]atan2(y, x)[/code]. *)

    val angle_to :
      BuiltinClass0.Vector2.t structure ptr ->
      BuiltinClass0.Vector2.t structure ptr ->
      BuiltinClass0.Float.t structure ptr
    (** Returns the angle to the given vector, in radians.
[url=https://raw.githubusercontent.com/godotengine/godot-docs/master/img/vector2_angle_to.png]Illustration of the returned angle.[/url] *)

    val angle_to_point :
      BuiltinClass0.Vector2.t structure ptr ->
      BuiltinClass0.Vector2.t structure ptr ->
      BuiltinClass0.Float.t structure ptr
    (** Returns the angle between the line connecting the two points and the X axis, in radians.
[code]a.angle_to_point(b)[/code] is equivalent of doing [code](b - a).angle()[/code].
[url=https://raw.githubusercontent.com/godotengine/godot-docs/master/img/vector2_angle_to_point.png]Illustration of the returned angle.[/url] *)

    val direction_to :
      BuiltinClass0.Vector2.t structure ptr ->
      BuiltinClass0.Vector2.t structure ptr ->
      BuiltinClass0.Vector2.t structure ptr
    (** Returns the normalized vector pointing from this vector to [param to]. This is equivalent to using [code](b - a).normalized()[/code]. *)

    val distance_to :
      BuiltinClass0.Vector2.t structure ptr ->
      BuiltinClass0.Vector2.t structure ptr ->
      BuiltinClass0.Float.t structure ptr
    (** Returns the distance between this vector and [param to]. *)

    val distance_squared_to :
      BuiltinClass0.Vector2.t structure ptr ->
      BuiltinClass0.Vector2.t structure ptr ->
      BuiltinClass0.Float.t structure ptr
    (** Returns the squared distance between this vector and [param to].
This method runs faster than [method distance_to], so prefer it if you need to compare vectors or need the squared distance for some formula. *)

    val length :
      BuiltinClass0.Vector2.t structure ptr ->
      BuiltinClass0.Float.t structure ptr
    (** Returns the length (magnitude) of this vector. *)

    val length_squared :
      BuiltinClass0.Vector2.t structure ptr ->
      BuiltinClass0.Float.t structure ptr
    (** Returns the squared length (squared magnitude) of this vector.
This method runs faster than [method length], so prefer it if you need to compare vectors or need the squared distance for some formula. *)

    val limit_length :
      BuiltinClass0.Float.t structure ptr ->
      BuiltinClass0.Vector2.t structure ptr ->
      BuiltinClass0.Vector2.t structure ptr
    (** Returns the vector with a maximum length by limiting its length to [param length]. *)

    val normalized :
      BuiltinClass0.Vector2.t structure ptr ->
      BuiltinClass0.Vector2.t structure ptr
    (** Returns the result of scaling the vector to unit length. Equivalent to [code]v / v.length()[/code]. See also [method is_normalized].
[b]Note:[/b] This function may return incorrect values if the input vector length is near zero. *)

    val is_normalized :
      BuiltinClass0.Vector2.t structure ptr ->
      BuiltinClass0.Bool.t structure ptr
    (** Returns [code]true[/code] if the vector is normalized, i.e. its length is approximately equal to 1. *)

    val is_equal_approx :
      BuiltinClass0.Vector2.t structure ptr ->
      BuiltinClass0.Vector2.t structure ptr ->
      BuiltinClass0.Bool.t structure ptr
    (** Returns [code]true[/code] if this vector and [param to] are approximately equal, by running [method @GlobalScope.is_equal_approx] on each component. *)

    val is_zero_approx :
      BuiltinClass0.Vector2.t structure ptr ->
      BuiltinClass0.Bool.t structure ptr
    (** Returns [code]true[/code] if this vector's values are approximately zero, by running [method @GlobalScope.is_zero_approx] on each component.
This method is faster than using [method is_equal_approx] with one value as a zero vector. *)

    val is_finite :
      BuiltinClass0.Vector2.t structure ptr ->
      BuiltinClass0.Bool.t structure ptr
    (** Returns [code]true[/code] if this vector is finite, by calling [method @GlobalScope.is_finite] on each component. *)

    val posmod :
      BuiltinClass0.Float.t structure ptr ->
      BuiltinClass0.Vector2.t structure ptr ->
      BuiltinClass0.Vector2.t structure ptr
    (** Returns a vector composed of the [method @GlobalScope.fposmod] of this vector's components and [param mod]. *)

    val posmodv :
      BuiltinClass0.Vector2.t structure ptr ->
      BuiltinClass0.Vector2.t structure ptr ->
      BuiltinClass0.Vector2.t structure ptr
    (** Returns a vector composed of the [method @GlobalScope.fposmod] of this vector's components and [param modv]'s components. *)

    val project :
      BuiltinClass0.Vector2.t structure ptr ->
      BuiltinClass0.Vector2.t structure ptr ->
      BuiltinClass0.Vector2.t structure ptr
    (** Returns the result of projecting the vector onto the given vector [param b]. *)

    val lerp :
      BuiltinClass0.Vector2.t structure ptr ->
      BuiltinClass0.Float.t structure ptr ->
      BuiltinClass0.Vector2.t structure ptr ->
      BuiltinClass0.Vector2.t structure ptr
    (** Returns the result of the linear interpolation between this vector and [param to] by amount [param weight]. [param weight] is on the range of [code]0.0[/code] to [code]1.0[/code], representing the amount of interpolation. *)

    val slerp :
      BuiltinClass0.Vector2.t structure ptr ->
      BuiltinClass0.Float.t structure ptr ->
      BuiltinClass0.Vector2.t structure ptr ->
      BuiltinClass0.Vector2.t structure ptr
    (** Returns the result of spherical linear interpolation between this vector and [param to], by amount [param weight]. [param weight] is on the range of 0.0 to 1.0, representing the amount of interpolation.
This method also handles interpolating the lengths if the input vectors have different lengths. For the special case of one or both input vectors having zero length, this method behaves like [method lerp]. *)

    val cubic_interpolate :
      BuiltinClass0.Vector2.t structure ptr ->
      BuiltinClass0.Vector2.t structure ptr ->
      BuiltinClass0.Vector2.t structure ptr ->
      BuiltinClass0.Float.t structure ptr ->
      BuiltinClass0.Vector2.t structure ptr ->
      BuiltinClass0.Vector2.t structure ptr
    (** Performs a cubic interpolation between this vector and [param b] using [param pre_a] and [param post_b] as handles, and returns the result at position [param weight]. [param weight] is on the range of 0.0 to 1.0, representing the amount of interpolation. *)

    val cubic_interpolate_in_time :
      BuiltinClass0.Vector2.t structure ptr ->
      BuiltinClass0.Vector2.t structure ptr ->
      BuiltinClass0.Vector2.t structure ptr ->
      BuiltinClass0.Float.t structure ptr ->
      BuiltinClass0.Float.t structure ptr ->
      BuiltinClass0.Float.t structure ptr ->
      BuiltinClass0.Float.t structure ptr ->
      BuiltinClass0.Vector2.t structure ptr ->
      BuiltinClass0.Vector2.t structure ptr
    (** Performs a cubic interpolation between this vector and [param b] using [param pre_a] and [param post_b] as handles, and returns the result at position [param weight]. [param weight] is on the range of 0.0 to 1.0, representing the amount of interpolation.
It can perform smoother interpolation than [method cubic_interpolate] by the time values. *)

    val bezier_interpolate :
      BuiltinClass0.Vector2.t structure ptr ->
      BuiltinClass0.Vector2.t structure ptr ->
      BuiltinClass0.Vector2.t structure ptr ->
      BuiltinClass0.Float.t structure ptr ->
      BuiltinClass0.Vector2.t structure ptr ->
      BuiltinClass0.Vector2.t structure ptr
    (** Returns the point at the given [param t] on the [url=https://en.wikipedia.org/wiki/B%C3%A9zier_curve]Bézier curve[/url] defined by this vector and the given [param control_1], [param control_2], and [param end] points. *)

    val bezier_derivative :
      BuiltinClass0.Vector2.t structure ptr ->
      BuiltinClass0.Vector2.t structure ptr ->
      BuiltinClass0.Vector2.t structure ptr ->
      BuiltinClass0.Float.t structure ptr ->
      BuiltinClass0.Vector2.t structure ptr ->
      BuiltinClass0.Vector2.t structure ptr
    (** Returns the derivative at the given [param t] on the [url=https://en.wikipedia.org/wiki/B%C3%A9zier_curve]Bézier curve[/url] defined by this vector and the given [param control_1], [param control_2], and [param end] points. *)

    val max_axis_index :
      BuiltinClass0.Vector2.t structure ptr -> BuiltinClass0.Int.t structure ptr
    (** Returns the axis of the vector's highest value. See [code]AXIS_ * [/code] constants. If all components are equal, this method returns [constant AXIS_X]. *)

    val min_axis_index :
      BuiltinClass0.Vector2.t structure ptr -> BuiltinClass0.Int.t structure ptr
    (** Returns the axis of the vector's lowest value. See [code]AXIS_ * [/code] constants. If all components are equal, this method returns [constant AXIS_Y]. *)

    val move_toward :
      BuiltinClass0.Vector2.t structure ptr ->
      BuiltinClass0.Float.t structure ptr ->
      BuiltinClass0.Vector2.t structure ptr ->
      BuiltinClass0.Vector2.t structure ptr
    (** Returns a new vector moved toward [param to] by the fixed [param delta] amount. Will not go past the final value. *)

    val rotated :
      BuiltinClass0.Float.t structure ptr ->
      BuiltinClass0.Vector2.t structure ptr ->
      BuiltinClass0.Vector2.t structure ptr
    (** Returns the result of rotating this vector by [param angle] (in radians). See also [method @GlobalScope.deg_to_rad]. *)

    val orthogonal :
      BuiltinClass0.Vector2.t structure ptr ->
      BuiltinClass0.Vector2.t structure ptr
    (** Returns a perpendicular vector rotated 90 degrees counter-clockwise compared to the original, with the same length. *)

    val floor :
      BuiltinClass0.Vector2.t structure ptr ->
      BuiltinClass0.Vector2.t structure ptr
    (** Returns a new vector with all components rounded down (towards negative infinity). *)

    val ceil :
      BuiltinClass0.Vector2.t structure ptr ->
      BuiltinClass0.Vector2.t structure ptr
    (** Returns a new vector with all components rounded up (towards positive infinity). *)

    val round :
      BuiltinClass0.Vector2.t structure ptr ->
      BuiltinClass0.Vector2.t structure ptr
    (** Returns a new vector with all components rounded to the nearest integer, with halfway cases rounded away from zero. *)

    val aspect :
      BuiltinClass0.Vector2.t structure ptr ->
      BuiltinClass0.Float.t structure ptr
    (** Returns the aspect ratio of this vector, the ratio of [member x] to [member y]. *)

    val dot :
      BuiltinClass0.Vector2.t structure ptr ->
      BuiltinClass0.Vector2.t structure ptr ->
      BuiltinClass0.Float.t structure ptr
    (** Returns the dot product of this vector and [param with]. This can be used to compare the angle between two vectors. For example, this can be used to determine whether an enemy is facing the player.
The dot product will be [code]0[/code] for a straight angle (90 degrees), greater than 0 for angles narrower than 90 degrees and lower than 0 for angles wider than 90 degrees.
When using unit (normalized) vectors, the result will always be between [code]-1.0[/code] (180 degree angle) when the vectors are facing opposite directions, and [code]1.0[/code] (0 degree angle) when the vectors are aligned.
[b]Note:[/b] [code]a.dot(b)[/code] is equivalent to [code]b.dot(a)[/code]. *)

    val slide :
      BuiltinClass0.Vector2.t structure ptr ->
      BuiltinClass0.Vector2.t structure ptr ->
      BuiltinClass0.Vector2.t structure ptr
    (** Returns the result of sliding the vector along a plane defined by the given normal. *)

    val bounce :
      BuiltinClass0.Vector2.t structure ptr ->
      BuiltinClass0.Vector2.t structure ptr ->
      BuiltinClass0.Vector2.t structure ptr
    (** Returns a new vector ""bounced off"" from a plane defined by the given normal. *)

    val reflect :
      BuiltinClass0.Vector2.t structure ptr ->
      BuiltinClass0.Vector2.t structure ptr ->
      BuiltinClass0.Vector2.t structure ptr
    (** Returns the result of reflecting the vector from a line defined by the given direction vector [param n]. *)

    val cross :
      BuiltinClass0.Vector2.t structure ptr ->
      BuiltinClass0.Vector2.t structure ptr ->
      BuiltinClass0.Float.t structure ptr
    (** Returns the 2D analog of the cross product for this vector and [param with].
This is the signed area of the parallelogram formed by the two vectors. If the second vector is clockwise from the first vector, then the cross product is the positive area. If counter-clockwise, the cross product is the negative area. If the two vectors are parallel this returns zero, making it useful for testing if two vectors are parallel.
[b]Note:[/b] Cross product is not defined in 2D mathematically. This method embeds the 2D vectors in the XY plane of 3D space and uses their cross product's Z component as the analog. *)

    val abs :
      BuiltinClass0.Vector2.t structure ptr ->
      BuiltinClass0.Vector2.t structure ptr
    (** Returns a new vector with all components in absolute values (i.e. positive). *)

    val sign :
      BuiltinClass0.Vector2.t structure ptr ->
      BuiltinClass0.Vector2.t structure ptr
    (** Returns a new vector with each component set to [code]1.0[/code] if it's positive, [code]-1.0[/code] if it's negative, and [code]0.0[/code] if it's zero. The result is identical to calling [method @GlobalScope.sign] on each component. *)

    val clamp :
      BuiltinClass0.Vector2.t structure ptr ->
      BuiltinClass0.Vector2.t structure ptr ->
      BuiltinClass0.Vector2.t structure ptr ->
      BuiltinClass0.Vector2.t structure ptr
    (** Returns a new vector with all components clamped between the components of [param min] and [param max], by running [method @GlobalScope.clamp] on each component. *)

    val snapped :
      BuiltinClass0.Vector2.t structure ptr ->
      BuiltinClass0.Vector2.t structure ptr ->
      BuiltinClass0.Vector2.t structure ptr
    (** Returns a new vector with each component snapped to the nearest multiple of the corresponding component in [param step]. This can also be used to round the components to an arbitrary number of decimals. *)

    val from_angle :
      BuiltinClass0.Float.t structure ptr ->
      BuiltinClass0.Vector2.t structure ptr
    (** Creates a unit [Vector2] rotated to the given [param angle] in radians. This is equivalent to doing [code]Vector2(cos(angle), sin(angle))[/code] or [code]Vector2.RIGHT.rotated(angle)[/code].
[codeblock]
print(Vector2.from_angle(0)) # Prints (1, 0).
print(Vector2(1, 0).angle()) # Prints 0, which is the angle used above.
print(Vector2.from_angle(PI / 2)) # Prints (0, 1).
[/codeblock] *)

    val ( ~- ) :
      Vector2.t structure ptr ->
      Vector2.t structure ptr ->
      Vector2.t structure ptr ->
      unit
    (** Returns the negative value of the [Vector2]. This is the same as writing [code]Vector2(-v.x, -v.y)[/code]. This operation flips the direction of the vector while keeping the same magnitude. With floats, the number zero can be either positive or negative. *)

    val ( ~+ ) :
      Vector2.t structure ptr ->
      Vector2.t structure ptr ->
      Vector2.t structure ptr ->
      unit
    (** Returns the same value as if the [code]+[/code] was not there. Unary [code]+[/code] does nothing, but sometimes it can make your code more readable. *)

    val not :
      Vector2.t structure ptr ->
      Vector2.t structure ptr ->
      Bool.t structure ptr ->
      unit

    val ( = ) :
      Vector2.t structure ptr ->
      Vector2.t structure ptr ->
      Bool.t structure ptr ->
      unit
    (** Returns [code]true[/code] if the vectors are exactly equal.
[b]Note:[/b] Due to floating-point precision errors, consider using [method is_equal_approx] instead, which is more reliable.
[b]Note:[/b] Vectors with [constant @GDScript.NAN] elements don't behave the same as other vectors. Therefore, the results from this operator may not be accurate if NaNs are included. *)

    val ( <> ) :
      Vector2.t structure ptr ->
      Vector2.t structure ptr ->
      Bool.t structure ptr ->
      unit
    (** Returns [code]true[/code] if the vectors are not equal.
[b]Note:[/b] Due to floating-point precision errors, consider using [method is_equal_approx] instead, which is more reliable.
[b]Note:[/b] Vectors with [constant @GDScript.NAN] elements don't behave the same as other vectors. Therefore, the results from this operator may not be accurate if NaNs are included. *)

    val ( < ) :
      Vector2.t structure ptr ->
      Vector2.t structure ptr ->
      Bool.t structure ptr ->
      unit
    (** Compares two [Vector2] vectors by first checking if the X value of the left vector is less than the X value of the [param right] vector. If the X values are exactly equal, then it repeats this check with the Y values of the two vectors. This operator is useful for sorting vectors.
[b]Note:[/b] Vectors with [constant @GDScript.NAN] elements don't behave the same as other vectors. Therefore, the results from this operator may not be accurate if NaNs are included. *)

    val ( <= ) :
      Vector2.t structure ptr ->
      Vector2.t structure ptr ->
      Bool.t structure ptr ->
      unit
    (** Compares two [Vector2] vectors by first checking if the X value of the left vector is less than or equal to the X value of the [param right] vector. If the X values are exactly equal, then it repeats this check with the Y values of the two vectors. This operator is useful for sorting vectors.
[b]Note:[/b] Vectors with [constant @GDScript.NAN] elements don't behave the same as other vectors. Therefore, the results from this operator may not be accurate if NaNs are included. *)

    val ( > ) :
      Vector2.t structure ptr ->
      Vector2.t structure ptr ->
      Bool.t structure ptr ->
      unit
    (** Compares two [Vector2] vectors by first checking if the X value of the left vector is greater than the X value of the [param right] vector. If the X values are exactly equal, then it repeats this check with the Y values of the two vectors. This operator is useful for sorting vectors.
[b]Note:[/b] Vectors with [constant @GDScript.NAN] elements don't behave the same as other vectors. Therefore, the results from this operator may not be accurate if NaNs are included. *)

    val ( >= ) :
      Vector2.t structure ptr ->
      Vector2.t structure ptr ->
      Bool.t structure ptr ->
      unit
    (** Compares two [Vector2] vectors by first checking if the X value of the left vector is greater than or equal to the X value of the [param right] vector. If the X values are exactly equal, then it repeats this check with the Y values of the two vectors. This operator is useful for sorting vectors.
[b]Note:[/b] Vectors with [constant @GDScript.NAN] elements don't behave the same as other vectors. Therefore, the results from this operator may not be accurate if NaNs are included. *)

    val ( + ) :
      Vector2.t structure ptr ->
      Vector2.t structure ptr ->
      Vector2.t structure ptr ->
      unit
    (** Adds each component of the [Vector2] by the components of the given [Vector2].
[codeblock]
print(Vector2(10, 20) + Vector2(3, 4)) # Prints ""(13, 24)""
[/codeblock] *)

    val ( - ) :
      Vector2.t structure ptr ->
      Vector2.t structure ptr ->
      Vector2.t structure ptr ->
      unit
    (** Subtracts each component of the [Vector2] by the components of the given [Vector2].
[codeblock]
print(Vector2(10, 20) - Vector2(3, 4)) # Prints ""(7, 16)""
[/codeblock] *)

    val ( * ) :
      Vector2.t structure ptr ->
      Vector2.t structure ptr ->
      Vector2.t structure ptr ->
      unit
    (** Multiplies each component of the [Vector2] by the components of the given [Vector2].
[codeblock]
print(Vector2(10, 20)  *  Vector2(3, 4)) # Prints ""(30, 80)""
[/codeblock] *)

    val ( / ) :
      Vector2.t structure ptr ->
      Vector2.t structure ptr ->
      Vector2.t structure ptr ->
      unit
    (** Divides each component of the [Vector2] by the components of the given [Vector2].
[codeblock]
print(Vector2(10, 20) / Vector2(2, 5)) # Prints ""(5, 4)""
[/codeblock] *)

    val _Vector2_elem_Dictionary :
      Vector2.t structure ptr ->
      Dictionary.t structure ptr ->
      Bool.t structure ptr ->
      unit

    val _Vector2_elem_Array :
      Vector2.t structure ptr ->
      Array.t structure ptr ->
      Bool.t structure ptr ->
      unit

    val _Vector2_elem_PackedVector2Array :
      Vector2.t structure ptr ->
      PackedVector2Array.t structure ptr ->
      Bool.t structure ptr ->
      unit

    module AXIS : sig
      type t

      val typ : Int.t structure ptr typ

      val _AXIS_X : int
      (** Enumerated value for the X axis. Returned by [method max_axis_index] and [method min_axis_index]. *)

      val _AXIS_Y : int
      (** Enumerated value for the Y axis. Returned by [method max_axis_index] and [method min_axis_index]. *)
    end
  end

  module type VECTOR2I = sig
    type t

    include Api_types.API_TYPE with type t := t

    val aspect :
      BuiltinClass0.Vector2i.t structure ptr ->
      BuiltinClass0.Float.t structure ptr
    (** Returns the aspect ratio of this vector, the ratio of [member x] to [member y]. *)

    val max_axis_index :
      BuiltinClass0.Vector2i.t structure ptr ->
      BuiltinClass0.Int.t structure ptr
    (** Returns the axis of the vector's highest value. See [code]AXIS_ * [/code] constants. If all components are equal, this method returns [constant AXIS_X]. *)

    val min_axis_index :
      BuiltinClass0.Vector2i.t structure ptr ->
      BuiltinClass0.Int.t structure ptr
    (** Returns the axis of the vector's lowest value. See [code]AXIS_ * [/code] constants. If all components are equal, this method returns [constant AXIS_Y]. *)

    val length :
      BuiltinClass0.Vector2i.t structure ptr ->
      BuiltinClass0.Float.t structure ptr
    (** Returns the length (magnitude) of this vector. *)

    val length_squared :
      BuiltinClass0.Vector2i.t structure ptr ->
      BuiltinClass0.Int.t structure ptr
    (** Returns the squared length (squared magnitude) of this vector.
This method runs faster than [method length], so prefer it if you need to compare vectors or need the squared distance for some formula. *)

    val sign :
      BuiltinClass0.Vector2i.t structure ptr ->
      BuiltinClass0.Vector2i.t structure ptr
    (** Returns a new vector with each component set to [code]1[/code] if it's positive, [code]-1[/code] if it's negative, and [code]0[/code] if it's zero. The result is identical to calling [method @GlobalScope.sign] on each component. *)

    val abs :
      BuiltinClass0.Vector2i.t structure ptr ->
      BuiltinClass0.Vector2i.t structure ptr
    (** Returns a new vector with all components in absolute values (i.e. positive). *)

    val clamp :
      BuiltinClass0.Vector2i.t structure ptr ->
      BuiltinClass0.Vector2i.t structure ptr ->
      BuiltinClass0.Vector2i.t structure ptr ->
      BuiltinClass0.Vector2i.t structure ptr
    (** Returns a new vector with all components clamped between the components of [param min] and [param max], by running [method @GlobalScope.clamp] on each component. *)

    val snapped :
      BuiltinClass0.Vector2i.t structure ptr ->
      BuiltinClass0.Vector2i.t structure ptr ->
      BuiltinClass0.Vector2i.t structure ptr
    (** Returns a new vector with each component snapped to the closest multiple of the corresponding component in [param step]. *)

    val ( ~- ) :
      Vector2i.t structure ptr ->
      Vector2i.t structure ptr ->
      Vector2i.t structure ptr ->
      unit
    (** Returns the negative value of the [Vector2i]. This is the same as writing [code]Vector2i(-v.x, -v.y)[/code]. This operation flips the direction of the vector while keeping the same magnitude. *)

    val ( ~+ ) :
      Vector2i.t structure ptr ->
      Vector2i.t structure ptr ->
      Vector2i.t structure ptr ->
      unit
    (** Returns the same value as if the [code]+[/code] was not there. Unary [code]+[/code] does nothing, but sometimes it can make your code more readable. *)

    val not :
      Vector2i.t structure ptr ->
      Vector2i.t structure ptr ->
      Bool.t structure ptr ->
      unit

    val ( = ) :
      Vector2i.t structure ptr ->
      Vector2i.t structure ptr ->
      Bool.t structure ptr ->
      unit
    (** Returns [code]true[/code] if the vectors are equal. *)

    val ( <> ) :
      Vector2i.t structure ptr ->
      Vector2i.t structure ptr ->
      Bool.t structure ptr ->
      unit
    (** Returns [code]true[/code] if the vectors are not equal. *)

    val ( < ) :
      Vector2i.t structure ptr ->
      Vector2i.t structure ptr ->
      Bool.t structure ptr ->
      unit
    (** Compares two [Vector2i] vectors by first checking if the X value of the left vector is less than the X value of the [param right] vector. If the X values are exactly equal, then it repeats this check with the Y values of the two vectors. This operator is useful for sorting vectors. *)

    val ( <= ) :
      Vector2i.t structure ptr ->
      Vector2i.t structure ptr ->
      Bool.t structure ptr ->
      unit
    (** Compares two [Vector2i] vectors by first checking if the X value of the left vector is less than or equal to the X value of the [param right] vector. If the X values are exactly equal, then it repeats this check with the Y values of the two vectors. This operator is useful for sorting vectors. *)

    val ( > ) :
      Vector2i.t structure ptr ->
      Vector2i.t structure ptr ->
      Bool.t structure ptr ->
      unit
    (** Compares two [Vector2i] vectors by first checking if the X value of the left vector is greater than the X value of the [param right] vector. If the X values are exactly equal, then it repeats this check with the Y values of the two vectors. This operator is useful for sorting vectors. *)

    val ( >= ) :
      Vector2i.t structure ptr ->
      Vector2i.t structure ptr ->
      Bool.t structure ptr ->
      unit
    (** Compares two [Vector2i] vectors by first checking if the X value of the left vector is greater than or equal to the X value of the [param right] vector. If the X values are exactly equal, then it repeats this check with the Y values of the two vectors. This operator is useful for sorting vectors. *)

    val ( + ) :
      Vector2i.t structure ptr ->
      Vector2i.t structure ptr ->
      Vector2i.t structure ptr ->
      unit
    (** Adds each component of the [Vector2i] by the components of the given [Vector2i].
[codeblock]
print(Vector2i(10, 20) + Vector2i(3, 4)) # Prints ""(13, 24)""
[/codeblock] *)

    val ( - ) :
      Vector2i.t structure ptr ->
      Vector2i.t structure ptr ->
      Vector2i.t structure ptr ->
      unit
    (** Subtracts each component of the [Vector2i] by the components of the given [Vector2i].
[codeblock]
print(Vector2i(10, 20) - Vector2i(3, 4)) # Prints ""(7, 16)""
[/codeblock] *)

    val ( * ) :
      Vector2i.t structure ptr ->
      Vector2i.t structure ptr ->
      Vector2i.t structure ptr ->
      unit
    (** Multiplies each component of the [Vector2i] by the components of the given [Vector2i].
[codeblock]
print(Vector2i(10, 20)  *  Vector2i(3, 4)) # Prints ""(30, 80)""
[/codeblock] *)

    val ( / ) :
      Vector2i.t structure ptr ->
      Vector2i.t structure ptr ->
      Vector2i.t structure ptr ->
      unit
    (** Divides each component of the [Vector2i] by the components of the given [Vector2i].
[codeblock]
print(Vector2i(10, 20) / Vector2i(2, 5)) # Prints ""(5, 4)""
[/codeblock] *)

    val ( % ) :
      Vector2i.t structure ptr ->
      Vector2i.t structure ptr ->
      Vector2i.t structure ptr ->
      unit
    (** Gets the remainder of each component of the [Vector2i] with the components of the given [Vector2i]. This operation uses truncated division, which is often not desired as it does not work well with negative numbers. Consider using [method @GlobalScope.posmod] instead if you want to handle negative numbers.
[codeblock]
print(Vector2i(10, -20) % Vector2i(7, 8)) # Prints ""(3, -4)""
[/codeblock] *)

    val _Vector2i_elem_Dictionary :
      Vector2i.t structure ptr ->
      Dictionary.t structure ptr ->
      Bool.t structure ptr ->
      unit

    val _Vector2i_elem_Array :
      Vector2i.t structure ptr ->
      Array.t structure ptr ->
      Bool.t structure ptr ->
      unit

    module AXIS : sig
      type t

      val typ : Int.t structure ptr typ

      val _AXIS_X : int
      (** Enumerated value for the X axis. Returned by [method max_axis_index] and [method min_axis_index]. *)

      val _AXIS_Y : int
      (** Enumerated value for the Y axis. Returned by [method max_axis_index] and [method min_axis_index]. *)
    end
  end

  module type RECT2 = sig
    type t

    include Api_types.API_TYPE with type t := t

    val get_center :
      BuiltinClass0.Rect2.t structure ptr ->
      BuiltinClass0.Vector2.t structure ptr
    (** Returns the center point of the rectangle. This is the same as [code]position + (size / 2.0)[/code]. *)

    val get_area :
      BuiltinClass0.Rect2.t structure ptr -> BuiltinClass0.Float.t structure ptr
    (** Returns the rectangle's area. This is equivalent to [code]size.x  *  size.y[/code]. See also [method has_area]. *)

    val has_area :
      BuiltinClass0.Rect2.t structure ptr -> BuiltinClass0.Bool.t structure ptr
    (** Returns [code]true[/code] if this rectangle has positive width and height. See also [method get_area]. *)

    val has_point :
      BuiltinClass0.Vector2.t structure ptr ->
      BuiltinClass0.Rect2.t structure ptr ->
      BuiltinClass0.Bool.t structure ptr
    (** Returns [code]true[/code] if the rectangle contains the given [param point]. By convention, points on the right and bottom edges are [b]not[/b] included.
[b]Note:[/b] This method is not reliable for [Rect2] with a [i]negative[/i] [member size]. Use [method abs] first to get a valid rectangle. *)

    val is_equal_approx :
      BuiltinClass0.Rect2.t structure ptr ->
      BuiltinClass0.Rect2.t structure ptr ->
      BuiltinClass0.Bool.t structure ptr
    (** Returns [code]true[/code] if this rectangle and [param rect] are approximately equal, by calling [method Vector2.is_equal_approx] on the [member position] and the [member size]. *)

    val is_finite :
      BuiltinClass0.Rect2.t structure ptr -> BuiltinClass0.Bool.t structure ptr
    (** Returns [code]true[/code] if this rectangle's values are finite, by calling [method Vector2.is_finite] on the [member position] and the [member size]. *)

    val intersects :
      BuiltinClass0.Rect2.t structure ptr ->
      BuiltinClass0.Bool.t structure ptr ->
      BuiltinClass0.Rect2.t structure ptr ->
      BuiltinClass0.Bool.t structure ptr
    (** Returns [code]true[/code] if this rectangle overlaps with the [param b] rectangle. The edges of both rectangles are excluded, unless [param include_borders] is [code]true[/code]. *)

    val encloses :
      BuiltinClass0.Rect2.t structure ptr ->
      BuiltinClass0.Rect2.t structure ptr ->
      BuiltinClass0.Bool.t structure ptr
    (** Returns [code]true[/code] if this rectangle [i]completely[/i] encloses the [param b] rectangle. *)

    val intersection :
      BuiltinClass0.Rect2.t structure ptr ->
      BuiltinClass0.Rect2.t structure ptr ->
      BuiltinClass0.Rect2.t structure ptr
    (** Returns the intersection between this rectangle and [param b]. If the rectangles do not intersect, returns an empty [Rect2].
[codeblocks]
[gdscript]
var rect1 = Rect2(0, 0, 5, 10)
var rect2 = Rect2(2, 0, 8, 4)

var a = rect1.intersection(rect2) # a is Rect2(2, 0, 3, 4)
[/gdscript]
[csharp]
var rect1 = new Rect2(0, 0, 5, 10);
var rect2 = new Rect2(2, 0, 8, 4);

var a = rect1.Intersection(rect2); // a is Rect2(2, 0, 3, 4)
[/csharp]
[/codeblocks]
[b]Note:[/b] If you only need to know whether two rectangles are overlapping, use [method intersects], instead. *)

    val merge :
      BuiltinClass0.Rect2.t structure ptr ->
      BuiltinClass0.Rect2.t structure ptr ->
      BuiltinClass0.Rect2.t structure ptr
    (** Returns a [Rect2] that encloses both this rectangle and [param b] around the edges. See also [method encloses]. *)

    val expand :
      BuiltinClass0.Vector2.t structure ptr ->
      BuiltinClass0.Rect2.t structure ptr ->
      BuiltinClass0.Rect2.t structure ptr
    (** Returns a copy of this rectangle expanded to align the edges with the given [param to] point, if necessary.
[codeblocks]
[gdscript]
var rect = Rect2(0, 0, 5, 2)

rect = rect.expand(Vector2(10, 0)) # rect is Rect2(0, 0, 10, 2)
rect = rect.expand(Vector2(-5, 5)) # rect is Rect2(-5, 0, 10, 5)
[/gdscript]
[csharp]
var rect = new Rect2(0, 0, 5, 2);

rect = rect.Expand(new Vector2(10, 0)); // rect is Rect2(0, 0, 10, 2)
rect = rect.Expand(new Vector2(-5, 5)); // rect is Rect2(-5, 0, 10, 5)
[/csharp]
[/codeblocks] *)

    val grow :
      BuiltinClass0.Float.t structure ptr ->
      BuiltinClass0.Rect2.t structure ptr ->
      BuiltinClass0.Rect2.t structure ptr
    (** Returns a copy of this rectangle extended on all sides by the given [param amount]. A negative [param amount] shrinks the rectangle instead. See also [method grow_individual] and [method grow_side].
[codeblocks]
[gdscript]
var a = Rect2(4, 4, 8, 8).grow(4) # a is Rect2(0, 0, 16, 16)
var b = Rect2(0, 0, 8, 4).grow(2) # b is Rect2(-2, -2, 12, 8)
[/gdscript]
[csharp]
var a = new Rect2(4, 4, 8, 8).Grow(4); // a is Rect2(0, 0, 16, 16)
var b = new Rect2(0, 0, 8, 4).Grow(2); // b is Rect2(-2, -2, 12, 8)
[/csharp]
[/codeblocks] *)

    val grow_side :
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.Float.t structure ptr ->
      BuiltinClass0.Rect2.t structure ptr ->
      BuiltinClass0.Rect2.t structure ptr
    (** Returns a copy of this rectangle with its [param side] extended by the given [param amount] (see [enum Side] constants). A negative [param amount] shrinks the rectangle, instead. See also [method grow] and [method grow_individual]. *)

    val grow_individual :
      BuiltinClass0.Float.t structure ptr ->
      BuiltinClass0.Float.t structure ptr ->
      BuiltinClass0.Float.t structure ptr ->
      BuiltinClass0.Float.t structure ptr ->
      BuiltinClass0.Rect2.t structure ptr ->
      BuiltinClass0.Rect2.t structure ptr
    (** Returns a copy of this rectangle with its [param left], [param top], [param right], and [param bottom] sides extended by the given amounts. Negative values shrink the sides, instead. See also [method grow] and [method grow_side]. *)

    val abs :
      BuiltinClass0.Rect2.t structure ptr -> BuiltinClass0.Rect2.t structure ptr
    (** Returns a [Rect2] equivalent to this rectangle, with its width and height modified to be non-negative values, and with its [member position] being the top-left corner of the rectangle.
[codeblocks]
[gdscript]
var rect = Rect2(25, 25, -100, -50)
var absolute = rect.abs() # absolute is Rect2(-75, -25, 100, 50)
[/gdscript]
[csharp]
var rect = new Rect2(25, 25, -100, -50);
var absolute = rect.Abs(); // absolute is Rect2(-75, -25, 100, 50)
[/csharp]
[/codeblocks]
[b]Note:[/b] It's recommended to use this method when [member size] is negative, as most other methods in Godot assume that the [member position] is the top-left corner, and the [member end] is the bottom-right corner. *)

    val not :
      Rect2.t structure ptr ->
      Rect2.t structure ptr ->
      Bool.t structure ptr ->
      unit

    val ( = ) :
      Rect2.t structure ptr ->
      Rect2.t structure ptr ->
      Bool.t structure ptr ->
      unit
    (** Returns [code]true[/code] if both [member position] and [member size] of the rectangles are exactly equal, respectively.
[b]Note:[/b] Due to floating-point precision errors, consider using [method is_equal_approx] instead, which is more reliable. *)

    val ( <> ) :
      Rect2.t structure ptr ->
      Rect2.t structure ptr ->
      Bool.t structure ptr ->
      unit
    (** Returns [code]true[/code] if the [member position] or [member size] of both rectangles are not equal.
[b]Note:[/b] Due to floating-point precision errors, consider using [method is_equal_approx] instead, which is more reliable. *)

    val _Rect2_elem_Dictionary :
      Rect2.t structure ptr ->
      Dictionary.t structure ptr ->
      Bool.t structure ptr ->
      unit

    val _Rect2_elem_Array :
      Rect2.t structure ptr ->
      Array.t structure ptr ->
      Bool.t structure ptr ->
      unit
  end

  module type RECT2I = sig
    type t

    include Api_types.API_TYPE with type t := t

    val get_center :
      BuiltinClass0.Rect2i.t structure ptr ->
      BuiltinClass0.Vector2i.t structure ptr
    (** Returns the center point of the rectangle. This is the same as [code]position + (size / 2)[/code].
[b]Note:[/b] If the [member size] is odd, the result will be rounded towards [member position]. *)

    val get_area :
      BuiltinClass0.Rect2i.t structure ptr -> BuiltinClass0.Int.t structure ptr
    (** Returns the rectangle's area. This is equivalent to [code]size.x  *  size.y[/code]. See also [method has_area]. *)

    val has_area :
      BuiltinClass0.Rect2i.t structure ptr -> BuiltinClass0.Bool.t structure ptr
    (** Returns [code]true[/code] if this rectangle has positive width and height. See also [method get_area]. *)

    val has_point :
      BuiltinClass0.Vector2i.t structure ptr ->
      BuiltinClass0.Rect2i.t structure ptr ->
      BuiltinClass0.Bool.t structure ptr
    (** Returns [code]true[/code] if the rectangle contains the given [param point]. By convention, points on the right and bottom edges are [b]not[/b] included.
[b]Note:[/b] This method is not reliable for [Rect2i] with a [i]negative[/i] [member size]. Use [method abs] first to get a valid rectangle. *)

    val intersects :
      BuiltinClass0.Rect2i.t structure ptr ->
      BuiltinClass0.Rect2i.t structure ptr ->
      BuiltinClass0.Bool.t structure ptr
    (** Returns [code]true[/code] if this rectangle overlaps with the [param b] rectangle. The edges of both rectangles are excluded. *)

    val encloses :
      BuiltinClass0.Rect2i.t structure ptr ->
      BuiltinClass0.Rect2i.t structure ptr ->
      BuiltinClass0.Bool.t structure ptr
    (** Returns [code]true[/code] if this [Rect2i] completely encloses another one. *)

    val intersection :
      BuiltinClass0.Rect2i.t structure ptr ->
      BuiltinClass0.Rect2i.t structure ptr ->
      BuiltinClass0.Rect2i.t structure ptr
    (** Returns the intersection between this rectangle and [param b]. If the rectangles do not intersect, returns an empty [Rect2i].
[codeblocks]
[gdscript]
var a = Rect2i(0, 0, 5, 10)
var b = Rect2i(2, 0, 8, 4)

var c = a.intersection(b) # c is Rect2i(2, 0, 3, 4)
[/gdscript]
[csharp]
var a = new Rect2I(0, 0, 5, 10);
var b = new Rect2I(2, 0, 8, 4);

var c = rect1.Intersection(rect2); // c is Rect2I(2, 0, 3, 4)
[/csharp]
[/codeblocks]
[b]Note:[/b] If you only need to know whether two rectangles are overlapping, use [method intersects], instead. *)

    val merge :
      BuiltinClass0.Rect2i.t structure ptr ->
      BuiltinClass0.Rect2i.t structure ptr ->
      BuiltinClass0.Rect2i.t structure ptr
    (** Returns a [Rect2i] that encloses both this rectangle and [param b] around the edges. See also [method encloses]. *)

    val expand :
      BuiltinClass0.Vector2i.t structure ptr ->
      BuiltinClass0.Rect2i.t structure ptr ->
      BuiltinClass0.Rect2i.t structure ptr
    (** Returns a copy of this rectangle expanded to align the edges with the given [param to] point, if necessary.
[codeblocks]
[gdscript]
var rect = Rect2i(0, 0, 5, 2)

rect = rect.expand(Vector2i(10, 0)) # rect is Rect2i(0, 0, 10, 2)
rect = rect.expand(Vector2i(-5, 5)) # rect is Rect2i(-5, 0, 10, 5)
[/gdscript]
[csharp]
var rect = new Rect2I(0, 0, 5, 2);

rect = rect.Expand(new Vector2I(10, 0)); // rect is Rect2I(0, 0, 10, 2)
rect = rect.Expand(new Vector2I(-5, 5)); // rect is Rect2I(-5, 0, 10, 5)
[/csharp]
[/codeblocks] *)

    val grow :
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.Rect2i.t structure ptr ->
      BuiltinClass0.Rect2i.t structure ptr
    (** Returns a copy of this rectangle extended on all sides by the given [param amount]. A negative [param amount] shrinks the rectangle instead. See also [method grow_individual] and [method grow_side].
[codeblocks]
[gdscript]
var a = Rect2i(4, 4, 8, 8).grow(4) # a is Rect2i(0, 0, 16, 16)
var b = Rect2i(0, 0, 8, 4).grow(2) # b is Rect2i(-2, -2, 12, 8)
[/gdscript]
[csharp]
var a = new Rect2I(4, 4, 8, 8).Grow(4); // a is Rect2I(0, 0, 16, 16)
var b = new Rect2I(0, 0, 8, 4).Grow(2); // b is Rect2I(-2, -2, 12, 8)
[/csharp]
[/codeblocks] *)

    val grow_side :
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.Rect2i.t structure ptr ->
      BuiltinClass0.Rect2i.t structure ptr
    (** Returns a copy of this rectangle with its [param side] extended by the given [param amount] (see [enum Side] constants). A negative [param amount] shrinks the rectangle, instead. See also [method grow] and [method grow_individual]. *)

    val grow_individual :
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.Rect2i.t structure ptr ->
      BuiltinClass0.Rect2i.t structure ptr
    (** Returns a copy of this rectangle with its [param left], [param top], [param right], and [param bottom] sides extended by the given amounts. Negative values shrink the sides, instead. See also [method grow] and [method grow_side]. *)

    val abs :
      BuiltinClass0.Rect2i.t structure ptr ->
      BuiltinClass0.Rect2i.t structure ptr
    (** Returns a [Rect2i] equivalent to this rectangle, with its width and height modified to be non-negative values, and with its [member position] being the top-left corner of the rectangle.
[codeblocks]
[gdscript]
var rect = Rect2i(25, 25, -100, -50)
var absolute = rect.abs() # absolute is Rect2i(-75, -25, 100, 50)
[/gdscript]
[csharp]
var rect = new Rect2I(25, 25, -100, -50);
var absolute = rect.Abs(); // absolute is Rect2I(-75, -25, 100, 50)
[/csharp]
[/codeblocks]
[b]Note:[/b] It's recommended to use this method when [member size] is negative, as most other methods in Godot assume that the [member position] is the top-left corner, and the [member end] is the bottom-right corner. *)

    val not :
      Rect2i.t structure ptr ->
      Rect2i.t structure ptr ->
      Bool.t structure ptr ->
      unit

    val ( = ) :
      Rect2i.t structure ptr ->
      Rect2i.t structure ptr ->
      Bool.t structure ptr ->
      unit
    (** Returns [code]true[/code] if both [member position] and [member size] of the rectangles are equal, respectively. *)

    val ( <> ) :
      Rect2i.t structure ptr ->
      Rect2i.t structure ptr ->
      Bool.t structure ptr ->
      unit
    (** Returns [code]true[/code] if the [member position] or [member size] of both rectangles are not equal. *)

    val _Rect2i_elem_Dictionary :
      Rect2i.t structure ptr ->
      Dictionary.t structure ptr ->
      Bool.t structure ptr ->
      unit

    val _Rect2i_elem_Array :
      Rect2i.t structure ptr ->
      Array.t structure ptr ->
      Bool.t structure ptr ->
      unit
  end

  module type VECTOR3 = sig
    type t

    include Api_types.API_TYPE with type t := t

    val min_axis_index :
      BuiltinClass0.Vector3.t structure ptr -> BuiltinClass0.Int.t structure ptr
    (** Returns the axis of the vector's lowest value. See [code]AXIS_ * [/code] constants. If all components are equal, this method returns [constant AXIS_Z]. *)

    val max_axis_index :
      BuiltinClass0.Vector3.t structure ptr -> BuiltinClass0.Int.t structure ptr
    (** Returns the axis of the vector's highest value. See [code]AXIS_ * [/code] constants. If all components are equal, this method returns [constant AXIS_X]. *)

    val angle_to :
      BuiltinClass0.Vector3.t structure ptr ->
      BuiltinClass0.Vector3.t structure ptr ->
      BuiltinClass0.Float.t structure ptr
    (** Returns the unsigned minimum angle to the given vector, in radians. *)

    val signed_angle_to :
      BuiltinClass0.Vector3.t structure ptr ->
      BuiltinClass0.Vector3.t structure ptr ->
      BuiltinClass0.Vector3.t structure ptr ->
      BuiltinClass0.Float.t structure ptr
    (** Returns the signed angle to the given vector, in radians. The sign of the angle is positive in a counter-clockwise direction and negative in a clockwise direction when viewed from the side specified by the [param axis]. *)

    val direction_to :
      BuiltinClass0.Vector3.t structure ptr ->
      BuiltinClass0.Vector3.t structure ptr ->
      BuiltinClass0.Vector3.t structure ptr
    (** Returns the normalized vector pointing from this vector to [param to]. This is equivalent to using [code](b - a).normalized()[/code]. *)

    val distance_to :
      BuiltinClass0.Vector3.t structure ptr ->
      BuiltinClass0.Vector3.t structure ptr ->
      BuiltinClass0.Float.t structure ptr
    (** Returns the distance between this vector and [param to]. *)

    val distance_squared_to :
      BuiltinClass0.Vector3.t structure ptr ->
      BuiltinClass0.Vector3.t structure ptr ->
      BuiltinClass0.Float.t structure ptr
    (** Returns the squared distance between this vector and [param to].
This method runs faster than [method distance_to], so prefer it if you need to compare vectors or need the squared distance for some formula. *)

    val length :
      BuiltinClass0.Vector3.t structure ptr ->
      BuiltinClass0.Float.t structure ptr
    (** Returns the length (magnitude) of this vector. *)

    val length_squared :
      BuiltinClass0.Vector3.t structure ptr ->
      BuiltinClass0.Float.t structure ptr
    (** Returns the squared length (squared magnitude) of this vector.
This method runs faster than [method length], so prefer it if you need to compare vectors or need the squared distance for some formula. *)

    val limit_length :
      BuiltinClass0.Float.t structure ptr ->
      BuiltinClass0.Vector3.t structure ptr ->
      BuiltinClass0.Vector3.t structure ptr
    (** Returns the vector with a maximum length by limiting its length to [param length]. *)

    val normalized :
      BuiltinClass0.Vector3.t structure ptr ->
      BuiltinClass0.Vector3.t structure ptr
    (** Returns the result of scaling the vector to unit length. Equivalent to [code]v / v.length()[/code]. See also [method is_normalized].
[b]Note:[/b] This function may return incorrect values if the input vector length is near zero. *)

    val is_normalized :
      BuiltinClass0.Vector3.t structure ptr ->
      BuiltinClass0.Bool.t structure ptr
    (** Returns [code]true[/code] if the vector is normalized, i.e. its length is approximately equal to 1. *)

    val is_equal_approx :
      BuiltinClass0.Vector3.t structure ptr ->
      BuiltinClass0.Vector3.t structure ptr ->
      BuiltinClass0.Bool.t structure ptr
    (** Returns [code]true[/code] if this vector and [param to] are approximately equal, by running [method @GlobalScope.is_equal_approx] on each component. *)

    val is_zero_approx :
      BuiltinClass0.Vector3.t structure ptr ->
      BuiltinClass0.Bool.t structure ptr
    (** Returns [code]true[/code] if this vector's values are approximately zero, by running [method @GlobalScope.is_zero_approx] on each component.
This method is faster than using [method is_equal_approx] with one value as a zero vector. *)

    val is_finite :
      BuiltinClass0.Vector3.t structure ptr ->
      BuiltinClass0.Bool.t structure ptr
    (** Returns [code]true[/code] if this vector is finite, by calling [method @GlobalScope.is_finite] on each component. *)

    val inverse :
      BuiltinClass0.Vector3.t structure ptr ->
      BuiltinClass0.Vector3.t structure ptr
    (** Returns the inverse of the vector. This is the same as [code]Vector3(1.0 / v.x, 1.0 / v.y, 1.0 / v.z)[/code]. *)

    val clamp :
      BuiltinClass0.Vector3.t structure ptr ->
      BuiltinClass0.Vector3.t structure ptr ->
      BuiltinClass0.Vector3.t structure ptr ->
      BuiltinClass0.Vector3.t structure ptr
    (** Returns a new vector with all components clamped between the components of [param min] and [param max], by running [method @GlobalScope.clamp] on each component. *)

    val snapped :
      BuiltinClass0.Vector3.t structure ptr ->
      BuiltinClass0.Vector3.t structure ptr ->
      BuiltinClass0.Vector3.t structure ptr
    (** Returns a new vector with each component snapped to the nearest multiple of the corresponding component in [param step]. This can also be used to round the components to an arbitrary number of decimals. *)

    val rotated :
      BuiltinClass0.Vector3.t structure ptr ->
      BuiltinClass0.Float.t structure ptr ->
      BuiltinClass0.Vector3.t structure ptr ->
      BuiltinClass0.Vector3.t structure ptr
    (** Returns the result of rotating this vector around a given axis by [param angle] (in radians). The axis must be a normalized vector. See also [method @GlobalScope.deg_to_rad]. *)

    val lerp :
      BuiltinClass0.Vector3.t structure ptr ->
      BuiltinClass0.Float.t structure ptr ->
      BuiltinClass0.Vector3.t structure ptr ->
      BuiltinClass0.Vector3.t structure ptr
    (** Returns the result of the linear interpolation between this vector and [param to] by amount [param weight]. [param weight] is on the range of [code]0.0[/code] to [code]1.0[/code], representing the amount of interpolation. *)

    val slerp :
      BuiltinClass0.Vector3.t structure ptr ->
      BuiltinClass0.Float.t structure ptr ->
      BuiltinClass0.Vector3.t structure ptr ->
      BuiltinClass0.Vector3.t structure ptr
    (** Returns the result of spherical linear interpolation between this vector and [param to], by amount [param weight]. [param weight] is on the range of 0.0 to 1.0, representing the amount of interpolation.
This method also handles interpolating the lengths if the input vectors have different lengths. For the special case of one or both input vectors having zero length, this method behaves like [method lerp]. *)

    val cubic_interpolate :
      BuiltinClass0.Vector3.t structure ptr ->
      BuiltinClass0.Vector3.t structure ptr ->
      BuiltinClass0.Vector3.t structure ptr ->
      BuiltinClass0.Float.t structure ptr ->
      BuiltinClass0.Vector3.t structure ptr ->
      BuiltinClass0.Vector3.t structure ptr
    (** Performs a cubic interpolation between this vector and [param b] using [param pre_a] and [param post_b] as handles, and returns the result at position [param weight]. [param weight] is on the range of 0.0 to 1.0, representing the amount of interpolation. *)

    val cubic_interpolate_in_time :
      BuiltinClass0.Vector3.t structure ptr ->
      BuiltinClass0.Vector3.t structure ptr ->
      BuiltinClass0.Vector3.t structure ptr ->
      BuiltinClass0.Float.t structure ptr ->
      BuiltinClass0.Float.t structure ptr ->
      BuiltinClass0.Float.t structure ptr ->
      BuiltinClass0.Float.t structure ptr ->
      BuiltinClass0.Vector3.t structure ptr ->
      BuiltinClass0.Vector3.t structure ptr
    (** Performs a cubic interpolation between this vector and [param b] using [param pre_a] and [param post_b] as handles, and returns the result at position [param weight]. [param weight] is on the range of 0.0 to 1.0, representing the amount of interpolation.
It can perform smoother interpolation than [method cubic_interpolate] by the time values. *)

    val bezier_interpolate :
      BuiltinClass0.Vector3.t structure ptr ->
      BuiltinClass0.Vector3.t structure ptr ->
      BuiltinClass0.Vector3.t structure ptr ->
      BuiltinClass0.Float.t structure ptr ->
      BuiltinClass0.Vector3.t structure ptr ->
      BuiltinClass0.Vector3.t structure ptr
    (** Returns the point at the given [param t] on the [url=https://en.wikipedia.org/wiki/B%C3%A9zier_curve]Bézier curve[/url] defined by this vector and the given [param control_1], [param control_2], and [param end] points. *)

    val bezier_derivative :
      BuiltinClass0.Vector3.t structure ptr ->
      BuiltinClass0.Vector3.t structure ptr ->
      BuiltinClass0.Vector3.t structure ptr ->
      BuiltinClass0.Float.t structure ptr ->
      BuiltinClass0.Vector3.t structure ptr ->
      BuiltinClass0.Vector3.t structure ptr
    (** Returns the derivative at the given [param t] on the [url=https://en.wikipedia.org/wiki/B%C3%A9zier_curve]Bézier curve[/url] defined by this vector and the given [param control_1], [param control_2], and [param end] points. *)

    val move_toward :
      BuiltinClass0.Vector3.t structure ptr ->
      BuiltinClass0.Float.t structure ptr ->
      BuiltinClass0.Vector3.t structure ptr ->
      BuiltinClass0.Vector3.t structure ptr
    (** Returns a new vector moved toward [param to] by the fixed [param delta] amount. Will not go past the final value. *)

    val dot :
      BuiltinClass0.Vector3.t structure ptr ->
      BuiltinClass0.Vector3.t structure ptr ->
      BuiltinClass0.Float.t structure ptr
    (** Returns the dot product of this vector and [param with]. This can be used to compare the angle between two vectors. For example, this can be used to determine whether an enemy is facing the player.
The dot product will be [code]0[/code] for a straight angle (90 degrees), greater than 0 for angles narrower than 90 degrees and lower than 0 for angles wider than 90 degrees.
When using unit (normalized) vectors, the result will always be between [code]-1.0[/code] (180 degree angle) when the vectors are facing opposite directions, and [code]1.0[/code] (0 degree angle) when the vectors are aligned.
[b]Note:[/b] [code]a.dot(b)[/code] is equivalent to [code]b.dot(a)[/code]. *)

    val cross :
      BuiltinClass0.Vector3.t structure ptr ->
      BuiltinClass0.Vector3.t structure ptr ->
      BuiltinClass0.Vector3.t structure ptr
    (** Returns the cross product of this vector and [param with].
This returns a vector perpendicular to both this and [param with], which would be the normal vector of the plane defined by the two vectors. As there are two such vectors, in opposite directions, this method returns the vector defined by a right-handed coordinate system. If the two vectors are parallel this returns an empty vector, making it useful for testing if two vectors are parallel. *)

    val outer :
      BuiltinClass0.Vector3.t structure ptr ->
      BuiltinClass0.Vector3.t structure ptr ->
      BuiltinClass0.Basis.t structure ptr
    (** Returns the outer product with [param with]. *)

    val abs :
      BuiltinClass0.Vector3.t structure ptr ->
      BuiltinClass0.Vector3.t structure ptr
    (** Returns a new vector with all components in absolute values (i.e. positive). *)

    val floor :
      BuiltinClass0.Vector3.t structure ptr ->
      BuiltinClass0.Vector3.t structure ptr
    (** Returns a new vector with all components rounded down (towards negative infinity). *)

    val ceil :
      BuiltinClass0.Vector3.t structure ptr ->
      BuiltinClass0.Vector3.t structure ptr
    (** Returns a new vector with all components rounded up (towards positive infinity). *)

    val round :
      BuiltinClass0.Vector3.t structure ptr ->
      BuiltinClass0.Vector3.t structure ptr
    (** Returns a new vector with all components rounded to the nearest integer, with halfway cases rounded away from zero. *)

    val posmod :
      BuiltinClass0.Float.t structure ptr ->
      BuiltinClass0.Vector3.t structure ptr ->
      BuiltinClass0.Vector3.t structure ptr
    (** Returns a vector composed of the [method @GlobalScope.fposmod] of this vector's components and [param mod]. *)

    val posmodv :
      BuiltinClass0.Vector3.t structure ptr ->
      BuiltinClass0.Vector3.t structure ptr ->
      BuiltinClass0.Vector3.t structure ptr
    (** Returns a vector composed of the [method @GlobalScope.fposmod] of this vector's components and [param modv]'s components. *)

    val project :
      BuiltinClass0.Vector3.t structure ptr ->
      BuiltinClass0.Vector3.t structure ptr ->
      BuiltinClass0.Vector3.t structure ptr
    (** Returns the result of projecting the vector onto the given vector [param b]. *)

    val slide :
      BuiltinClass0.Vector3.t structure ptr ->
      BuiltinClass0.Vector3.t structure ptr ->
      BuiltinClass0.Vector3.t structure ptr
    (** Returns a new vector slid along a plane defined by the given normal. *)

    val bounce :
      BuiltinClass0.Vector3.t structure ptr ->
      BuiltinClass0.Vector3.t structure ptr ->
      BuiltinClass0.Vector3.t structure ptr
    (** Returns the vector ""bounced off"" from a plane defined by the given normal. *)

    val reflect :
      BuiltinClass0.Vector3.t structure ptr ->
      BuiltinClass0.Vector3.t structure ptr ->
      BuiltinClass0.Vector3.t structure ptr
    (** Returns the result of reflecting the vector from a plane defined by the given normal [param n]. *)

    val sign :
      BuiltinClass0.Vector3.t structure ptr ->
      BuiltinClass0.Vector3.t structure ptr
    (** Returns a new vector with each component set to [code]1.0[/code] if it's positive, [code]-1.0[/code] if it's negative, and [code]0.0[/code] if it's zero. The result is identical to calling [method @GlobalScope.sign] on each component. *)

    val octahedron_encode :
      BuiltinClass0.Vector3.t structure ptr ->
      BuiltinClass0.Vector2.t structure ptr
    (** Returns the octahedral-encoded (oct32) form of this [Vector3] as a [Vector2]. Since a [Vector2] occupies 1/3 less memory compared to [Vector3], this form of compression can be used to pass greater amounts of [method normalized] [Vector3]s without increasing storage or memory requirements. See also [method octahedron_decode].
[b]Note:[/b] [method octahedron_encode] can only be used for [method normalized] vectors. [method octahedron_encode] does [i]not[/i] check whether this [Vector3] is normalized, and will return a value that does not decompress to the original value if the [Vector3] is not normalized.
[b]Note:[/b] Octahedral compression is [i]lossy[/i], although visual differences are rarely perceptible in real world scenarios. *)

    val octahedron_decode :
      BuiltinClass0.Vector2.t structure ptr ->
      BuiltinClass0.Vector3.t structure ptr
    (** Returns the [Vector3] from an octahedral-compressed form created using [method octahedron_encode] (stored as a [Vector2]). *)

    val ( ~- ) :
      Vector3.t structure ptr ->
      Vector3.t structure ptr ->
      Vector3.t structure ptr ->
      unit
    (** Returns the negative value of the [Vector3]. This is the same as writing [code]Vector3(-v.x, -v.y, -v.z)[/code]. This operation flips the direction of the vector while keeping the same magnitude. With floats, the number zero can be either positive or negative. *)

    val ( ~+ ) :
      Vector3.t structure ptr ->
      Vector3.t structure ptr ->
      Vector3.t structure ptr ->
      unit
    (** Returns the same value as if the [code]+[/code] was not there. Unary [code]+[/code] does nothing, but sometimes it can make your code more readable. *)

    val not :
      Vector3.t structure ptr ->
      Vector3.t structure ptr ->
      Bool.t structure ptr ->
      unit

    val ( = ) :
      Vector3.t structure ptr ->
      Vector3.t structure ptr ->
      Bool.t structure ptr ->
      unit
    (** Returns [code]true[/code] if the vectors are exactly equal.
[b]Note:[/b] Due to floating-point precision errors, consider using [method is_equal_approx] instead, which is more reliable.
[b]Note:[/b] Vectors with [constant @GDScript.NAN] elements don't behave the same as other vectors. Therefore, the results from this operator may not be accurate if NaNs are included. *)

    val ( <> ) :
      Vector3.t structure ptr ->
      Vector3.t structure ptr ->
      Bool.t structure ptr ->
      unit
    (** Returns [code]true[/code] if the vectors are not equal.
[b]Note:[/b] Due to floating-point precision errors, consider using [method is_equal_approx] instead, which is more reliable.
[b]Note:[/b] Vectors with [constant @GDScript.NAN] elements don't behave the same as other vectors. Therefore, the results from this operator may not be accurate if NaNs are included. *)

    val ( < ) :
      Vector3.t structure ptr ->
      Vector3.t structure ptr ->
      Bool.t structure ptr ->
      unit
    (** Compares two [Vector3] vectors by first checking if the X value of the left vector is less than the X value of the [param right] vector. If the X values are exactly equal, then it repeats this check with the Y values of the two vectors, and then with the Z values. This operator is useful for sorting vectors.
[b]Note:[/b] Vectors with [constant @GDScript.NAN] elements don't behave the same as other vectors. Therefore, the results from this operator may not be accurate if NaNs are included. *)

    val ( <= ) :
      Vector3.t structure ptr ->
      Vector3.t structure ptr ->
      Bool.t structure ptr ->
      unit
    (** Compares two [Vector3] vectors by first checking if the X value of the left vector is less than or equal to the X value of the [param right] vector. If the X values are exactly equal, then it repeats this check with the Y values of the two vectors, and then with the Z values. This operator is useful for sorting vectors.
[b]Note:[/b] Vectors with [constant @GDScript.NAN] elements don't behave the same as other vectors. Therefore, the results from this operator may not be accurate if NaNs are included. *)

    val ( > ) :
      Vector3.t structure ptr ->
      Vector3.t structure ptr ->
      Bool.t structure ptr ->
      unit
    (** Compares two [Vector3] vectors by first checking if the X value of the left vector is greater than the X value of the [param right] vector. If the X values are exactly equal, then it repeats this check with the Y values of the two vectors, and then with the Z values. This operator is useful for sorting vectors.
[b]Note:[/b] Vectors with [constant @GDScript.NAN] elements don't behave the same as other vectors. Therefore, the results from this operator may not be accurate if NaNs are included. *)

    val ( >= ) :
      Vector3.t structure ptr ->
      Vector3.t structure ptr ->
      Bool.t structure ptr ->
      unit
    (** Compares two [Vector3] vectors by first checking if the X value of the left vector is greater than or equal to the X value of the [param right] vector. If the X values are exactly equal, then it repeats this check with the Y values of the two vectors, and then with the Z values. This operator is useful for sorting vectors.
[b]Note:[/b] Vectors with [constant @GDScript.NAN] elements don't behave the same as other vectors. Therefore, the results from this operator may not be accurate if NaNs are included. *)

    val ( + ) :
      Vector3.t structure ptr ->
      Vector3.t structure ptr ->
      Vector3.t structure ptr ->
      unit
    (** Adds each component of the [Vector3] by the components of the given [Vector3].
[codeblock]
print(Vector3(10, 20, 30) + Vector3(3, 4, 5)) # Prints ""(13, 24, 35)""
[/codeblock] *)

    val ( - ) :
      Vector3.t structure ptr ->
      Vector3.t structure ptr ->
      Vector3.t structure ptr ->
      unit
    (** Subtracts each component of the [Vector3] by the components of the given [Vector3].
[codeblock]
print(Vector3(10, 20, 30) - Vector3(3, 4, 5)) # Prints ""(7, 16, 25)""
[/codeblock] *)

    val ( * ) :
      Vector3.t structure ptr ->
      Vector3.t structure ptr ->
      Vector3.t structure ptr ->
      unit
    (** Multiplies each component of the [Vector3] by the components of the given [Vector3].
[codeblock]
print(Vector3(10, 20, 30)  *  Vector3(3, 4, 5)) # Prints ""(30, 80, 150)""
[/codeblock] *)

    val ( / ) :
      Vector3.t structure ptr ->
      Vector3.t structure ptr ->
      Vector3.t structure ptr ->
      unit
    (** Divides each component of the [Vector3] by the components of the given [Vector3].
[codeblock]
print(Vector3(10, 20, 30) / Vector3(2, 5, 3)) # Prints ""(5, 4, 10)""
[/codeblock] *)

    val _Vector3_elem_Dictionary :
      Vector3.t structure ptr ->
      Dictionary.t structure ptr ->
      Bool.t structure ptr ->
      unit

    val _Vector3_elem_Array :
      Vector3.t structure ptr ->
      Array.t structure ptr ->
      Bool.t structure ptr ->
      unit

    val _Vector3_elem_PackedVector3Array :
      Vector3.t structure ptr ->
      PackedVector3Array.t structure ptr ->
      Bool.t structure ptr ->
      unit

    module AXIS : sig
      type t

      val typ : Int.t structure ptr typ

      val _AXIS_X : int
      (** Enumerated value for the X axis. Returned by [method max_axis_index] and [method min_axis_index]. *)

      val _AXIS_Y : int
      (** Enumerated value for the Y axis. Returned by [method max_axis_index] and [method min_axis_index]. *)

      val _AXIS_Z : int
      (** Enumerated value for the Z axis. Returned by [method max_axis_index] and [method min_axis_index]. *)
    end
  end

  module type VECTOR3I = sig
    type t

    include Api_types.API_TYPE with type t := t

    val min_axis_index :
      BuiltinClass0.Vector3i.t structure ptr ->
      BuiltinClass0.Int.t structure ptr
    (** Returns the axis of the vector's lowest value. See [code]AXIS_ * [/code] constants. If all components are equal, this method returns [constant AXIS_Z]. *)

    val max_axis_index :
      BuiltinClass0.Vector3i.t structure ptr ->
      BuiltinClass0.Int.t structure ptr
    (** Returns the axis of the vector's highest value. See [code]AXIS_ * [/code] constants. If all components are equal, this method returns [constant AXIS_X]. *)

    val length :
      BuiltinClass0.Vector3i.t structure ptr ->
      BuiltinClass0.Float.t structure ptr
    (** Returns the length (magnitude) of this vector. *)

    val length_squared :
      BuiltinClass0.Vector3i.t structure ptr ->
      BuiltinClass0.Int.t structure ptr
    (** Returns the squared length (squared magnitude) of this vector.
This method runs faster than [method length], so prefer it if you need to compare vectors or need the squared distance for some formula. *)

    val sign :
      BuiltinClass0.Vector3i.t structure ptr ->
      BuiltinClass0.Vector3i.t structure ptr
    (** Returns a new vector with each component set to [code]1[/code] if it's positive, [code]-1[/code] if it's negative, and [code]0[/code] if it's zero. The result is identical to calling [method @GlobalScope.sign] on each component. *)

    val abs :
      BuiltinClass0.Vector3i.t structure ptr ->
      BuiltinClass0.Vector3i.t structure ptr
    (** Returns a new vector with all components in absolute values (i.e. positive). *)

    val clamp :
      BuiltinClass0.Vector3i.t structure ptr ->
      BuiltinClass0.Vector3i.t structure ptr ->
      BuiltinClass0.Vector3i.t structure ptr ->
      BuiltinClass0.Vector3i.t structure ptr
    (** Returns a new vector with all components clamped between the components of [param min] and [param max], by running [method @GlobalScope.clamp] on each component. *)

    val snapped :
      BuiltinClass0.Vector3i.t structure ptr ->
      BuiltinClass0.Vector3i.t structure ptr ->
      BuiltinClass0.Vector3i.t structure ptr
    (** Returns a new vector with each component snapped to the closest multiple of the corresponding component in [param step]. *)

    val ( ~- ) :
      Vector3i.t structure ptr ->
      Vector3i.t structure ptr ->
      Vector3i.t structure ptr ->
      unit
    (** Returns the negative value of the [Vector3i]. This is the same as writing [code]Vector3i(-v.x, -v.y, -v.z)[/code]. This operation flips the direction of the vector while keeping the same magnitude. *)

    val ( ~+ ) :
      Vector3i.t structure ptr ->
      Vector3i.t structure ptr ->
      Vector3i.t structure ptr ->
      unit
    (** Returns the same value as if the [code]+[/code] was not there. Unary [code]+[/code] does nothing, but sometimes it can make your code more readable. *)

    val not :
      Vector3i.t structure ptr ->
      Vector3i.t structure ptr ->
      Bool.t structure ptr ->
      unit

    val ( = ) :
      Vector3i.t structure ptr ->
      Vector3i.t structure ptr ->
      Bool.t structure ptr ->
      unit
    (** Returns [code]true[/code] if the vectors are equal. *)

    val ( <> ) :
      Vector3i.t structure ptr ->
      Vector3i.t structure ptr ->
      Bool.t structure ptr ->
      unit
    (** Returns [code]true[/code] if the vectors are not equal. *)

    val ( < ) :
      Vector3i.t structure ptr ->
      Vector3i.t structure ptr ->
      Bool.t structure ptr ->
      unit
    (** Compares two [Vector3i] vectors by first checking if the X value of the left vector is less than the X value of the [param right] vector. If the X values are exactly equal, then it repeats this check with the Y values of the two vectors, and then with the Z values. This operator is useful for sorting vectors. *)

    val ( <= ) :
      Vector3i.t structure ptr ->
      Vector3i.t structure ptr ->
      Bool.t structure ptr ->
      unit
    (** Compares two [Vector3i] vectors by first checking if the X value of the left vector is less than or equal to the X value of the [param right] vector. If the X values are exactly equal, then it repeats this check with the Y values of the two vectors, and then with the Z values. This operator is useful for sorting vectors. *)

    val ( > ) :
      Vector3i.t structure ptr ->
      Vector3i.t structure ptr ->
      Bool.t structure ptr ->
      unit
    (** Compares two [Vector3i] vectors by first checking if the X value of the left vector is greater than the X value of the [param right] vector. If the X values are exactly equal, then it repeats this check with the Y values of the two vectors, and then with the Z values. This operator is useful for sorting vectors. *)

    val ( >= ) :
      Vector3i.t structure ptr ->
      Vector3i.t structure ptr ->
      Bool.t structure ptr ->
      unit
    (** Compares two [Vector3i] vectors by first checking if the X value of the left vector is greater than or equal to the X value of the [param right] vector. If the X values are exactly equal, then it repeats this check with the Y values of the two vectors, and then with the Z values. This operator is useful for sorting vectors. *)

    val ( + ) :
      Vector3i.t structure ptr ->
      Vector3i.t structure ptr ->
      Vector3i.t structure ptr ->
      unit
    (** Adds each component of the [Vector3i] by the components of the given [Vector3i].
[codeblock]
print(Vector3i(10, 20, 30) + Vector3i(3, 4, 5)) # Prints ""(13, 24, 35)""
[/codeblock] *)

    val ( - ) :
      Vector3i.t structure ptr ->
      Vector3i.t structure ptr ->
      Vector3i.t structure ptr ->
      unit
    (** Subtracts each component of the [Vector3i] by the components of the given [Vector3i].
[codeblock]
print(Vector3i(10, 20, 30) - Vector3i(3, 4, 5)) # Prints ""(7, 16, 25)""
[/codeblock] *)

    val ( * ) :
      Vector3i.t structure ptr ->
      Vector3i.t structure ptr ->
      Vector3i.t structure ptr ->
      unit
    (** Multiplies each component of the [Vector3i] by the components of the given [Vector3i].
[codeblock]
print(Vector3i(10, 20, 30)  *  Vector3i(3, 4, 5)) # Prints ""(30, 80, 150)""
[/codeblock] *)

    val ( / ) :
      Vector3i.t structure ptr ->
      Vector3i.t structure ptr ->
      Vector3i.t structure ptr ->
      unit
    (** Divides each component of the [Vector3i] by the components of the given [Vector3i].
[codeblock]
print(Vector3i(10, 20, 30) / Vector3i(2, 5, 3)) # Prints ""(5, 4, 10)""
[/codeblock] *)

    val ( % ) :
      Vector3i.t structure ptr ->
      Vector3i.t structure ptr ->
      Vector3i.t structure ptr ->
      unit
    (** Gets the remainder of each component of the [Vector3i] with the components of the given [Vector3i]. This operation uses truncated division, which is often not desired as it does not work well with negative numbers. Consider using [method @GlobalScope.posmod] instead if you want to handle negative numbers.
[codeblock]
print(Vector3i(10, -20, 30) % Vector3i(7, 8, 9)) # Prints ""(3, -4, 3)""
[/codeblock] *)

    val _Vector3i_elem_Dictionary :
      Vector3i.t structure ptr ->
      Dictionary.t structure ptr ->
      Bool.t structure ptr ->
      unit

    val _Vector3i_elem_Array :
      Vector3i.t structure ptr ->
      Array.t structure ptr ->
      Bool.t structure ptr ->
      unit

    module AXIS : sig
      type t

      val typ : Int.t structure ptr typ

      val _AXIS_X : int
      (** Enumerated value for the X axis. Returned by [method max_axis_index] and [method min_axis_index]. *)

      val _AXIS_Y : int
      (** Enumerated value for the Y axis. Returned by [method max_axis_index] and [method min_axis_index]. *)

      val _AXIS_Z : int
      (** Enumerated value for the Z axis. Returned by [method max_axis_index] and [method min_axis_index]. *)
    end
  end

  module type TRANSFORM2D = sig
    type t

    include Api_types.API_TYPE with type t := t

    val inverse :
      BuiltinClass0.Transform2D.t structure ptr ->
      BuiltinClass0.Transform2D.t structure ptr
    (** Returns the inverse of the transform, under the assumption that the transformation basis is orthonormal (i.e. rotation/reflection is fine, scaling/skew is not). Use [method affine_inverse] for non-orthonormal transforms (e.g. with scaling). *)

    val affine_inverse :
      BuiltinClass0.Transform2D.t structure ptr ->
      BuiltinClass0.Transform2D.t structure ptr
    (** Returns the inverse of the transform, under the assumption that the basis is invertible (must have non-zero determinant). *)

    val get_rotation :
      BuiltinClass0.Transform2D.t structure ptr ->
      BuiltinClass0.Float.t structure ptr
    (** Returns the transform's rotation (in radians). *)

    val get_origin :
      BuiltinClass0.Transform2D.t structure ptr ->
      BuiltinClass0.Vector2.t structure ptr
    (** Returns the transform's origin (translation). *)

    val get_scale :
      BuiltinClass0.Transform2D.t structure ptr ->
      BuiltinClass0.Vector2.t structure ptr
    (** Returns the scale. *)

    val get_skew :
      BuiltinClass0.Transform2D.t structure ptr ->
      BuiltinClass0.Float.t structure ptr
    (** Returns the transform's skew (in radians). *)

    val orthonormalized :
      BuiltinClass0.Transform2D.t structure ptr ->
      BuiltinClass0.Transform2D.t structure ptr
    (** Returns the transform with the basis orthogonal (90 degrees), and normalized axis vectors (scale of 1 or -1). *)

    val rotated :
      BuiltinClass0.Float.t structure ptr ->
      BuiltinClass0.Transform2D.t structure ptr ->
      BuiltinClass0.Transform2D.t structure ptr
    (** Returns a copy of the transform rotated by the given [param angle] (in radians).
This method is an optimized version of multiplying the given transform [code]X[/code] with a corresponding rotation transform [code]R[/code] from the left, i.e., [code]R  *  X[/code].
This can be seen as transforming with respect to the global/parent frame. *)

    val rotated_local :
      BuiltinClass0.Float.t structure ptr ->
      BuiltinClass0.Transform2D.t structure ptr ->
      BuiltinClass0.Transform2D.t structure ptr
    (** Returns a copy of the transform rotated by the given [param angle] (in radians).
This method is an optimized version of multiplying the given transform [code]X[/code] with a corresponding rotation transform [code]R[/code] from the right, i.e., [code]X  *  R[/code].
This can be seen as transforming with respect to the local frame. *)

    val scaled :
      BuiltinClass0.Vector2.t structure ptr ->
      BuiltinClass0.Transform2D.t structure ptr ->
      BuiltinClass0.Transform2D.t structure ptr
    (** Returns a copy of the transform scaled by the given [param scale] factor.
This method is an optimized version of multiplying the given transform [code]X[/code] with a corresponding scaling transform [code]S[/code] from the left, i.e., [code]S  *  X[/code].
This can be seen as transforming with respect to the global/parent frame. *)

    val scaled_local :
      BuiltinClass0.Vector2.t structure ptr ->
      BuiltinClass0.Transform2D.t structure ptr ->
      BuiltinClass0.Transform2D.t structure ptr
    (** Returns a copy of the transform scaled by the given [param scale] factor.
This method is an optimized version of multiplying the given transform [code]X[/code] with a corresponding scaling transform [code]S[/code] from the right, i.e., [code]X  *  S[/code].
This can be seen as transforming with respect to the local frame. *)

    val translated :
      BuiltinClass0.Vector2.t structure ptr ->
      BuiltinClass0.Transform2D.t structure ptr ->
      BuiltinClass0.Transform2D.t structure ptr
    (** Returns a copy of the transform translated by the given [param offset].
This method is an optimized version of multiplying the given transform [code]X[/code] with a corresponding translation transform [code]T[/code] from the left, i.e., [code]T  *  X[/code].
This can be seen as transforming with respect to the global/parent frame. *)

    val translated_local :
      BuiltinClass0.Vector2.t structure ptr ->
      BuiltinClass0.Transform2D.t structure ptr ->
      BuiltinClass0.Transform2D.t structure ptr
    (** Returns a copy of the transform translated by the given [param offset].
This method is an optimized version of multiplying the given transform [code]X[/code] with a corresponding translation transform [code]T[/code] from the right, i.e., [code]X  *  T[/code].
This can be seen as transforming with respect to the local frame. *)

    val determinant :
      BuiltinClass0.Transform2D.t structure ptr ->
      BuiltinClass0.Float.t structure ptr
    (** Returns the determinant of the basis matrix. If the basis is uniformly scaled, then its determinant equals the square of the scale factor.
A negative determinant means the basis was flipped, so one part of the scale is negative. A zero determinant means the basis isn't invertible, and is usually considered invalid. *)

    val basis_xform :
      BuiltinClass0.Vector2.t structure ptr ->
      BuiltinClass0.Transform2D.t structure ptr ->
      BuiltinClass0.Vector2.t structure ptr
    (** Returns a vector transformed (multiplied) by the basis matrix.
This method does not account for translation (the [member origin] vector). *)

    val basis_xform_inv :
      BuiltinClass0.Vector2.t structure ptr ->
      BuiltinClass0.Transform2D.t structure ptr ->
      BuiltinClass0.Vector2.t structure ptr
    (** Returns a vector transformed (multiplied) by the inverse basis matrix, under the assumption that the basis is orthonormal (i.e. rotation/reflection is fine, scaling/skew is not).
This method does not account for translation (the [member origin] vector).
[code]transform.basis_xform_inv(vector)[/code] is equivalent to [code]transform.inverse().basis_xform(vector)[/code]. See [method inverse].
For non-orthonormal transforms (e.g. with scaling) [code]transform.affine_inverse().basis_xform(vector)[/code] can be used instead. See [method affine_inverse]. *)

    val interpolate_with :
      BuiltinClass0.Transform2D.t structure ptr ->
      BuiltinClass0.Float.t structure ptr ->
      BuiltinClass0.Transform2D.t structure ptr ->
      BuiltinClass0.Transform2D.t structure ptr
    (** Returns a transform interpolated between this transform and another by a given [param weight] (on the range of 0.0 to 1.0). *)

    val is_conformal :
      BuiltinClass0.Transform2D.t structure ptr ->
      BuiltinClass0.Bool.t structure ptr
    (** Returns [code]true[/code] if the transform's basis is conformal, meaning it preserves angles and distance ratios, and may only be composed of rotation and uniform scale. Returns [code]false[/code] if the transform's basis has non-uniform scale or shear/skew. This can be used to validate if the transform is non-distorted, which is important for physics and other use cases. *)

    val is_equal_approx :
      BuiltinClass0.Transform2D.t structure ptr ->
      BuiltinClass0.Transform2D.t structure ptr ->
      BuiltinClass0.Bool.t structure ptr
    (** Returns [code]true[/code] if this transform and [param xform] are approximately equal, by running [method @GlobalScope.is_equal_approx] on each component. *)

    val is_finite :
      BuiltinClass0.Transform2D.t structure ptr ->
      BuiltinClass0.Bool.t structure ptr
    (** Returns [code]true[/code] if this transform is finite, by calling [method @GlobalScope.is_finite] on each component. *)

    val looking_at :
      BuiltinClass0.Vector2.t structure ptr ->
      BuiltinClass0.Transform2D.t structure ptr ->
      BuiltinClass0.Transform2D.t structure ptr
    (** Returns a copy of the transform rotated such that the rotated X-axis points towards the [param target] position.
Operations take place in global space. *)

    val not :
      Transform2D.t structure ptr ->
      Transform2D.t structure ptr ->
      Bool.t structure ptr ->
      unit

    val ( = ) :
      Transform2D.t structure ptr ->
      Transform2D.t structure ptr ->
      Bool.t structure ptr ->
      unit
    (** Returns [code]true[/code] if the transforms are exactly equal.
[b]Note:[/b] Due to floating-point precision errors, consider using [method is_equal_approx] instead, which is more reliable. *)

    val ( <> ) :
      Transform2D.t structure ptr ->
      Transform2D.t structure ptr ->
      Bool.t structure ptr ->
      unit
    (** Returns [code]true[/code] if the transforms are not equal.
[b]Note:[/b] Due to floating-point precision errors, consider using [method is_equal_approx] instead, which is more reliable. *)

    val ( * ) :
      Transform2D.t structure ptr ->
      Transform2D.t structure ptr ->
      Transform2D.t structure ptr ->
      unit
    (** Composes these two transformation matrices by multiplying them together. This has the effect of transforming the second transform (the child) by the first transform (the parent). *)

    val _Transform2D_elem_Dictionary :
      Transform2D.t structure ptr ->
      Dictionary.t structure ptr ->
      Bool.t structure ptr ->
      unit

    val _Transform2D_elem_Array :
      Transform2D.t structure ptr ->
      Array.t structure ptr ->
      Bool.t structure ptr ->
      unit
  end

  module type VECTOR4 = sig
    type t

    include Api_types.API_TYPE with type t := t

    val min_axis_index :
      BuiltinClass0.Vector4.t structure ptr -> BuiltinClass0.Int.t structure ptr
    (** Returns the axis of the vector's lowest value. See [code]AXIS_ * [/code] constants. If all components are equal, this method returns [constant AXIS_W]. *)

    val max_axis_index :
      BuiltinClass0.Vector4.t structure ptr -> BuiltinClass0.Int.t structure ptr
    (** Returns the axis of the vector's highest value. See [code]AXIS_ * [/code] constants. If all components are equal, this method returns [constant AXIS_X]. *)

    val length :
      BuiltinClass0.Vector4.t structure ptr ->
      BuiltinClass0.Float.t structure ptr
    (** Returns the length (magnitude) of this vector. *)

    val length_squared :
      BuiltinClass0.Vector4.t structure ptr ->
      BuiltinClass0.Float.t structure ptr
    (** Returns the squared length (squared magnitude) of this vector.
This method runs faster than [method length], so prefer it if you need to compare vectors or need the squared distance for some formula. *)

    val abs :
      BuiltinClass0.Vector4.t structure ptr ->
      BuiltinClass0.Vector4.t structure ptr
    (** Returns a new vector with all components in absolute values (i.e. positive). *)

    val sign :
      BuiltinClass0.Vector4.t structure ptr ->
      BuiltinClass0.Vector4.t structure ptr
    (** Returns a new vector with each component set to [code]1.0[/code] if it's positive, [code]-1.0[/code] if it's negative, and [code]0.0[/code] if it's zero. The result is identical to calling [method @GlobalScope.sign] on each component. *)

    val floor :
      BuiltinClass0.Vector4.t structure ptr ->
      BuiltinClass0.Vector4.t structure ptr
    (** Returns a new vector with all components rounded down (towards negative infinity). *)

    val ceil :
      BuiltinClass0.Vector4.t structure ptr ->
      BuiltinClass0.Vector4.t structure ptr
    (** Returns a new vector with all components rounded up (towards positive infinity). *)

    val round :
      BuiltinClass0.Vector4.t structure ptr ->
      BuiltinClass0.Vector4.t structure ptr
    (** Returns a new vector with all components rounded to the nearest integer, with halfway cases rounded away from zero. *)

    val lerp :
      BuiltinClass0.Vector4.t structure ptr ->
      BuiltinClass0.Float.t structure ptr ->
      BuiltinClass0.Vector4.t structure ptr ->
      BuiltinClass0.Vector4.t structure ptr
    (** Returns the result of the linear interpolation between this vector and [param to] by amount [param weight]. [param weight] is on the range of [code]0.0[/code] to [code]1.0[/code], representing the amount of interpolation. *)

    val cubic_interpolate :
      BuiltinClass0.Vector4.t structure ptr ->
      BuiltinClass0.Vector4.t structure ptr ->
      BuiltinClass0.Vector4.t structure ptr ->
      BuiltinClass0.Float.t structure ptr ->
      BuiltinClass0.Vector4.t structure ptr ->
      BuiltinClass0.Vector4.t structure ptr
    (** Performs a cubic interpolation between this vector and [param b] using [param pre_a] and [param post_b] as handles, and returns the result at position [param weight]. [param weight] is on the range of 0.0 to 1.0, representing the amount of interpolation. *)

    val cubic_interpolate_in_time :
      BuiltinClass0.Vector4.t structure ptr ->
      BuiltinClass0.Vector4.t structure ptr ->
      BuiltinClass0.Vector4.t structure ptr ->
      BuiltinClass0.Float.t structure ptr ->
      BuiltinClass0.Float.t structure ptr ->
      BuiltinClass0.Float.t structure ptr ->
      BuiltinClass0.Float.t structure ptr ->
      BuiltinClass0.Vector4.t structure ptr ->
      BuiltinClass0.Vector4.t structure ptr
    (** Performs a cubic interpolation between this vector and [param b] using [param pre_a] and [param post_b] as handles, and returns the result at position [param weight]. [param weight] is on the range of 0.0 to 1.0, representing the amount of interpolation.
It can perform smoother interpolation than [method cubic_interpolate] by the time values. *)

    val posmod :
      BuiltinClass0.Float.t structure ptr ->
      BuiltinClass0.Vector4.t structure ptr ->
      BuiltinClass0.Vector4.t structure ptr
    (** Returns a vector composed of the [method @GlobalScope.fposmod] of this vector's components and [param mod]. *)

    val posmodv :
      BuiltinClass0.Vector4.t structure ptr ->
      BuiltinClass0.Vector4.t structure ptr ->
      BuiltinClass0.Vector4.t structure ptr
    (** Returns a vector composed of the [method @GlobalScope.fposmod] of this vector's components and [param modv]'s components. *)

    val snapped :
      BuiltinClass0.Vector4.t structure ptr ->
      BuiltinClass0.Vector4.t structure ptr ->
      BuiltinClass0.Vector4.t structure ptr
    (** Returns a new vector with each component snapped to the nearest multiple of the corresponding component in [param step]. This can also be used to round the components to an arbitrary number of decimals. *)

    val clamp :
      BuiltinClass0.Vector4.t structure ptr ->
      BuiltinClass0.Vector4.t structure ptr ->
      BuiltinClass0.Vector4.t structure ptr ->
      BuiltinClass0.Vector4.t structure ptr
    (** Returns a new vector with all components clamped between the components of [param min] and [param max], by running [method @GlobalScope.clamp] on each component. *)

    val normalized :
      BuiltinClass0.Vector4.t structure ptr ->
      BuiltinClass0.Vector4.t structure ptr
    (** Returns the result of scaling the vector to unit length. Equivalent to [code]v / v.length()[/code]. See also [method is_normalized].
[b]Note:[/b] This function may return incorrect values if the input vector length is near zero. *)

    val is_normalized :
      BuiltinClass0.Vector4.t structure ptr ->
      BuiltinClass0.Bool.t structure ptr
    (** Returns [code]true[/code] if the vector is normalized, i.e. its length is approximately equal to 1. *)

    val direction_to :
      BuiltinClass0.Vector4.t structure ptr ->
      BuiltinClass0.Vector4.t structure ptr ->
      BuiltinClass0.Vector4.t structure ptr
    (** Returns the normalized vector pointing from this vector to [param to]. This is equivalent to using [code](b - a).normalized()[/code]. *)

    val distance_to :
      BuiltinClass0.Vector4.t structure ptr ->
      BuiltinClass0.Vector4.t structure ptr ->
      BuiltinClass0.Float.t structure ptr
    (** Returns the distance between this vector and [param to]. *)

    val distance_squared_to :
      BuiltinClass0.Vector4.t structure ptr ->
      BuiltinClass0.Vector4.t structure ptr ->
      BuiltinClass0.Float.t structure ptr
    (** Returns the squared distance between this vector and [param to].
This method runs faster than [method distance_to], so prefer it if you need to compare vectors or need the squared distance for some formula. *)

    val dot :
      BuiltinClass0.Vector4.t structure ptr ->
      BuiltinClass0.Vector4.t structure ptr ->
      BuiltinClass0.Float.t structure ptr
    (** Returns the dot product of this vector and [param with]. *)

    val inverse :
      BuiltinClass0.Vector4.t structure ptr ->
      BuiltinClass0.Vector4.t structure ptr
    (** Returns the inverse of the vector. This is the same as [code]Vector4(1.0 / v.x, 1.0 / v.y, 1.0 / v.z, 1.0 / v.w)[/code]. *)

    val is_equal_approx :
      BuiltinClass0.Vector4.t structure ptr ->
      BuiltinClass0.Vector4.t structure ptr ->
      BuiltinClass0.Bool.t structure ptr
    (** Returns [code]true[/code] if this vector and [param to] are approximately equal, by running [method @GlobalScope.is_equal_approx] on each component. *)

    val is_zero_approx :
      BuiltinClass0.Vector4.t structure ptr ->
      BuiltinClass0.Bool.t structure ptr
    (** Returns [code]true[/code] if this vector's values are approximately zero, by running [method @GlobalScope.is_zero_approx] on each component.
This method is faster than using [method is_equal_approx] with one value as a zero vector. *)

    val is_finite :
      BuiltinClass0.Vector4.t structure ptr ->
      BuiltinClass0.Bool.t structure ptr
    (** Returns [code]true[/code] if this vector is finite, by calling [method @GlobalScope.is_finite] on each component. *)

    val ( ~- ) :
      Vector4.t structure ptr ->
      Vector4.t structure ptr ->
      Vector4.t structure ptr ->
      unit
    (** Returns the negative value of the [Vector4]. This is the same as writing [code]Vector4(-v.x, -v.y, -v.z, -v.w)[/code]. This operation flips the direction of the vector while keeping the same magnitude. With floats, the number zero can be either positive or negative. *)

    val ( ~+ ) :
      Vector4.t structure ptr ->
      Vector4.t structure ptr ->
      Vector4.t structure ptr ->
      unit
    (** Returns the same value as if the [code]+[/code] was not there. Unary [code]+[/code] does nothing, but sometimes it can make your code more readable. *)

    val not :
      Vector4.t structure ptr ->
      Vector4.t structure ptr ->
      Bool.t structure ptr ->
      unit

    val ( = ) :
      Vector4.t structure ptr ->
      Vector4.t structure ptr ->
      Bool.t structure ptr ->
      unit
    (** Returns [code]true[/code] if the vectors are exactly equal.
[b]Note:[/b] Due to floating-point precision errors, consider using [method is_equal_approx] instead, which is more reliable.
[b]Note:[/b] Vectors with [constant @GDScript.NAN] elements don't behave the same as other vectors. Therefore, the results from this operator may not be accurate if NaNs are included. *)

    val ( <> ) :
      Vector4.t structure ptr ->
      Vector4.t structure ptr ->
      Bool.t structure ptr ->
      unit
    (** Returns [code]true[/code] if the vectors are not equal.
[b]Note:[/b] Due to floating-point precision errors, consider using [method is_equal_approx] instead, which is more reliable.
[b]Note:[/b] Vectors with [constant @GDScript.NAN] elements don't behave the same as other vectors. Therefore, the results from this operator may not be accurate if NaNs are included. *)

    val ( < ) :
      Vector4.t structure ptr ->
      Vector4.t structure ptr ->
      Bool.t structure ptr ->
      unit
    (** Compares two [Vector4] vectors by first checking if the X value of the left vector is less than the X value of the [param right] vector. If the X values are exactly equal, then it repeats this check with the Y values of the two vectors, Z values of the two vectors, and then with the W values. This operator is useful for sorting vectors.
[b]Note:[/b] Vectors with [constant @GDScript.NAN] elements don't behave the same as other vectors. Therefore, the results from this operator may not be accurate if NaNs are included. *)

    val ( <= ) :
      Vector4.t structure ptr ->
      Vector4.t structure ptr ->
      Bool.t structure ptr ->
      unit
    (** Compares two [Vector4] vectors by first checking if the X value of the left vector is less than or equal to the X value of the [param right] vector. If the X values are exactly equal, then it repeats this check with the Y values of the two vectors, Z values of the two vectors, and then with the W values. This operator is useful for sorting vectors.
[b]Note:[/b] Vectors with [constant @GDScript.NAN] elements don't behave the same as other vectors. Therefore, the results from this operator may not be accurate if NaNs are included. *)

    val ( > ) :
      Vector4.t structure ptr ->
      Vector4.t structure ptr ->
      Bool.t structure ptr ->
      unit
    (** Compares two [Vector4] vectors by first checking if the X value of the left vector is greater than the X value of the [param right] vector. If the X values are exactly equal, then it repeats this check with the Y values of the two vectors, Z values of the two vectors, and then with the W values. This operator is useful for sorting vectors.
[b]Note:[/b] Vectors with [constant @GDScript.NAN] elements don't behave the same as other vectors. Therefore, the results from this operator may not be accurate if NaNs are included. *)

    val ( >= ) :
      Vector4.t structure ptr ->
      Vector4.t structure ptr ->
      Bool.t structure ptr ->
      unit
    (** Compares two [Vector4] vectors by first checking if the X value of the left vector is greater than or equal to the X value of the [param right] vector. If the X values are exactly equal, then it repeats this check with the Y values of the two vectors, Z values of the two vectors, and then with the W values. This operator is useful for sorting vectors.
[b]Note:[/b] Vectors with [constant @GDScript.NAN] elements don't behave the same as other vectors. Therefore, the results from this operator may not be accurate if NaNs are included. *)

    val ( + ) :
      Vector4.t structure ptr ->
      Vector4.t structure ptr ->
      Vector4.t structure ptr ->
      unit
    (** Adds each component of the [Vector4] by the components of the given [Vector4].
[codeblock]
print(Vector4(10, 20, 30, 40) + Vector4(3, 4, 5, 6)) # Prints ""(13, 24, 35, 46)""
[/codeblock] *)

    val ( - ) :
      Vector4.t structure ptr ->
      Vector4.t structure ptr ->
      Vector4.t structure ptr ->
      unit
    (** Subtracts each component of the [Vector4] by the components of the given [Vector4].
[codeblock]
print(Vector4(10, 20, 30, 40) - Vector4(3, 4, 5, 6)) # Prints ""(7, 16, 25, 34)""
[/codeblock] *)

    val ( * ) :
      Vector4.t structure ptr ->
      Vector4.t structure ptr ->
      Vector4.t structure ptr ->
      unit
    (** Multiplies each component of the [Vector4] by the components of the given [Vector4].
[codeblock]
print(Vector4(10, 20, 30, 40)  *  Vector4(3, 4, 5, 6)) # Prints ""(30, 80, 150, 240)""
[/codeblock] *)

    val ( / ) :
      Vector4.t structure ptr ->
      Vector4.t structure ptr ->
      Vector4.t structure ptr ->
      unit
    (** Divides each component of the [Vector4] by the components of the given [Vector4].
[codeblock]
print(Vector4(10, 20, 30, 40) / Vector4(2, 5, 3, 4)) # Prints ""(5, 4, 10, 10)""
[/codeblock] *)

    val _Vector4_elem_Dictionary :
      Vector4.t structure ptr ->
      Dictionary.t structure ptr ->
      Bool.t structure ptr ->
      unit

    val _Vector4_elem_Array :
      Vector4.t structure ptr ->
      Array.t structure ptr ->
      Bool.t structure ptr ->
      unit

    module AXIS : sig
      type t

      val typ : Int.t structure ptr typ

      val _AXIS_X : int
      (** Enumerated value for the X axis. Returned by [method max_axis_index] and [method min_axis_index]. *)

      val _AXIS_Y : int
      (** Enumerated value for the Y axis. Returned by [method max_axis_index] and [method min_axis_index]. *)

      val _AXIS_Z : int
      (** Enumerated value for the Z axis. Returned by [method max_axis_index] and [method min_axis_index]. *)

      val _AXIS_W : int
      (** Enumerated value for the W axis. Returned by [method max_axis_index] and [method min_axis_index]. *)
    end
  end

  module type VECTOR4I = sig
    type t

    include Api_types.API_TYPE with type t := t

    val min_axis_index :
      BuiltinClass0.Vector4i.t structure ptr ->
      BuiltinClass0.Int.t structure ptr
    (** Returns the axis of the vector's lowest value. See [code]AXIS_ * [/code] constants. If all components are equal, this method returns [constant AXIS_W]. *)

    val max_axis_index :
      BuiltinClass0.Vector4i.t structure ptr ->
      BuiltinClass0.Int.t structure ptr
    (** Returns the axis of the vector's highest value. See [code]AXIS_ * [/code] constants. If all components are equal, this method returns [constant AXIS_X]. *)

    val length :
      BuiltinClass0.Vector4i.t structure ptr ->
      BuiltinClass0.Float.t structure ptr
    (** Returns the length (magnitude) of this vector. *)

    val length_squared :
      BuiltinClass0.Vector4i.t structure ptr ->
      BuiltinClass0.Int.t structure ptr
    (** Returns the squared length (squared magnitude) of this vector.
This method runs faster than [method length], so prefer it if you need to compare vectors or need the squared distance for some formula. *)

    val sign :
      BuiltinClass0.Vector4i.t structure ptr ->
      BuiltinClass0.Vector4i.t structure ptr
    (** Returns a new vector with each component set to [code]1[/code] if it's positive, [code]-1[/code] if it's negative, and [code]0[/code] if it's zero. The result is identical to calling [method @GlobalScope.sign] on each component. *)

    val abs :
      BuiltinClass0.Vector4i.t structure ptr ->
      BuiltinClass0.Vector4i.t structure ptr
    (** Returns a new vector with all components in absolute values (i.e. positive). *)

    val clamp :
      BuiltinClass0.Vector4i.t structure ptr ->
      BuiltinClass0.Vector4i.t structure ptr ->
      BuiltinClass0.Vector4i.t structure ptr ->
      BuiltinClass0.Vector4i.t structure ptr
    (** Returns a new vector with all components clamped between the components of [param min] and [param max], by running [method @GlobalScope.clamp] on each component. *)

    val snapped :
      BuiltinClass0.Vector4i.t structure ptr ->
      BuiltinClass0.Vector4i.t structure ptr ->
      BuiltinClass0.Vector4i.t structure ptr
    (** Returns a new vector with each component snapped to the closest multiple of the corresponding component in [param step]. *)

    val ( ~- ) :
      Vector4i.t structure ptr ->
      Vector4i.t structure ptr ->
      Vector4i.t structure ptr ->
      unit
    (** Returns the negative value of the [Vector4i]. This is the same as writing [code]Vector4i(-v.x, -v.y, -v.z, -v.w)[/code]. This operation flips the direction of the vector while keeping the same magnitude. *)

    val ( ~+ ) :
      Vector4i.t structure ptr ->
      Vector4i.t structure ptr ->
      Vector4i.t structure ptr ->
      unit
    (** Returns the same value as if the [code]+[/code] was not there. Unary [code]+[/code] does nothing, but sometimes it can make your code more readable. *)

    val not :
      Vector4i.t structure ptr ->
      Vector4i.t structure ptr ->
      Bool.t structure ptr ->
      unit

    val ( = ) :
      Vector4i.t structure ptr ->
      Vector4i.t structure ptr ->
      Bool.t structure ptr ->
      unit
    (** Returns [code]true[/code] if the vectors are exactly equal. *)

    val ( <> ) :
      Vector4i.t structure ptr ->
      Vector4i.t structure ptr ->
      Bool.t structure ptr ->
      unit
    (** Returns [code]true[/code] if the vectors are not equal. *)

    val ( < ) :
      Vector4i.t structure ptr ->
      Vector4i.t structure ptr ->
      Bool.t structure ptr ->
      unit
    (** Compares two [Vector4i] vectors by first checking if the X value of the left vector is less than the X value of the [param right] vector. If the X values are exactly equal, then it repeats this check with the Y values of the two vectors, Z values of the two vectors, and then with the W values. This operator is useful for sorting vectors. *)

    val ( <= ) :
      Vector4i.t structure ptr ->
      Vector4i.t structure ptr ->
      Bool.t structure ptr ->
      unit
    (** Compares two [Vector4i] vectors by first checking if the X value of the left vector is less than or equal to the X value of the [param right] vector. If the X values are exactly equal, then it repeats this check with the Y values of the two vectors, Z values of the two vectors, and then with the W values. This operator is useful for sorting vectors. *)

    val ( > ) :
      Vector4i.t structure ptr ->
      Vector4i.t structure ptr ->
      Bool.t structure ptr ->
      unit
    (** Compares two [Vector4i] vectors by first checking if the X value of the left vector is greater than the X value of the [param right] vector. If the X values are exactly equal, then it repeats this check with the Y values of the two vectors, Z values of the two vectors, and then with the W values. This operator is useful for sorting vectors. *)

    val ( >= ) :
      Vector4i.t structure ptr ->
      Vector4i.t structure ptr ->
      Bool.t structure ptr ->
      unit
    (** Compares two [Vector4i] vectors by first checking if the X value of the left vector is greater than or equal to the X value of the [param right] vector. If the X values are exactly equal, then it repeats this check with the Y values of the two vectors, Z values of the two vectors, and then with the W values. This operator is useful for sorting vectors. *)

    val ( + ) :
      Vector4i.t structure ptr ->
      Vector4i.t structure ptr ->
      Vector4i.t structure ptr ->
      unit
    (** Adds each component of the [Vector4i] by the components of the given [Vector4i].
[codeblock]
print(Vector4i(10, 20, 30, 40) + Vector4i(3, 4, 5, 6)) # Prints ""(13, 24, 35, 46)""
[/codeblock] *)

    val ( - ) :
      Vector4i.t structure ptr ->
      Vector4i.t structure ptr ->
      Vector4i.t structure ptr ->
      unit
    (** Subtracts each component of the [Vector4i] by the components of the given [Vector4i].
[codeblock]
print(Vector4i(10, 20, 30, 40) - Vector4i(3, 4, 5, 6)) # Prints ""(7, 16, 25, 34)""
[/codeblock] *)

    val ( * ) :
      Vector4i.t structure ptr ->
      Vector4i.t structure ptr ->
      Vector4i.t structure ptr ->
      unit
    (** Multiplies each component of the [Vector4i] by the components of the given [Vector4i].
[codeblock]
print(Vector4i(10, 20, 30, 40)  *  Vector4i(3, 4, 5, 6)) # Prints ""(30, 80, 150, 240)""
[/codeblock] *)

    val ( / ) :
      Vector4i.t structure ptr ->
      Vector4i.t structure ptr ->
      Vector4i.t structure ptr ->
      unit
    (** Divides each component of the [Vector4i] by the components of the given [Vector4i].
[codeblock]
print(Vector4i(10, 20, 30, 40) / Vector4i(2, 5, 3, 4)) # Prints ""(5, 4, 10, 10)""
[/codeblock] *)

    val ( % ) :
      Vector4i.t structure ptr ->
      Vector4i.t structure ptr ->
      Vector4i.t structure ptr ->
      unit
    (** Gets the remainder of each component of the [Vector4i] with the components of the given [Vector4i]. This operation uses truncated division, which is often not desired as it does not work well with negative numbers. Consider using [method @GlobalScope.posmod] instead if you want to handle negative numbers.
[codeblock]
print(Vector4i(10, -20, 30, -40) % Vector4i(7, 8, 9, 10))  # Prints ""(3, -4, 3, 0)""
[/codeblock] *)

    val _Vector4i_elem_Dictionary :
      Vector4i.t structure ptr ->
      Dictionary.t structure ptr ->
      Bool.t structure ptr ->
      unit

    val _Vector4i_elem_Array :
      Vector4i.t structure ptr ->
      Array.t structure ptr ->
      Bool.t structure ptr ->
      unit

    module AXIS : sig
      type t

      val typ : Int.t structure ptr typ

      val _AXIS_X : int
      (** Enumerated value for the X axis. Returned by [method max_axis_index] and [method min_axis_index]. *)

      val _AXIS_Y : int
      (** Enumerated value for the Y axis. Returned by [method max_axis_index] and [method min_axis_index]. *)

      val _AXIS_Z : int
      (** Enumerated value for the Z axis. Returned by [method max_axis_index] and [method min_axis_index]. *)

      val _AXIS_W : int
      (** Enumerated value for the W axis. Returned by [method max_axis_index] and [method min_axis_index]. *)
    end
  end

  module type PLANE = sig
    type t

    include Api_types.API_TYPE with type t := t

    val normalized :
      BuiltinClass0.Plane.t structure ptr -> BuiltinClass0.Plane.t structure ptr
    (** Returns a copy of the plane, with normalized [member normal] (so it's a unit vector). Returns [code]Plane(0, 0, 0, 0)[/code] if [member normal] can't be normalized (it has zero length). *)

    val get_center :
      BuiltinClass0.Plane.t structure ptr ->
      BuiltinClass0.Vector3.t structure ptr
    (** Returns the center of the plane. *)

    val is_equal_approx :
      BuiltinClass0.Plane.t structure ptr ->
      BuiltinClass0.Plane.t structure ptr ->
      BuiltinClass0.Bool.t structure ptr
    (** Returns [code]true[/code] if this plane and [param to_plane] are approximately equal, by running [method @GlobalScope.is_equal_approx] on each component. *)

    val is_finite :
      BuiltinClass0.Plane.t structure ptr -> BuiltinClass0.Bool.t structure ptr
    (** Returns [code]true[/code] if this plane is finite, by calling [method @GlobalScope.is_finite] on each component. *)

    val is_point_over :
      BuiltinClass0.Vector3.t structure ptr ->
      BuiltinClass0.Plane.t structure ptr ->
      BuiltinClass0.Bool.t structure ptr
    (** Returns [code]true[/code] if [param point] is located above the plane. *)

    val distance_to :
      BuiltinClass0.Vector3.t structure ptr ->
      BuiltinClass0.Plane.t structure ptr ->
      BuiltinClass0.Float.t structure ptr
    (** Returns the shortest distance from the plane to the position [param point]. If the point is above the plane, the distance will be positive. If below, the distance will be negative. *)

    val has_point :
      BuiltinClass0.Vector3.t structure ptr ->
      BuiltinClass0.Float.t structure ptr ->
      BuiltinClass0.Plane.t structure ptr ->
      BuiltinClass0.Bool.t structure ptr
    (** Returns [code]true[/code] if [param point] is inside the plane. Comparison uses a custom minimum [param tolerance] threshold. *)

    val project :
      BuiltinClass0.Vector3.t structure ptr ->
      BuiltinClass0.Plane.t structure ptr ->
      BuiltinClass0.Vector3.t structure ptr
    (** Returns the orthogonal projection of [param point] into a point in the plane. *)

    val intersect_3 :
      BuiltinClass0.Plane.t structure ptr ->
      BuiltinClass0.Plane.t structure ptr ->
      BuiltinClass0.Plane.t structure ptr ->
      BuiltinClass0.Variant.t structure ptr
    (** Returns the intersection point of the three planes [param b], [param c] and this plane. If no intersection is found, [code]null[/code] is returned. *)

    val intersects_ray :
      BuiltinClass0.Vector3.t structure ptr ->
      BuiltinClass0.Vector3.t structure ptr ->
      BuiltinClass0.Plane.t structure ptr ->
      BuiltinClass0.Variant.t structure ptr
    (** Returns the intersection point of a ray consisting of the position [param from] and the direction normal [param dir] with this plane. If no intersection is found, [code]null[/code] is returned. *)

    val intersects_segment :
      BuiltinClass0.Vector3.t structure ptr ->
      BuiltinClass0.Vector3.t structure ptr ->
      BuiltinClass0.Plane.t structure ptr ->
      BuiltinClass0.Variant.t structure ptr
    (** Returns the intersection point of a segment from position [param from] to position [param to] with this plane. If no intersection is found, [code]null[/code] is returned. *)

    val ( ~- ) :
      Plane.t structure ptr ->
      Plane.t structure ptr ->
      Plane.t structure ptr ->
      unit
    (** Returns the negative value of the [Plane]. This is the same as writing [code]Plane(-p.normal, -p.d)[/code]. This operation flips the direction of the normal vector and also flips the distance value, resulting in a Plane that is in the same place, but facing the opposite direction. *)

    val ( ~+ ) :
      Plane.t structure ptr ->
      Plane.t structure ptr ->
      Plane.t structure ptr ->
      unit
    (** Returns the same value as if the [code]+[/code] was not there. Unary [code]+[/code] does nothing, but sometimes it can make your code more readable. *)

    val not :
      Plane.t structure ptr ->
      Plane.t structure ptr ->
      Bool.t structure ptr ->
      unit

    val ( = ) :
      Plane.t structure ptr ->
      Plane.t structure ptr ->
      Bool.t structure ptr ->
      unit
    (** Returns [code]true[/code] if the planes are exactly equal.
[b]Note:[/b] Due to floating-point precision errors, consider using [method is_equal_approx] instead, which is more reliable. *)

    val ( <> ) :
      Plane.t structure ptr ->
      Plane.t structure ptr ->
      Bool.t structure ptr ->
      unit
    (** Returns [code]true[/code] if the planes are not equal.
[b]Note:[/b] Due to floating-point precision errors, consider using [method is_equal_approx] instead, which is more reliable. *)

    val _Plane_elem_Dictionary :
      Plane.t structure ptr ->
      Dictionary.t structure ptr ->
      Bool.t structure ptr ->
      unit

    val _Plane_elem_Array :
      Plane.t structure ptr ->
      Array.t structure ptr ->
      Bool.t structure ptr ->
      unit
  end

  module type QUATERNION = sig
    type t

    include Api_types.API_TYPE with type t := t

    val length :
      BuiltinClass0.Quaternion.t structure ptr ->
      BuiltinClass0.Float.t structure ptr
    (** Returns this quaternion's length, also called magnitude. *)

    val length_squared :
      BuiltinClass0.Quaternion.t structure ptr ->
      BuiltinClass0.Float.t structure ptr
    (** Returns this quaternion's length, squared.
[b]Note:[/b] This method is faster than [method length], so prefer it if you only need to compare quaternion lengths. *)

    val normalized :
      BuiltinClass0.Quaternion.t structure ptr ->
      BuiltinClass0.Quaternion.t structure ptr
    (** Returns a copy of this quaternion, normalized so that its length is [code]1.0[/code]. See also [method is_normalized]. *)

    val is_normalized :
      BuiltinClass0.Quaternion.t structure ptr ->
      BuiltinClass0.Bool.t structure ptr
    (** Returns [code]true[/code] if this quaternion is normalized. See also [method normalized]. *)

    val is_equal_approx :
      BuiltinClass0.Quaternion.t structure ptr ->
      BuiltinClass0.Quaternion.t structure ptr ->
      BuiltinClass0.Bool.t structure ptr
    (** Returns [code]true[/code] if this quaternion and [param to] are approximately equal, by running [method @GlobalScope.is_equal_approx] on each component. *)

    val is_finite :
      BuiltinClass0.Quaternion.t structure ptr ->
      BuiltinClass0.Bool.t structure ptr
    (** Returns [code]true[/code] if this quaternion is finite, by calling [method @GlobalScope.is_finite] on each component. *)

    val inverse :
      BuiltinClass0.Quaternion.t structure ptr ->
      BuiltinClass0.Quaternion.t structure ptr
    (** Returns the inverse version of this quaternion, inverting the sign of every component except [member w]. *)

    val log :
      BuiltinClass0.Quaternion.t structure ptr ->
      BuiltinClass0.Quaternion.t structure ptr
    (** Returns the logarithm of this quaternion. Multiplies this quaternion's rotation axis by its rotation angle, and stores the result in the returned quaternion's vector part ([member x], [member y], and [member z]). The returned quaternion's real part ([member w]) is always [code]0.0[/code]. *)

    val exp :
      BuiltinClass0.Quaternion.t structure ptr ->
      BuiltinClass0.Quaternion.t structure ptr
    (** Returns the exponential of this quaternion. The rotation axis of the result is the normalized rotation axis of this quaternion, the angle of the result is the length of the vector part of this quaternion. *)

    val angle_to :
      BuiltinClass0.Quaternion.t structure ptr ->
      BuiltinClass0.Quaternion.t structure ptr ->
      BuiltinClass0.Float.t structure ptr
    (** Returns the angle between this quaternion and [param to]. This is the magnitude of the angle you would need to rotate by to get from one to the other.
[b]Note:[/b] The magnitude of the floating-point error for this method is abnormally high, so methods such as [code]is_zero_approx[/code] will not work reliably. *)

    val dot :
      BuiltinClass0.Quaternion.t structure ptr ->
      BuiltinClass0.Quaternion.t structure ptr ->
      BuiltinClass0.Float.t structure ptr
    (** Returns the dot product between this quaternion and [param with].
This is equivalent to [code](quat.x  *  with.x) + (quat.y  *  with.y) + (quat.z  *  with.z) + (quat.w  *  with.w)[/code]. *)

    val slerp :
      BuiltinClass0.Quaternion.t structure ptr ->
      BuiltinClass0.Float.t structure ptr ->
      BuiltinClass0.Quaternion.t structure ptr ->
      BuiltinClass0.Quaternion.t structure ptr
    (** Performs a spherical-linear interpolation with the [param to] quaternion, given a [param weight] and returns the result. Both this quaternion and [param to] must be normalized. *)

    val slerpni :
      BuiltinClass0.Quaternion.t structure ptr ->
      BuiltinClass0.Float.t structure ptr ->
      BuiltinClass0.Quaternion.t structure ptr ->
      BuiltinClass0.Quaternion.t structure ptr
    (** Performs a spherical-linear interpolation with the [param to] quaternion, given a [param weight] and returns the result. Unlike [method slerp], this method does not check if the rotation path is smaller than 90 degrees. Both this quaternion and [param to] must be normalized. *)

    val spherical_cubic_interpolate :
      BuiltinClass0.Quaternion.t structure ptr ->
      BuiltinClass0.Quaternion.t structure ptr ->
      BuiltinClass0.Quaternion.t structure ptr ->
      BuiltinClass0.Float.t structure ptr ->
      BuiltinClass0.Quaternion.t structure ptr ->
      BuiltinClass0.Quaternion.t structure ptr
    (** Performs a spherical cubic interpolation between quaternions [param pre_a], this vector, [param b], and [param post_b], by the given amount [param weight]. *)

    val spherical_cubic_interpolate_in_time :
      BuiltinClass0.Quaternion.t structure ptr ->
      BuiltinClass0.Quaternion.t structure ptr ->
      BuiltinClass0.Quaternion.t structure ptr ->
      BuiltinClass0.Float.t structure ptr ->
      BuiltinClass0.Float.t structure ptr ->
      BuiltinClass0.Float.t structure ptr ->
      BuiltinClass0.Float.t structure ptr ->
      BuiltinClass0.Quaternion.t structure ptr ->
      BuiltinClass0.Quaternion.t structure ptr
    (** Performs a spherical cubic interpolation between quaternions [param pre_a], this vector, [param b], and [param post_b], by the given amount [param weight].
It can perform smoother interpolation than [method spherical_cubic_interpolate] by the time values. *)

    val get_euler :
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.Quaternion.t structure ptr ->
      BuiltinClass0.Vector3.t structure ptr
    (** Returns this quaternion's rotation as a [Vector3] of [url=https://en.wikipedia.org/wiki/Euler_angles]Euler angles[/url], in radians.
The order of each consecutive rotation can be changed with [param order] (see [enum EulerOrder] constants). By default, the YXZ convention is used ([constant EULER_ORDER_YXZ]): Z (roll) is calculated first, then X (pitch), and lastly Y (yaw). When using the opposite method [method from_euler], this order is reversed. *)

    val from_euler :
      BuiltinClass0.Vector3.t structure ptr ->
      BuiltinClass0.Quaternion.t structure ptr
    (** Constructs a new [Quaternion] from the given [Vector3] of [url=https://en.wikipedia.org/wiki/Euler_angles]Euler angles[/url], in radians. This method always uses the YXZ convention ([constant EULER_ORDER_YXZ]). *)

    val get_axis :
      BuiltinClass0.Quaternion.t structure ptr ->
      BuiltinClass0.Vector3.t structure ptr
    (** Returns the rotation axis of the rotation represented by this quaternion. *)

    val get_angle :
      BuiltinClass0.Quaternion.t structure ptr ->
      BuiltinClass0.Float.t structure ptr
    (** Returns the angle of the rotation represented by this quaternion.
[b]Note:[/b] The quaternion must be normalized. *)

    val ( ~- ) :
      Quaternion.t structure ptr ->
      Quaternion.t structure ptr ->
      Quaternion.t structure ptr ->
      unit
    (** Returns the negative value of the [Quaternion]. This is the same as multiplying all components by [code]-1[/code]. This operation results in a quaternion that represents the same rotation. *)

    val ( ~+ ) :
      Quaternion.t structure ptr ->
      Quaternion.t structure ptr ->
      Quaternion.t structure ptr ->
      unit
    (** Returns the same value as if the [code]+[/code] was not there. Unary [code]+[/code] does nothing, but sometimes it can make your code more readable. *)

    val not :
      Quaternion.t structure ptr ->
      Quaternion.t structure ptr ->
      Bool.t structure ptr ->
      unit

    val ( = ) :
      Quaternion.t structure ptr ->
      Quaternion.t structure ptr ->
      Bool.t structure ptr ->
      unit
    (** Returns [code]true[/code] if the components of both quaternions are exactly equal.
[b]Note:[/b] Due to floating-point precision errors, consider using [method is_equal_approx] instead, which is more reliable. *)

    val ( <> ) :
      Quaternion.t structure ptr ->
      Quaternion.t structure ptr ->
      Bool.t structure ptr ->
      unit
    (** Returns [code]true[/code] if the components of both quaternions are not exactly equal.
[b]Note:[/b] Due to floating-point precision errors, consider using [method is_equal_approx] instead, which is more reliable. *)

    val ( + ) :
      Quaternion.t structure ptr ->
      Quaternion.t structure ptr ->
      Quaternion.t structure ptr ->
      unit
    (** Adds each component of the left [Quaternion] to the right [Quaternion].
This operation is not meaningful on its own, but it can be used as a part of a larger expression, such as approximating an intermediate rotation between two nearby rotations. *)

    val ( - ) :
      Quaternion.t structure ptr ->
      Quaternion.t structure ptr ->
      Quaternion.t structure ptr ->
      unit
    (** Subtracts each component of the left [Quaternion] by the right [Quaternion].
This operation is not meaningful on its own, but it can be used as a part of a larger expression. *)

    val ( * ) :
      Quaternion.t structure ptr ->
      Quaternion.t structure ptr ->
      Quaternion.t structure ptr ->
      unit
    (** Composes (multiplies) two quaternions. This rotates the [param right] quaternion (the child) by this quaternion (the parent). *)

    val _Quaternion_elem_Dictionary :
      Quaternion.t structure ptr ->
      Dictionary.t structure ptr ->
      Bool.t structure ptr ->
      unit

    val _Quaternion_elem_Array :
      Quaternion.t structure ptr ->
      Array.t structure ptr ->
      Bool.t structure ptr ->
      unit
  end

  module type AABB = sig
    type t

    include Api_types.API_TYPE with type t := t

    val abs :
      BuiltinClass0.AABB.t structure ptr -> BuiltinClass0.AABB.t structure ptr
    (** Returns an [AABB] equivalent to this bounding box, with its width, height, and depth modified to be non-negative values.
[codeblocks]
[gdscript]
var box = AABB(Vector3(5, 0, 5), Vector3(-20, -10, -5))
var absolute = box.abs()
print(absolute.position) # Prints (-15, -10, 0)
print(absolute.size)     # Prints (20, 10, 5)
[/gdscript]
[csharp]
var box = new Aabb(new Vector3(5, 0, 5), new Vector3(-20, -10, -5));
var absolute = box.Abs();
GD.Print(absolute.Position); // Prints (-15, -10, 0)
GD.Print(absolute.Size);     // Prints (20, 10, 5)
[/csharp]
[/codeblocks]
[b]Note:[/b] It's recommended to use this method when [member size] is negative, as most other methods in Godot assume that the [member size]'s components are greater than [code]0[/code]. *)

    val get_center :
      BuiltinClass0.AABB.t structure ptr ->
      BuiltinClass0.Vector3.t structure ptr
    (** Returns the center point of the bounding box. This is the same as [code]position + (size / 2.0)[/code]. *)

    val get_volume :
      BuiltinClass0.AABB.t structure ptr -> BuiltinClass0.Float.t structure ptr
    (** Returns the bounding box's volume. This is equivalent to [code]size.x  *  size.y  *  size.z[/code]. See also [method has_volume]. *)

    val has_volume :
      BuiltinClass0.AABB.t structure ptr -> BuiltinClass0.Bool.t structure ptr
    (** Returns [code]true[/code] if this bounding box's width, height, and depth are all positive. See also [method get_volume]. *)

    val has_surface :
      BuiltinClass0.AABB.t structure ptr -> BuiltinClass0.Bool.t structure ptr
    (** Returns [code]true[/code] if this bounding box has a surface or a length, that is, at least one component of [member size] is greater than [code]0[/code]. Otherwise, returns [code]false[/code]. *)

    val has_point :
      BuiltinClass0.Vector3.t structure ptr ->
      BuiltinClass0.AABB.t structure ptr ->
      BuiltinClass0.Bool.t structure ptr
    (** Returns [code]true[/code] if the bounding box contains the given [param point]. By convention, points exactly on the right, top, and front sides are [b]not[/b] included.
[b]Note:[/b] This method is not reliable for [AABB] with a [i]negative[/i] [member size]. Use [method abs] first to get a valid bounding box. *)

    val is_equal_approx :
      BuiltinClass0.AABB.t structure ptr ->
      BuiltinClass0.AABB.t structure ptr ->
      BuiltinClass0.Bool.t structure ptr
    (** Returns [code]true[/code] if this bounding box and [param aabb] are approximately equal, by calling [method Vector2.is_equal_approx] on the [member position] and the [member size]. *)

    val is_finite :
      BuiltinClass0.AABB.t structure ptr -> BuiltinClass0.Bool.t structure ptr
    (** Returns [code]true[/code] if this bounding box's values are finite, by calling [method Vector2.is_finite] on the [member position] and the [member size]. *)

    val intersects :
      BuiltinClass0.AABB.t structure ptr ->
      BuiltinClass0.AABB.t structure ptr ->
      BuiltinClass0.Bool.t structure ptr
    (** Returns [code]true[/code] if this bounding box overlaps with the box [param with]. The edges of both boxes are [i]always[/i] excluded. *)

    val encloses :
      BuiltinClass0.AABB.t structure ptr ->
      BuiltinClass0.AABB.t structure ptr ->
      BuiltinClass0.Bool.t structure ptr
    (** Returns [code]true[/code] if this bounding box [i]completely[/i] encloses the [param with] box. The edges of both boxes are included.
[codeblocks]
[gdscript]
var a = AABB(Vector3(0, 0, 0), Vector3(4, 4, 4))
var b = AABB(Vector3(1, 1, 1), Vector3(3, 3, 3))
var c = AABB(Vector3(2, 2, 2), Vector3(8, 8, 8))

print(a.encloses(a)) # Prints true
print(a.encloses(b)) # Prints true
print(a.encloses(c)) # Prints false
[/gdscript]
[csharp]
var a = new Aabb(new Vector3(0, 0, 0), new Vector3(4, 4, 4));
var b = new Aabb(new Vector3(1, 1, 1), new Vector3(3, 3, 3));
var c = new Aabb(new Vector3(2, 2, 2), new Vector3(8, 8, 8));

GD.Print(a.Encloses(a)); // Prints True
GD.Print(a.Encloses(b)); // Prints True
GD.Print(a.Encloses(c)); // Prints False
[/csharp]
[/codeblocks] *)

    val intersects_plane :
      BuiltinClass0.Plane.t structure ptr ->
      BuiltinClass0.AABB.t structure ptr ->
      BuiltinClass0.Bool.t structure ptr
    (** Returns [code]true[/code] if this bounding box is on both sides of the given [param plane]. *)

    val intersection :
      BuiltinClass0.AABB.t structure ptr ->
      BuiltinClass0.AABB.t structure ptr ->
      BuiltinClass0.AABB.t structure ptr
    (** Returns the intersection between this bounding box and [param with]. If the boxes do not intersect, returns an empty [AABB]. If the boxes intersect at the edge, returns a flat [AABB] with no volume (see [method has_surface] and [method has_volume]).
[codeblocks]
[gdscript]
var box1 = AABB(Vector3(0, 0, 0), Vector3(5, 2, 8))
var box2 = AABB(Vector3(2, 0, 2), Vector3(8, 4, 4))

var intersection = box1.intersection(box2)
print(intersection.position) # Prints (2, 0, 2)
print(intersection.size)     # Prints (3, 2, 4)
[/gdscript]
[csharp]
var box1 = new Aabb(new Vector3(0, 0, 0), new Vector3(5, 2, 8));
var box2 = new Aabb(new Vector3(2, 0, 2), new Vector3(8, 4, 4));

var intersection = box1.Intersection(box2);
GD.Print(intersection.Position); // Prints (2, 0, 2)
GD.Print(intersection.Size);     // Prints (3, 2, 4)
[/csharp]
[/codeblocks]
[b]Note:[/b] If you only need to know whether two bounding boxes are intersecting, use [method intersects], instead. *)

    val merge :
      BuiltinClass0.AABB.t structure ptr ->
      BuiltinClass0.AABB.t structure ptr ->
      BuiltinClass0.AABB.t structure ptr
    (** Returns an [AABB] that encloses both this bounding box and [param with] around the edges. See also [method encloses]. *)

    val expand :
      BuiltinClass0.Vector3.t structure ptr ->
      BuiltinClass0.AABB.t structure ptr ->
      BuiltinClass0.AABB.t structure ptr
    (** Returns a copy of this bounding box expanded to align the edges with the given [param to_point], if necessary.
[codeblocks]
[gdscript]
var box = AABB(Vector3(0, 0, 0), Vector3(5, 2, 5))

box = box.expand(Vector3(10, 0, 0))
print(box.position) # Prints (0, 0, 0)
print(box.size)     # Prints (10, 2, 5)

box = box.expand(Vector3(-5, 0, 5))
print(box.position) # Prints (-5, 0, 0)
print(box.size)     # Prints (15, 2, 5)
[/gdscript]
[csharp]
var box = new Aabb(new Vector3(0, 0, 0), new Vector3(5, 2, 5));

box = box.Expand(new Vector3(10, 0, 0));
GD.Print(box.Position); // Prints (0, 0, 0)
GD.Print(box.Size);     // Prints (10, 2, 5)

box = box.Expand(new Vector3(-5, 0, 5));
GD.Print(box.Position); // Prints (-5, 0, 0)
GD.Print(box.Size);     // Prints (15, 2, 5)
[/csharp]
[/codeblocks] *)

    val grow :
      BuiltinClass0.Float.t structure ptr ->
      BuiltinClass0.AABB.t structure ptr ->
      BuiltinClass0.AABB.t structure ptr
    (** Returns a copy of this bounding box extended on all sides by the given amount [param by]. A negative amount shrinks the box instead.
[codeblocks]
[gdscript]
var a = AABB(Vector3(4, 4, 4), Vector3(8, 8, 8)).grow(4)
print(a.position) # Prints (0, 0, 0)
print(a.size)     # Prints (16, 16, 16)

var b = AABB(Vector3(0, 0, 0), Vector3(8, 4, 2)).grow(2)
print(b.position) # Prints (-2, -2, -2)
print(b.size)     # Prints (12, 8, 6)
[/gdscript]
[csharp]
var a = new Aabb(new Vector3(4, 4, 4), new Vector3(8, 8, 8)).Grow(4);
GD.Print(a.Position); // Prints (0, 0, 0)
GD.Print(a.Size);     // Prints (16, 16, 16)

var b = new Aabb(new Vector3(0, 0, 0), new Vector3(8, 4, 2)).Grow(2);
GD.Print(b.Position); // Prints (-2, -2, -2)
GD.Print(b.Size);     // Prints (12, 8, 6)
[/csharp]
[/codeblocks] *)

    val get_support :
      BuiltinClass0.Vector3.t structure ptr ->
      BuiltinClass0.AABB.t structure ptr ->
      BuiltinClass0.Vector3.t structure ptr
    (** Returns the vertex's position of this bounding box that's the farthest in the given direction. This point is commonly known as the support point in collision detection algorithms. *)

    val get_longest_axis :
      BuiltinClass0.AABB.t structure ptr ->
      BuiltinClass0.Vector3.t structure ptr
    (** Returns the longest normalized axis of this bounding box's [member size], as a [Vector3] ([constant Vector3.RIGHT], [constant Vector3.UP], or [constant Vector3.BACK]).
[codeblocks]
[gdscript]
var box = AABB(Vector3(0, 0, 0), Vector3(2, 4, 8))

print(box.get_longest_axis())       # Prints (0, 0, 1)
print(box.get_longest_axis_index()) # Prints 2
print(box.get_longest_axis_size())  # Prints 8
[/gdscript]
[csharp]
var box = new Aabb(new Vector3(0, 0, 0), new Vector3(2, 4, 8));

GD.Print(box.GetLongestAxis());      // Prints (0, 0, 1)
GD.Print(box.GetLongestAxisIndex()); // Prints 2
GD.Print(box.GetLongestAxisSize());  // Prints 8
[/csharp]
[/codeblocks]
See also [method get_longest_axis_index] and [method get_longest_axis_size]. *)

    val get_longest_axis_index :
      BuiltinClass0.AABB.t structure ptr -> BuiltinClass0.Int.t structure ptr
    (** Returns the index to the longest axis of this bounding box's [member size] (see [constant Vector3.AXIS_X], [constant Vector3.AXIS_Y], and [constant Vector3.AXIS_Z]).
For an example, see [method get_longest_axis]. *)

    val get_longest_axis_size :
      BuiltinClass0.AABB.t structure ptr -> BuiltinClass0.Float.t structure ptr
    (** Returns the longest dimension of this bounding box's [member size].
For an example, see [method get_longest_axis]. *)

    val get_shortest_axis :
      BuiltinClass0.AABB.t structure ptr ->
      BuiltinClass0.Vector3.t structure ptr
    (** Returns the shortest normaalized axis of this bounding box's [member size], as a [Vector3] ([constant Vector3.RIGHT], [constant Vector3.UP], or [constant Vector3.BACK]).
[codeblocks]
[gdscript]
var box = AABB(Vector3(0, 0, 0), Vector3(2, 4, 8))

print(box.get_shortest_axis())       # Prints (1, 0, 0)
print(box.get_shortest_axis_index()) # Prints 0
print(box.get_shortest_axis_size())  # Prints 2
[/gdscript]
[csharp]
var box = new Aabb(new Vector3(0, 0, 0), new Vector3(2, 4, 8));

GD.Print(box.GetShortestAxis());      // Prints (1, 0, 0)
GD.Print(box.GetShortestAxisIndex()); // Prints 0
GD.Print(box.GetShortestAxisSize());  // Prints 2
[/csharp]
[/codeblocks]
See also [method get_shortest_axis_index] and [method get_shortest_axis_size]. *)

    val get_shortest_axis_index :
      BuiltinClass0.AABB.t structure ptr -> BuiltinClass0.Int.t structure ptr
    (** Returns the index to the shortest axis of this bounding box's [member size] (see [constant Vector3.AXIS_X], [constant Vector3.AXIS_Y], and [constant Vector3.AXIS_Z]).
For an example, see [method get_shortest_axis]. *)

    val get_shortest_axis_size :
      BuiltinClass0.AABB.t structure ptr -> BuiltinClass0.Float.t structure ptr
    (** Returns the shortest dimension of this bounding box's [member size].
For an example, see [method get_shortest_axis]. *)

    val get_endpoint :
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.AABB.t structure ptr ->
      BuiltinClass0.Vector3.t structure ptr
    (** Returns the position of one of the 8 vertices that compose this bounding box. With a [param idx] of [code]0[/code] this is the same as [member position], and a [param idx] of [code]7[/code] is the same as [member end]. *)

    val intersects_segment :
      BuiltinClass0.Vector3.t structure ptr ->
      BuiltinClass0.Vector3.t structure ptr ->
      BuiltinClass0.AABB.t structure ptr ->
      BuiltinClass0.Variant.t structure ptr
    (** Returns the first point where this bounding box and the given segment intersect, as a [Vector3]. If no intersection occurs, returns [code]null[/code].
The segment begins at [param from] and ends at [param to]. *)

    val intersects_ray :
      BuiltinClass0.Vector3.t structure ptr ->
      BuiltinClass0.Vector3.t structure ptr ->
      BuiltinClass0.AABB.t structure ptr ->
      BuiltinClass0.Variant.t structure ptr
    (** Returns the first point where this bounding box and the given ray intersect, as a [Vector3]. If no intersection occurs, returns [code]null[/code].
The ray begin at [param from], faces [param dir] and extends towards infinity. *)

    val not :
      AABB.t structure ptr ->
      AABB.t structure ptr ->
      Bool.t structure ptr ->
      unit

    val ( = ) :
      AABB.t structure ptr ->
      AABB.t structure ptr ->
      Bool.t structure ptr ->
      unit
    (** Returns [code]true[/code] if both [member position] and [member size] of the bounding boxes are exactly equal, respectively.
[b]Note:[/b] Due to floating-point precision errors, consider using [method is_equal_approx] instead, which is more reliable. *)

    val ( <> ) :
      AABB.t structure ptr ->
      AABB.t structure ptr ->
      Bool.t structure ptr ->
      unit
    (** Returns [code]true[/code] if the [member position] or [member size] of both bounding boxes are not equal.
[b]Note:[/b] Due to floating-point precision errors, consider using [method is_equal_approx] instead, which is more reliable. *)

    val _AABB_elem_Dictionary :
      AABB.t structure ptr ->
      Dictionary.t structure ptr ->
      Bool.t structure ptr ->
      unit

    val _AABB_elem_Array :
      AABB.t structure ptr ->
      Array.t structure ptr ->
      Bool.t structure ptr ->
      unit
  end

  module type BASIS = sig
    type t

    include Api_types.API_TYPE with type t := t

    val inverse :
      BuiltinClass0.Basis.t structure ptr -> BuiltinClass0.Basis.t structure ptr
    (** Returns the [url=https://en.wikipedia.org/wiki/Invertible_matrix]inverse of this basis's matrix[/url]. *)

    val transposed :
      BuiltinClass0.Basis.t structure ptr -> BuiltinClass0.Basis.t structure ptr
    (** Returns the transposed version of this basis. This turns the basis matrix's columns into rows, and its rows into columns.
[codeblocks]
[gdscript]
var my_basis = Basis(
    Vector3(1, 2, 3),
    Vector3(4, 5, 6),
    Vector3(7, 8, 9)
)
my_basis = my_basis.transposed()

print(my_basis.x) # Prints (1, 4, 7).
print(my_basis.y) # Prints (2, 5, 8).
print(my_basis.z) # Prints (3, 6, 9).
[/gdscript]
[csharp]
var myBasis = new Basis(
    new Vector3(1.0f, 2.0f, 3.0f),
    new Vector3(4.0f, 5.0f, 6.0f),
    new Vector3(7.0f, 8.0f, 9.0f)
);
myBasis = myBasis.Transposed();

GD.Print(myBasis.X); // Prints (1, 4, 7).
GD.Print(myBasis.Y); // Prints (2, 5, 8).
GD.Print(myBasis.Z); // Prints (3, 6, 9).
[/csharp]
[/codeblocks] *)

    val orthonormalized :
      BuiltinClass0.Basis.t structure ptr -> BuiltinClass0.Basis.t structure ptr
    (** Returns the orthonormalized version of this basis. An orthonormal basis is both [i]orthogonal[/i] (the axes are perpendicular to each other) and [i]normalized[/i] (the axes have a length of [code]1[/code]), which also means it can only represent rotation.
It is often useful to call this method to avoid rounding errors on a rotating basis:
[codeblocks]
[gdscript]
# Rotate this Node3D every frame.
func _process(delta):
    basis = basis.rotated(Vector3.UP, TAU  *  delta)
    basis = basis.rotated(Vector3.RIGHT, TAU  *  delta)

    basis = basis.orthonormalized()
[/gdscript]
[csharp]
// Rotate this Node3D every frame.
public override void _Process(double delta)
{
    Basis = Basis.Rotated(Vector3.Up, Mathf.Tau  *  (float)delta)
                 .Rotated(Vector3.Right, Mathf.Tau  *  (float)delta)
                 .Orthonormalized();
}
[/csharp]
[/codeblocks] *)

    val determinant :
      BuiltinClass0.Basis.t structure ptr -> BuiltinClass0.Float.t structure ptr
    (** Returns the [url=https://en.wikipedia.org/wiki/Determinant]determinant[/url] of this basis's matrix. For advanced math, this number can be used to determine a few attributes:
- If the determinant is exactly [code]0[/code], the basis is not invertible (see [method inverse]).
- If the determinant is a negative number, the basis represents a negative scale.
[b]Note:[/b] If the basis's scale is the same for every axis, its determinant is always that scale by the power of 2. *)

    val rotated :
      BuiltinClass0.Vector3.t structure ptr ->
      BuiltinClass0.Float.t structure ptr ->
      BuiltinClass0.Basis.t structure ptr ->
      BuiltinClass0.Basis.t structure ptr
    (** Returns this basis rotated around the given [param axis] by [param angle] (in radians). The [param axis] must be a normalized vector (see [method Vector3.normalized]).
Positive values rotate this basis clockwise around the axis, while negative values rotate it counterclockwise.
[codeblocks]
[gdscript]
var my_basis = Basis.IDENTITY
var angle = TAU / 2

my_basis = my_basis.rotated(Vector3.UP, angle)    # Rotate around the up axis (yaw).
my_basis = my_basis.rotated(Vector3.RIGHT, angle) # Rotate around the right axis (pitch).
my_basis = my_basis.rotated(Vector3.BACK, angle)  # Rotate around the back axis (roll).
[/gdscript]
[csharp]
var myBasis = Basis.Identity;
var angle = Mathf.Tau / 2.0f;

myBasis = myBasis.Rotated(Vector3.Up, angle);    // Rotate around the up axis (yaw).
myBasis = myBasis.Rotated(Vector3.Right, angle); // Rotate around the right axis (pitch).
myBasis = myBasis.Rotated(Vector3.Back, angle);  // Rotate around the back axis (roll).
[/csharp]
[/codeblocks] *)

    val scaled :
      BuiltinClass0.Vector3.t structure ptr ->
      BuiltinClass0.Basis.t structure ptr ->
      BuiltinClass0.Basis.t structure ptr
    (** Returns this basis with each axis's components scaled by the given [param scale]'s components.
The basis matrix's rows are multiplied by [param scale]'s components. This operation is a global scale (relative to the parent).
[codeblocks]
[gdscript]
var my_basis = Basis(
    Vector3(1, 1, 1),
    Vector3(2, 2, 2),
    Vector3(3, 3, 3)
)
my_basis = my_basis.scaled(Vector3(0, 2, -2))

print(my_basis.x) # Prints (0, 2, -2).
print(my_basis.y) # Prints (0, 4, -4).
print(my_basis.z) # Prints (0, 6, -6).
[/gdscript]
[csharp]
var myBasis = new Basis(
    new Vector3(1.0f, 1.0f, 1.0f),
    new Vector3(2.0f, 2.0f, 2.0f),
    new Vector3(3.0f, 3.0f, 3.0f)
);
myBasis = myBasis.Scaled(new Vector3(0.0f, 2.0f, -2.0f));

GD.Print(myBasis.X); // Prints (0, 2, -2).
GD.Print(myBasis.Y); // Prints (0, 4, -4).
GD.Print(myBasis.Z); // Prints (0, 6, -6).
[/csharp]
[/codeblocks] *)

    val get_scale :
      BuiltinClass0.Basis.t structure ptr ->
      BuiltinClass0.Vector3.t structure ptr
    (** Returns the length of each axis of this basis, as a [Vector3]. If the basis is not sheared, this is the scaling factor. It is not affected by rotation.
[codeblocks]
[gdscript]
var my_basis = Basis(
    Vector3(2, 0, 0),
    Vector3(0, 4, 0),
    Vector3(0, 0, 8)
)
# Rotating the Basis in any way preserves its scale.
my_basis = my_basis.rotated(Vector3.UP, TAU / 2)
my_basis = my_basis.rotated(Vector3.RIGHT, TAU / 4)

print(my_basis.get_scale()) # Prints (2, 4, 8).
[/gdscript]
[csharp]
var myBasis = new Basis(
    Vector3(2.0f, 0.0f, 0.0f),
    Vector3(0.0f, 4.0f, 0.0f),
    Vector3(0.0f, 0.0f, 8.0f)
);
// Rotating the Basis in any way preserves its scale.
myBasis = myBasis.Rotated(Vector3.Up, Mathf.Tau / 2.0f);
myBasis = myBasis.Rotated(Vector3.Right, Mathf.Tau / 4.0f);

GD.Print(myBasis.Scale); // Prints (2, 4, 8).
[/csharp]
[/codeblocks]
[b]Note:[/b] If the value returned by [method determinant] is negative, the scale is also negative. *)

    val get_euler :
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.Basis.t structure ptr ->
      BuiltinClass0.Vector3.t structure ptr
    (** Returns this basis's rotation as a [Vector3] of [url=https://en.wikipedia.org/wiki/Euler_angles]Euler angles[/url], in radians.
- The [member Vector3.x] contains the angle around the [member x] axis (pitch);
- The [member Vector3.y] contains the angle around the [member y] axis (yaw);
- The [member Vector3.z] contains the angle around the [member z] axis (roll).
The order of each consecutive rotation can be changed with [param order] (see [enum EulerOrder] constants). By default, the YXZ convention is used ([constant EULER_ORDER_YXZ]): Z (roll) is calculated first, then X (pitch), and lastly Y (yaw). When using the opposite method [method from_euler], this order is reversed.
[b]Note:[/b] Euler angles are much more intuitive but are not suitable for 3D math. Because of this, consider using the [method get_rotation_quaternion] method instead, which returns a [Quaternion].
[b]Note:[/b] In the Inspector dock, a basis's rotation is often displayed in Euler angles (in degrees), as is the case with the [member Node3D.rotation] property. *)

    val tdotx :
      BuiltinClass0.Vector3.t structure ptr ->
      BuiltinClass0.Basis.t structure ptr ->
      BuiltinClass0.Float.t structure ptr
    (** Returns the transposed dot product between [param with] and the [member x] axis (see [method transposed]).
This is equivalent to [code]basis.x.dot(vector)[/code]. *)

    val tdoty :
      BuiltinClass0.Vector3.t structure ptr ->
      BuiltinClass0.Basis.t structure ptr ->
      BuiltinClass0.Float.t structure ptr
    (** Returns the transposed dot product between [param with] and the [member y] axis (see [method transposed]).
This is equivalent to [code]basis.y.dot(vector)[/code]. *)

    val tdotz :
      BuiltinClass0.Vector3.t structure ptr ->
      BuiltinClass0.Basis.t structure ptr ->
      BuiltinClass0.Float.t structure ptr
    (** Returns the transposed dot product between [param with] and the [member z] axis (see [method transposed]).
This is equivalent to [code]basis.z.dot(vector)[/code]. *)

    val slerp :
      BuiltinClass0.Basis.t structure ptr ->
      BuiltinClass0.Float.t structure ptr ->
      BuiltinClass0.Basis.t structure ptr ->
      BuiltinClass0.Basis.t structure ptr
    (** Performs a spherical-linear interpolation with the [param to] basis, given a [param weight]. Both this basis and [param to] should represent a rotation.
[b]Example:[/b] Smoothly rotate a [Node3D] to the target basis over time, with a [Tween].
[codeblock]
var start_basis = Basis.IDENTITY
var target_basis = Basis.IDENTITY.rotated(Vector3.UP, TAU / 2)

func _ready():
    create_tween().tween_method(interpolate, 0.0, 1.0, 5.0).set_trans(Tween.TRANS_EXPO)

func interpolate(weight):
    basis = start_basis.slerp(target_basis, weight)
[/codeblock] *)

    val is_conformal :
      BuiltinClass0.Basis.t structure ptr -> BuiltinClass0.Bool.t structure ptr
    (** Returns [code]true[/code] if this basis is conformal. A conformal basis is both [i]orthogonal[/i] (the axes are perpendicular to each other) and [i]uniform[/i] (the axes share the same length). This method can be especially useful during physics calculations. *)

    val is_equal_approx :
      BuiltinClass0.Basis.t structure ptr ->
      BuiltinClass0.Basis.t structure ptr ->
      BuiltinClass0.Bool.t structure ptr
    (** Returns [code]true[/code] if this basis and [param b] are approximately equal, by calling [method @GlobalScope.is_equal_approx] on all vector components. *)

    val is_finite :
      BuiltinClass0.Basis.t structure ptr -> BuiltinClass0.Bool.t structure ptr
    (** Returns [code]true[/code] if this basis is finite, by calling [method @GlobalScope.is_finite] on all vector components. *)

    val get_rotation_quaternion :
      BuiltinClass0.Basis.t structure ptr ->
      BuiltinClass0.Quaternion.t structure ptr
    (** Returns this basis's rotation as a [Quaternion].
[b]Note:[/b] Quatenions are much more suitable for 3D math but are less intuitive. For user interfaces, consider using the [method get_euler] method, which returns Euler angles. *)

    val looking_at :
      BuiltinClass0.Vector3.t structure ptr ->
      BuiltinClass0.Vector3.t structure ptr ->
      BuiltinClass0.Bool.t structure ptr ->
      BuiltinClass0.Basis.t structure ptr
    (** Creates a new [Basis] with a rotation such that the forward axis (-Z) points towards the [param target] position.
By default, the -Z axis (camera forward) is treated as forward (implies +X is right). If [param use_model_front] is [code]true[/code], the +Z axis (asset front) is treated as forward (implies +X is left) and points toward the [param target] position.
The up axis (+Y) points as close to the [param up] vector as possible while staying perpendicular to the forward axis. The returned basis is orthonormalized (see [method orthonormalized]). The [param target] and [param up] vectors cannot be [constant Vector3.ZERO], and cannot be parallel to each other. *)

    val from_scale :
      BuiltinClass0.Vector3.t structure ptr ->
      BuiltinClass0.Basis.t structure ptr
    (** Constructs a new [Basis] that only represents scale, with no rotation or shear, from the given [param scale] vector.
[codeblocks]
[gdscript]
var my_basis = Basis.from_scale(Vector3(2, 4, 8))

print(my_basis.x) # Prints (2, 0, 0).
print(my_basis.y) # Prints (0, 4, 0).
print(my_basis.z) # Prints (0, 0, 8).
[/gdscript]
[csharp]
var myBasis = Basis.FromScale(new Vector3(2.0f, 4.0f, 8.0f));

GD.Print(myBasis.X); // Prints (2, 0, 0).
GD.Print(myBasis.Y); // Prints (0, 4, 0).
GD.Print(myBasis.Z); // Prints (0, 0, 8).
[/csharp]
[/codeblocks]
[b]Note:[/b] In linear algebra, the matrix of this basis is also known as a [url=https://en.wikipedia.org/wiki/Diagonal_matrix]diagonal matrix[/url]. *)

    val from_euler :
      BuiltinClass0.Vector3.t structure ptr ->
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.Basis.t structure ptr
    (** Constructs a new [Basis] that only represents rotation from the given [Vector3] of [url=https://en.wikipedia.org/wiki/Euler_angles]Euler angles[/url], in radians.
- The [member Vector3.x] should contain the angle around the [member x] axis (pitch).
- The [member Vector3.y] should contain the angle around the [member y] axis (yaw).
- The [member Vector3.z] should contain the angle around the [member z] axis (roll).
[codeblocks]
[gdscript]
# Creates a Basis whose z axis points down.
var my_basis = Basis.from_euler(Vector3(TAU / 4, 0, 0))

print(my_basis.z) # Prints (0, -1, 0).
[/gdscript]
[csharp]
// Creates a Basis whose z axis points down.
var myBasis = Basis.FromEuler(new Vector3(Mathf.Tau / 4.0f, 0.0f, 0.0f));

GD.Print(myBasis.Z); // Prints (0, -1, 0).
[/csharp]
[/codeblocks]
The order of each consecutive rotation can be changed with [param order] (see [enum EulerOrder] constants). By default, the YXZ convention is used ([constant EULER_ORDER_YXZ]): the basis rotates first around the Y axis (yaw), then X (pitch), and lastly Z (roll). When using the opposite method [method get_euler], this order is reversed. *)

    val not :
      Basis.t structure ptr ->
      Basis.t structure ptr ->
      Bool.t structure ptr ->
      unit

    val ( = ) :
      Basis.t structure ptr ->
      Basis.t structure ptr ->
      Bool.t structure ptr ->
      unit
    (** Returns [code]true[/code] if the components of both [Basis] matrices are exactly equal.
[b]Note:[/b] Due to floating-point precision errors, consider using [method is_equal_approx] instead, which is more reliable. *)

    val ( <> ) :
      Basis.t structure ptr ->
      Basis.t structure ptr ->
      Bool.t structure ptr ->
      unit
    (** Returns [code]true[/code] if the components of both [Basis] matrices are not equal.
[b]Note:[/b] Due to floating-point precision errors, consider using [method is_equal_approx] instead, which is more reliable. *)

    val ( * ) :
      Basis.t structure ptr ->
      Basis.t structure ptr ->
      Basis.t structure ptr ->
      unit
    (** Transforms (multiplies) the [param right] basis by this basis.
This is the operation performed between parent and child [Node3D]s. *)

    val _Basis_elem_Dictionary :
      Basis.t structure ptr ->
      Dictionary.t structure ptr ->
      Bool.t structure ptr ->
      unit

    val _Basis_elem_Array :
      Basis.t structure ptr ->
      Array.t structure ptr ->
      Bool.t structure ptr ->
      unit
  end

  module type TRANSFORM3D = sig
    type t

    include Api_types.API_TYPE with type t := t

    val inverse :
      BuiltinClass0.Transform3D.t structure ptr ->
      BuiltinClass0.Transform3D.t structure ptr
    (** Returns the inverted version of this transform. See also [method Basis.inverse].
[b]Note:[/b] For this method to return correctly, the transform's [member basis] needs to be [i]orthonormal[/i] (see [method Basis.orthonormalized]). That means, the basis should only represent a rotation. If it does not, use [method affine_inverse] instead. *)

    val affine_inverse :
      BuiltinClass0.Transform3D.t structure ptr ->
      BuiltinClass0.Transform3D.t structure ptr
    (** Returns the inverted version of this transform. Unlike [method inverse], this method works with almost any [member basis], including non-uniform ones, but is slower. See also [method Basis.inverse].
[b]Note:[/b] For this method to return correctly, the transform's [member basis] needs to have a determinant that is not exactly [code]0[/code] (see [method Basis.determinant]). *)

    val orthonormalized :
      BuiltinClass0.Transform3D.t structure ptr ->
      BuiltinClass0.Transform3D.t structure ptr
    (** Returns a copy of this transform with its [member basis] orthonormalized. An orthonormal basis is both [i]orthogonal[/i] (the axes are perpendicular to each other) and [i]normalized[/i] (the axes have a length of [code]1[/code]), which also means it can only represent rotation. See also [method Basis.orthonormalized]. *)

    val rotated :
      BuiltinClass0.Vector3.t structure ptr ->
      BuiltinClass0.Float.t structure ptr ->
      BuiltinClass0.Transform3D.t structure ptr ->
      BuiltinClass0.Transform3D.t structure ptr
    (** Returns a copy of this transform rotated around the given [param axis] by the given [param angle] (in radians).
The [param axis] must be a normalized vector.
This method is an optimized version of multiplying the given transform [code]X[/code] with a corresponding rotation transform [code]R[/code] from the left, i.e., [code]R  *  X[/code].
This can be seen as transforming with respect to the global/parent frame. *)

    val rotated_local :
      BuiltinClass0.Vector3.t structure ptr ->
      BuiltinClass0.Float.t structure ptr ->
      BuiltinClass0.Transform3D.t structure ptr ->
      BuiltinClass0.Transform3D.t structure ptr
    (** Returns a copy of this transform rotated around the given [param axis] by the given [param angle] (in radians).
The [param axis] must be a normalized vector.
This method is an optimized version of multiplying the given transform [code]X[/code] with a corresponding rotation transform [code]R[/code] from the right, i.e., [code]X  *  R[/code].
This can be seen as transforming with respect to the local frame. *)

    val scaled :
      BuiltinClass0.Vector3.t structure ptr ->
      BuiltinClass0.Transform3D.t structure ptr ->
      BuiltinClass0.Transform3D.t structure ptr
    (** Returns a copy of this transform scaled by the given [param scale] factor.
This method is an optimized version of multiplying the given transform [code]X[/code] with a corresponding scaling transform [code]S[/code] from the left, i.e., [code]S  *  X[/code].
This can be seen as transforming with respect to the global/parent frame. *)

    val scaled_local :
      BuiltinClass0.Vector3.t structure ptr ->
      BuiltinClass0.Transform3D.t structure ptr ->
      BuiltinClass0.Transform3D.t structure ptr
    (** Returns a copy of this transform scaled by the given [param scale] factor.
This method is an optimized version of multiplying the given transform [code]X[/code] with a corresponding scaling transform [code]S[/code] from the right, i.e., [code]X  *  S[/code].
This can be seen as transforming with respect to the local frame. *)

    val translated :
      BuiltinClass0.Vector3.t structure ptr ->
      BuiltinClass0.Transform3D.t structure ptr ->
      BuiltinClass0.Transform3D.t structure ptr
    (** Returns a copy of this transform translated by the given [param offset].
This method is an optimized version of multiplying the given transform [code]X[/code] with a corresponding translation transform [code]T[/code] from the left, i.e., [code]T  *  X[/code].
This can be seen as transforming with respect to the global/parent frame. *)

    val translated_local :
      BuiltinClass0.Vector3.t structure ptr ->
      BuiltinClass0.Transform3D.t structure ptr ->
      BuiltinClass0.Transform3D.t structure ptr
    (** Returns a copy of this transform translated by the given [param offset].
This method is an optimized version of multiplying the given transform [code]X[/code] with a corresponding translation transform [code]T[/code] from the right, i.e., [code]X  *  T[/code].
This can be seen as transforming with respect to the local frame. *)

    val looking_at :
      BuiltinClass0.Vector3.t structure ptr ->
      BuiltinClass0.Vector3.t structure ptr ->
      BuiltinClass0.Bool.t structure ptr ->
      BuiltinClass0.Transform3D.t structure ptr ->
      BuiltinClass0.Transform3D.t structure ptr
    (** Returns a copy of this transform rotated so that the forward axis (-Z) points towards the [param target] position.
The up axis (+Y) points as close to the [param up] vector as possible while staying perpendicular to the forward axis. The resulting transform is orthonormalized. The existing rotation, scale, and skew information from the original transform is discarded. The [param target] and [param up] vectors cannot be zero, cannot be parallel to each other, and are defined in global/parent space.
If [param use_model_front] is [code]true[/code], the +Z axis (asset front) is treated as forward (implies +X is left) and points toward the [param target] position. By default, the -Z axis (camera forward) is treated as forward (implies +X is right). *)

    val interpolate_with :
      BuiltinClass0.Transform3D.t structure ptr ->
      BuiltinClass0.Float.t structure ptr ->
      BuiltinClass0.Transform3D.t structure ptr ->
      BuiltinClass0.Transform3D.t structure ptr
    (** Returns the result of the linear interpolation between this transform and [param xform] by the given [param weight].
The [param weight] should be between [code]0.0[/code] and [code]1.0[/code] (inclusive). Values outside this range are allowed and can be used to perform [i]extrapolation[/i] instead. *)

    val is_equal_approx :
      BuiltinClass0.Transform3D.t structure ptr ->
      BuiltinClass0.Transform3D.t structure ptr ->
      BuiltinClass0.Bool.t structure ptr
    (** Returns [code]true[/code] if this transform and [param xform] are approximately equal, by running [method @GlobalScope.is_equal_approx] on each component. *)

    val is_finite :
      BuiltinClass0.Transform3D.t structure ptr ->
      BuiltinClass0.Bool.t structure ptr
    (** Returns [code]true[/code] if this transform is finite, by calling [method @GlobalScope.is_finite] on each component. *)

    val not :
      Transform3D.t structure ptr ->
      Transform3D.t structure ptr ->
      Bool.t structure ptr ->
      unit

    val ( = ) :
      Transform3D.t structure ptr ->
      Transform3D.t structure ptr ->
      Bool.t structure ptr ->
      unit
    (** Returns [code]true[/code] if the components of both transforms are exactly equal.
[b]Note:[/b] Due to floating-point precision errors, consider using [method is_equal_approx] instead, which is more reliable. *)

    val ( <> ) :
      Transform3D.t structure ptr ->
      Transform3D.t structure ptr ->
      Bool.t structure ptr ->
      unit
    (** Returns [code]true[/code] if the components of both transforms are not equal.
[b]Note:[/b] Due to floating-point precision errors, consider using [method is_equal_approx] instead, which is more reliable. *)

    val ( * ) :
      Transform3D.t structure ptr ->
      Transform3D.t structure ptr ->
      Transform3D.t structure ptr ->
      unit
    (** Transforms (multiplies) this transform by the [param right] transform.
This is the operation performed between parent and child [Node3D]s.
[b]Note:[/b] If you need to only modify one attribute of this transform, consider using one of the following methods, instead:
- For translation, see [method translated] or [method translated_local].
- For rotation, see [method rotated] or [method rotated_local].
- For scale, see [method scaled] or [method scaled_local]. *)

    val _Transform3D_elem_Dictionary :
      Transform3D.t structure ptr ->
      Dictionary.t structure ptr ->
      Bool.t structure ptr ->
      unit

    val _Transform3D_elem_Array :
      Transform3D.t structure ptr ->
      Array.t structure ptr ->
      Bool.t structure ptr ->
      unit
  end

  module type PROJECTION = sig
    type t

    include Api_types.API_TYPE with type t := t

    val create_depth_correction :
      BuiltinClass0.Bool.t structure ptr ->
      BuiltinClass0.Projection.t structure ptr
    (** Creates a new [Projection] that projects positions from a depth range of [code]-1[/code] to [code]1[/code] to one that ranges from [code]0[/code] to [code]1[/code], and flips the projected positions vertically, according to [param flip_y]. *)

    val create_light_atlas_rect :
      BuiltinClass0.Rect2.t structure ptr ->
      BuiltinClass0.Projection.t structure ptr
    (** Creates a new [Projection] that projects positions into the given [Rect2]. *)

    val create_perspective :
      BuiltinClass0.Float.t structure ptr ->
      BuiltinClass0.Float.t structure ptr ->
      BuiltinClass0.Float.t structure ptr ->
      BuiltinClass0.Float.t structure ptr ->
      BuiltinClass0.Bool.t structure ptr ->
      BuiltinClass0.Projection.t structure ptr
    (** Creates a new [Projection] that projects positions using a perspective projection with the given Y-axis field of view (in degrees), X:Y aspect ratio, and clipping planes.
[param flip_fov] determines whether the projection's field of view is flipped over its diagonal. *)

    val create_perspective_hmd :
      BuiltinClass0.Float.t structure ptr ->
      BuiltinClass0.Float.t structure ptr ->
      BuiltinClass0.Float.t structure ptr ->
      BuiltinClass0.Float.t structure ptr ->
      BuiltinClass0.Bool.t structure ptr ->
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.Float.t structure ptr ->
      BuiltinClass0.Float.t structure ptr ->
      BuiltinClass0.Projection.t structure ptr
    (** Creates a new [Projection] that projects positions using a perspective projection with the given Y-axis field of view (in degrees), X:Y aspect ratio, and clipping distances. The projection is adjusted for a head-mounted display with the given distance between eyes and distance to a point that can be focused on.
[param eye] creates the projection for the left eye when set to 1, or the right eye when set to 2.
[param flip_fov] determines whether the projection's field of view is flipped over its diagonal. *)

    val create_for_hmd :
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.Float.t structure ptr ->
      BuiltinClass0.Float.t structure ptr ->
      BuiltinClass0.Float.t structure ptr ->
      BuiltinClass0.Float.t structure ptr ->
      BuiltinClass0.Float.t structure ptr ->
      BuiltinClass0.Float.t structure ptr ->
      BuiltinClass0.Float.t structure ptr ->
      BuiltinClass0.Projection.t structure ptr
    (** Creates a new [Projection] for projecting positions onto a head-mounted display with the given X:Y aspect ratio, distance between eyes, display width, distance to lens, oversampling factor, and depth clipping planes.
[param eye] creates the projection for the left eye when set to 1, or the right eye when set to 2. *)

    val create_orthogonal :
      BuiltinClass0.Float.t structure ptr ->
      BuiltinClass0.Float.t structure ptr ->
      BuiltinClass0.Float.t structure ptr ->
      BuiltinClass0.Float.t structure ptr ->
      BuiltinClass0.Float.t structure ptr ->
      BuiltinClass0.Float.t structure ptr ->
      BuiltinClass0.Projection.t structure ptr
    (** Creates a new [Projection] that projects positions using an orthogonal projection with the given clipping planes. *)

    val create_orthogonal_aspect :
      BuiltinClass0.Float.t structure ptr ->
      BuiltinClass0.Float.t structure ptr ->
      BuiltinClass0.Float.t structure ptr ->
      BuiltinClass0.Float.t structure ptr ->
      BuiltinClass0.Bool.t structure ptr ->
      BuiltinClass0.Projection.t structure ptr
    (** Creates a new [Projection] that projects positions using an orthogonal projection with the given size, X:Y aspect ratio, and clipping planes.
[param flip_fov] determines whether the projection's field of view is flipped over its diagonal. *)

    val create_frustum :
      BuiltinClass0.Float.t structure ptr ->
      BuiltinClass0.Float.t structure ptr ->
      BuiltinClass0.Float.t structure ptr ->
      BuiltinClass0.Float.t structure ptr ->
      BuiltinClass0.Float.t structure ptr ->
      BuiltinClass0.Float.t structure ptr ->
      BuiltinClass0.Projection.t structure ptr
    (** Creates a new [Projection] that projects positions in a frustum with the given clipping planes. *)

    val create_frustum_aspect :
      BuiltinClass0.Float.t structure ptr ->
      BuiltinClass0.Float.t structure ptr ->
      BuiltinClass0.Vector2.t structure ptr ->
      BuiltinClass0.Float.t structure ptr ->
      BuiltinClass0.Float.t structure ptr ->
      BuiltinClass0.Bool.t structure ptr ->
      BuiltinClass0.Projection.t structure ptr
    (** Creates a new [Projection] that projects positions in a frustum with the given size, X:Y aspect ratio, offset, and clipping planes.
[param flip_fov] determines whether the projection's field of view is flipped over its diagonal. *)

    val create_fit_aabb :
      BuiltinClass0.AABB.t structure ptr ->
      BuiltinClass0.Projection.t structure ptr
    (** Creates a new [Projection] that scales a given projection to fit around a given [AABB] in projection space. *)

    val determinant :
      BuiltinClass0.Projection.t structure ptr ->
      BuiltinClass0.Float.t structure ptr
    (** Returns a scalar value that is the signed factor by which areas are scaled by this matrix. If the sign is negative, the matrix flips the orientation of the area.
The determinant can be used to calculate the invertibility of a matrix or solve linear systems of equations involving the matrix, among other applications. *)

    val perspective_znear_adjusted :
      BuiltinClass0.Float.t structure ptr ->
      BuiltinClass0.Projection.t structure ptr ->
      BuiltinClass0.Projection.t structure ptr
    (** Returns a [Projection] with the near clipping distance adjusted to be [param new_znear].
[b]Note:[/b] The original [Projection] must be a perspective projection. *)

    val get_projection_plane :
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.Projection.t structure ptr ->
      BuiltinClass0.Plane.t structure ptr
    (** Returns the clipping plane of this [Projection] whose index is given by [param plane].
[param plane] should be equal to one of [constant PLANE_NEAR], [constant PLANE_FAR], [constant PLANE_LEFT], [constant PLANE_TOP], [constant PLANE_RIGHT], or [constant PLANE_BOTTOM]. *)

    val flipped_y :
      BuiltinClass0.Projection.t structure ptr ->
      BuiltinClass0.Projection.t structure ptr
    (** Returns a copy of this [Projection] with the signs of the values of the Y column flipped. *)

    val jitter_offseted :
      BuiltinClass0.Vector2.t structure ptr ->
      BuiltinClass0.Projection.t structure ptr ->
      BuiltinClass0.Projection.t structure ptr
    (** Returns a [Projection] with the X and Y values from the given [Vector2] added to the first and second values of the final column respectively. *)

    val get_fovy :
      BuiltinClass0.Float.t structure ptr ->
      BuiltinClass0.Float.t structure ptr ->
      BuiltinClass0.Float.t structure ptr
    (** Returns the vertical field of view of the projection (in degrees) associated with the given horizontal field of view (in degrees) and aspect ratio. *)

    val get_z_far :
      BuiltinClass0.Projection.t structure ptr ->
      BuiltinClass0.Float.t structure ptr
    (** Returns the distance for this [Projection] beyond which positions are clipped. *)

    val get_z_near :
      BuiltinClass0.Projection.t structure ptr ->
      BuiltinClass0.Float.t structure ptr
    (** Returns the distance for this [Projection] before which positions are clipped. *)

    val get_aspect :
      BuiltinClass0.Projection.t structure ptr ->
      BuiltinClass0.Float.t structure ptr
    (** Returns the X:Y aspect ratio of this [Projection]'s viewport. *)

    val get_fov :
      BuiltinClass0.Projection.t structure ptr ->
      BuiltinClass0.Float.t structure ptr
    (** Returns the horizontal field of view of the projection (in degrees). *)

    val is_orthogonal :
      BuiltinClass0.Projection.t structure ptr ->
      BuiltinClass0.Bool.t structure ptr
    (** Returns [code]true[/code] if this [Projection] performs an orthogonal projection. *)

    val get_viewport_half_extents :
      BuiltinClass0.Projection.t structure ptr ->
      BuiltinClass0.Vector2.t structure ptr
    (** Returns the dimensions of the viewport plane that this [Projection] projects positions onto, divided by two. *)

    val get_far_plane_half_extents :
      BuiltinClass0.Projection.t structure ptr ->
      BuiltinClass0.Vector2.t structure ptr
    (** Returns the dimensions of the far clipping plane of the projection, divided by two. *)

    val inverse :
      BuiltinClass0.Projection.t structure ptr ->
      BuiltinClass0.Projection.t structure ptr
    (** Returns a [Projection] that performs the inverse of this [Projection]'s projective transformation. *)

    val get_pixels_per_meter :
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.Projection.t structure ptr ->
      BuiltinClass0.Int.t structure ptr
    (** Returns the number of pixels with the given pixel width displayed per meter, after this [Projection] is applied. *)

    val get_lod_multiplier :
      BuiltinClass0.Projection.t structure ptr ->
      BuiltinClass0.Float.t structure ptr
    (** Returns the factor by which the visible level of detail is scaled by this [Projection]. *)

    val not :
      Projection.t structure ptr ->
      Projection.t structure ptr ->
      Bool.t structure ptr ->
      unit

    val ( = ) :
      Projection.t structure ptr ->
      Projection.t structure ptr ->
      Bool.t structure ptr ->
      unit
    (** Returns [code]true[/code] if the projections are equal.
[b]Note:[/b] Due to floating-point precision errors, this may return [code]false[/code], even if the projections are virtually equal. An [code]is_equal_approx[/code] method may be added in a future version of Godot. *)

    val ( <> ) :
      Projection.t structure ptr ->
      Projection.t structure ptr ->
      Bool.t structure ptr ->
      unit
    (** Returns [code]true[/code] if the projections are not equal.
[b]Note:[/b] Due to floating-point precision errors, this may return [code]true[/code], even if the projections are virtually equal. An [code]is_equal_approx[/code] method may be added in a future version of Godot. *)

    val ( * ) :
      Projection.t structure ptr ->
      Projection.t structure ptr ->
      Projection.t structure ptr ->
      unit
    (** Returns a [Projection] that applies the combined transformations of this [Projection] and [param right]. *)

    val _Projection_elem_Dictionary :
      Projection.t structure ptr ->
      Dictionary.t structure ptr ->
      Bool.t structure ptr ->
      unit

    val _Projection_elem_Array :
      Projection.t structure ptr ->
      Array.t structure ptr ->
      Bool.t structure ptr ->
      unit

    module PLANES : sig
      type t

      val typ : Int.t structure ptr typ

      val _PLANE_NEAR : int
      (** The index value of the projection's near clipping plane. *)

      val _PLANE_FAR : int
      (** The index value of the projection's far clipping plane. *)

      val _PLANE_LEFT : int
      (** The index value of the projection's left clipping plane. *)

      val _PLANE_TOP : int
      (** The index value of the projection's top clipping plane. *)

      val _PLANE_RIGHT : int
      (** The index value of the projection's right clipping plane. *)

      val _PLANE_BOTTOM : int
      (** The index value of the projection bottom clipping plane. *)
    end
  end

  module type COLOR = sig
    type t

    include Api_types.API_TYPE with type t := t

    val to_argb32 :
      BuiltinClass0.Color.t structure ptr -> BuiltinClass0.Int.t structure ptr
    (** Returns the color converted to a 32-bit integer in ARGB format (each component is 8 bits). ARGB is more compatible with DirectX.
[codeblocks]
[gdscript]
var color = Color(1, 0.5, 0.2)
print(color.to_argb32()) # Prints 4294934323
[/gdscript]
[csharp]
var color = new Color(1.0f, 0.5f, 0.2f);
GD.Print(color.ToArgb32()); // Prints 4294934323
[/csharp]
[/codeblocks] *)

    val to_abgr32 :
      BuiltinClass0.Color.t structure ptr -> BuiltinClass0.Int.t structure ptr
    (** Returns the color converted to a 32-bit integer in ABGR format (each component is 8 bits). ABGR is the reversed version of the default RGBA format.
[codeblocks]
[gdscript]
var color = Color(1, 0.5, 0.2)
print(color.to_abgr32()) # Prints 4281565439
[/gdscript]
[csharp]
var color = new Color(1.0f, 0.5f, 0.2f);
GD.Print(color.ToAbgr32()); // Prints 4281565439
[/csharp]
[/codeblocks] *)

    val to_rgba32 :
      BuiltinClass0.Color.t structure ptr -> BuiltinClass0.Int.t structure ptr
    (** Returns the color converted to a 32-bit integer in RGBA format (each component is 8 bits). RGBA is Godot's default format.
[codeblocks]
[gdscript]
var color = Color(1, 0.5, 0.2)
print(color.to_rgba32()) # Prints 4286526463
[/gdscript]
[csharp]
var color = new Color(1, 0.5f, 0.2f);
GD.Print(color.ToRgba32()); // Prints 4286526463
[/csharp]
[/codeblocks] *)

    val to_argb64 :
      BuiltinClass0.Color.t structure ptr -> BuiltinClass0.Int.t structure ptr
    (** Returns the color converted to a 64-bit integer in ARGB format (each component is 16 bits). ARGB is more compatible with DirectX.
[codeblocks]
[gdscript]
var color = Color(1, 0.5, 0.2)
print(color.to_argb64()) # Prints -2147470541
[/gdscript]
[csharp]
var color = new Color(1.0f, 0.5f, 0.2f);
GD.Print(color.ToArgb64()); // Prints -2147470541
[/csharp]
[/codeblocks] *)

    val to_abgr64 :
      BuiltinClass0.Color.t structure ptr -> BuiltinClass0.Int.t structure ptr
    (** Returns the color converted to a 64-bit integer in ABGR format (each component is 16 bits). ABGR is the reversed version of the default RGBA format.
[codeblocks]
[gdscript]
var color = Color(1, 0.5, 0.2)
print(color.to_abgr64()) # Prints -225178692812801
[/gdscript]
[csharp]
var color = new Color(1.0f, 0.5f, 0.2f);
GD.Print(color.ToAbgr64()); // Prints -225178692812801
[/csharp]
[/codeblocks] *)

    val to_rgba64 :
      BuiltinClass0.Color.t structure ptr -> BuiltinClass0.Int.t structure ptr
    (** Returns the color converted to a 64-bit integer in RGBA format (each component is 16 bits). RGBA is Godot's default format.
[codeblocks]
[gdscript]
var color = Color(1, 0.5, 0.2)
print(color.to_rgba64()) # Prints -140736629309441
[/gdscript]
[csharp]
var color = new Color(1, 0.5f, 0.2f);
GD.Print(color.ToRgba64()); // Prints -140736629309441
[/csharp]
[/codeblocks] *)

    val to_html :
      BuiltinClass0.Bool.t structure ptr ->
      BuiltinClass0.Color.t structure ptr ->
      BuiltinClass0.String.t structure ptr
    (** Returns the color converted to an HTML hexadecimal color [String] in RGBA format, without the hash ([code]#[/code]) prefix.
Setting [param with_alpha] to [code]false[/code], excludes alpha from the hexadecimal string, using RGB format instead of RGBA format.
[codeblocks]
[gdscript]
var white = Color(1, 1, 1, 0.5)
var with_alpha = white.to_html() # Returns ""ffffff7f""
var without_alpha = white.to_html(false) # Returns ""ffffff""
[/gdscript]
[csharp]
var white = new Color(1, 1, 1, 0.5f);
string withAlpha = white.ToHtml(); // Returns ""ffffff7f""
string withoutAlpha = white.ToHtml(false); // Returns ""ffffff""
[/csharp]
[/codeblocks] *)

    val clamp :
      BuiltinClass0.Color.t structure ptr ->
      BuiltinClass0.Color.t structure ptr ->
      BuiltinClass0.Color.t structure ptr ->
      BuiltinClass0.Color.t structure ptr
    (** Returns a new color with all components clamped between the components of [param min] and [param max], by running [method @GlobalScope.clamp] on each component. *)

    val inverted :
      BuiltinClass0.Color.t structure ptr -> BuiltinClass0.Color.t structure ptr
    (** Returns the color with its [member r], [member g], and [member b] components inverted ([code](1 - r, 1 - g, 1 - b, a)[/code]).
[codeblocks]
[gdscript]
var black = Color.WHITE.inverted()
var color = Color(0.3, 0.4, 0.9)
var inverted_color = color.inverted() # Equivalent to `Color(0.7, 0.6, 0.1)`
[/gdscript]
[csharp]
var black = Colors.White.Inverted();
var color = new Color(0.3f, 0.4f, 0.9f);
Color invertedColor = color.Inverted(); // Equivalent to `new Color(0.7f, 0.6f, 0.1f)`
[/csharp]
[/codeblocks] *)

    val lerp :
      BuiltinClass0.Color.t structure ptr ->
      BuiltinClass0.Float.t structure ptr ->
      BuiltinClass0.Color.t structure ptr ->
      BuiltinClass0.Color.t structure ptr
    (** Returns the linear interpolation between this color's components and [param to]'s components. The interpolation factor [param weight] should be between 0.0 and 1.0 (inclusive). See also [method @GlobalScope.lerp].
[codeblocks]
[gdscript]
var red = Color(1.0, 0.0, 0.0)
var aqua = Color(0.0, 1.0, 0.8)

red.lerp(aqua, 0.2) # Returns Color(0.8, 0.2, 0.16)
red.lerp(aqua, 0.5) # Returns Color(0.5, 0.5, 0.4)
red.lerp(aqua, 1.0) # Returns Color(0.0, 1.0, 0.8)
[/gdscript]
[csharp]
var red = new Color(1.0f, 0.0f, 0.0f);
var aqua = new Color(0.0f, 1.0f, 0.8f);

red.Lerp(aqua, 0.2f); // Returns Color(0.8f, 0.2f, 0.16f)
red.Lerp(aqua, 0.5f); // Returns Color(0.5f, 0.5f, 0.4f)
red.Lerp(aqua, 1.0f); // Returns Color(0.0f, 1.0f, 0.8f)
[/csharp]
[/codeblocks] *)

    val lightened :
      BuiltinClass0.Float.t structure ptr ->
      BuiltinClass0.Color.t structure ptr ->
      BuiltinClass0.Color.t structure ptr
    (** Returns a new color resulting from making this color lighter by the specified [param amount], which should be a ratio from 0.0 to 1.0. See also [method darkened].
[codeblocks]
[gdscript]
var green = Color(0.0, 1.0, 0.0)
var light_green = green.lightened(0.2) # 20% lighter than regular green
[/gdscript]
[csharp]
var green = new Color(0.0f, 1.0f, 0.0f);
Color lightGreen = green.Lightened(0.2f); // 20% lighter than regular green
[/csharp]
[/codeblocks] *)

    val darkened :
      BuiltinClass0.Float.t structure ptr ->
      BuiltinClass0.Color.t structure ptr ->
      BuiltinClass0.Color.t structure ptr
    (** Returns a new color resulting from making this color darker by the specified [param amount] (ratio from 0.0 to 1.0). See also [method lightened].
[codeblocks]
[gdscript]
var green = Color(0.0, 1.0, 0.0)
var darkgreen = green.darkened(0.2) # 20% darker than regular green
[/gdscript]
[csharp]
var green = new Color(0.0f, 1.0f, 0.0f);
Color darkgreen = green.Darkened(0.2f); // 20% darker than regular green
[/csharp]
[/codeblocks] *)

    val blend :
      BuiltinClass0.Color.t structure ptr ->
      BuiltinClass0.Color.t structure ptr ->
      BuiltinClass0.Color.t structure ptr
    (** Returns a new color resulting from overlaying this color over the given color. In a painting program, you can imagine it as the [param over] color painted over this color (including alpha).
[codeblocks]
[gdscript]
var bg = Color(0.0, 1.0, 0.0, 0.5) # Green with alpha of 50%
var fg = Color(1.0, 0.0, 0.0, 0.5) # Red with alpha of 50%
var blended_color = bg.blend(fg) # Brown with alpha of 75%
[/gdscript]
[csharp]
var bg = new Color(0.0f, 1.0f, 0.0f, 0.5f); // Green with alpha of 50%
var fg = new Color(1.0f, 0.0f, 0.0f, 0.5f); // Red with alpha of 50%
Color blendedColor = bg.Blend(fg); // Brown with alpha of 75%
[/csharp]
[/codeblocks] *)

    val get_luminance :
      BuiltinClass0.Color.t structure ptr -> BuiltinClass0.Float.t structure ptr
    (** Returns the light intensity of the color, as a value between 0.0 and 1.0 (inclusive). This is useful when determining light or dark color. Colors with a luminance smaller than 0.5 can be generally considered dark.
[b]Note:[/b] [method get_luminance] relies on the color being in the linear color space to return an accurate relative luminance value. If the color is in the sRGB color space, use [method srgb_to_linear] to convert it to the linear color space first. *)

    val srgb_to_linear :
      BuiltinClass0.Color.t structure ptr -> BuiltinClass0.Color.t structure ptr
    (** Returns the color converted to the linear color space. This method assumes the original color already is in the sRGB color space. See also [method linear_to_srgb] which performs the opposite operation. *)

    val linear_to_srgb :
      BuiltinClass0.Color.t structure ptr -> BuiltinClass0.Color.t structure ptr
    (** Returns the color converted to the [url=https://en.wikipedia.org/wiki/SRGB]sRGB[/url] color space. This method assumes the original color is in the linear color space. See also [method srgb_to_linear] which performs the opposite operation. *)

    val is_equal_approx :
      BuiltinClass0.Color.t structure ptr ->
      BuiltinClass0.Color.t structure ptr ->
      BuiltinClass0.Bool.t structure ptr
    (** Returns [code]true[/code] if this color and [param to] are approximately equal, by running [method @GlobalScope.is_equal_approx] on each component. *)

    val hex :
      BuiltinClass0.Int.t structure ptr -> BuiltinClass0.Color.t structure ptr
    (** Returns the [Color] associated with the provided [param hex] integer in 32-bit RGBA format (8 bits per channel).
In GDScript and C#, the [int] is best visualized with hexadecimal notation ([code]""0x""[/code] prefix, making it [code]""0xRRGGBBAA""[/code]).
[codeblocks]
[gdscript]
var red = Color.hex(0xff0000ff)
var dark_cyan = Color.hex(0x008b8bff)
var my_color = Color.hex(0xbbefd2a4)
[/gdscript]
[csharp]
var red = new Color(0xff0000ff);
var dark_cyan = new Color(0x008b8bff);
var my_color = new Color(0xbbefd2a4);
[/csharp]
[/codeblocks] *)

    val hex64 :
      BuiltinClass0.Int.t structure ptr -> BuiltinClass0.Color.t structure ptr
    (** Returns the [Color] associated with the provided [param hex] integer in 64-bit RGBA format (16 bits per channel).
In GDScript and C#, the [int] is best visualized with hexadecimal notation ([code]""0x""[/code] prefix, making it [code]""0xRRRRGGGGBBBBAAAA""[/code]). *)

    val html :
      BuiltinClass0.String.t structure ptr ->
      BuiltinClass0.Color.t structure ptr
    (** Returns a new color from [param rgba], an HTML hexadecimal color string. [param rgba] is not case-sensitive, and may be prefixed by a hash sign ([code]#[/code]).
[param rgba] must be a valid three-digit or six-digit hexadecimal color string, and may contain an alpha channel value. If [param rgba] does not contain an alpha channel value, an alpha channel value of 1.0 is applied. If [param rgba] is invalid, returns an empty color.
[codeblocks]
[gdscript]
var blue = Color.html(""#0000ff"") # blue is Color(0.0, 0.0, 1.0, 1.0)
var green = Color.html(""#0F0"")   # green is Color(0.0, 1.0, 0.0, 1.0)
var col = Color.html(""663399cc"") # col is Color(0.4, 0.2, 0.6, 0.8)
[/gdscript]
[csharp]
var blue = Color.FromHtml(""#0000ff""); // blue is Color(0.0, 0.0, 1.0, 1.0)
var green = Color.FromHtml(""#0F0"");   // green is Color(0.0, 1.0, 0.0, 1.0)
var col = Color.FromHtml(""663399cc""); // col is Color(0.4, 0.2, 0.6, 0.8)
[/csharp]
[/codeblocks] *)

    val html_is_valid :
      BuiltinClass0.String.t structure ptr -> BuiltinClass0.Bool.t structure ptr
    (** Returns [code]true[/code] if [param color] is a valid HTML hexadecimal color string. The string must be a hexadecimal value (case-insensitive) of either 3, 4, 6 or 8 digits, and may be prefixed by a hash sign ([code]#[/code]). This method is identical to [method String.is_valid_html_color].
[codeblocks]
[gdscript]
Color.html_is_valid(""#55aaFF"")   # Returns true
Color.html_is_valid(""#55AAFF20"") # Returns true
Color.html_is_valid(""55AAFF"")    # Returns true
Color.html_is_valid(""#F2C"")      # Returns true

Color.html_is_valid(""#AABBC"")    # Returns false
Color.html_is_valid(""#55aaFF5"")  # Returns false
[/gdscript]
[csharp]
Color.HtmlIsValid(""#55AAFF"");   // Returns true
Color.HtmlIsValid(""#55AAFF20""); // Returns true
Color.HtmlIsValid(""55AAFF"");    // Returns true
Color.HtmlIsValid(""#F2C"");      // Returns true

Color.HtmlIsValid(""#AABBC"");    // Returns false
Color.HtmlIsValid(""#55aaFF5"");  // Returns false
[/csharp]
[/codeblocks] *)

    val from_string :
      BuiltinClass0.String.t structure ptr ->
      BuiltinClass0.Color.t structure ptr ->
      BuiltinClass0.Color.t structure ptr
    (** Creates a [Color] from the given string, which can be either an HTML color code or a named color (case-insensitive). Returns [param default] if the color cannot be inferred from the string. *)

    val from_hsv :
      BuiltinClass0.Float.t structure ptr ->
      BuiltinClass0.Float.t structure ptr ->
      BuiltinClass0.Float.t structure ptr ->
      BuiltinClass0.Float.t structure ptr ->
      BuiltinClass0.Color.t structure ptr
    (** Constructs a color from an [url=https://en.wikipedia.org/wiki/HSL_and_HSV]HSV profile[/url]. The hue ([param h]), saturation ([param s]), and value ([param v]) are typically between 0.0 and 1.0.
[codeblocks]
[gdscript]
var color = Color.from_hsv(0.58, 0.5, 0.79, 0.8)
[/gdscript]
[csharp]
var color = Color.FromHsv(0.58f, 0.5f, 0.79f, 0.8f);
[/csharp]
[/codeblocks] *)

    val from_ok_hsl :
      BuiltinClass0.Float.t structure ptr ->
      BuiltinClass0.Float.t structure ptr ->
      BuiltinClass0.Float.t structure ptr ->
      BuiltinClass0.Float.t structure ptr ->
      BuiltinClass0.Color.t structure ptr
    (** Constructs a color from an [url=https://bottosson.github.io/posts/colorpicker/]OK HSL profile[/url]. The hue ([param h]), saturation ([param s]), and lightness ([param l]) are typically between 0.0 and 1.0.
[codeblocks]
[gdscript]
var color = Color.from_ok_hsl(0.58, 0.5, 0.79, 0.8)
[/gdscript]
[csharp]
var color = Color.FromOkHsl(0.58f, 0.5f, 0.79f, 0.8f);
[/csharp]
[/codeblocks] *)

    val from_rgbe9995 :
      BuiltinClass0.Int.t structure ptr -> BuiltinClass0.Color.t structure ptr
    (** Decodes a [Color] from a RGBE9995 format integer. See [constant Image.FORMAT_RGBE9995]. *)

    val ( ~- ) :
      Color.t structure ptr ->
      Color.t structure ptr ->
      Color.t structure ptr ->
      unit
    (** Inverts the given color. This is equivalent to [code]Color.WHITE - c[/code] or [code]Color(1 - c.r, 1 - c.g, 1 - c.b, 1 - c.a)[/code]. Unlike with [method inverted], the [member a] component is inverted, too. *)

    val ( ~+ ) :
      Color.t structure ptr ->
      Color.t structure ptr ->
      Color.t structure ptr ->
      unit
    (** Returns the same value as if the [code]+[/code] was not there. Unary [code]+[/code] does nothing, but sometimes it can make your code more readable. *)

    val not :
      Color.t structure ptr ->
      Color.t structure ptr ->
      Bool.t structure ptr ->
      unit

    val ( = ) :
      Color.t structure ptr ->
      Color.t structure ptr ->
      Bool.t structure ptr ->
      unit
    (** Returns [code]true[/code] if the colors are exactly equal.
[b]Note:[/b] Due to floating-point precision errors, consider using [method is_equal_approx] instead, which is more reliable. *)

    val ( <> ) :
      Color.t structure ptr ->
      Color.t structure ptr ->
      Bool.t structure ptr ->
      unit
    (** Returns [code]true[/code] if the colors are not exactly equal.
[b]Note:[/b] Due to floating-point precision errors, consider using [method is_equal_approx] instead, which is more reliable. *)

    val ( + ) :
      Color.t structure ptr ->
      Color.t structure ptr ->
      Color.t structure ptr ->
      unit
    (** Adds each component of the [Color] with the components of the given [Color]. *)

    val ( - ) :
      Color.t structure ptr ->
      Color.t structure ptr ->
      Color.t structure ptr ->
      unit
    (** Subtracts each component of the [Color] by the components of the given [Color]. *)

    val ( * ) :
      Color.t structure ptr ->
      Color.t structure ptr ->
      Color.t structure ptr ->
      unit
    (** Multiplies each component of the [Color] by the components of the given [Color]. *)

    val ( / ) :
      Color.t structure ptr ->
      Color.t structure ptr ->
      Color.t structure ptr ->
      unit
    (** Divides each component of the [Color] by the components of the given [Color]. *)

    val _Color_elem_Dictionary :
      Color.t structure ptr ->
      Dictionary.t structure ptr ->
      Bool.t structure ptr ->
      unit

    val _Color_elem_Array :
      Color.t structure ptr ->
      Array.t structure ptr ->
      Bool.t structure ptr ->
      unit

    val _Color_elem_PackedColorArray :
      Color.t structure ptr ->
      PackedColorArray.t structure ptr ->
      Bool.t structure ptr ->
      unit
  end

  module type STRINGNAME = sig
    type t

    include Api_types.API_TYPE with type t := t

    val casecmp_to :
      BuiltinClass0.String.t structure ptr ->
      BuiltinClass0.StringName.t structure ptr ->
      BuiltinClass0.Int.t structure ptr
    (** Performs a case-sensitive comparison to another string. Returns [code]-1[/code] if less than, [code]1[/code] if greater than, or [code]0[/code] if equal. ""Less than"" and ""greater than"" are determined by the [url=https://en.wikipedia.org/wiki/List_of_Unicode_characters]Unicode code points[/url] of each string, which roughly matches the alphabetical order.
With different string lengths, returns [code]1[/code] if this string is longer than the [param to] string, or [code]-1[/code] if shorter. Note that the length of empty strings is [i]always[/i] [code]0[/code].
To get a [bool] result from a string comparison, use the [code]==[/code] operator instead. See also [method nocasecmp_to], [method naturalcasecmp_to], and [method naturalnocasecmp_to]. *)

    val nocasecmp_to :
      BuiltinClass0.String.t structure ptr ->
      BuiltinClass0.StringName.t structure ptr ->
      BuiltinClass0.Int.t structure ptr
    (** Performs a [b]case-insensitive[/b] comparison to another string. Returns [code]-1[/code] if less than, [code]1[/code] if greater than, or [code]0[/code] if equal. ""Less than"" or ""greater than"" are determined by the [url=https://en.wikipedia.org/wiki/List_of_Unicode_characters]Unicode code points[/url] of each string, which roughly matches the alphabetical order. Internally, lowercase characters are converted to uppercase for the comparison.
With different string lengths, returns [code]1[/code] if this string is longer than the [param to] string, or [code]-1[/code] if shorter. Note that the length of empty strings is [i]always[/i] [code]0[/code].
To get a [bool] result from a string comparison, use the [code]==[/code] operator instead. See also [method casecmp_to], [method naturalcasecmp_to], and [method naturalnocasecmp_to]. *)

    val naturalcasecmp_to :
      BuiltinClass0.String.t structure ptr ->
      BuiltinClass0.StringName.t structure ptr ->
      BuiltinClass0.Int.t structure ptr
    (** Performs a [b]case-sensitive[/b], [i]natural order[/i] comparison to another string. Returns [code]-1[/code] if less than, [code]1[/code] if greater than, or [code]0[/code] if equal. ""Less than"" or ""greater than"" are determined by the [url=https://en.wikipedia.org/wiki/List_of_Unicode_characters]Unicode code points[/url] of each string, which roughly matches the alphabetical order.
When used for sorting, natural order comparison orders sequences of numbers by the combined value of each digit as is often expected, instead of the single digit's value. A sorted sequence of numbered strings will be [code][""1"", ""2"", ""3"", ...][/code], not [code][""1"", ""10"", ""2"", ""3"", ...][/code].
With different string lengths, returns [code]1[/code] if this string is longer than the [param to] string, or [code]-1[/code] if shorter. Note that the length of empty strings is [i]always[/i] [code]0[/code].
To get a [bool] result from a string comparison, use the [code]==[/code] operator instead. See also [method naturalnocasecmp_to], [method nocasecmp_to], and [method casecmp_to]. *)

    val naturalnocasecmp_to :
      BuiltinClass0.String.t structure ptr ->
      BuiltinClass0.StringName.t structure ptr ->
      BuiltinClass0.Int.t structure ptr
    (** Performs a [b]case-insensitive[/b], [i]natural order[/i] comparison to another string. Returns [code]-1[/code] if less than, [code]1[/code] if greater than, or [code]0[/code] if equal. ""Less than"" or ""greater than"" are determined by the [url=https://en.wikipedia.org/wiki/List_of_Unicode_characters]Unicode code points[/url] of each string, which roughly matches the alphabetical order. Internally, lowercase characters are converted to uppercase for the comparison.
When used for sorting, natural order comparison orders sequences of numbers by the combined value of each digit as is often expected, instead of the single digit's value. A sorted sequence of numbered strings will be [code][""1"", ""2"", ""3"", ...][/code], not [code][""1"", ""10"", ""2"", ""3"", ...][/code].
With different string lengths, returns [code]1[/code] if this string is longer than the [param to] string, or [code]-1[/code] if shorter. Note that the length of empty strings is [i]always[/i] [code]0[/code].
To get a [bool] result from a string comparison, use the [code]==[/code] operator instead. See also [method naturalcasecmp_to], [method nocasecmp_to], and [method casecmp_to]. *)

    val length :
      BuiltinClass0.StringName.t structure ptr ->
      BuiltinClass0.Int.t structure ptr
    (** Returns the number of characters in the string. Empty strings ([code]""""[/code]) always return [code]0[/code]. See also [method is_empty]. *)

    val substr :
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.StringName.t structure ptr ->
      BuiltinClass0.String.t structure ptr
    (** Returns part of the string from the position [param from] with length [param len]. If [param len] is [code]-1[/code] (as by default), returns the rest of the string starting from the given position. *)

    val get_slice :
      BuiltinClass0.String.t structure ptr ->
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.StringName.t structure ptr ->
      BuiltinClass0.String.t structure ptr
    (** Splits the string using a [param delimiter] and returns the substring at index [param slice]. Returns an empty string if the [param slice] does not exist.
This is faster than [method split], if you only need one substring.
[b]Example:[/b]
[codeblock]
print(""i/am/example/hi"".get_slice(""/"", 2)) # Prints ""example""
[/codeblock] *)

    val get_slicec :
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.StringName.t structure ptr ->
      BuiltinClass0.String.t structure ptr
    (** Splits the string using a Unicode character with code [param delimiter] and returns the substring at index [param slice]. Returns an empty string if the [param slice] does not exist.
This is faster than [method split], if you only need one substring. *)

    val get_slice_count :
      BuiltinClass0.String.t structure ptr ->
      BuiltinClass0.StringName.t structure ptr ->
      BuiltinClass0.Int.t structure ptr
    (** Returns the total number of slices when the string is split with the given [param delimiter] (see [method split]). *)

    val find :
      BuiltinClass0.String.t structure ptr ->
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.StringName.t structure ptr ->
      BuiltinClass0.Int.t structure ptr
    (** Returns the index of the [b]first[/b] occurrence of [param what] in this string, or [code]-1[/code] if there are none. The search's start can be specified with [param from], continuing to the end of the string.
[codeblocks]
[gdscript]
print(""Team"".find(""I"")) # Prints -1

print(""Potato"".find(""t""))    # Prints 2
print(""Potato"".find(""t"", 3)) # Prints 4
print(""Potato"".find(""t"", 5)) # Prints -1
[/gdscript]
[csharp]
GD.Print(""Team"".Find(""I"")); // Prints -1

GD.Print(""Potato"".Find(""t""));    // Prints 2
GD.Print(""Potato"".Find(""t"", 3)); // Prints 4
GD.Print(""Potato"".Find(""t"", 5)); // Prints -1
[/csharp]
[/codeblocks]
[b]Note:[/b] If you just want to know whether the string contains [param what], use [method contains]. In GDScript, you may also use the [code]in[/code] operator. *)

    val count :
      BuiltinClass0.String.t structure ptr ->
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.StringName.t structure ptr ->
      BuiltinClass0.Int.t structure ptr
    (** Returns the number of occurrences of the substring [param what] between [param from] and [param to] positions. If [param to] is 0, the search continues until the end of the string. *)

    val countn :
      BuiltinClass0.String.t structure ptr ->
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.StringName.t structure ptr ->
      BuiltinClass0.Int.t structure ptr
    (** Returns the number of occurrences of the substring [param what] between [param from] and [param to] positions, [b]ignoring case[/b]. If [param to] is 0, the search continues until the end of the string. *)

    val findn :
      BuiltinClass0.String.t structure ptr ->
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.StringName.t structure ptr ->
      BuiltinClass0.Int.t structure ptr
    (** Returns the index of the [b]first[/b] [b]case-insensitive[/b] occurrence of [param what] in this string, or [code]-1[/code] if there are none. The starting search index can be specified with [param from], continuing to the end of the string. *)

    val rfind :
      BuiltinClass0.String.t structure ptr ->
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.StringName.t structure ptr ->
      BuiltinClass0.Int.t structure ptr
    (** Returns the index of the [b]last[/b] occurrence of [param what] in this string, or [code]-1[/code] if there are none. The search's start can be specified with [param from], continuing to the beginning of the string. This method is the reverse of [method find]. *)

    val rfindn :
      BuiltinClass0.String.t structure ptr ->
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.StringName.t structure ptr ->
      BuiltinClass0.Int.t structure ptr
    (** Returns the index of the [b]last[/b] [b]case-insensitive[/b] occurrence of [param what] in this string, or [code]-1[/code] if there are none. The starting search index can be specified with [param from], continuing to the beginning of the string. This method is the reverse of [method findn]. *)

    val match_ :
      BuiltinClass0.String.t structure ptr ->
      BuiltinClass0.StringName.t structure ptr ->
      BuiltinClass0.Bool.t structure ptr
    (** Does a simple expression match (also called ""glob"" or ""globbing""), where [code] * [/code] matches zero or more arbitrary characters and [code]?[/code] matches any single character except a period ([code].[/code]). An empty string or empty expression always evaluates to [code]false[/code]. *)

    val matchn :
      BuiltinClass0.String.t structure ptr ->
      BuiltinClass0.StringName.t structure ptr ->
      BuiltinClass0.Bool.t structure ptr
    (** Does a simple [b]case-insensitive[/b] expression match, where [code] * [/code] matches zero or more arbitrary characters and [code]?[/code] matches any single character except a period ([code].[/code]). An empty string or empty expression always evaluates to [code]false[/code]. *)

    val begins_with :
      BuiltinClass0.String.t structure ptr ->
      BuiltinClass0.StringName.t structure ptr ->
      BuiltinClass0.Bool.t structure ptr
    (** Returns [code]true[/code] if the string begins with the given [param text]. See also [method ends_with]. *)

    val ends_with :
      BuiltinClass0.String.t structure ptr ->
      BuiltinClass0.StringName.t structure ptr ->
      BuiltinClass0.Bool.t structure ptr
    (** Returns [code]true[/code] if the string ends with the given [param text]. See also [method begins_with]. *)

    val is_subsequence_of :
      BuiltinClass0.String.t structure ptr ->
      BuiltinClass0.StringName.t structure ptr ->
      BuiltinClass0.Bool.t structure ptr
    (** Returns [code]true[/code] if all characters of this string can be found in [param text] in their original order.
[codeblock]
var text = ""Wow, incredible!""

print(""inedible"".is_subsequence_of(text)) # Prints true
print(""Word!"".is_subsequence_of(text))    # Prints true
print(""Window"".is_subsequence_of(text))   # Prints false
print("""".is_subsequence_of(text))         # Prints true
[/codeblock] *)

    val is_subsequence_ofn :
      BuiltinClass0.String.t structure ptr ->
      BuiltinClass0.StringName.t structure ptr ->
      BuiltinClass0.Bool.t structure ptr
    (** Returns [code]true[/code] if all characters of this string can be found in [param text] in their original order, [b]ignoring case[/b]. *)

    val bigrams :
      BuiltinClass0.StringName.t structure ptr ->
      BuiltinClass0.PackedStringArray.t structure ptr
    (** Returns an array containing the bigrams (pairs of consecutive characters) of this string.
[codeblock]
print(""Get up!"".bigrams()) # Prints [""Ge"", ""et"", ""t "", "" u"", ""up"", ""p!""]
[/codeblock] *)

    val similarity :
      BuiltinClass0.String.t structure ptr ->
      BuiltinClass0.StringName.t structure ptr ->
      BuiltinClass0.Float.t structure ptr
    (** Returns the similarity index ([url=https://en.wikipedia.org/wiki/S%C3%B8rensen%E2%80%93Dice_coefficient]Sorensen-Dice coefficient[/url]) of this string compared to another. A result of [code]1.0[/code] means totally similar, while [code]0.0[/code] means totally dissimilar.
[codeblock]
print(""ABC123"".similarity(""ABC123"")) # Prints 1.0
print(""ABC123"".similarity(""XYZ456"")) # Prints 0.0
print(""ABC123"".similarity(""123ABC"")) # Prints 0.8
print(""ABC123"".similarity(""abc123"")) # Prints 0.4
[/codeblock] *)

    val format :
      BuiltinClass0.Variant.t structure ptr ->
      BuiltinClass0.String.t structure ptr ->
      BuiltinClass0.StringName.t structure ptr ->
      BuiltinClass0.String.t structure ptr
    (** Formats the string by replacing all occurrences of [param placeholder] with the elements of [param values].
[param values] can be a [Dictionary] or an [Array]. Any underscores in [param placeholder] will be replaced with the corresponding keys in advance. Array elements use their index as keys.
[codeblock]
# Prints ""Waiting for Godot is a play by Samuel Beckett, and Godot Engine is named after it.""
var use_array_values = ""Waiting for {0} is a play by {1}, and {0} Engine is named after it.""
print(use_array_values.format([""Godot"", ""Samuel Beckett""]))

# Prints ""User 42 is Godot.""
print(""User {id} is {name}."".format({""id"": 42, ""name"": ""Godot""}))
[/codeblock]
Some additional handling is performed when [param values] is an [Array]. If [param placeholder] does not contain an underscore, the elements of the [param values] array will be used to replace one occurrence of the placeholder in order; If an element of [param values] is another 2-element array, it'll be interpreted as a key-value pair.
[codeblock]
# Prints ""User 42 is Godot.""
print(""User {} is {}."".format([42, ""Godot""], ""{}""))
print(""User {id} is {name}."".format([[""id"", 42], [""name"", ""Godot""]]))
[/codeblock]
See also the [url=$DOCS_URL/tutorials/scripting/gdscript/gdscript_format_string.html]GDScript format string[/url] tutorial.
[b]Note:[/b] In C#, it's recommended to [url=https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/tokens/interpolated]interpolate strings with ""$""[/url], instead. *)

    val replace :
      BuiltinClass0.String.t structure ptr ->
      BuiltinClass0.String.t structure ptr ->
      BuiltinClass0.StringName.t structure ptr ->
      BuiltinClass0.String.t structure ptr
    (** Replaces all occurrences of [param what] inside the string with the given [param forwhat]. *)

    val replacen :
      BuiltinClass0.String.t structure ptr ->
      BuiltinClass0.String.t structure ptr ->
      BuiltinClass0.StringName.t structure ptr ->
      BuiltinClass0.String.t structure ptr
    (** Replaces all [b]case-insensitive[/b] occurrences of [param what] inside the string with the given [param forwhat]. *)

    val repeat :
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.StringName.t structure ptr ->
      BuiltinClass0.String.t structure ptr
    (** Repeats this string a number of times. [param count] needs to be greater than [code]0[/code]. Otherwise, returns an empty string. *)

    val reverse :
      BuiltinClass0.StringName.t structure ptr ->
      BuiltinClass0.String.t structure ptr
    (** Returns the copy of this string in reverse order. *)

    val insert :
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.String.t structure ptr ->
      BuiltinClass0.StringName.t structure ptr ->
      BuiltinClass0.String.t structure ptr
    (** Inserts [param what] at the given [param position] in the string. *)

    val erase :
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.StringName.t structure ptr ->
      BuiltinClass0.String.t structure ptr
    (** Returns a string with [param chars] characters erased starting from [param position]. If [param chars] goes beyond the string's length given the specified [param position], fewer characters will be erased from the returned string. Returns an empty string if either [param position] or [param chars] is negative. Returns the original string unmodified if [param chars] is [code]0[/code]. *)

    val capitalize :
      BuiltinClass0.StringName.t structure ptr ->
      BuiltinClass0.String.t structure ptr
    (** Changes the appearance of the string: replaces underscores ([code]_[/code]) with spaces, adds spaces before uppercase letters in the middle of a word, converts all letters to lowercase, then converts the first one and each one following a space to uppercase.
[codeblocks]
[gdscript]
""move_local_x"".capitalize()   # Returns ""Move Local X""
""sceneFile_path"".capitalize() # Returns ""Scene File Path""
""2D, FPS, PNG"".capitalize()   # Returns ""2d, Fps, Png""
[/gdscript]
[csharp]
""move_local_x"".Capitalize();   // Returns ""Move Local X""
""sceneFile_path"".Capitalize(); // Returns ""Scene File Path""
""2D, FPS, PNG"".Capitalize();   // Returns ""2d, Fps, Png""
[/csharp]
[/codeblocks] *)

    val to_camel_case :
      BuiltinClass0.StringName.t structure ptr ->
      BuiltinClass0.String.t structure ptr
    (** Returns the string converted to [code]camelCase[/code]. *)

    val to_pascal_case :
      BuiltinClass0.StringName.t structure ptr ->
      BuiltinClass0.String.t structure ptr
    (** Returns the string converted to [code]PascalCase[/code]. *)

    val to_snake_case :
      BuiltinClass0.StringName.t structure ptr ->
      BuiltinClass0.String.t structure ptr
    (** Returns the string converted to [code]snake_case[/code].
[b]Note:[/b] Numbers followed by a [i]single[/i] letter are not separated in the conversion to keep some words (such as ""2D"") together.
[codeblocks]
[gdscript]
""Node2D"".to_snake_case()               # Returns ""node_2d""
""2nd place"".to_snake_case()            # Returns ""2_nd_place""
""Texture3DAssetFolder"".to_snake_case() # Returns ""texture_3d_asset_folder""
[/gdscript]
[csharp]
""Node2D"".ToSnakeCase();               // Returns ""node_2d""
""2nd place"".ToSnakeCase();            // Returns ""2_nd_place""
""Texture3DAssetFolder"".ToSnakeCase(); // Returns ""texture_3d_asset_folder""
[/csharp]
[/codeblocks] *)

    val split :
      BuiltinClass0.String.t structure ptr ->
      BuiltinClass0.Bool.t structure ptr ->
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.StringName.t structure ptr ->
      BuiltinClass0.PackedStringArray.t structure ptr
    (** Splits the string using a [param delimiter] and returns an array of the substrings. If [param delimiter] is an empty string, each substring will be a single character. This method is the opposite of [method join].
If [param allow_empty] is [code]false[/code], empty strings between adjacent delimiters are excluded from the array.
If [param maxsplit] is greater than [code]0[/code], the number of splits may not exceed [param maxsplit]. By default, the entire string is split.
[b]Example:[/b]
[codeblocks]
[gdscript]
var some_array = ""One,Two,Three,Four"".split("","", true, 2)

print(some_array.size()) # Prints 3
print(some_array[0])     # Prints ""One""
print(some_array[1])     # Prints ""Two""
print(some_array[2])     # Prints ""Three,Four""
[/gdscript]
[csharp]
// C#'s `Split()` does not support the `maxsplit` parameter.
var someArray = ""One,Two,Three"".Split("","");

GD.Print(someArray[0]); // Prints ""One""
GD.Print(someArray[1]); // Prints ""Two""
GD.Print(someArray[2]); // Prints ""Three""
[/csharp]
[/codeblocks]
[b]Note:[/b] If you only need one substring from the array, consider using [method get_slice] which is faster. If you need to split strings with more complex rules, use the [RegEx] class instead. *)

    val rsplit :
      BuiltinClass0.String.t structure ptr ->
      BuiltinClass0.Bool.t structure ptr ->
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.StringName.t structure ptr ->
      BuiltinClass0.PackedStringArray.t structure ptr
    (** Splits the string using a [param delimiter] and returns an array of the substrings, starting from the end of the string. The splits in the returned array appear in the same order as the original string. If [param delimiter] is an empty string, each substring will be a single character.
If [param allow_empty] is [code]false[/code], empty strings between adjacent delimiters are excluded from the array.
If [param maxsplit] is greater than [code]0[/code], the number of splits may not exceed [param maxsplit]. By default, the entire string is split, which is mostly identical to [method split].
[b]Example:[/b]
[codeblocks]
[gdscript]
var some_string = ""One,Two,Three,Four""
var some_array = some_string.rsplit("","", true, 1)

print(some_array.size()) # Prints 2
print(some_array[0])     # Prints ""One,Two,Three""
print(some_array[1])     # Prints ""Four""
[/gdscript]
[csharp]
// In C#, there is no String.RSplit() method.
[/csharp]
[/codeblocks] *)

    val split_floats :
      BuiltinClass0.String.t structure ptr ->
      BuiltinClass0.Bool.t structure ptr ->
      BuiltinClass0.StringName.t structure ptr ->
      BuiltinClass0.PackedFloat64Array.t structure ptr
    (** Splits the string into floats by using a [param delimiter] and returns a [PackedFloat64Array].
If [param allow_empty] is [code]false[/code], empty or invalid [float] conversions between adjacent delimiters are excluded.
[codeblock]
var a = ""1,2,4.5"".split_floats("","")         # a is [1.0, 2.0, 4.5]
var c = ""1| ||4.5"".split_floats(""|"")        # c is [1.0, 0.0, 0.0, 4.5]
var b = ""1| ||4.5"".split_floats(""|"", false) # b is [1.0, 4.5]
[/codeblock] *)

    val join :
      BuiltinClass0.PackedStringArray.t structure ptr ->
      BuiltinClass0.StringName.t structure ptr ->
      BuiltinClass0.String.t structure ptr
    (** Returns the concatenation of [param parts]' elements, with each element separated by the string calling this method. This method is the opposite of [method split].
[b]Example:[/b]
[codeblocks]
[gdscript]
var fruits = [""Apple"", ""Orange"", ""Pear"", ""Kiwi""]

print("", "".join(fruits))  # Prints ""Apple, Orange, Pear, Kiwi""
print(""---"".join(fruits)) # Prints ""Apple---Orange---Pear---Kiwi""
[/gdscript]
[csharp]
var fruits = new string[] {""Apple"", ""Orange"", ""Pear"", ""Kiwi""};

// In C#, this method is static.
GD.Print(string.Join("", "", fruits));  // Prints ""Apple, Orange, Pear, Kiwi""
GD.Print(string.Join(""---"", fruits)); // Prints ""Apple---Orange---Pear---Kiwi""
[/csharp]
[/codeblocks] *)

    val to_upper :
      BuiltinClass0.StringName.t structure ptr ->
      BuiltinClass0.String.t structure ptr
    (** Returns the string converted to [code]UPPERCASE[/code]. *)

    val to_lower :
      BuiltinClass0.StringName.t structure ptr ->
      BuiltinClass0.String.t structure ptr
    (** Returns the string converted to [code]lowercase[/code]. *)

    val left :
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.StringName.t structure ptr ->
      BuiltinClass0.String.t structure ptr
    (** Returns the first [param length] characters from the beginning of the string. If [param length] is negative, strips the last [param length] characters from the string's end.
[codeblock]
print(""Hello World!"".left(3))  # Prints ""Hel""
print(""Hello World!"".left(-4)) # Prints ""Hello Wo""
[/codeblock] *)

    val right :
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.StringName.t structure ptr ->
      BuiltinClass0.String.t structure ptr
    (** Returns the last [param length] characters from the end of the string. If [param length] is negative, strips the first [param length] characters from the string's beginning.
[codeblock]
print(""Hello World!"".right(3))  # Prints ""ld!""
print(""Hello World!"".right(-4)) # Prints ""o World!""
[/codeblock] *)

    val strip_edges :
      BuiltinClass0.Bool.t structure ptr ->
      BuiltinClass0.Bool.t structure ptr ->
      BuiltinClass0.StringName.t structure ptr ->
      BuiltinClass0.String.t structure ptr
    (** Strips all non-printable characters from the beginning and the end of the string. These include spaces, tabulations ([code]\t[/code]), and newlines ([code]\n[/code] [code]\r[/code]).
If [param left] is [code]false[/code], ignores the string's beginning. Likewise, if [param right] is [code]false[/code], ignores the string's end. *)

    val strip_escapes :
      BuiltinClass0.StringName.t structure ptr ->
      BuiltinClass0.String.t structure ptr
    (** Strips all escape characters from the string. These include all non-printable control characters of the first page of the ASCII table (values from 0 to 31), such as tabulation ([code]\t[/code]) and newline ([code]\n[/code], [code]\r[/code]) characters, but [i]not[/i] spaces. *)

    val lstrip :
      BuiltinClass0.String.t structure ptr ->
      BuiltinClass0.StringName.t structure ptr ->
      BuiltinClass0.String.t structure ptr
    (** Removes a set of characters defined in [param chars] from the string's beginning. See also [method rstrip].
[b]Note:[/b] [param chars] is not a prefix. Use [method trim_prefix] to remove a single prefix, rather than a set of characters. *)

    val rstrip :
      BuiltinClass0.String.t structure ptr ->
      BuiltinClass0.StringName.t structure ptr ->
      BuiltinClass0.String.t structure ptr
    (** Removes a set of characters defined in [param chars] from the string's end. See also [method lstrip].
[b]Note:[/b] [param chars] is not a suffix. Use [method trim_suffix] to remove a single suffix, rather than a set of characters. *)

    val get_extension :
      BuiltinClass0.StringName.t structure ptr ->
      BuiltinClass0.String.t structure ptr
    (** If the string is a valid file name or path, returns the file extension without the leading period ([code].[/code]). Otherwise, returns an empty string.
[codeblock]
var a = ""/path/to/file.txt"".get_extension() # a is ""txt""
var b = ""cool.txt"".get_extension()          # b is ""txt""
var c = ""cool.font.tres"".get_extension()    # c is ""tres""
var d = "".pack1"".get_extension()            # d is ""pack1""

var e = ""file.txt."".get_extension()  # e is """"
var f = ""file.txt.."".get_extension() # f is """"
var g = ""txt"".get_extension()        # g is """"
var h = """".get_extension()           # h is """"
[/codeblock] *)

    val get_basename :
      BuiltinClass0.StringName.t structure ptr ->
      BuiltinClass0.String.t structure ptr
    (** If the string is a valid file path, returns the full file path, without the extension.
[codeblock]
var base = ""/path/to/file.txt"".get_basename() # base is ""/path/to/file""
[/codeblock] *)

    val path_join :
      BuiltinClass0.String.t structure ptr ->
      BuiltinClass0.StringName.t structure ptr ->
      BuiltinClass0.String.t structure ptr
    (** Concatenates [param file] at the end of the string as a subpath, adding [code]/[/code] if necessary.
[b]Example:[/b] [code]""this/is"".path_join(""path"") == ""this/is/path""[/code]. *)

    val unicode_at :
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.StringName.t structure ptr ->
      BuiltinClass0.Int.t structure ptr
    (** Returns the character code at position [param at]. *)

    val indent :
      BuiltinClass0.String.t structure ptr ->
      BuiltinClass0.StringName.t structure ptr ->
      BuiltinClass0.String.t structure ptr
    (** Indents every line of the string with the given [param prefix]. Empty lines are not indented. See also [method dedent] to remove indentation.
For example, the string can be indented with two tabulations using [code]""\t\t""[/code], or four spaces using [code]""    ""[/code]. *)

    val dedent :
      BuiltinClass0.StringName.t structure ptr ->
      BuiltinClass0.String.t structure ptr
    (** Returns a copy of the string with indentation (leading tabs and spaces) removed. See also [method indent] to add indentation. *)

    val md5_text :
      BuiltinClass0.StringName.t structure ptr ->
      BuiltinClass0.String.t structure ptr
    (** Returns the [url=https://en.wikipedia.org/wiki/MD5]MD5 hash[/url] of the string as another [String]. *)

    val sha1_text :
      BuiltinClass0.StringName.t structure ptr ->
      BuiltinClass0.String.t structure ptr
    (** Returns the [url=https://en.wikipedia.org/wiki/SHA-1]SHA-1[/url] hash of the string as another [String]. *)

    val sha256_text :
      BuiltinClass0.StringName.t structure ptr ->
      BuiltinClass0.String.t structure ptr
    (** Returns the [url=https://en.wikipedia.org/wiki/SHA-2]SHA-256[/url] hash of the string as another [String]. *)

    val md5_buffer :
      BuiltinClass0.StringName.t structure ptr ->
      BuiltinClass0.PackedByteArray.t structure ptr
    (** Returns the [url=https://en.wikipedia.org/wiki/MD5]MD5 hash[/url] of the string as a [PackedByteArray]. *)

    val sha1_buffer :
      BuiltinClass0.StringName.t structure ptr ->
      BuiltinClass0.PackedByteArray.t structure ptr
    (** Returns the [url=https://en.wikipedia.org/wiki/SHA-1]SHA-1[/url] hash of the string as a [PackedByteArray]. *)

    val sha256_buffer :
      BuiltinClass0.StringName.t structure ptr ->
      BuiltinClass0.PackedByteArray.t structure ptr
    (** Returns the [url=https://en.wikipedia.org/wiki/SHA-2]SHA-256[/url] hash of the string as a [PackedByteArray]. *)

    val is_empty :
      BuiltinClass0.StringName.t structure ptr ->
      BuiltinClass0.Bool.t structure ptr
    (** Returns [code]true[/code] if the string's length is [code]0[/code] ([code]""""[/code]). See also [method length]. *)

    val contains :
      BuiltinClass0.String.t structure ptr ->
      BuiltinClass0.StringName.t structure ptr ->
      BuiltinClass0.Bool.t structure ptr
    (** Returns [code]true[/code] if the string contains [param what]. In GDScript, this corresponds to the [code]in[/code] operator.
[codeblocks]
[gdscript]
print(""Node"".contains(""de"")) # Prints true
print(""team"".contains(""I""))  # Prints false
print(""I"" in ""team"")         # Prints false
[/gdscript]
[csharp]
GD.Print(""Node"".Contains(""de"")); // Prints true
GD.Print(""team"".Contains(""I""));  // Prints false
[/csharp]
[/codeblocks]
If you need to know where [param what] is within the string, use [method find]. *)

    val is_absolute_path :
      BuiltinClass0.StringName.t structure ptr ->
      BuiltinClass0.Bool.t structure ptr
    (** Returns [code]true[/code] if the string is a path to a file or directory, and its starting point is explicitly defined. This method is the opposite of [method is_relative_path].
This includes all paths starting with [code]""res://""[/code], [code]""user://""[/code], [code]""C:\""[/code], [code]""/""[/code], etc. *)

    val is_relative_path :
      BuiltinClass0.StringName.t structure ptr ->
      BuiltinClass0.Bool.t structure ptr
    (** Returns [code]true[/code] if the string is a path, and its starting point is dependent on context. The path could begin from the current directory, or the current [Node] (if the string is derived from a [NodePath]), and may sometimes be prefixed with [code]""./""[/code]. This method is the opposite of [method is_absolute_path]. *)

    val simplify_path :
      BuiltinClass0.StringName.t structure ptr ->
      BuiltinClass0.String.t structure ptr
    (** If the string is a valid file path, converts the string into a canonical path. This is the shortest possible path, without [code]""./""[/code], and all the unnecessary [code]""..""[/code] and [code]""/""[/code].
[codeblock]
var simple_path = ""./path/to///../file"".simplify_path()
print(simple_path) # Prints ""path/file""
[/codeblock] *)

    val get_base_dir :
      BuiltinClass0.StringName.t structure ptr ->
      BuiltinClass0.String.t structure ptr
    (** If the string is a valid file path, returns the base directory name.
[codeblock]
var dir_path = ""/path/to/file.txt"".get_base_dir() # dir_path is ""/path/to""
[/codeblock] *)

    val get_file :
      BuiltinClass0.StringName.t structure ptr ->
      BuiltinClass0.String.t structure ptr
    (** If the string is a valid file path, returns the file name, including the extension.
[codeblock]
var file = ""/path/to/icon.png"".get_file() # file is ""icon.png""
[/codeblock] *)

    val xml_escape :
      BuiltinClass0.Bool.t structure ptr ->
      BuiltinClass0.StringName.t structure ptr ->
      BuiltinClass0.String.t structure ptr
    (** Returns a copy of the string with special characters escaped using the XML standard. If [param escape_quotes] is [code]true[/code], the single quote ([code]'[/code]) and double quote ([code]""[/code]) characters are also escaped. *)

    val xml_unescape :
      BuiltinClass0.StringName.t structure ptr ->
      BuiltinClass0.String.t structure ptr
    (** Returns a copy of the string with escaped characters replaced by their meanings according to the XML standard. *)

    val uri_encode :
      BuiltinClass0.StringName.t structure ptr ->
      BuiltinClass0.String.t structure ptr
    (** Encodes the string to URL-friendly format. This method is meant to properly encode the parameters in a URL when sending an HTTP request.
[codeblocks]
[gdscript]
var prefix = ""$DOCS_URL/?highlight=""
var url = prefix + ""Godot Engine:docs"".uri_encode()

print(url) # Prints ""$DOCS_URL/?highlight=Godot%20Engine%3%docs""
[/gdscript]
[csharp]
var prefix = ""$DOCS_URL/?highlight="";
var url = prefix + ""Godot Engine:docs"".URIEncode();

GD.Print(url); // Prints ""$DOCS_URL/?highlight=Godot%20Engine%3%docs""
[/csharp]
[/codeblocks] *)

    val uri_decode :
      BuiltinClass0.StringName.t structure ptr ->
      BuiltinClass0.String.t structure ptr
    (** Decodes the string from its URL-encoded format. This method is meant to properly decode the parameters in a URL when receiving an HTTP request.
[codeblocks]
[gdscript]
var url = ""$DOCS_URL/?highlight=Godot%20Engine%3%docs""
print(url.uri_decode()) # Prints ""$DOCS_URL/?highlight=Godot Engine:docs""
[/gdscript]
[csharp]
var url = ""$DOCS_URL/?highlight=Godot%20Engine%3%docs""
GD.Print(url.URIDecode()) // Prints ""$DOCS_URL/?highlight=Godot Engine:docs""
[/csharp]
[/codeblocks] *)

    val c_escape :
      BuiltinClass0.StringName.t structure ptr ->
      BuiltinClass0.String.t structure ptr
    (** Returns a copy of the string with special characters escaped using the C language standard. *)

    val c_unescape :
      BuiltinClass0.StringName.t structure ptr ->
      BuiltinClass0.String.t structure ptr
    (** Returns a copy of the string with escaped characters replaced by their meanings. Supported escape sequences are [code]\'[/code], [code]\""[/code], [code]\\[/code], [code]\a[/code], [code]\b[/code], [code]\f[/code], [code]\n[/code], [code]\r[/code], [code]\t[/code], [code]\v[/code].
[b]Note:[/b] Unlike the GDScript parser, this method doesn't support the [code]\uXXXX[/code] escape sequence. *)

    val json_escape :
      BuiltinClass0.StringName.t structure ptr ->
      BuiltinClass0.String.t structure ptr
    (** Returns a copy of the string with special characters escaped using the JSON standard. Because it closely matches the C standard, it is possible to use [method c_unescape] to unescape the string, if necessary. *)

    val validate_node_name :
      BuiltinClass0.StringName.t structure ptr ->
      BuiltinClass0.String.t structure ptr
    (** Returns a copy of the string with all characters that are not allowed in [member Node.name] ([code].[/code] [code]:[/code] [code]@[/code] [code]/[/code] [code]""[/code] [code]%[/code]) replaced with underscores. *)

    val validate_filename :
      BuiltinClass0.StringName.t structure ptr ->
      BuiltinClass0.String.t structure ptr
    (** Returns a copy of the string with all characters that are not allowed in [method is_valid_filename] replaced with underscores. *)

    val is_valid_identifier :
      BuiltinClass0.StringName.t structure ptr ->
      BuiltinClass0.Bool.t structure ptr
    (** Returns [code]true[/code] if this string is a valid identifier. A valid identifier may contain only letters, digits and underscores ([code]_[/code]), and the first character may not be a digit.
[codeblock]
print(""node_2d"".is_valid_identifier())    # Prints true
print(""TYPE_FLOAT"".is_valid_identifier()) # Prints true
print(""1st_method"".is_valid_identifier()) # Prints false
print(""MyMethod#2"".is_valid_identifier()) # Prints false
[/codeblock] *)

    val is_valid_int :
      BuiltinClass0.StringName.t structure ptr ->
      BuiltinClass0.Bool.t structure ptr
    (** Returns [code]true[/code] if this string represents a valid integer. A valid integer only contains digits, and may be prefixed with a positive ([code]+[/code]) or negative ([code]-[/code]) sign. See also [method to_int].
[codeblock]
print(""7"".is_valid_int())    # Prints true
print(""1.65"".is_valid_int()) # Prints false
print(""Hi"".is_valid_int())   # Prints false
print(""+3"".is_valid_int())   # Prints true
print(""-12"".is_valid_int())  # Prints true
[/codeblock] *)

    val is_valid_float :
      BuiltinClass0.StringName.t structure ptr ->
      BuiltinClass0.Bool.t structure ptr
    (** Returns [code]true[/code] if this string represents a valid floating-point number. A valid float may contain only digits, one decimal point ([code].[/code]), and the exponent letter ([code]e[/code]). It may also be prefixed with a positive ([code]+[/code]) or negative ([code]-[/code]) sign. Any valid integer is also a valid float (see [method is_valid_int]). See also [method to_float].
[codeblock]
print(""1.7"".is_valid_float())   # Prints true
print(""24"".is_valid_float())    # Prints true
print(""7e3"".is_valid_float())   # Prints true
print(""Hello"".is_valid_float()) # Prints false
[/codeblock] *)

    val is_valid_hex_number :
      BuiltinClass0.Bool.t structure ptr ->
      BuiltinClass0.StringName.t structure ptr ->
      BuiltinClass0.Bool.t structure ptr
    (** Returns [code]true[/code] if this string is a valid hexadecimal number. A valid hexadecimal number only contains digits or letters [code]A[/code] to [code]F[/code] (either uppercase or lowercase), and may be prefixed with a positive ([code]+[/code]) or negative ([code]-[/code]) sign.
If [param with_prefix] is [code]true[/code], the hexadecimal number needs to prefixed by [code]""0x""[/code] to be considered valid.
[codeblock]
print(""A08E"".is_valid_hex_number())    # Prints true
print(""-AbCdEf"".is_valid_hex_number()) # Prints true
print(""2.5"".is_valid_hex_number())     # Prints false

print(""0xDEADC0DE"".is_valid_hex_number(true)) # Prints true
[/codeblock] *)

    val is_valid_html_color :
      BuiltinClass0.StringName.t structure ptr ->
      BuiltinClass0.Bool.t structure ptr
    (** Returns [code]true[/code] if this string is a valid color in hexadecimal HTML notation. The string must be a hexadecimal value (see [method is_valid_hex_number]) of either 3, 4, 6 or 8 digits, and may be prefixed by a hash sign ([code]#[/code]). Other HTML notations for colors, such as names or [code]hsl()[/code], are not considered valid. See also [method Color.html]. *)

    val is_valid_ip_address :
      BuiltinClass0.StringName.t structure ptr ->
      BuiltinClass0.Bool.t structure ptr
    (** Returns [code]true[/code] if this string represents a well-formatted IPv4 or IPv6 address. This method considers [url=https://en.wikipedia.org/wiki/Reserved_IP_addresses]reserved IP addresses[/url] such as [code]""0.0.0.0""[/code] and [code]""ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff""[/code] as valid. *)

    val is_valid_filename :
      BuiltinClass0.StringName.t structure ptr ->
      BuiltinClass0.Bool.t structure ptr
    (** Returns [code]true[/code] if this string does not contain characters that are not allowed in file names ([code]:[/code] [code]/[/code] [code]\[/code] [code]?[/code] [code] * [/code] [code]""[/code] [code]|[/code] [code]%[/code] [code]<[/code] [code]>[/code]). *)

    val to_int :
      BuiltinClass0.StringName.t structure ptr ->
      BuiltinClass0.Int.t structure ptr
    (** Converts the string representing an integer number into an [int]. This method removes any non-number character and stops at the first decimal point ([code].[/code]). See also [method is_valid_int].
[codeblock]
var a = ""123"".to_int()    # a is 123
var b = ""x1y2z3"".to_int() # b is 123
var c = ""-1.2.3"".to_int() # c is -1
var d = ""Hello!"".to_int() # d is 0
[/codeblock] *)

    val to_float :
      BuiltinClass0.StringName.t structure ptr ->
      BuiltinClass0.Float.t structure ptr
    (** Converts the string representing a decimal number into a [float]. This method stops on the first non-number character, except the first decimal point ([code].[/code]) and the exponent letter ([code]e[/code]). See also [method is_valid_float].
[codeblock]
var a = ""12.35"".to_float() # a is 12.35
var b = ""1.2.3"".to_float() # b is 1.2
var c = ""12xy3"".to_float() # c is 12.0
var d = ""1e3"".to_float()   # d is 1000.0
var e = ""Hello!"".to_int()  # e is 0.0
[/codeblock] *)

    val hex_to_int :
      BuiltinClass0.StringName.t structure ptr ->
      BuiltinClass0.Int.t structure ptr
    (** Converts the string representing a hexadecimal number into an [int]. The string may be optionally prefixed with [code]""0x""[/code], and an additional [code]-[/code] prefix for negative numbers.
[codeblocks]
[gdscript]
print(""0xff"".hex_to_int()) # Prints 255
print(""ab"".hex_to_int())   # Prints 171
[/gdscript]
[csharp]
GD.Print(""0xff"".HexToInt()); // Prints 255
GD.Print(""ab"".HexToInt());   // Prints 171
[/csharp]
[/codeblocks] *)

    val bin_to_int :
      BuiltinClass0.StringName.t structure ptr ->
      BuiltinClass0.Int.t structure ptr
    (** Converts the string representing a binary number into an [int]. The string may optionally be prefixed with [code]""0b""[/code], and an additional [code]-[/code] prefix for negative numbers.
[codeblocks]
[gdscript]
print(""101"".bin_to_int())   # Prints 5
print(""0b101"".bin_to_int()) # Prints 5
print(""-0b10"".bin_to_int()) # Prints -2
[/gdscript]
[csharp]
GD.Print(""101"".BinToInt());   // Prints 5
GD.Print(""0b101"".BinToInt()); // Prints 5
GD.Print(""-0b10"".BinToInt()); // Prints -2
[/csharp]
[/codeblocks] *)

    val lpad :
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.String.t structure ptr ->
      BuiltinClass0.StringName.t structure ptr ->
      BuiltinClass0.String.t structure ptr
    (** Formats the string to be at least [param min_length] long by adding [param character]s to the left of the string, if necessary. See also [method rpad]. *)

    val rpad :
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.String.t structure ptr ->
      BuiltinClass0.StringName.t structure ptr ->
      BuiltinClass0.String.t structure ptr
    (** Formats the string to be at least [param min_length] long, by adding [param character]s to the right of the string, if necessary. See also [method lpad]. *)

    val pad_decimals :
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.StringName.t structure ptr ->
      BuiltinClass0.String.t structure ptr
    (** Formats the string representing a number to have an exact number of [param digits] [i]after[/i] the decimal point. *)

    val pad_zeros :
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.StringName.t structure ptr ->
      BuiltinClass0.String.t structure ptr
    (** Formats the string representing a number to have an exact number of [param digits] [i]before[/i] the decimal point. *)

    val trim_prefix :
      BuiltinClass0.String.t structure ptr ->
      BuiltinClass0.StringName.t structure ptr ->
      BuiltinClass0.String.t structure ptr
    (** Removes the given [param prefix] from the start of the string, or returns the string unchanged. *)

    val trim_suffix :
      BuiltinClass0.String.t structure ptr ->
      BuiltinClass0.StringName.t structure ptr ->
      BuiltinClass0.String.t structure ptr
    (** Removes the given [param suffix] from the end of the string, or returns the string unchanged. *)

    val to_ascii_buffer :
      BuiltinClass0.StringName.t structure ptr ->
      BuiltinClass0.PackedByteArray.t structure ptr
    (** Converts the string to an [url=https://en.wikipedia.org/wiki/ASCII]ASCII[/url]/Latin-1 encoded [PackedByteArray]. This method is slightly faster than [method to_utf8_buffer], but replaces all unsupported characters with spaces. *)

    val to_utf8_buffer :
      BuiltinClass0.StringName.t structure ptr ->
      BuiltinClass0.PackedByteArray.t structure ptr
    (** Converts the string to a [url=https://en.wikipedia.org/wiki/UTF-8]UTF-8[/url] encoded [PackedByteArray]. This method is slightly slower than [method to_ascii_buffer], but supports all UTF-8 characters. For most cases, prefer using this method. *)

    val to_utf16_buffer :
      BuiltinClass0.StringName.t structure ptr ->
      BuiltinClass0.PackedByteArray.t structure ptr
    (** Converts the string to a [url=https://en.wikipedia.org/wiki/UTF-16]UTF-16[/url] encoded [PackedByteArray]. *)

    val to_utf32_buffer :
      BuiltinClass0.StringName.t structure ptr ->
      BuiltinClass0.PackedByteArray.t structure ptr
    (** Converts the string to a [url=https://en.wikipedia.org/wiki/UTF-32]UTF-32[/url] encoded [PackedByteArray]. *)

    val hex_decode :
      BuiltinClass0.StringName.t structure ptr ->
      BuiltinClass0.PackedByteArray.t structure ptr
    (** Decodes a hexadecimal string as a [PackedByteArray].
[codeblocks]
[gdscript]
var text = ""hello world""
var encoded = text.to_utf8_buffer().hex_encode() # outputs ""68656c6c6f20776f726c64""
print(buf.hex_decode().get_string_from_utf8())
[/gdscript]
[csharp]
var text = ""hello world"";
var encoded = text.ToUtf8Buffer().HexEncode(); // outputs ""68656c6c6f20776f726c64""
GD.Print(buf.HexDecode().GetStringFromUtf8());
[/csharp]
[/codeblocks] *)

    val to_wchar_buffer :
      BuiltinClass0.StringName.t structure ptr ->
      BuiltinClass0.PackedByteArray.t structure ptr
    (** Converts the string to a [url=https://en.wikipedia.org/wiki/Wide_character]wide character[/url] ([code]wchar_t[/code], UTF-16 on Windows, UTF-32 on other platforms) encoded [PackedByteArray]. *)

    val hash :
      BuiltinClass0.StringName.t structure ptr ->
      BuiltinClass0.Int.t structure ptr
    (** Returns the 32-bit hash value representing the string's contents.
[b]Note:[/b] Strings with equal hash values are [i]not[/i] guaranteed to be the same, as a result of hash collisions. On the contrary, strings with different hash values are guaranteed to be different. *)

    val not :
      StringName.t structure ptr ->
      StringName.t structure ptr ->
      Bool.t structure ptr ->
      unit

    val _StringName_elem_String :
      StringName.t structure ptr ->
      String.t structure ptr ->
      Bool.t structure ptr ->
      unit

    val ( = ) :
      StringName.t structure ptr ->
      StringName.t structure ptr ->
      Bool.t structure ptr ->
      unit
    (** Returns [code]true[/code] if the [StringName] and [param right] refer to the same name. Comparisons between [StringName]s are much faster than regular [String] comparisons. *)

    val ( <> ) :
      StringName.t structure ptr ->
      StringName.t structure ptr ->
      Bool.t structure ptr ->
      unit
    (** Returns [code]true[/code] if the [StringName] and [param right] do not refer to the same name. Comparisons between [StringName]s are much faster than regular [String] comparisons. *)

    val ( < ) :
      StringName.t structure ptr ->
      StringName.t structure ptr ->
      Bool.t structure ptr ->
      unit
    (** Returns [code]true[/code] if the left [StringName]'s pointer comes before [param right]. Note that this will not match their [url=https://en.wikipedia.org/wiki/List_of_Unicode_characters]Unicode order[/url]. *)

    val ( <= ) :
      StringName.t structure ptr ->
      StringName.t structure ptr ->
      Bool.t structure ptr ->
      unit
    (** Returns [code]true[/code] if the left [StringName]'s pointer comes before [param right] or if they are the same. Note that this will not match their [url=https://en.wikipedia.org/wiki/List_of_Unicode_characters]Unicode order[/url]. *)

    val ( > ) :
      StringName.t structure ptr ->
      StringName.t structure ptr ->
      Bool.t structure ptr ->
      unit
    (** Returns [code]true[/code] if the left [StringName]'s pointer comes after [param right]. Note that this will not match their [url=https://en.wikipedia.org/wiki/List_of_Unicode_characters]Unicode order[/url]. *)

    val ( >= ) :
      StringName.t structure ptr ->
      StringName.t structure ptr ->
      Bool.t structure ptr ->
      unit
    (** Returns [code]true[/code] if the left [StringName]'s pointer comes after [param right] or if they are the same. Note that this will not match their [url=https://en.wikipedia.org/wiki/List_of_Unicode_characters]Unicode order[/url]. *)

    val ( + ) :
      StringName.t structure ptr ->
      StringName.t structure ptr ->
      String.t structure ptr ->
      unit
    (** Appends [param right] at the end of this [StringName], returning a [String]. This is also known as a string concatenation. *)

    val ( % ) :
      StringName.t structure ptr ->
      StringName.t structure ptr ->
      String.t structure ptr ->
      unit

    val _StringName_elem_StringName :
      StringName.t structure ptr ->
      StringName.t structure ptr ->
      Bool.t structure ptr ->
      unit

    val _StringName_elem_Object :
      StringName.t structure ptr ->
      Object.t structure ptr ->
      Bool.t structure ptr ->
      unit

    val _StringName_elem_Dictionary :
      StringName.t structure ptr ->
      Dictionary.t structure ptr ->
      Bool.t structure ptr ->
      unit

    val _StringName_elem_Array :
      StringName.t structure ptr ->
      Array.t structure ptr ->
      Bool.t structure ptr ->
      unit

    val _StringName_elem_PackedStringArray :
      StringName.t structure ptr ->
      PackedStringArray.t structure ptr ->
      Bool.t structure ptr ->
      unit
  end

  module type NODEPATH = sig
    type t

    include Api_types.API_TYPE with type t := t

    val is_absolute :
      BuiltinClass0.NodePath.t structure ptr ->
      BuiltinClass0.Bool.t structure ptr
    (** Returns [code]true[/code] if the node path is absolute (as opposed to relative), which means that it starts with a slash character ([code]/[/code]). Absolute node paths can be used to access the root node ([code]""/root""[/code]) or autoloads (e.g. [code]""/global""[/code] if a ""global"" autoload was registered). *)

    val get_name_count :
      BuiltinClass0.NodePath.t structure ptr ->
      BuiltinClass0.Int.t structure ptr
    (** Gets the number of node names which make up the path. Subnames (see [method get_subname_count]) are not included.
For example, [code]""Path2D/PathFollow2D/Sprite2D""[/code] has 3 names. *)

    val get_name :
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.NodePath.t structure ptr ->
      BuiltinClass0.StringName.t structure ptr
    (** Gets the node name indicated by [param idx] (0 to [method get_name_count] - 1).
[codeblocks]
[gdscript]
var node_path = NodePath(""Path2D/PathFollow2D/Sprite2D"")
print(node_path.get_name(0)) # Path2D
print(node_path.get_name(1)) # PathFollow2D
print(node_path.get_name(2)) # Sprite
[/gdscript]
[csharp]
var nodePath = new NodePath(""Path2D/PathFollow2D/Sprite2D"");
GD.Print(nodePath.GetName(0)); // Path2D
GD.Print(nodePath.GetName(1)); // PathFollow2D
GD.Print(nodePath.GetName(2)); // Sprite
[/csharp]
[/codeblocks] *)

    val get_subname_count :
      BuiltinClass0.NodePath.t structure ptr ->
      BuiltinClass0.Int.t structure ptr
    (** Gets the number of resource or property names (""subnames"") in the path. Each subname is listed after a colon character ([code]:[/code]) in the node path.
For example, [code]""Path2D/PathFollow2D/Sprite2D:texture:load_path""[/code] has 2 subnames. *)

    val hash :
      BuiltinClass0.NodePath.t structure ptr ->
      BuiltinClass0.Int.t structure ptr
    (** Returns the 32-bit hash value representing the [NodePath]'s contents. *)

    val get_subname :
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.NodePath.t structure ptr ->
      BuiltinClass0.StringName.t structure ptr
    (** Gets the resource or property name indicated by [param idx] (0 to [method get_subname_count] - 1).
[codeblocks]
[gdscript]
var node_path = NodePath(""Path2D/PathFollow2D/Sprite2D:texture:load_path"")
print(node_path.get_subname(0)) # texture
print(node_path.get_subname(1)) # load_path
[/gdscript]
[csharp]
var nodePath = new NodePath(""Path2D/PathFollow2D/Sprite2D:texture:load_path"");
GD.Print(nodePath.GetSubname(0)); // texture
GD.Print(nodePath.GetSubname(1)); // load_path
[/csharp]
[/codeblocks] *)

    val get_concatenated_names :
      BuiltinClass0.NodePath.t structure ptr ->
      BuiltinClass0.StringName.t structure ptr
    (** Returns all paths concatenated with a slash character ([code]/[/code]) as separator without subnames. *)

    val get_concatenated_subnames :
      BuiltinClass0.NodePath.t structure ptr ->
      BuiltinClass0.StringName.t structure ptr
    (** Returns all subnames concatenated with a colon character ([code]:[/code]) as separator, i.e. the right side of the first colon in a node path.
[codeblocks]
[gdscript]
var node_path = NodePath(""Path2D/PathFollow2D/Sprite2D:texture:load_path"")
print(node_path.get_concatenated_subnames()) # texture:load_path
[/gdscript]
[csharp]
var nodePath = new NodePath(""Path2D/PathFollow2D/Sprite2D:texture:load_path"");
GD.Print(nodePath.GetConcatenatedSubnames()); // texture:load_path
[/csharp]
[/codeblocks] *)

    val get_as_property_path :
      BuiltinClass0.NodePath.t structure ptr ->
      BuiltinClass0.NodePath.t structure ptr
    (** Returns a node path with a colon character ([code]:[/code]) prepended, transforming it to a pure property path with no node name (defaults to resolving from the current node).
[codeblocks]
[gdscript]
# This will be parsed as a node path to the ""x"" property in the ""position"" node.
var node_path = NodePath(""position:x"")
# This will be parsed as a node path to the ""x"" component of the ""position"" property in the current node.
var property_path = node_path.get_as_property_path()
print(property_path) # :position:x
[/gdscript]
[csharp]
// This will be parsed as a node path to the ""x"" property in the ""position"" node.
var nodePath = new NodePath(""position:x"");
// This will be parsed as a node path to the ""x"" component of the ""position"" property in the current node.
NodePath propertyPath = nodePath.GetAsPropertyPath();
GD.Print(propertyPath); // :position:x
[/csharp]
[/codeblocks] *)

    val is_empty :
      BuiltinClass0.NodePath.t structure ptr ->
      BuiltinClass0.Bool.t structure ptr
    (** Returns [code]true[/code] if the node path is empty. *)

    val not :
      NodePath.t structure ptr ->
      NodePath.t structure ptr ->
      Bool.t structure ptr ->
      unit

    val ( = ) :
      NodePath.t structure ptr ->
      NodePath.t structure ptr ->
      Bool.t structure ptr ->
      unit
    (** Returns [code]true[/code] if two node paths are equal, i.e. all node names in the path are the same and in the same order. *)

    val ( <> ) :
      NodePath.t structure ptr ->
      NodePath.t structure ptr ->
      Bool.t structure ptr ->
      unit
    (** Returns [code]true[/code] if two node paths are not equal. *)

    val _NodePath_elem_Dictionary :
      NodePath.t structure ptr ->
      Dictionary.t structure ptr ->
      Bool.t structure ptr ->
      unit

    val _NodePath_elem_Array :
      NodePath.t structure ptr ->
      Array.t structure ptr ->
      Bool.t structure ptr ->
      unit
  end

  module type RID = sig
    type t

    include Api_types.API_TYPE with type t := t

    val is_valid :
      BuiltinClass0.RID.t structure ptr -> BuiltinClass0.Bool.t structure ptr
    (** Returns [code]true[/code] if the [RID] is not [code]0[/code]. *)

    val get_id :
      BuiltinClass0.RID.t structure ptr -> BuiltinClass0.Int.t structure ptr
    (** Returns the ID of the referenced low-level resource. *)

    val not :
      RID.t structure ptr -> RID.t structure ptr -> Bool.t structure ptr -> unit

    val ( = ) :
      RID.t structure ptr -> RID.t structure ptr -> Bool.t structure ptr -> unit
    (** Returns [code]true[/code] if both [RID]s are equal, which means they both refer to the same low-level resource. *)

    val ( <> ) :
      RID.t structure ptr -> RID.t structure ptr -> Bool.t structure ptr -> unit
    (** Returns [code]true[/code] if the [RID]s are not equal. *)

    val ( < ) :
      RID.t structure ptr -> RID.t structure ptr -> Bool.t structure ptr -> unit
    (** Returns [code]true[/code] if the [RID]'s ID is less than [param right]'s ID. *)

    val ( <= ) :
      RID.t structure ptr -> RID.t structure ptr -> Bool.t structure ptr -> unit
    (** Returns [code]true[/code] if the [RID]'s ID is less than or equal to [param right]'s ID. *)

    val ( > ) :
      RID.t structure ptr -> RID.t structure ptr -> Bool.t structure ptr -> unit
    (** Returns [code]true[/code] if the [RID]'s ID is greater than [param right]'s ID. *)

    val ( >= ) :
      RID.t structure ptr -> RID.t structure ptr -> Bool.t structure ptr -> unit
    (** Returns [code]true[/code] if the [RID]'s ID is greater than or equal to [param right]'s ID. *)
  end

  module type CALLABLE = sig
    type t

    include Api_types.API_TYPE with type t := t

    val callv :
      BuiltinClass0.Array.t structure ptr ->
      BuiltinClass0.Callable.t structure ptr ->
      BuiltinClass0.Variant.t structure ptr
    (** Calls the method represented by this [Callable]. Unlike [method call], this method expects all arguments to be contained inside the [param arguments] [Array]. *)

    val is_null :
      BuiltinClass0.Callable.t structure ptr ->
      BuiltinClass0.Bool.t structure ptr
    (** Returns [code]true[/code] if this [Callable] has no target to call the method on. *)

    val is_custom :
      BuiltinClass0.Callable.t structure ptr ->
      BuiltinClass0.Bool.t structure ptr
    (** Returns [code]true[/code] if this [Callable] is a custom callable. Custom callables are created from [method bind] or [method unbind]. In GDScript, lambda functions are also custom callables. *)

    val is_standard :
      BuiltinClass0.Callable.t structure ptr ->
      BuiltinClass0.Bool.t structure ptr
    (** Returns [code]true[/code] if this [Callable] is a standard callable. This method is the opposite of [method is_custom]. Returns [code]false[/code] if this callable is a lambda function. *)

    val is_valid :
      BuiltinClass0.Callable.t structure ptr ->
      BuiltinClass0.Bool.t structure ptr
    (** Returns [code]true[/code] if the callable's object exists and has a valid method name assigned, or is a custom callable. *)

    val get_object :
      BuiltinClass0.Callable.t structure ptr ->
      BuiltinClass0.Object.t structure ptr
    (** Returns the object on which this [Callable] is called. *)

    val get_object_id :
      BuiltinClass0.Callable.t structure ptr ->
      BuiltinClass0.Int.t structure ptr
    (** Returns the ID of this [Callable]'s object (see [method Object.get_instance_id]). *)

    val get_method :
      BuiltinClass0.Callable.t structure ptr ->
      BuiltinClass0.StringName.t structure ptr
    (** Returns the name of the method represented by this [Callable]. If the callable is a GDScript lambda function, returns the function's name or [code]""<anonymous lambda>""[/code]. *)

    val get_bound_arguments_count :
      BuiltinClass0.Callable.t structure ptr ->
      BuiltinClass0.Int.t structure ptr
    (** Returns the total amount of arguments bound (or unbound) via successive [method bind] or [method unbind] calls. If the amount of arguments unbound is greater than the ones bound, this function returns a value less than zero. *)

    val get_bound_arguments :
      BuiltinClass0.Callable.t structure ptr ->
      BuiltinClass0.Array.t structure ptr
    (** Return the bound arguments (as long as [method get_bound_arguments_count] is greater than zero), or empty (if [method get_bound_arguments_count] is less than or equal to zero). *)

    val hash :
      BuiltinClass0.Callable.t structure ptr ->
      BuiltinClass0.Int.t structure ptr
    (** Returns the 32-bit hash value of this [Callable]'s object.
[b]Note:[/b] [Callable]s with equal content will always produce identical hash values. However, the reverse is not true. Returning identical hash values does [i]not[/i] imply the callables are equal, because different callables can have identical hash values due to hash collisions. The engine uses a 32-bit hash algorithm for [method hash]. *)

    val bindv :
      BuiltinClass0.Array.t structure ptr ->
      BuiltinClass0.Callable.t structure ptr ->
      BuiltinClass0.Callable.t structure ptr
    (** Returns a copy of this [Callable] with one or more arguments bound, reading them from an array. When called, the bound arguments are passed [i]after[/i] the arguments supplied by [method call]. See also [method unbind].
[b]Note:[/b] When this method is chained with other similar methods, the order in which the argument list is modified is read from right to left. *)

    val unbind :
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.Callable.t structure ptr ->
      BuiltinClass0.Callable.t structure ptr
    (** Returns a copy of this [Callable] with a number of arguments unbound. In other words, when the new callable is called the last few arguments supplied by the user are ignored, according to [param argcount]. The remaining arguments are passed to the callable. This allows to use the original callable in a context that attempts to pass more arguments than this callable can handle, e.g. a signal with a fixed number of arguments. See also [method bind].
[b]Note:[/b] When this method is chained with other similar methods, the order in which the argument list is modified is read from right to left.
[codeblock]
func _ready():
    foo.unbind(1).call(1, 2) # Calls foo(1).
    foo.bind(3, 4).unbind(1).call(1, 2) # Calls foo(1, 3, 4), note that it does not change the arguments from bind.
[/codeblock] *)

    val call :
      Variadic.t structure ptr ->
      BuiltinClass0.Callable.t structure ptr ->
      BuiltinClass0.Variant.t structure ptr
    (** Calls the method represented by this [Callable]. Arguments can be passed and should match the method's signature. *)

    val call_deferred :
      Variadic.t structure ptr -> BuiltinClass0.Callable.t structure ptr -> unit
    (** Calls the method represented by this [Callable] in deferred mode, i.e. at the end of the current frame. Arguments can be passed and should match the method's signature.
[codeblock]
func _ready():
    grab_focus.call_deferred()
[/codeblock]
[b]Note:[/b] Deferred calls are processed at idle time. Idle time happens mainly at the end of process and physics frames. In it, deferred calls will be run until there are none left, which means you can defer calls from other deferred calls and they'll still be run in the current idle time cycle. This means you should not call a method deferred from itself (or from a method called by it), as this causes infinite recursion the same way as if you had called the method directly.
See also [method Object.call_deferred]. *)

    val rpc :
      Variadic.t structure ptr -> BuiltinClass0.Callable.t structure ptr -> unit
    (** Perform an RPC (Remote Procedure Call) on all connected peers. This is used for multiplayer and is normally not available, unless the function being called has been marked as [i]RPC[/i] (using [annotation @GDScript.@rpc] or [method Node.rpc_config]). Calling this method on unsupported functions will result in an error. See [method Node.rpc]. *)

    val rpc_id :
      BuiltinClass0.Int.t structure ptr ->
      Variadic.t structure ptr ->
      BuiltinClass0.Callable.t structure ptr ->
      unit
    (** Perform an RPC (Remote Procedure Call) on a specific peer ID (see multiplayer documentation for reference). This is used for multiplayer and is normally not available unless the function being called has been marked as [i]RPC[/i] (using [annotation @GDScript.@rpc] or [method Node.rpc_config]). Calling this method on unsupported functions will result in an error. See [method Node.rpc_id]. *)

    val bind :
      Variadic.t structure ptr ->
      BuiltinClass0.Callable.t structure ptr ->
      BuiltinClass0.Callable.t structure ptr
    (** Returns a copy of this [Callable] with one or more arguments bound. When called, the bound arguments are passed [i]after[/i] the arguments supplied by [method call]. See also [method unbind].
[b]Note:[/b] When this method is chained with other similar methods, the order in which the argument list is modified is read from right to left. *)

    val not :
      Callable.t structure ptr ->
      Callable.t structure ptr ->
      Bool.t structure ptr ->
      unit

    val ( = ) :
      Callable.t structure ptr ->
      Callable.t structure ptr ->
      Bool.t structure ptr ->
      unit
    (** Returns [code]true[/code] if both [Callable]s invoke the same custom target. *)

    val ( <> ) :
      Callable.t structure ptr ->
      Callable.t structure ptr ->
      Bool.t structure ptr ->
      unit
    (** Returns [code]true[/code] if both [Callable]s invoke different targets. *)

    val _Callable_elem_Dictionary :
      Callable.t structure ptr ->
      Dictionary.t structure ptr ->
      Bool.t structure ptr ->
      unit

    val _Callable_elem_Array :
      Callable.t structure ptr ->
      Array.t structure ptr ->
      Bool.t structure ptr ->
      unit
  end

  module type SIGNAL = sig
    type t

    include Api_types.API_TYPE with type t := t

    val is_null :
      BuiltinClass0.Signal.t structure ptr -> BuiltinClass0.Bool.t structure ptr
    (** Returns [code]true[/code] if the signal's name does not exist in its object, or the object is not valid. *)

    val get_object :
      BuiltinClass0.Signal.t structure ptr ->
      BuiltinClass0.Object.t structure ptr
    (** Returns the object emitting this signal. *)

    val get_object_id :
      BuiltinClass0.Signal.t structure ptr -> BuiltinClass0.Int.t structure ptr
    (** Returns the ID of the object emitting this signal (see [method Object.get_instance_id]). *)

    val get_name :
      BuiltinClass0.Signal.t structure ptr ->
      BuiltinClass0.StringName.t structure ptr
    (** Returns the name of this signal. *)

    val connect :
      BuiltinClass0.Callable.t structure ptr ->
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.Signal.t structure ptr ->
      BuiltinClass0.Int.t structure ptr
    (** Connects this signal to the specified [param callable]. Optional [param flags] can be also added to configure the connection's behavior (see [enum Object.ConnectFlags] constants). You can provide additional arguments to the connected [param callable] by using [method Callable.bind].
A signal can only be connected once to the same [Callable]. If the signal is already connected, returns [constant ERR_INVALID_PARAMETER] and pushes an error message, unless the signal is connected with [constant Object.CONNECT_REFERENCE_COUNTED]. To prevent this, use [method is_connected] first to check for existing connections.
[codeblock]
for button in $Buttons.get_children():
    button.pressed.connect(_on_pressed.bind(button))

func _on_pressed(button):
    print(button.name, "" was pressed"")
[/codeblock] *)

    val disconnect :
      BuiltinClass0.Callable.t structure ptr ->
      BuiltinClass0.Signal.t structure ptr ->
      unit
    (** Disconnects this signal from the specified [Callable]. If the connection does not exist, generates an error. Use [method is_connected] to make sure that the connection exists. *)

    val is_connected :
      BuiltinClass0.Callable.t structure ptr ->
      BuiltinClass0.Signal.t structure ptr ->
      BuiltinClass0.Bool.t structure ptr
    (** Returns [code]true[/code] if the specified [Callable] is connected to this signal. *)

    val get_connections :
      BuiltinClass0.Signal.t structure ptr ->
      BuiltinClass0.Array.t structure ptr
    (** Returns an [Array] of connections for this signal. Each connection is represented as a [Dictionary] that contains three entries:
- [code]signal[/code] is a reference to this signal;
- [code]callable[/code] is a reference to the connected [Callable];
- [code]flags[/code] is a combination of [enum Object.ConnectFlags]. *)

    val emit :
      Variadic.t structure ptr -> BuiltinClass0.Signal.t structure ptr -> unit
    (** Emits this signal. All [Callable]s connected to this signal will be triggered. This method supports a variable number of arguments, so parameters can be passed as a comma separated list. *)

    val not :
      Signal.t structure ptr ->
      Signal.t structure ptr ->
      Bool.t structure ptr ->
      unit

    val ( = ) :
      Signal.t structure ptr ->
      Signal.t structure ptr ->
      Bool.t structure ptr ->
      unit
    (** Returns [code]true[/code] if both signals share the same object and name. *)

    val ( <> ) :
      Signal.t structure ptr ->
      Signal.t structure ptr ->
      Bool.t structure ptr ->
      unit
    (** Returns [code]true[/code] if the signals do not share the same object and name. *)

    val _Signal_elem_Dictionary :
      Signal.t structure ptr ->
      Dictionary.t structure ptr ->
      Bool.t structure ptr ->
      unit

    val _Signal_elem_Array :
      Signal.t structure ptr ->
      Array.t structure ptr ->
      Bool.t structure ptr ->
      unit
  end

  module type DICTIONARY = sig
    type t

    include Api_types.API_TYPE with type t := t

    val size :
      BuiltinClass0.Dictionary.t structure ptr ->
      BuiltinClass0.Int.t structure ptr
    (** Returns the number of entries in the dictionary. Empty dictionaries ([code]{ }[/code]) always return [code]0[/code]. See also [method is_empty]. *)

    val is_empty :
      BuiltinClass0.Dictionary.t structure ptr ->
      BuiltinClass0.Bool.t structure ptr
    (** Returns [code]true[/code] if the dictionary is empty (its size is [code]0[/code]). See also [method size]. *)

    val clear : BuiltinClass0.Dictionary.t structure ptr -> unit
    (** Clears the dictionary, removing all entries from it. *)

    val merge :
      BuiltinClass0.Dictionary.t structure ptr ->
      BuiltinClass0.Bool.t structure ptr ->
      BuiltinClass0.Dictionary.t structure ptr ->
      unit
    (** Adds entries from [param dictionary] to this dictionary. By default, duplicate keys are not copied over, unless [param overwrite] is [code]true[/code].
[codeblocks]
[gdscript]
var dict = { ""item"": ""sword"", ""quantity"": 2 }
var other_dict = { ""quantity"": 15, ""color"": ""silver"" }

# Overwriting of existing keys is disabled by default.
dict.merge(other_dict)
print(dict)  # { ""item"": ""sword"", ""quantity"": 2, ""color"": ""silver"" }

# With overwriting of existing keys enabled.
dict.merge(other_dict, true)
print(dict)  # { ""item"": ""sword"", ""quantity"": 15, ""color"": ""silver"" }
[/gdscript]
[csharp]
var dict = new Godot.Collections.Dictionary
{
    [""item""] = ""sword"",
    [""quantity""] = 2,
};

var otherDict = new Godot.Collections.Dictionary
{
    [""quantity""] = 15,
    [""color""] = ""silver"",
};

// Overwriting of existing keys is disabled by default.
dict.Merge(otherDict);
GD.Print(dict); // { ""item"": ""sword"", ""quantity"": 2, ""color"": ""silver"" }

// With overwriting of existing keys enabled.
dict.Merge(otherDict, true);
GD.Print(dict); // { ""item"": ""sword"", ""quantity"": 15, ""color"": ""silver"" }
[/csharp]
[/codeblocks]
[b]Note:[/b] [method merge] is [i]not[/i] recursive. Nested dictionaries are considered as keys that can be overwritten or not depending on the value of [param overwrite], but they will never be merged together. *)

    val has :
      BuiltinClass0.Variant.t structure ptr ->
      BuiltinClass0.Dictionary.t structure ptr ->
      BuiltinClass0.Bool.t structure ptr
    (** Returns [code]true[/code] if the dictionary contains an entry with the given [param key].
[codeblocks]
[gdscript]
var my_dict = {
    ""Godot"" : 4,
    210 : null,
}

print(my_dict.has(""Godot"")) # Prints true
print(my_dict.has(210))     # Prints true
print(my_dict.has(4))       # Prints false
[/gdscript]
[csharp]
var myDict = new Godot.Collections.Dictionary
{
    { ""Godot"", 4 },
    { 210, default },
};

GD.Print(myDict.ContainsKey(""Godot"")); // Prints true
GD.Print(myDict.ContainsKey(210));     // Prints true
GD.Print(myDict.ContainsKey(4));       // Prints false
[/csharp]
[/codeblocks]
In GDScript, this is equivalent to the [code]in[/code] operator:
[codeblock]
if ""Godot"" in {""Godot"": 4}:
    print(""The key is here!"") # Will be printed.
[/codeblock]
[b]Note:[/b] This method returns [code]true[/code] as long as the [param key] exists, even if its corresponding value is [code]null[/code]. *)

    val has_all :
      BuiltinClass0.Array.t structure ptr ->
      BuiltinClass0.Dictionary.t structure ptr ->
      BuiltinClass0.Bool.t structure ptr
    (** Returns [code]true[/code] if the dictionary contains all keys in the given [param keys] array.
[codeblock]
var data = {""width"" : 10, ""height"" : 20}
data.has_all([""height"", ""width""]) # Returns true
[/codeblock] *)

    val find_key :
      BuiltinClass0.Variant.t structure ptr ->
      BuiltinClass0.Dictionary.t structure ptr ->
      BuiltinClass0.Variant.t structure ptr
    (** Finds and returns the first key whose associated value is equal to [param value], or [code]null[/code] if it is not found.
[b]Note:[/b] [code]null[/code] is also a valid key. If inside the dictionary, [method find_key] may give misleading results. *)

    val erase :
      BuiltinClass0.Variant.t structure ptr ->
      BuiltinClass0.Dictionary.t structure ptr ->
      BuiltinClass0.Bool.t structure ptr
    (** Removes the dictionary entry by key, if it exists. Returns [code]true[/code] if the given [param key] existed in the dictionary, otherwise [code]false[/code].
[b]Note:[/b] Do not erase entries while iterating over the dictionary. You can iterate over the [method keys] array instead. *)

    val hash :
      BuiltinClass0.Dictionary.t structure ptr ->
      BuiltinClass0.Int.t structure ptr
    (** Returns a hashed 32-bit integer value representing the dictionary contents.
[codeblocks]
[gdscript]
var dict1 = {""A"": 10, ""B"": 2}
var dict2 = {""A"": 10, ""B"": 2}

print(dict1.hash() == dict2.hash()) # Prints true
[/gdscript]
[csharp]
var dict1 = new Godot.Collections.Dictionary{{""A"", 10}, {""B"", 2}};
var dict2 = new Godot.Collections.Dictionary{{""A"", 10}, {""B"", 2}};

// Godot.Collections.Dictionary has no Hash() method. Use GD.Hash() instead.
GD.Print(GD.Hash(dict1) == GD.Hash(dict2)); // Prints true
[/csharp]
[/codeblocks]
[b]Note:[/b] Dictionaries with the same entries but in a different order will not have the same hash.
[b]Note:[/b] Dictionaries with equal hash values are [i]not[/i] guaranteed to be the same, because of hash collisions. On the contrary, dictionaries with different hash values are guaranteed to be different. *)

    val keys :
      BuiltinClass0.Dictionary.t structure ptr ->
      BuiltinClass0.Array.t structure ptr
    (** Returns the list of keys in the dictionary. *)

    val values :
      BuiltinClass0.Dictionary.t structure ptr ->
      BuiltinClass0.Array.t structure ptr
    (** Returns the list of values in this dictionary. *)

    val duplicate :
      BuiltinClass0.Bool.t structure ptr ->
      BuiltinClass0.Dictionary.t structure ptr ->
      BuiltinClass0.Dictionary.t structure ptr
    (** Creates and returns a new copy of the dictionary. If [param deep] is [code]true[/code], inner [Dictionary] and [Array] keys and values are also copied, recursively. *)

    val get :
      BuiltinClass0.Variant.t structure ptr ->
      BuiltinClass0.Variant.t structure ptr ->
      BuiltinClass0.Dictionary.t structure ptr ->
      BuiltinClass0.Variant.t structure ptr
    (** Returns the corresponding value for the given [param key] in the dictionary. If the [param key] does not exist, returns [param default], or [code]null[/code] if the parameter is omitted. *)

    val make_read_only : BuiltinClass0.Dictionary.t structure ptr -> unit
    (** Makes the dictionary read-only, i.e. disables modification of the dictionary's contents. Does not apply to nested content, e.g. content of nested dictionaries. *)

    val is_read_only :
      BuiltinClass0.Dictionary.t structure ptr ->
      BuiltinClass0.Bool.t structure ptr
    (** Returns [code]true[/code] if the dictionary is read-only. See [method make_read_only]. Dictionaries are automatically read-only if declared with [code]const[/code] keyword. *)

    val not :
      Dictionary.t structure ptr ->
      Dictionary.t structure ptr ->
      Bool.t structure ptr ->
      unit

    val ( = ) :
      Dictionary.t structure ptr ->
      Dictionary.t structure ptr ->
      Bool.t structure ptr ->
      unit
    (** Returns [code]true[/code] if the two dictionaries contain the same keys and values. The order of the entries does not matter.
[b]Note:[/b] In C#, by convention, this operator compares by [b]reference[/b]. If you need to compare by value, iterate over both dictionaries. *)

    val ( <> ) :
      Dictionary.t structure ptr ->
      Dictionary.t structure ptr ->
      Bool.t structure ptr ->
      unit
    (** Returns [code]true[/code] if the two dictionaries do not contain the same keys and values. *)

    val _Dictionary_elem_Dictionary :
      Dictionary.t structure ptr ->
      Dictionary.t structure ptr ->
      Bool.t structure ptr ->
      unit

    val _Dictionary_elem_Array :
      Dictionary.t structure ptr ->
      Array.t structure ptr ->
      Bool.t structure ptr ->
      unit
  end

  module type ARRAY = sig
    type t

    include Api_types.API_TYPE with type t := t

    val size :
      BuiltinClass0.Array.t structure ptr -> BuiltinClass0.Int.t structure ptr
    (** Returns the number of elements in the array. *)

    val is_empty :
      BuiltinClass0.Array.t structure ptr -> BuiltinClass0.Bool.t structure ptr
    (** Returns [code]true[/code] if the array is empty. *)

    val clear : BuiltinClass0.Array.t structure ptr -> unit
    (** Clears the array. This is equivalent to using [method resize] with a size of [code]0[/code]. *)

    val hash :
      BuiltinClass0.Array.t structure ptr -> BuiltinClass0.Int.t structure ptr
    (** Returns a hashed 32-bit integer value representing the array and its contents.
[b]Note:[/b] [Array]s with equal content will always produce identical hash values. However, the reverse is not true. Returning identical hash values does [i]not[/i] imply the arrays are equal, because different arrays can have identical hash values due to hash collisions. *)

    val assign :
      BuiltinClass0.Array.t structure ptr ->
      BuiltinClass0.Array.t structure ptr ->
      unit
    (** Assigns elements of another [param array] into the array. Resizes the array to match [param array]. Performs type conversions if the array is typed. *)

    val push_back :
      BuiltinClass0.Variant.t structure ptr ->
      BuiltinClass0.Array.t structure ptr ->
      unit
    (** Appends an element at the end of the array. See also [method push_front]. *)

    val push_front :
      BuiltinClass0.Variant.t structure ptr ->
      BuiltinClass0.Array.t structure ptr ->
      unit
    (** Adds an element at the beginning of the array. See also [method push_back].
[b]Note:[/b] On large arrays, this method is much slower than [method push_back] as it will reindex all the array's elements every time it's called. The larger the array, the slower [method push_front] will be. *)

    val append :
      BuiltinClass0.Variant.t structure ptr ->
      BuiltinClass0.Array.t structure ptr ->
      unit
    (** Appends an element at the end of the array (alias of [method push_back]). *)

    val append_array :
      BuiltinClass0.Array.t structure ptr ->
      BuiltinClass0.Array.t structure ptr ->
      unit
    (** Appends another array at the end of this array.
[codeblock]
var array1 = [1, 2, 3]
var array2 = [4, 5, 6]
array1.append_array(array2)
print(array1) # Prints [1, 2, 3, 4, 5, 6].
[/codeblock] *)

    val resize :
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.Array.t structure ptr ->
      BuiltinClass0.Int.t structure ptr
    (** Resizes the array to contain a different number of elements. If the array size is smaller, elements are cleared, if bigger, new elements are [code]null[/code]. Returns [constant OK] on success, or one of the other [enum Error] values if the operation failed.
Calling [method resize] once and assigning the new values is faster than adding new elements one by one.
[b]Note:[/b] This method acts in-place and doesn't return a modified array. *)

    val insert :
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.Variant.t structure ptr ->
      BuiltinClass0.Array.t structure ptr ->
      BuiltinClass0.Int.t structure ptr
    (** Inserts a new element at a given position in the array. The position must be valid, or at the end of the array ([code]pos == size()[/code]). Returns [constant OK] on success, or one of the other [enum Error] values if the operation failed.
[b]Note:[/b] This method acts in-place and doesn't return a modified array.
[b]Note:[/b] On large arrays, this method will be slower if the inserted element is close to the beginning of the array (index 0). This is because all elements placed after the newly inserted element have to be reindexed. *)

    val remove_at :
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.Array.t structure ptr ->
      unit
    (** Removes an element from the array by index. If the index does not exist in the array, nothing happens. To remove an element by searching for its value, use [method erase] instead.
[b]Note:[/b] This method acts in-place and doesn't return a modified array.
[b]Note:[/b] On large arrays, this method will be slower if the removed element is close to the beginning of the array (index 0). This is because all elements placed after the removed element have to be reindexed.
[b]Note:[/b] [param position] cannot be negative. To remove an element relative to the end of the array, use [code]arr.remove_at(arr.size() - (i + 1))[/code]. To remove the last element from the array without returning the value, use [code]arr.resize(arr.size() - 1)[/code]. *)

    val fill :
      BuiltinClass0.Variant.t structure ptr ->
      BuiltinClass0.Array.t structure ptr ->
      unit
    (** Assigns the given value to all elements in the array. This can typically be used together with [method resize] to create an array with a given size and initialized elements:
[codeblocks]
[gdscript]
var array = []
array.resize(10)
array.fill(0) # Initialize the 10 elements to 0.
[/gdscript]
[csharp]
var array = new Godot.Collections.Array();
array.Resize(10);
array.Fill(0); // Initialize the 10 elements to 0.
[/csharp]
[/codeblocks]
[b]Note:[/b] If [param value] is of a reference type ([Object]-derived, [Array], [Dictionary], etc.) then the array is filled with the references to the same object, i.e. no duplicates are created. *)

    val erase :
      BuiltinClass0.Variant.t structure ptr ->
      BuiltinClass0.Array.t structure ptr ->
      unit
    (** Removes the first occurrence of a value from the array. If the value does not exist in the array, nothing happens. To remove an element by index, use [method remove_at] instead.
[b]Note:[/b] This method acts in-place and doesn't return a modified array.
[b]Note:[/b] On large arrays, this method will be slower if the removed element is close to the beginning of the array (index 0). This is because all elements placed after the removed element have to be reindexed.
[b]Note:[/b] Do not erase entries while iterating over the array. *)

    val front :
      BuiltinClass0.Array.t structure ptr ->
      BuiltinClass0.Variant.t structure ptr
    (** Returns the first element of the array. Prints an error and returns [code]null[/code] if the array is empty.
[b]Note:[/b] Calling this function is not the same as writing [code]array[0][/code]. If the array is empty, accessing by index will pause project execution when running from the editor. *)

    val back :
      BuiltinClass0.Array.t structure ptr ->
      BuiltinClass0.Variant.t structure ptr
    (** Returns the last element of the array. Prints an error and returns [code]null[/code] if the array is empty.
[b]Note:[/b] Calling this function is not the same as writing [code]array[-1][/code]. If the array is empty, accessing by index will pause project execution when running from the editor. *)

    val pick_random :
      BuiltinClass0.Array.t structure ptr ->
      BuiltinClass0.Variant.t structure ptr
    (** Returns a random value from the target array. Prints an error and returns [code]null[/code] if the array is empty.
[codeblocks]
[gdscript]
var array: Array[int] = [1, 2, 3, 4]
print(array.pick_random())  # Prints either of the four numbers.
[/gdscript]
[csharp]
var array = new Godot.Collections.Array { 1, 2, 3, 4 };
GD.Print(array.PickRandom()); // Prints either of the four numbers.
[/csharp]
[/codeblocks] *)

    val find :
      BuiltinClass0.Variant.t structure ptr ->
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.Array.t structure ptr ->
      BuiltinClass0.Int.t structure ptr
    (** Searches the array for a value and returns its index or [code]-1[/code] if not found. Optionally, the initial search index can be passed. *)

    val rfind :
      BuiltinClass0.Variant.t structure ptr ->
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.Array.t structure ptr ->
      BuiltinClass0.Int.t structure ptr
    (** Searches the array in reverse order. Optionally, a start search index can be passed. If negative, the start index is considered relative to the end of the array. *)

    val count :
      BuiltinClass0.Variant.t structure ptr ->
      BuiltinClass0.Array.t structure ptr ->
      BuiltinClass0.Int.t structure ptr
    (** Returns the number of times an element is in the array. *)

    val has :
      BuiltinClass0.Variant.t structure ptr ->
      BuiltinClass0.Array.t structure ptr ->
      BuiltinClass0.Bool.t structure ptr
    (** Returns [code]true[/code] if the array contains the given value.
[codeblocks]
[gdscript]
print([""inside"", 7].has(""inside"")) # True
print([""inside"", 7].has(""outside"")) # False
print([""inside"", 7].has(7)) # True
print([""inside"", 7].has(""7"")) # False
[/gdscript]
[csharp]
var arr = new Godot.Collections.Array { ""inside"", 7 };
// has is renamed to Contains
GD.Print(arr.Contains(""inside"")); // True
GD.Print(arr.Contains(""outside"")); // False
GD.Print(arr.Contains(7)); // True
GD.Print(arr.Contains(""7"")); // False
[/csharp]
[/codeblocks]
[b]Note:[/b] This is equivalent to using the [code]in[/code] operator as follows:
[codeblocks]
[gdscript]
# Will evaluate to `true`.
if 2 in [2, 4, 6, 8]:
    print(""Contains!"")
[/gdscript]
[csharp]
// As there is no ""in"" keyword in C#, you have to use Contains
var array = new Godot.Collections.Array { 2, 4, 6, 8 };
if (array.Contains(2))
{
    GD.Print(""Contains!"");
}
[/csharp]
[/codeblocks] *)

    val pop_back :
      BuiltinClass0.Array.t structure ptr ->
      BuiltinClass0.Variant.t structure ptr
    (** Removes and returns the last element of the array. Returns [code]null[/code] if the array is empty, without printing an error message. See also [method pop_front]. *)

    val pop_front :
      BuiltinClass0.Array.t structure ptr ->
      BuiltinClass0.Variant.t structure ptr
    (** Removes and returns the first element of the array. Returns [code]null[/code] if the array is empty, without printing an error message. See also [method pop_back].
[b]Note:[/b] On large arrays, this method is much slower than [method pop_back] as it will reindex all the array's elements every time it's called. The larger the array, the slower [method pop_front] will be. *)

    val pop_at :
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.Array.t structure ptr ->
      BuiltinClass0.Variant.t structure ptr
    (** Removes and returns the element of the array at index [param position]. If negative, [param position] is considered relative to the end of the array. Leaves the array unchanged and returns [code]null[/code] if the array is empty or if it's accessed out of bounds. An error message is printed when the array is accessed out of bounds, but not when the array is empty.
[b]Note:[/b] On large arrays, this method can be slower than [method pop_back] as it will reindex the array's elements that are located after the removed element. The larger the array and the lower the index of the removed element, the slower [method pop_at] will be. *)

    val sort : BuiltinClass0.Array.t structure ptr -> unit
    (** Sorts the array.
[b]Note:[/b] The sorting algorithm used is not [url=https://en.wikipedia.org/wiki/Sorting_algorithm#Stability]stable[/url]. This means that values considered equal may have their order changed when using [method sort].
[b]Note:[/b] Strings are sorted in alphabetical order (as opposed to natural order). This may lead to unexpected behavior when sorting an array of strings ending with a sequence of numbers. Consider the following example:
[codeblocks]
[gdscript]
var strings = [""string1"", ""string2"", ""string10"", ""string11""]
strings.sort()
print(strings) # Prints [string1, string10, string11, string2]
[/gdscript]
[csharp]
var strings = new Godot.Collections.Array { ""string1"", ""string2"", ""string10"", ""string11"" };
strings.Sort();
GD.Print(strings); // Prints [string1, string10, string11, string2]
[/csharp]
[/codeblocks]
To perform natural order sorting, you can use [method sort_custom] with [method String.naturalnocasecmp_to] as follows:
[codeblock]
var strings = [""string1"", ""string2"", ""string10"", ""string11""]
strings.sort_custom(func(a, b): return a.naturalnocasecmp_to(b) < 0)
print(strings) # Prints [string1, string2, string10, string11]
[/codeblock] *)

    val sort_custom :
      BuiltinClass0.Callable.t structure ptr ->
      BuiltinClass0.Array.t structure ptr ->
      unit
    (** Sorts the array using a custom method. The custom method receives two arguments (a pair of elements from the array) and must return either [code]true[/code] or [code]false[/code]. For two elements [code]a[/code] and [code]b[/code], if the given method returns [code]true[/code], element [code]b[/code] will be after element [code]a[/code] in the array.
[b]Note:[/b] The sorting algorithm used is not [url=https://en.wikipedia.org/wiki/Sorting_algorithm#Stability]stable[/url]. This means that values considered equal may have their order changed when using [method sort_custom].
[b]Note:[/b] You cannot randomize the return value as the heapsort algorithm expects a deterministic result. Randomizing the return value will result in unexpected behavior.
[codeblocks]
[gdscript]
func sort_ascending(a, b):
    if a[0] < b[0]:
        return true
    return false

func _ready():
    var my_items = [[5, ""Potato""], [9, ""Rice""], [4, ""Tomato""]]
    my_items.sort_custom(sort_ascending)
    print(my_items) # Prints [[4, Tomato], [5, Potato], [9, Rice]].

    # Descending, lambda version.
    my_items.sort_custom(func(a, b): return a[0] > b[0])
    print(my_items) # Prints [[9, Rice], [5, Potato], [4, Tomato]].
[/gdscript]
[csharp]
// There is no custom sort support for Godot.Collections.Array
[/csharp]
[/codeblocks] *)

    val shuffle : BuiltinClass0.Array.t structure ptr -> unit
    (** Shuffles the array such that the items will have a random order. This method uses the global random number generator common to methods such as [method @GlobalScope.randi]. Call [method @GlobalScope.randomize] to ensure that a new seed will be used each time if you want non-reproducible shuffling. *)

    val bsearch :
      BuiltinClass0.Variant.t structure ptr ->
      BuiltinClass0.Bool.t structure ptr ->
      BuiltinClass0.Array.t structure ptr ->
      BuiltinClass0.Int.t structure ptr
    (** Finds the index of an existing value (or the insertion index that maintains sorting order, if the value is not yet present in the array) using binary search. Optionally, a [param before] specifier can be passed. If [code]false[/code], the returned index comes after all existing entries of the value in the array.
[codeblock]
var array = [""a"", ""b"", ""c"", ""c"", ""d"", ""e""]
print(array.bsearch(""c"", true))  # Prints 2, at the first matching element.
print(array.bsearch(""c"", false)) # Prints 4, after the last matching element, pointing to ""d"".
[/codeblock]
[b]Note:[/b] Calling [method bsearch] on an unsorted array results in unexpected behavior. *)

    val bsearch_custom :
      BuiltinClass0.Variant.t structure ptr ->
      BuiltinClass0.Callable.t structure ptr ->
      BuiltinClass0.Bool.t structure ptr ->
      BuiltinClass0.Array.t structure ptr ->
      BuiltinClass0.Int.t structure ptr
    (** Finds the index of an existing value (or the insertion index that maintains sorting order, if the value is not yet present in the array) using binary search and a custom comparison method. Optionally, a [param before] specifier can be passed. If [code]false[/code], the returned index comes after all existing entries of the value in the array. The custom method receives two arguments (an element from the array and the value searched for) and must return [code]true[/code] if the first argument is less than the second, and return [code]false[/code] otherwise.
[b]Note:[/b] The custom method must accept the two arguments in any order, you cannot rely on that the first argument will always be from the array.
[b]Note:[/b] Calling [method bsearch_custom] on an unsorted array results in unexpected behavior. *)

    val reverse : BuiltinClass0.Array.t structure ptr -> unit
    (** Reverses the order of the elements in the array. *)

    val duplicate :
      BuiltinClass0.Bool.t structure ptr ->
      BuiltinClass0.Array.t structure ptr ->
      BuiltinClass0.Array.t structure ptr
    (** Returns a copy of the array.
If [param deep] is [code]true[/code], a deep copy is performed: all nested arrays and dictionaries are duplicated and will not be shared with the original array. If [code]false[/code], a shallow copy is made and references to the original nested arrays and dictionaries are kept, so that modifying a sub-array or dictionary in the copy will also impact those referenced in the source array. Note that any [Object]-derived elements will be shallow copied regardless of the [param deep] setting. *)

    val slice :
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.Bool.t structure ptr ->
      BuiltinClass0.Array.t structure ptr ->
      BuiltinClass0.Array.t structure ptr
    (** Returns the slice of the [Array], from [param begin] (inclusive) to [param end] (exclusive), as a new [Array].
The absolute value of [param begin] and [param end] will be clamped to the array size, so the default value for [param end] makes it slice to the size of the array by default (i.e. [code]arr.slice(1)[/code] is a shorthand for [code]arr.slice(1, arr.size())[/code]).
If either [param begin] or [param end] are negative, they will be relative to the end of the array (i.e. [code]arr.slice(0, -2)[/code] is a shorthand for [code]arr.slice(0, arr.size() - 2)[/code]).
If specified, [param step] is the relative index between source elements. It can be negative, then [param begin] must be higher than [param end]. For example, [code][0, 1, 2, 3, 4, 5].slice(5, 1, -2)[/code] returns [code][5, 3][/code].
If [param deep] is true, each element will be copied by value rather than by reference.
[b]Note:[/b] To include the first element when [param step] is negative, use [code]arr.slice(begin, -arr.size() - 1, step)[/code] (i.e. [code][0, 1, 2].slice(1, -4, -1)[/code] returns [code][1, 0][/code]). *)

    val filter :
      BuiltinClass0.Callable.t structure ptr ->
      BuiltinClass0.Array.t structure ptr ->
      BuiltinClass0.Array.t structure ptr
    (** Calls the provided [Callable] on each element in the array and returns a new array with the elements for which the method returned [code]true[/code].
The callable's method should take one [Variant] parameter (the current array element) and return a boolean value.
[codeblock]
func _ready():
    print([1, 2, 3].filter(remove_1)) # Prints [2, 3].
    print([1, 2, 3].filter(func(number): return number != 1)) # Same as above, but using lambda function.

func remove_1(number):
    return number != 1
[/codeblock]
See also [method any], [method all], [method map] and [method reduce]. *)

    val map :
      BuiltinClass0.Callable.t structure ptr ->
      BuiltinClass0.Array.t structure ptr ->
      BuiltinClass0.Array.t structure ptr
    (** Calls the provided [Callable] for each element in the array and returns a new array filled with values returned by the method.
The callable's method should take one [Variant] parameter (the current array element) and can return any [Variant].
[codeblock]
func _ready():
    print([1, 2, 3].map(negate)) # Prints [-1, -2, -3].
    print([1, 2, 3].map(func(number): return -number)) # Same as above, but using lambda function.

func negate(number):
    return -number
[/codeblock]
See also [method filter], [method reduce], [method any] and [method all]. *)

    val reduce :
      BuiltinClass0.Callable.t structure ptr ->
      BuiltinClass0.Variant.t structure ptr ->
      BuiltinClass0.Array.t structure ptr ->
      BuiltinClass0.Variant.t structure ptr
    (** Calls the provided [Callable] for each element in array and accumulates the result in [param accum].
The callable's method takes two arguments: the current value of [param accum] and the current array element. If [param accum] is [code]null[/code] (default value), the iteration will start from the second element, with the first one used as initial value of [param accum].
[codeblock]
func _ready():
    print([1, 2, 3].reduce(sum, 10)) # Prints 16.
    print([1, 2, 3].reduce(func(accum, number): return accum + number, 10)) # Same as above, but using lambda function.

func sum(accum, number):
    return accum + number
[/codeblock]
See also [method map], [method filter], [method any] and [method all]. *)

    val any :
      BuiltinClass0.Callable.t structure ptr ->
      BuiltinClass0.Array.t structure ptr ->
      BuiltinClass0.Bool.t structure ptr
    (** Calls the provided [Callable] on each element in the array and returns [code]true[/code] if the [Callable] returns [code]true[/code] for [i]one or more[/i] elements in the array. If the [Callable] returns [code]false[/code] for all elements in the array, this method returns [code]false[/code].
The callable's method should take one [Variant] parameter (the current array element) and return a boolean value.
[codeblock]
func _ready():
    print([6, 10, 6].any(greater_than_5))  # Prints True (3 elements evaluate to `true`).
    print([4, 10, 4].any(greater_than_5))  # Prints True (1 elements evaluate to `true`).
    print([4, 4, 4].any(greater_than_5))  # Prints False (0 elements evaluate to `true`).
    print([].any(greater_than_5))  # Prints False (0 elements evaluate to `true`).

    print([6, 10, 6].any(func(number): return number > 5))  # Prints True. Same as the first line above, but using lambda function.

func greater_than_5(number):
    return number > 5
[/codeblock]
See also [method all], [method filter], [method map] and [method reduce].
[b]Note:[/b] Unlike relying on the size of an array returned by [method filter], this method will return as early as possible to improve performance (especially with large arrays).
[b]Note:[/b] For an empty array, this method always returns [code]false[/code]. *)

    val all :
      BuiltinClass0.Callable.t structure ptr ->
      BuiltinClass0.Array.t structure ptr ->
      BuiltinClass0.Bool.t structure ptr
    (** Calls the provided [Callable] on each element in the array and returns [code]true[/code] if the [Callable] returns [code]true[/code] for [i]all[/i] elements in the array. If the [Callable] returns [code]false[/code] for one array element or more, this method returns [code]false[/code].
The callable's method should take one [Variant] parameter (the current array element) and return a boolean value.
[codeblock]
func _ready():
    print([6, 10, 6].all(greater_than_5))  # Prints True (3/3 elements evaluate to `true`).
    print([4, 10, 4].all(greater_than_5))  # Prints False (1/3 elements evaluate to `true`).
    print([4, 4, 4].all(greater_than_5))  # Prints False (0/3 elements evaluate to `true`).
    print([].all(greater_than_5))  # Prints True (0/0 elements evaluate to `true`).

    print([6, 10, 6].all(func(number): return number > 5))  # Prints True. Same as the first line above, but using lambda function.

func greater_than_5(number):
    return number > 5
[/codeblock]
See also [method any], [method filter], [method map] and [method reduce].
[b]Note:[/b] Unlike relying on the size of an array returned by [method filter], this method will return as early as possible to improve performance (especially with large arrays).
[b]Note:[/b] For an empty array, this method [url=https://en.wikipedia.org/wiki/Vacuous_truth]always[/url] returns [code]true[/code]. *)

    val max :
      BuiltinClass0.Array.t structure ptr ->
      BuiltinClass0.Variant.t structure ptr
    (** Returns the maximum value contained in the array if all elements are of comparable types. If the elements can't be compared, [code]null[/code] is returned.
To find the maximum value using a custom comparator, you can use [method reduce]. In this example every array element is checked and the first maximum value is returned:
[codeblock]
func _ready():
    var arr = [Vector2(0, 1), Vector2(2, 0), Vector2(1, 1), Vector2(1, 0), Vector2(0, 2)]
    # In this example we compare the lengths.
    print(arr.reduce(func(max, val): return val if is_length_greater(val, max) else max))

func is_length_greater(a, b):
    return a.length() > b.length()
[/codeblock] *)

    val min :
      BuiltinClass0.Array.t structure ptr ->
      BuiltinClass0.Variant.t structure ptr
    (** Returns the minimum value contained in the array if all elements are of comparable types. If the elements can't be compared, [code]null[/code] is returned.
See also [method max] for an example of using a custom comparator. *)

    val is_typed :
      BuiltinClass0.Array.t structure ptr -> BuiltinClass0.Bool.t structure ptr
    (** Returns [code]true[/code] if the array is typed. Typed arrays can only store elements of their associated type and provide type safety for the [code][][/code] operator. Methods of typed array still return [Variant]. *)

    val is_same_typed :
      BuiltinClass0.Array.t structure ptr ->
      BuiltinClass0.Array.t structure ptr ->
      BuiltinClass0.Bool.t structure ptr
    (** Returns [code]true[/code] if the array is typed the same as [param array]. *)

    val get_typed_builtin :
      BuiltinClass0.Array.t structure ptr -> BuiltinClass0.Int.t structure ptr
    (** Returns the built-in type of the typed array as a [enum Variant.Type] constant. If the array is not typed, returns [constant TYPE_NIL]. *)

    val get_typed_class_name :
      BuiltinClass0.Array.t structure ptr ->
      BuiltinClass0.StringName.t structure ptr
    (** Returns the [b]native[/b] class name of the typed array if the built-in type is [constant TYPE_OBJECT]. Otherwise, this method returns an empty string. *)

    val get_typed_script :
      BuiltinClass0.Array.t structure ptr ->
      BuiltinClass0.Variant.t structure ptr
    (** Returns the script associated with the typed array. This method returns a [Script] instance or [code]null[/code]. *)

    val make_read_only : BuiltinClass0.Array.t structure ptr -> unit
    (** Makes the array read-only, i.e. disabled modifying of the array's elements. Does not apply to nested content, e.g. content of nested arrays. *)

    val is_read_only :
      BuiltinClass0.Array.t structure ptr -> BuiltinClass0.Bool.t structure ptr
    (** Returns [code]true[/code] if the array is read-only. See [method make_read_only]. Arrays are automatically read-only if declared with [code]const[/code] keyword. *)

    val not :
      Array.t structure ptr ->
      Array.t structure ptr ->
      Bool.t structure ptr ->
      unit

    val _Array_elem_Dictionary :
      Array.t structure ptr ->
      Dictionary.t structure ptr ->
      Bool.t structure ptr ->
      unit

    val ( = ) :
      Array.t structure ptr ->
      Array.t structure ptr ->
      Bool.t structure ptr ->
      unit
    (** Compares the left operand [Array] against the [param right] [Array]. Returns [code]true[/code] if the sizes and contents of the arrays are equal, [code]false[/code] otherwise. *)

    val ( <> ) :
      Array.t structure ptr ->
      Array.t structure ptr ->
      Bool.t structure ptr ->
      unit
    (** Compares the left operand [Array] against the [param right] [Array]. Returns [code]true[/code] if the sizes or contents of the arrays are [i]not[/i] equal, [code]false[/code] otherwise. *)

    val ( < ) :
      Array.t structure ptr ->
      Array.t structure ptr ->
      Bool.t structure ptr ->
      unit
    (** Performs a comparison for each index between the left operand [Array] and the [param right] [Array], considering the highest common index of both arrays for this comparison: Returns [code]true[/code] on the first occurrence of an element that is less, or [code]false[/code] if the element is greater. Note that depending on the type of data stored, this function may be recursive. If all elements are equal, it compares the length of both arrays and returns [code]false[/code] if the left operand [Array] has fewer elements, otherwise it returns [code]true[/code]. *)

    val ( <= ) :
      Array.t structure ptr ->
      Array.t structure ptr ->
      Bool.t structure ptr ->
      unit
    (** Performs a comparison for each index between the left operand [Array] and the [param right] [Array], considering the highest common index of both arrays for this comparison: Returns [code]true[/code] on the first occurrence of an element that is less, or [code]false[/code] if the element is greater. Note that depending on the type of data stored, this function may be recursive. If all elements are equal, it compares the length of both arrays and returns [code]true[/code] if the left operand [Array] has the same number of elements or fewer, otherwise it returns [code]false[/code]. *)

    val ( > ) :
      Array.t structure ptr ->
      Array.t structure ptr ->
      Bool.t structure ptr ->
      unit
    (** Performs a comparison for each index between the left operand [Array] and the [param right] [Array], considering the highest common index of both arrays for this comparison: Returns [code]true[/code] on the first occurrence of an element that is greater, or [code]false[/code] if the element is less. Note that depending on the type of data stored, this function may be recursive. If all elements are equal, it compares the length of both arrays and returns [code]true[/code] if the [param right] [Array] has more elements, otherwise it returns [code]false[/code]. *)

    val ( >= ) :
      Array.t structure ptr ->
      Array.t structure ptr ->
      Bool.t structure ptr ->
      unit
    (** Performs a comparison for each index between the left operand [Array] and the [param right] [Array], considering the highest common index of both arrays for this comparison: Returns [code]true[/code] on the first occurrence of an element that is greater, or [code]false[/code] if the element is less. Note that depending on the type of data stored, this function may be recursive. If all elements are equal, it compares the length of both arrays and returns [code]true[/code] if the [param right] [Array] has more or the same number of elements, otherwise it returns [code]false[/code]. *)

    val ( + ) :
      Array.t structure ptr ->
      Array.t structure ptr ->
      Array.t structure ptr ->
      unit
    (** Concatenates two [Array]s together, with the [param right] [Array] being added to the end of the [Array] specified in the left operand. For example, [code][1, 2] + [3, 4][/code] results in [code][1, 2, 3, 4][/code]. *)

    val _Array_elem_Array :
      Array.t structure ptr ->
      Array.t structure ptr ->
      Bool.t structure ptr ->
      unit
  end

  module type PACKEDBYTEARRAY = sig
    type t

    include Api_types.API_TYPE with type t := t

    val size :
      BuiltinClass0.PackedByteArray.t structure ptr ->
      BuiltinClass0.Int.t structure ptr
    (** Returns the number of elements in the array. *)

    val is_empty :
      BuiltinClass0.PackedByteArray.t structure ptr ->
      BuiltinClass0.Bool.t structure ptr
    (** Returns [code]true[/code] if the array is empty. *)

    val set :
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.PackedByteArray.t structure ptr ->
      unit
    (** Changes the byte at the given index. *)

    val push_back :
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.PackedByteArray.t structure ptr ->
      BuiltinClass0.Bool.t structure ptr
    (** Appends an element at the end of the array. *)

    val append :
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.PackedByteArray.t structure ptr ->
      BuiltinClass0.Bool.t structure ptr
    (** Appends an element at the end of the array (alias of [method push_back]). *)

    val append_array :
      BuiltinClass0.PackedByteArray.t structure ptr ->
      BuiltinClass0.PackedByteArray.t structure ptr ->
      unit
    (** Appends a [PackedByteArray] at the end of this array. *)

    val remove_at :
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.PackedByteArray.t structure ptr ->
      unit
    (** Removes an element from the array by index. *)

    val insert :
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.PackedByteArray.t structure ptr ->
      BuiltinClass0.Int.t structure ptr
    (** Inserts a new element at a given position in the array. The position must be valid, or at the end of the array ([code]idx == size()[/code]). *)

    val fill :
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.PackedByteArray.t structure ptr ->
      unit
    (** Assigns the given value to all elements in the array. This can typically be used together with [method resize] to create an array with a given size and initialized elements. *)

    val resize :
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.PackedByteArray.t structure ptr ->
      BuiltinClass0.Int.t structure ptr
    (** Sets the size of the array. If the array is grown, reserves elements at the end of the array. If the array is shrunk, truncates the array to the new size. Calling [method resize] once and assigning the new values is faster than adding new elements one by one. *)

    val clear : BuiltinClass0.PackedByteArray.t structure ptr -> unit
    (** Clears the array. This is equivalent to using [method resize] with a size of [code]0[/code]. *)

    val has :
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.PackedByteArray.t structure ptr ->
      BuiltinClass0.Bool.t structure ptr
    (** Returns [code]true[/code] if the array contains [param value]. *)

    val reverse : BuiltinClass0.PackedByteArray.t structure ptr -> unit
    (** Reverses the order of the elements in the array. *)

    val slice :
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.PackedByteArray.t structure ptr ->
      BuiltinClass0.PackedByteArray.t structure ptr
    (** Returns the slice of the [PackedByteArray], from [param begin] (inclusive) to [param end] (exclusive), as a new [PackedByteArray].
The absolute value of [param begin] and [param end] will be clamped to the array size, so the default value for [param end] makes it slice to the size of the array by default (i.e. [code]arr.slice(1)[/code] is a shorthand for [code]arr.slice(1, arr.size())[/code]).
If either [param begin] or [param end] are negative, they will be relative to the end of the array (i.e. [code]arr.slice(0, -2)[/code] is a shorthand for [code]arr.slice(0, arr.size() - 2)[/code]). *)

    val sort : BuiltinClass0.PackedByteArray.t structure ptr -> unit
    (** Sorts the elements of the array in ascending order. *)

    val bsearch :
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.Bool.t structure ptr ->
      BuiltinClass0.PackedByteArray.t structure ptr ->
      BuiltinClass0.Int.t structure ptr
    (** Finds the index of an existing value (or the insertion index that maintains sorting order, if the value is not yet present in the array) using binary search. Optionally, a [param before] specifier can be passed. If [code]false[/code], the returned index comes after all existing entries of the value in the array.
[b]Note:[/b] Calling [method bsearch] on an unsorted array results in unexpected behavior. *)

    val duplicate :
      BuiltinClass0.PackedByteArray.t structure ptr ->
      BuiltinClass0.PackedByteArray.t structure ptr
    (** Creates a copy of the array, and returns it. *)

    val find :
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.PackedByteArray.t structure ptr ->
      BuiltinClass0.Int.t structure ptr
    (** Searches the array for a value and returns its index or [code]-1[/code] if not found. Optionally, the initial search index can be passed. *)

    val rfind :
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.PackedByteArray.t structure ptr ->
      BuiltinClass0.Int.t structure ptr
    (** Searches the array in reverse order. Optionally, a start search index can be passed. If negative, the start index is considered relative to the end of the array. *)

    val count :
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.PackedByteArray.t structure ptr ->
      BuiltinClass0.Int.t structure ptr
    (** Returns the number of times an element is in the array. *)

    val get_string_from_ascii :
      BuiltinClass0.PackedByteArray.t structure ptr ->
      BuiltinClass0.String.t structure ptr
    (** Converts ASCII/Latin-1 encoded array to [String]. Fast alternative to [method get_string_from_utf8] if the content is ASCII/Latin-1 only. Unlike the UTF-8 function this function maps every byte to a character in the array. Multibyte sequences will not be interpreted correctly. For parsing user input always use [method get_string_from_utf8]. This is the inverse of [method String.to_ascii_buffer]. *)

    val get_string_from_utf8 :
      BuiltinClass0.PackedByteArray.t structure ptr ->
      BuiltinClass0.String.t structure ptr
    (** Converts UTF-8 encoded array to [String]. Slower than [method get_string_from_ascii] but supports UTF-8 encoded data. Use this function if you are unsure about the source of the data. For user input this function should always be preferred. Returns empty string if source array is not valid UTF-8 string. This is the inverse of [method String.to_utf8_buffer]. *)

    val get_string_from_utf16 :
      BuiltinClass0.PackedByteArray.t structure ptr ->
      BuiltinClass0.String.t structure ptr
    (** Converts UTF-16 encoded array to [String]. If the BOM is missing, system endianness is assumed. Returns empty string if source array is not valid UTF-16 string. This is the inverse of [method String.to_utf16_buffer]. *)

    val get_string_from_utf32 :
      BuiltinClass0.PackedByteArray.t structure ptr ->
      BuiltinClass0.String.t structure ptr
    (** Converts UTF-32 encoded array to [String]. System endianness is assumed. Returns empty string if source array is not valid UTF-32 string. This is the inverse of [method String.to_utf32_buffer]. *)

    val get_string_from_wchar :
      BuiltinClass0.PackedByteArray.t structure ptr ->
      BuiltinClass0.String.t structure ptr
    (** Converts wide character ([code]wchar_t[/code], UTF-16 on Windows, UTF-32 on other platforms) encoded array to [String]. Returns empty string if source array is not valid wide string. This is the inverse of [method String.to_wchar_buffer]. *)

    val hex_encode :
      BuiltinClass0.PackedByteArray.t structure ptr ->
      BuiltinClass0.String.t structure ptr
    (** Returns a hexadecimal representation of this array as a [String].
[codeblocks]
[gdscript]
var array = PackedByteArray([11, 46, 255])
print(array.hex_encode()) # Prints: 0b2eff
[/gdscript]
[csharp]
var array = new byte[] {11, 46, 255};
GD.Print(array.HexEncode()); // Prints: 0b2eff
[/csharp]
[/codeblocks] *)

    val compress :
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.PackedByteArray.t structure ptr ->
      BuiltinClass0.PackedByteArray.t structure ptr
    (** Returns a new [PackedByteArray] with the data compressed. Set the compression mode using one of [enum FileAccess.CompressionMode]'s constants. *)

    val decompress :
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.PackedByteArray.t structure ptr ->
      BuiltinClass0.PackedByteArray.t structure ptr
    (** Returns a new [PackedByteArray] with the data decompressed. Set [param buffer_size] to the size of the uncompressed data. Set the compression mode using one of [enum FileAccess.CompressionMode]'s constants.
[b]Note:[/b] Decompression is not guaranteed to work with data not compressed by Godot, for example if data compressed with the deflate compression mode lacks a checksum or header. *)

    val decompress_dynamic :
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.PackedByteArray.t structure ptr ->
      BuiltinClass0.PackedByteArray.t structure ptr
    (** Returns a new [PackedByteArray] with the data decompressed. Set the compression mode using one of [enum FileAccess.CompressionMode]'s constants. [b]This method only accepts brotli, gzip, and deflate compression modes.[/b]
This method is potentially slower than [method decompress], as it may have to re-allocate its output buffer multiple times while decompressing, whereas [method decompress] knows it's output buffer size from the beginning.
GZIP has a maximal compression ratio of 1032:1, meaning it's very possible for a small compressed payload to decompress to a potentially very large output. To guard against this, you may provide a maximum size this function is allowed to allocate in bytes via [param max_output_size]. Passing -1 will allow for unbounded output. If any positive value is passed, and the decompression exceeds that amount in bytes, then an error will be returned.
[b]Note:[/b] Decompression is not guaranteed to work with data not compressed by Godot, for example if data compressed with the deflate compression mode lacks a checksum or header. *)

    val decode_u8 :
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.PackedByteArray.t structure ptr ->
      BuiltinClass0.Int.t structure ptr
    (** Decodes a 8-bit unsigned integer number from the bytes starting at [param byte_offset]. Fails if the byte count is insufficient. Returns [code]0[/code] if a valid number can't be decoded. *)

    val decode_s8 :
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.PackedByteArray.t structure ptr ->
      BuiltinClass0.Int.t structure ptr
    (** Decodes a 8-bit signed integer number from the bytes starting at [param byte_offset]. Fails if the byte count is insufficient. Returns [code]0[/code] if a valid number can't be decoded. *)

    val decode_u16 :
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.PackedByteArray.t structure ptr ->
      BuiltinClass0.Int.t structure ptr
    (** Decodes a 16-bit unsigned integer number from the bytes starting at [param byte_offset]. Fails if the byte count is insufficient. Returns [code]0[/code] if a valid number can't be decoded. *)

    val decode_s16 :
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.PackedByteArray.t structure ptr ->
      BuiltinClass0.Int.t structure ptr
    (** Decodes a 16-bit signed integer number from the bytes starting at [param byte_offset]. Fails if the byte count is insufficient. Returns [code]0[/code] if a valid number can't be decoded. *)

    val decode_u32 :
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.PackedByteArray.t structure ptr ->
      BuiltinClass0.Int.t structure ptr
    (** Decodes a 32-bit unsigned integer number from the bytes starting at [param byte_offset]. Fails if the byte count is insufficient. Returns [code]0[/code] if a valid number can't be decoded. *)

    val decode_s32 :
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.PackedByteArray.t structure ptr ->
      BuiltinClass0.Int.t structure ptr
    (** Decodes a 32-bit signed integer number from the bytes starting at [param byte_offset]. Fails if the byte count is insufficient. Returns [code]0[/code] if a valid number can't be decoded. *)

    val decode_u64 :
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.PackedByteArray.t structure ptr ->
      BuiltinClass0.Int.t structure ptr
    (** Decodes a 64-bit unsigned integer number from the bytes starting at [param byte_offset]. Fails if the byte count is insufficient. Returns [code]0[/code] if a valid number can't be decoded. *)

    val decode_s64 :
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.PackedByteArray.t structure ptr ->
      BuiltinClass0.Int.t structure ptr
    (** Decodes a 64-bit signed integer number from the bytes starting at [param byte_offset]. Fails if the byte count is insufficient. Returns [code]0[/code] if a valid number can't be decoded. *)

    val decode_half :
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.PackedByteArray.t structure ptr ->
      BuiltinClass0.Float.t structure ptr
    (** Decodes a 16-bit floating point number from the bytes starting at [param byte_offset]. Fails if the byte count is insufficient. Returns [code]0.0[/code] if a valid number can't be decoded. *)

    val decode_float :
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.PackedByteArray.t structure ptr ->
      BuiltinClass0.Float.t structure ptr
    (** Decodes a 32-bit floating point number from the bytes starting at [param byte_offset]. Fails if the byte count is insufficient. Returns [code]0.0[/code] if a valid number can't be decoded. *)

    val decode_double :
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.PackedByteArray.t structure ptr ->
      BuiltinClass0.Float.t structure ptr
    (** Decodes a 64-bit floating point number from the bytes starting at [param byte_offset]. Fails if the byte count is insufficient. Returns [code]0.0[/code] if a valid number can't be decoded. *)

    val has_encoded_var :
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.Bool.t structure ptr ->
      BuiltinClass0.PackedByteArray.t structure ptr ->
      BuiltinClass0.Bool.t structure ptr
    (** Returns [code]true[/code] if a valid [Variant] value can be decoded at the [param byte_offset]. Returns [code]false[/code] otherwise or when the value is [Object]-derived and [param allow_objects] is [code]false[/code]. *)

    val decode_var :
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.Bool.t structure ptr ->
      BuiltinClass0.PackedByteArray.t structure ptr ->
      BuiltinClass0.Variant.t structure ptr
    (** Decodes a [Variant] from the bytes starting at [param byte_offset]. Returns [code]null[/code] if a valid variant can't be decoded or the value is [Object]-derived and [param allow_objects] is [code]false[/code]. *)

    val decode_var_size :
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.Bool.t structure ptr ->
      BuiltinClass0.PackedByteArray.t structure ptr ->
      BuiltinClass0.Int.t structure ptr
    (** Decodes a size of a [Variant] from the bytes starting at [param byte_offset]. Requires at least 4 bytes of data starting at the offset, otherwise fails. *)

    val to_int32_array :
      BuiltinClass0.PackedByteArray.t structure ptr ->
      BuiltinClass0.PackedInt32Array.t structure ptr
    (** Returns a copy of the data converted to a [PackedInt32Array], where each block of 4 bytes has been converted to a signed 32-bit integer (C++ [code]int32_t[/code]).
The size of the input array must be a multiple of 4 (size of 32-bit integer). The size of the new array will be [code]byte_array.size() / 4[/code].
If the original data can't be converted to signed 32-bit integers, the resulting data is undefined. *)

    val to_int64_array :
      BuiltinClass0.PackedByteArray.t structure ptr ->
      BuiltinClass0.PackedInt64Array.t structure ptr
    (** Returns a copy of the data converted to a [PackedInt64Array], where each block of 8 bytes has been converted to a signed 64-bit integer (C++ [code]int64_t[/code], Godot [int]).
The size of the input array must be a multiple of 8 (size of 64-bit integer). The size of the new array will be [code]byte_array.size() / 8[/code].
If the original data can't be converted to signed 64-bit integers, the resulting data is undefined. *)

    val to_float32_array :
      BuiltinClass0.PackedByteArray.t structure ptr ->
      BuiltinClass0.PackedFloat32Array.t structure ptr
    (** Returns a copy of the data converted to a [PackedFloat32Array], where each block of 4 bytes has been converted to a 32-bit float (C++ [code skip-lint]float[/code]).
The size of the input array must be a multiple of 4 (size of 32-bit float). The size of the new array will be [code]byte_array.size() / 4[/code].
If the original data can't be converted to 32-bit floats, the resulting data is undefined. *)

    val to_float64_array :
      BuiltinClass0.PackedByteArray.t structure ptr ->
      BuiltinClass0.PackedFloat64Array.t structure ptr
    (** Returns a copy of the data converted to a [PackedFloat64Array], where each block of 8 bytes has been converted to a 64-bit float (C++ [code]double[/code], Godot [float]).
The size of the input array must be a multiple of 8 (size of 64-bit double). The size of the new array will be [code]byte_array.size() / 8[/code].
If the original data can't be converted to 64-bit floats, the resulting data is undefined. *)

    val encode_u8 :
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.PackedByteArray.t structure ptr ->
      unit
    (** Encodes a 8-bit unsigned integer number (byte) at the index of [param byte_offset] bytes. The array must have at least 1 byte of space, starting at the offset. *)

    val encode_s8 :
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.PackedByteArray.t structure ptr ->
      unit
    (** Encodes a 8-bit signed integer number (signed byte) at the index of [param byte_offset] bytes. The array must have at least 1 byte of space, starting at the offset. *)

    val encode_u16 :
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.PackedByteArray.t structure ptr ->
      unit
    (** Encodes a 16-bit unsigned integer number as bytes at the index of [param byte_offset] bytes. The array must have at least 2 bytes of space, starting at the offset. *)

    val encode_s16 :
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.PackedByteArray.t structure ptr ->
      unit
    (** Encodes a 16-bit signed integer number as bytes at the index of [param byte_offset] bytes. The array must have at least 2 bytes of space, starting at the offset. *)

    val encode_u32 :
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.PackedByteArray.t structure ptr ->
      unit
    (** Encodes a 32-bit unsigned integer number as bytes at the index of [param byte_offset] bytes. The array must have at least 4 bytes of space, starting at the offset. *)

    val encode_s32 :
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.PackedByteArray.t structure ptr ->
      unit
    (** Encodes a 32-bit signed integer number as bytes at the index of [param byte_offset] bytes. The array must have at least 4 bytes of space, starting at the offset. *)

    val encode_u64 :
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.PackedByteArray.t structure ptr ->
      unit
    (** Encodes a 64-bit unsigned integer number as bytes at the index of [param byte_offset] bytes. The array must have at least 8 bytes of space, starting at the offset. *)

    val encode_s64 :
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.PackedByteArray.t structure ptr ->
      unit
    (** Encodes a 64-bit signed integer number as bytes at the index of [param byte_offset] bytes. The array must have at least 8 bytes of space, starting at the offset. *)

    val encode_half :
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.Float.t structure ptr ->
      BuiltinClass0.PackedByteArray.t structure ptr ->
      unit
    (** Encodes a 16-bit floating point number as bytes at the index of [param byte_offset] bytes. The array must have at least 2 bytes of space, starting at the offset. *)

    val encode_float :
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.Float.t structure ptr ->
      BuiltinClass0.PackedByteArray.t structure ptr ->
      unit
    (** Encodes a 32-bit floating point number as bytes at the index of [param byte_offset] bytes. The array must have at least 4 bytes of space, starting at the offset. *)

    val encode_double :
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.Float.t structure ptr ->
      BuiltinClass0.PackedByteArray.t structure ptr ->
      unit
    (** Encodes a 64-bit floating point number as bytes at the index of [param byte_offset] bytes. The array must have at least 8 bytes of allocated space, starting at the offset. *)

    val encode_var :
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.Variant.t structure ptr ->
      BuiltinClass0.Bool.t structure ptr ->
      BuiltinClass0.PackedByteArray.t structure ptr ->
      BuiltinClass0.Int.t structure ptr
    (** Encodes a [Variant] at the index of [param byte_offset] bytes. A sufficient space must be allocated, depending on the encoded variant's size. If [param allow_objects] is [code]false[/code], [Object]-derived values are not permitted and will instead be serialized as ID-only. *)

    val not :
      PackedByteArray.t structure ptr ->
      PackedByteArray.t structure ptr ->
      Bool.t structure ptr ->
      unit

    val _PackedByteArray_elem_Dictionary :
      PackedByteArray.t structure ptr ->
      Dictionary.t structure ptr ->
      Bool.t structure ptr ->
      unit

    val _PackedByteArray_elem_Array :
      PackedByteArray.t structure ptr ->
      Array.t structure ptr ->
      Bool.t structure ptr ->
      unit

    val ( = ) :
      PackedByteArray.t structure ptr ->
      PackedByteArray.t structure ptr ->
      Bool.t structure ptr ->
      unit
    (** Returns [code]true[/code] if contents of both arrays are the same, i.e. they have all equal bytes at the corresponding indices. *)

    val ( <> ) :
      PackedByteArray.t structure ptr ->
      PackedByteArray.t structure ptr ->
      Bool.t structure ptr ->
      unit
    (** Returns [code]true[/code] if contents of the arrays differ. *)

    val ( + ) :
      PackedByteArray.t structure ptr ->
      PackedByteArray.t structure ptr ->
      PackedByteArray.t structure ptr ->
      unit
    (** Returns a new [PackedByteArray] with contents of [param right] added at the end of this array. For better performance, consider using [method append_array] instead. *)
  end

  module type PACKEDINT32ARRAY = sig
    type t

    include Api_types.API_TYPE with type t := t

    val size :
      BuiltinClass0.PackedInt32Array.t structure ptr ->
      BuiltinClass0.Int.t structure ptr
    (** Returns the number of elements in the array. *)

    val is_empty :
      BuiltinClass0.PackedInt32Array.t structure ptr ->
      BuiltinClass0.Bool.t structure ptr
    (** Returns [code]true[/code] if the array is empty. *)

    val set :
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.PackedInt32Array.t structure ptr ->
      unit
    (** Changes the integer at the given index. *)

    val push_back :
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.PackedInt32Array.t structure ptr ->
      BuiltinClass0.Bool.t structure ptr
    (** Appends a value to the array. *)

    val append :
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.PackedInt32Array.t structure ptr ->
      BuiltinClass0.Bool.t structure ptr
    (** Appends an element at the end of the array (alias of [method push_back]). *)

    val append_array :
      BuiltinClass0.PackedInt32Array.t structure ptr ->
      BuiltinClass0.PackedInt32Array.t structure ptr ->
      unit
    (** Appends a [PackedInt32Array] at the end of this array. *)

    val remove_at :
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.PackedInt32Array.t structure ptr ->
      unit
    (** Removes an element from the array by index. *)

    val insert :
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.PackedInt32Array.t structure ptr ->
      BuiltinClass0.Int.t structure ptr
    (** Inserts a new integer at a given position in the array. The position must be valid, or at the end of the array ([code]idx == size()[/code]). *)

    val fill :
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.PackedInt32Array.t structure ptr ->
      unit
    (** Assigns the given value to all elements in the array. This can typically be used together with [method resize] to create an array with a given size and initialized elements. *)

    val resize :
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.PackedInt32Array.t structure ptr ->
      BuiltinClass0.Int.t structure ptr
    (** Sets the size of the array. If the array is grown, reserves elements at the end of the array. If the array is shrunk, truncates the array to the new size. Calling [method resize] once and assigning the new values is faster than adding new elements one by one. *)

    val clear : BuiltinClass0.PackedInt32Array.t structure ptr -> unit
    (** Clears the array. This is equivalent to using [method resize] with a size of [code]0[/code]. *)

    val has :
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.PackedInt32Array.t structure ptr ->
      BuiltinClass0.Bool.t structure ptr
    (** Returns [code]true[/code] if the array contains [param value]. *)

    val reverse : BuiltinClass0.PackedInt32Array.t structure ptr -> unit
    (** Reverses the order of the elements in the array. *)

    val slice :
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.PackedInt32Array.t structure ptr ->
      BuiltinClass0.PackedInt32Array.t structure ptr
    (** Returns the slice of the [PackedInt32Array], from [param begin] (inclusive) to [param end] (exclusive), as a new [PackedInt32Array].
The absolute value of [param begin] and [param end] will be clamped to the array size, so the default value for [param end] makes it slice to the size of the array by default (i.e. [code]arr.slice(1)[/code] is a shorthand for [code]arr.slice(1, arr.size())[/code]).
If either [param begin] or [param end] are negative, they will be relative to the end of the array (i.e. [code]arr.slice(0, -2)[/code] is a shorthand for [code]arr.slice(0, arr.size() - 2)[/code]). *)

    val to_byte_array :
      BuiltinClass0.PackedInt32Array.t structure ptr ->
      BuiltinClass0.PackedByteArray.t structure ptr
    (** Returns a copy of the data converted to a [PackedByteArray], where each element have been encoded as 4 bytes.
The size of the new array will be [code]int32_array.size()  *  4[/code]. *)

    val sort : BuiltinClass0.PackedInt32Array.t structure ptr -> unit
    (** Sorts the elements of the array in ascending order. *)

    val bsearch :
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.Bool.t structure ptr ->
      BuiltinClass0.PackedInt32Array.t structure ptr ->
      BuiltinClass0.Int.t structure ptr
    (** Finds the index of an existing value (or the insertion index that maintains sorting order, if the value is not yet present in the array) using binary search. Optionally, a [param before] specifier can be passed. If [code]false[/code], the returned index comes after all existing entries of the value in the array.
[b]Note:[/b] Calling [method bsearch] on an unsorted array results in unexpected behavior. *)

    val duplicate :
      BuiltinClass0.PackedInt32Array.t structure ptr ->
      BuiltinClass0.PackedInt32Array.t structure ptr
    (** Creates a copy of the array, and returns it. *)

    val find :
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.PackedInt32Array.t structure ptr ->
      BuiltinClass0.Int.t structure ptr
    (** Searches the array for a value and returns its index or [code]-1[/code] if not found. Optionally, the initial search index can be passed. *)

    val rfind :
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.PackedInt32Array.t structure ptr ->
      BuiltinClass0.Int.t structure ptr
    (** Searches the array in reverse order. Optionally, a start search index can be passed. If negative, the start index is considered relative to the end of the array. *)

    val count :
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.PackedInt32Array.t structure ptr ->
      BuiltinClass0.Int.t structure ptr
    (** Returns the number of times an element is in the array. *)

    val not :
      PackedInt32Array.t structure ptr ->
      PackedInt32Array.t structure ptr ->
      Bool.t structure ptr ->
      unit

    val _PackedInt32Array_elem_Dictionary :
      PackedInt32Array.t structure ptr ->
      Dictionary.t structure ptr ->
      Bool.t structure ptr ->
      unit

    val _PackedInt32Array_elem_Array :
      PackedInt32Array.t structure ptr ->
      Array.t structure ptr ->
      Bool.t structure ptr ->
      unit

    val ( = ) :
      PackedInt32Array.t structure ptr ->
      PackedInt32Array.t structure ptr ->
      Bool.t structure ptr ->
      unit
    (** Returns [code]true[/code] if contents of both arrays are the same, i.e. they have all equal ints at the corresponding indices. *)

    val ( <> ) :
      PackedInt32Array.t structure ptr ->
      PackedInt32Array.t structure ptr ->
      Bool.t structure ptr ->
      unit
    (** Returns [code]true[/code] if contents of the arrays differ. *)

    val ( + ) :
      PackedInt32Array.t structure ptr ->
      PackedInt32Array.t structure ptr ->
      PackedInt32Array.t structure ptr ->
      unit
    (** Returns a new [PackedInt32Array] with contents of [param right] added at the end of this array. For better performance, consider using [method append_array] instead. *)
  end

  module type PACKEDINT64ARRAY = sig
    type t

    include Api_types.API_TYPE with type t := t

    val size :
      BuiltinClass0.PackedInt64Array.t structure ptr ->
      BuiltinClass0.Int.t structure ptr
    (** Returns the number of elements in the array. *)

    val is_empty :
      BuiltinClass0.PackedInt64Array.t structure ptr ->
      BuiltinClass0.Bool.t structure ptr
    (** Returns [code]true[/code] if the array is empty. *)

    val set :
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.PackedInt64Array.t structure ptr ->
      unit
    (** Changes the integer at the given index. *)

    val push_back :
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.PackedInt64Array.t structure ptr ->
      BuiltinClass0.Bool.t structure ptr
    (** Appends a value to the array. *)

    val append :
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.PackedInt64Array.t structure ptr ->
      BuiltinClass0.Bool.t structure ptr
    (** Appends an element at the end of the array (alias of [method push_back]). *)

    val append_array :
      BuiltinClass0.PackedInt64Array.t structure ptr ->
      BuiltinClass0.PackedInt64Array.t structure ptr ->
      unit
    (** Appends a [PackedInt64Array] at the end of this array. *)

    val remove_at :
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.PackedInt64Array.t structure ptr ->
      unit
    (** Removes an element from the array by index. *)

    val insert :
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.PackedInt64Array.t structure ptr ->
      BuiltinClass0.Int.t structure ptr
    (** Inserts a new integer at a given position in the array. The position must be valid, or at the end of the array ([code]idx == size()[/code]). *)

    val fill :
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.PackedInt64Array.t structure ptr ->
      unit
    (** Assigns the given value to all elements in the array. This can typically be used together with [method resize] to create an array with a given size and initialized elements. *)

    val resize :
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.PackedInt64Array.t structure ptr ->
      BuiltinClass0.Int.t structure ptr
    (** Sets the size of the array. If the array is grown, reserves elements at the end of the array. If the array is shrunk, truncates the array to the new size. Calling [method resize] once and assigning the new values is faster than adding new elements one by one. *)

    val clear : BuiltinClass0.PackedInt64Array.t structure ptr -> unit
    (** Clears the array. This is equivalent to using [method resize] with a size of [code]0[/code]. *)

    val has :
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.PackedInt64Array.t structure ptr ->
      BuiltinClass0.Bool.t structure ptr
    (** Returns [code]true[/code] if the array contains [param value]. *)

    val reverse : BuiltinClass0.PackedInt64Array.t structure ptr -> unit
    (** Reverses the order of the elements in the array. *)

    val slice :
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.PackedInt64Array.t structure ptr ->
      BuiltinClass0.PackedInt64Array.t structure ptr
    (** Returns the slice of the [PackedInt64Array], from [param begin] (inclusive) to [param end] (exclusive), as a new [PackedInt64Array].
The absolute value of [param begin] and [param end] will be clamped to the array size, so the default value for [param end] makes it slice to the size of the array by default (i.e. [code]arr.slice(1)[/code] is a shorthand for [code]arr.slice(1, arr.size())[/code]).
If either [param begin] or [param end] are negative, they will be relative to the end of the array (i.e. [code]arr.slice(0, -2)[/code] is a shorthand for [code]arr.slice(0, arr.size() - 2)[/code]). *)

    val to_byte_array :
      BuiltinClass0.PackedInt64Array.t structure ptr ->
      BuiltinClass0.PackedByteArray.t structure ptr
    (** Returns a copy of the data converted to a [PackedByteArray], where each element have been encoded as 8 bytes.
The size of the new array will be [code]int64_array.size()  *  8[/code]. *)

    val sort : BuiltinClass0.PackedInt64Array.t structure ptr -> unit
    (** Sorts the elements of the array in ascending order. *)

    val bsearch :
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.Bool.t structure ptr ->
      BuiltinClass0.PackedInt64Array.t structure ptr ->
      BuiltinClass0.Int.t structure ptr
    (** Finds the index of an existing value (or the insertion index that maintains sorting order, if the value is not yet present in the array) using binary search. Optionally, a [param before] specifier can be passed. If [code]false[/code], the returned index comes after all existing entries of the value in the array.
[b]Note:[/b] Calling [method bsearch] on an unsorted array results in unexpected behavior. *)

    val duplicate :
      BuiltinClass0.PackedInt64Array.t structure ptr ->
      BuiltinClass0.PackedInt64Array.t structure ptr
    (** Creates a copy of the array, and returns it. *)

    val find :
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.PackedInt64Array.t structure ptr ->
      BuiltinClass0.Int.t structure ptr
    (** Searches the array for a value and returns its index or [code]-1[/code] if not found. Optionally, the initial search index can be passed. *)

    val rfind :
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.PackedInt64Array.t structure ptr ->
      BuiltinClass0.Int.t structure ptr
    (** Searches the array in reverse order. Optionally, a start search index can be passed. If negative, the start index is considered relative to the end of the array. *)

    val count :
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.PackedInt64Array.t structure ptr ->
      BuiltinClass0.Int.t structure ptr
    (** Returns the number of times an element is in the array. *)

    val not :
      PackedInt64Array.t structure ptr ->
      PackedInt64Array.t structure ptr ->
      Bool.t structure ptr ->
      unit

    val _PackedInt64Array_elem_Dictionary :
      PackedInt64Array.t structure ptr ->
      Dictionary.t structure ptr ->
      Bool.t structure ptr ->
      unit

    val _PackedInt64Array_elem_Array :
      PackedInt64Array.t structure ptr ->
      Array.t structure ptr ->
      Bool.t structure ptr ->
      unit

    val ( = ) :
      PackedInt64Array.t structure ptr ->
      PackedInt64Array.t structure ptr ->
      Bool.t structure ptr ->
      unit
    (** Returns [code]true[/code] if contents of both arrays are the same, i.e. they have all equal ints at the corresponding indices. *)

    val ( <> ) :
      PackedInt64Array.t structure ptr ->
      PackedInt64Array.t structure ptr ->
      Bool.t structure ptr ->
      unit
    (** Returns [code]true[/code] if contents of the arrays differ. *)

    val ( + ) :
      PackedInt64Array.t structure ptr ->
      PackedInt64Array.t structure ptr ->
      PackedInt64Array.t structure ptr ->
      unit
    (** Returns a new [PackedInt64Array] with contents of [param right] added at the end of this array. For better performance, consider using [method append_array] instead. *)
  end

  module type PACKEDFLOAT32ARRAY = sig
    type t

    include Api_types.API_TYPE with type t := t

    val size :
      BuiltinClass0.PackedFloat32Array.t structure ptr ->
      BuiltinClass0.Int.t structure ptr
    (** Returns the number of elements in the array. *)

    val is_empty :
      BuiltinClass0.PackedFloat32Array.t structure ptr ->
      BuiltinClass0.Bool.t structure ptr
    (** Returns [code]true[/code] if the array is empty. *)

    val set :
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.Float.t structure ptr ->
      BuiltinClass0.PackedFloat32Array.t structure ptr ->
      unit
    (** Changes the float at the given index. *)

    val push_back :
      BuiltinClass0.Float.t structure ptr ->
      BuiltinClass0.PackedFloat32Array.t structure ptr ->
      BuiltinClass0.Bool.t structure ptr
    (** Appends an element at the end of the array. *)

    val append :
      BuiltinClass0.Float.t structure ptr ->
      BuiltinClass0.PackedFloat32Array.t structure ptr ->
      BuiltinClass0.Bool.t structure ptr
    (** Appends an element at the end of the array (alias of [method push_back]). *)

    val append_array :
      BuiltinClass0.PackedFloat32Array.t structure ptr ->
      BuiltinClass0.PackedFloat32Array.t structure ptr ->
      unit
    (** Appends a [PackedFloat32Array] at the end of this array. *)

    val remove_at :
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.PackedFloat32Array.t structure ptr ->
      unit
    (** Removes an element from the array by index. *)

    val insert :
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.Float.t structure ptr ->
      BuiltinClass0.PackedFloat32Array.t structure ptr ->
      BuiltinClass0.Int.t structure ptr
    (** Inserts a new element at a given position in the array. The position must be valid, or at the end of the array ([code]idx == size()[/code]). *)

    val fill :
      BuiltinClass0.Float.t structure ptr ->
      BuiltinClass0.PackedFloat32Array.t structure ptr ->
      unit
    (** Assigns the given value to all elements in the array. This can typically be used together with [method resize] to create an array with a given size and initialized elements. *)

    val resize :
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.PackedFloat32Array.t structure ptr ->
      BuiltinClass0.Int.t structure ptr
    (** Sets the size of the array. If the array is grown, reserves elements at the end of the array. If the array is shrunk, truncates the array to the new size. Calling [method resize] once and assigning the new values is faster than adding new elements one by one. *)

    val clear : BuiltinClass0.PackedFloat32Array.t structure ptr -> unit
    (** Clears the array. This is equivalent to using [method resize] with a size of [code]0[/code]. *)

    val has :
      BuiltinClass0.Float.t structure ptr ->
      BuiltinClass0.PackedFloat32Array.t structure ptr ->
      BuiltinClass0.Bool.t structure ptr
    (** Returns [code]true[/code] if the array contains [param value].
[b]Note:[/b] [constant @GDScript.NAN] doesn't behave the same as other numbers. Therefore, the results from this method may not be accurate if NaNs are included. *)

    val reverse : BuiltinClass0.PackedFloat32Array.t structure ptr -> unit
    (** Reverses the order of the elements in the array. *)

    val slice :
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.PackedFloat32Array.t structure ptr ->
      BuiltinClass0.PackedFloat32Array.t structure ptr
    (** Returns the slice of the [PackedFloat32Array], from [param begin] (inclusive) to [param end] (exclusive), as a new [PackedFloat32Array].
The absolute value of [param begin] and [param end] will be clamped to the array size, so the default value for [param end] makes it slice to the size of the array by default (i.e. [code]arr.slice(1)[/code] is a shorthand for [code]arr.slice(1, arr.size())[/code]).
If either [param begin] or [param end] are negative, they will be relative to the end of the array (i.e. [code]arr.slice(0, -2)[/code] is a shorthand for [code]arr.slice(0, arr.size() - 2)[/code]). *)

    val to_byte_array :
      BuiltinClass0.PackedFloat32Array.t structure ptr ->
      BuiltinClass0.PackedByteArray.t structure ptr
    (** Returns a copy of the data converted to a [PackedByteArray], where each element have been encoded as 4 bytes.
The size of the new array will be [code]float32_array.size()  *  4[/code]. *)

    val sort : BuiltinClass0.PackedFloat32Array.t structure ptr -> unit
    (** Sorts the elements of the array in ascending order.
[b]Note:[/b] [constant @GDScript.NAN] doesn't behave the same as other numbers. Therefore, the results from this method may not be accurate if NaNs are included. *)

    val bsearch :
      BuiltinClass0.Float.t structure ptr ->
      BuiltinClass0.Bool.t structure ptr ->
      BuiltinClass0.PackedFloat32Array.t structure ptr ->
      BuiltinClass0.Int.t structure ptr
    (** Finds the index of an existing value (or the insertion index that maintains sorting order, if the value is not yet present in the array) using binary search. Optionally, a [param before] specifier can be passed. If [code]false[/code], the returned index comes after all existing entries of the value in the array.
[b]Note:[/b] Calling [method bsearch] on an unsorted array results in unexpected behavior.
[b]Note:[/b] [constant @GDScript.NAN] doesn't behave the same as other numbers. Therefore, the results from this method may not be accurate if NaNs are included. *)

    val duplicate :
      BuiltinClass0.PackedFloat32Array.t structure ptr ->
      BuiltinClass0.PackedFloat32Array.t structure ptr
    (** Creates a copy of the array, and returns it. *)

    val find :
      BuiltinClass0.Float.t structure ptr ->
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.PackedFloat32Array.t structure ptr ->
      BuiltinClass0.Int.t structure ptr
    (** Searches the array for a value and returns its index or [code]-1[/code] if not found. Optionally, the initial search index can be passed.
[b]Note:[/b] [constant @GDScript.NAN] doesn't behave the same as other numbers. Therefore, the results from this method may not be accurate if NaNs are included. *)

    val rfind :
      BuiltinClass0.Float.t structure ptr ->
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.PackedFloat32Array.t structure ptr ->
      BuiltinClass0.Int.t structure ptr
    (** Searches the array in reverse order. Optionally, a start search index can be passed. If negative, the start index is considered relative to the end of the array.
[b]Note:[/b] [constant @GDScript.NAN] doesn't behave the same as other numbers. Therefore, the results from this method may not be accurate if NaNs are included. *)

    val count :
      BuiltinClass0.Float.t structure ptr ->
      BuiltinClass0.PackedFloat32Array.t structure ptr ->
      BuiltinClass0.Int.t structure ptr
    (** Returns the number of times an element is in the array.
[b]Note:[/b] [constant @GDScript.NAN] doesn't behave the same as other numbers. Therefore, the results from this method may not be accurate if NaNs are included. *)

    val not :
      PackedFloat32Array.t structure ptr ->
      PackedFloat32Array.t structure ptr ->
      Bool.t structure ptr ->
      unit

    val _PackedFloat32Array_elem_Dictionary :
      PackedFloat32Array.t structure ptr ->
      Dictionary.t structure ptr ->
      Bool.t structure ptr ->
      unit

    val _PackedFloat32Array_elem_Array :
      PackedFloat32Array.t structure ptr ->
      Array.t structure ptr ->
      Bool.t structure ptr ->
      unit

    val ( = ) :
      PackedFloat32Array.t structure ptr ->
      PackedFloat32Array.t structure ptr ->
      Bool.t structure ptr ->
      unit
    (** Returns [code]true[/code] if contents of both arrays are the same, i.e. they have all equal floats at the corresponding indices. *)

    val ( <> ) :
      PackedFloat32Array.t structure ptr ->
      PackedFloat32Array.t structure ptr ->
      Bool.t structure ptr ->
      unit
    (** Returns [code]true[/code] if contents of the arrays differ. *)

    val ( + ) :
      PackedFloat32Array.t structure ptr ->
      PackedFloat32Array.t structure ptr ->
      PackedFloat32Array.t structure ptr ->
      unit
    (** Returns a new [PackedFloat32Array] with contents of [param right] added at the end of this array. For better performance, consider using [method append_array] instead. *)
  end

  module type PACKEDFLOAT64ARRAY = sig
    type t

    include Api_types.API_TYPE with type t := t

    val size :
      BuiltinClass0.PackedFloat64Array.t structure ptr ->
      BuiltinClass0.Int.t structure ptr
    (** Returns the number of elements in the array. *)

    val is_empty :
      BuiltinClass0.PackedFloat64Array.t structure ptr ->
      BuiltinClass0.Bool.t structure ptr
    (** Returns [code]true[/code] if the array is empty. *)

    val set :
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.Float.t structure ptr ->
      BuiltinClass0.PackedFloat64Array.t structure ptr ->
      unit
    (** Changes the float at the given index. *)

    val push_back :
      BuiltinClass0.Float.t structure ptr ->
      BuiltinClass0.PackedFloat64Array.t structure ptr ->
      BuiltinClass0.Bool.t structure ptr
    (** Appends an element at the end of the array. *)

    val append :
      BuiltinClass0.Float.t structure ptr ->
      BuiltinClass0.PackedFloat64Array.t structure ptr ->
      BuiltinClass0.Bool.t structure ptr
    (** Appends an element at the end of the array (alias of [method push_back]). *)

    val append_array :
      BuiltinClass0.PackedFloat64Array.t structure ptr ->
      BuiltinClass0.PackedFloat64Array.t structure ptr ->
      unit
    (** Appends a [PackedFloat64Array] at the end of this array. *)

    val remove_at :
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.PackedFloat64Array.t structure ptr ->
      unit
    (** Removes an element from the array by index. *)

    val insert :
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.Float.t structure ptr ->
      BuiltinClass0.PackedFloat64Array.t structure ptr ->
      BuiltinClass0.Int.t structure ptr
    (** Inserts a new element at a given position in the array. The position must be valid, or at the end of the array ([code]idx == size()[/code]). *)

    val fill :
      BuiltinClass0.Float.t structure ptr ->
      BuiltinClass0.PackedFloat64Array.t structure ptr ->
      unit
    (** Assigns the given value to all elements in the array. This can typically be used together with [method resize] to create an array with a given size and initialized elements. *)

    val resize :
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.PackedFloat64Array.t structure ptr ->
      BuiltinClass0.Int.t structure ptr
    (** Sets the size of the array. If the array is grown, reserves elements at the end of the array. If the array is shrunk, truncates the array to the new size. Calling [method resize] once and assigning the new values is faster than adding new elements one by one. *)

    val clear : BuiltinClass0.PackedFloat64Array.t structure ptr -> unit
    (** Clears the array. This is equivalent to using [method resize] with a size of [code]0[/code]. *)

    val has :
      BuiltinClass0.Float.t structure ptr ->
      BuiltinClass0.PackedFloat64Array.t structure ptr ->
      BuiltinClass0.Bool.t structure ptr
    (** Returns [code]true[/code] if the array contains [param value].
[b]Note:[/b] [constant @GDScript.NAN] doesn't behave the same as other numbers. Therefore, the results from this method may not be accurate if NaNs are included. *)

    val reverse : BuiltinClass0.PackedFloat64Array.t structure ptr -> unit
    (** Reverses the order of the elements in the array. *)

    val slice :
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.PackedFloat64Array.t structure ptr ->
      BuiltinClass0.PackedFloat64Array.t structure ptr
    (** Returns the slice of the [PackedFloat64Array], from [param begin] (inclusive) to [param end] (exclusive), as a new [PackedFloat64Array].
The absolute value of [param begin] and [param end] will be clamped to the array size, so the default value for [param end] makes it slice to the size of the array by default (i.e. [code]arr.slice(1)[/code] is a shorthand for [code]arr.slice(1, arr.size())[/code]).
If either [param begin] or [param end] are negative, they will be relative to the end of the array (i.e. [code]arr.slice(0, -2)[/code] is a shorthand for [code]arr.slice(0, arr.size() - 2)[/code]). *)

    val to_byte_array :
      BuiltinClass0.PackedFloat64Array.t structure ptr ->
      BuiltinClass0.PackedByteArray.t structure ptr
    (** Returns a copy of the data converted to a [PackedByteArray], where each element have been encoded as 8 bytes.
The size of the new array will be [code]float64_array.size()  *  8[/code]. *)

    val sort : BuiltinClass0.PackedFloat64Array.t structure ptr -> unit
    (** Sorts the elements of the array in ascending order.
[b]Note:[/b] [constant @GDScript.NAN] doesn't behave the same as other numbers. Therefore, the results from this method may not be accurate if NaNs are included. *)

    val bsearch :
      BuiltinClass0.Float.t structure ptr ->
      BuiltinClass0.Bool.t structure ptr ->
      BuiltinClass0.PackedFloat64Array.t structure ptr ->
      BuiltinClass0.Int.t structure ptr
    (** Finds the index of an existing value (or the insertion index that maintains sorting order, if the value is not yet present in the array) using binary search. Optionally, a [param before] specifier can be passed. If [code]false[/code], the returned index comes after all existing entries of the value in the array.
[b]Note:[/b] Calling [method bsearch] on an unsorted array results in unexpected behavior.
[b]Note:[/b] [constant @GDScript.NAN] doesn't behave the same as other numbers. Therefore, the results from this method may not be accurate if NaNs are included. *)

    val duplicate :
      BuiltinClass0.PackedFloat64Array.t structure ptr ->
      BuiltinClass0.PackedFloat64Array.t structure ptr
    (** Creates a copy of the array, and returns it. *)

    val find :
      BuiltinClass0.Float.t structure ptr ->
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.PackedFloat64Array.t structure ptr ->
      BuiltinClass0.Int.t structure ptr
    (** Searches the array for a value and returns its index or [code]-1[/code] if not found. Optionally, the initial search index can be passed.
[b]Note:[/b] [constant @GDScript.NAN] doesn't behave the same as other numbers. Therefore, the results from this method may not be accurate if NaNs are included. *)

    val rfind :
      BuiltinClass0.Float.t structure ptr ->
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.PackedFloat64Array.t structure ptr ->
      BuiltinClass0.Int.t structure ptr
    (** Searches the array in reverse order. Optionally, a start search index can be passed. If negative, the start index is considered relative to the end of the array.
[b]Note:[/b] [constant @GDScript.NAN] doesn't behave the same as other numbers. Therefore, the results from this method may not be accurate if NaNs are included. *)

    val count :
      BuiltinClass0.Float.t structure ptr ->
      BuiltinClass0.PackedFloat64Array.t structure ptr ->
      BuiltinClass0.Int.t structure ptr
    (** Returns the number of times an element is in the array.
[b]Note:[/b] [constant @GDScript.NAN] doesn't behave the same as other numbers. Therefore, the results from this method may not be accurate if NaNs are included. *)

    val not :
      PackedFloat64Array.t structure ptr ->
      PackedFloat64Array.t structure ptr ->
      Bool.t structure ptr ->
      unit

    val _PackedFloat64Array_elem_Dictionary :
      PackedFloat64Array.t structure ptr ->
      Dictionary.t structure ptr ->
      Bool.t structure ptr ->
      unit

    val _PackedFloat64Array_elem_Array :
      PackedFloat64Array.t structure ptr ->
      Array.t structure ptr ->
      Bool.t structure ptr ->
      unit

    val ( = ) :
      PackedFloat64Array.t structure ptr ->
      PackedFloat64Array.t structure ptr ->
      Bool.t structure ptr ->
      unit
    (** Returns [code]true[/code] if contents of both arrays are the same, i.e. they have all equal doubles at the corresponding indices. *)

    val ( <> ) :
      PackedFloat64Array.t structure ptr ->
      PackedFloat64Array.t structure ptr ->
      Bool.t structure ptr ->
      unit
    (** Returns [code]true[/code] if contents of the arrays differ. *)

    val ( + ) :
      PackedFloat64Array.t structure ptr ->
      PackedFloat64Array.t structure ptr ->
      PackedFloat64Array.t structure ptr ->
      unit
    (** Returns a new [PackedFloat64Array] with contents of [param right] added at the end of this array. For better performance, consider using [method append_array] instead. *)
  end

  module type PACKEDSTRINGARRAY = sig
    type t

    include Api_types.API_TYPE with type t := t

    val size :
      BuiltinClass0.PackedStringArray.t structure ptr ->
      BuiltinClass0.Int.t structure ptr
    (** Returns the number of elements in the array. *)

    val is_empty :
      BuiltinClass0.PackedStringArray.t structure ptr ->
      BuiltinClass0.Bool.t structure ptr
    (** Returns [code]true[/code] if the array is empty. *)

    val set :
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.String.t structure ptr ->
      BuiltinClass0.PackedStringArray.t structure ptr ->
      unit
    (** Changes the [String] at the given index. *)

    val push_back :
      BuiltinClass0.String.t structure ptr ->
      BuiltinClass0.PackedStringArray.t structure ptr ->
      BuiltinClass0.Bool.t structure ptr
    (** Appends a string element at end of the array. *)

    val append :
      BuiltinClass0.String.t structure ptr ->
      BuiltinClass0.PackedStringArray.t structure ptr ->
      BuiltinClass0.Bool.t structure ptr
    (** Appends an element at the end of the array (alias of [method push_back]). *)

    val append_array :
      BuiltinClass0.PackedStringArray.t structure ptr ->
      BuiltinClass0.PackedStringArray.t structure ptr ->
      unit
    (** Appends a [PackedStringArray] at the end of this array. *)

    val remove_at :
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.PackedStringArray.t structure ptr ->
      unit
    (** Removes an element from the array by index. *)

    val insert :
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.String.t structure ptr ->
      BuiltinClass0.PackedStringArray.t structure ptr ->
      BuiltinClass0.Int.t structure ptr
    (** Inserts a new element at a given position in the array. The position must be valid, or at the end of the array ([code]idx == size()[/code]). *)

    val fill :
      BuiltinClass0.String.t structure ptr ->
      BuiltinClass0.PackedStringArray.t structure ptr ->
      unit
    (** Assigns the given value to all elements in the array. This can typically be used together with [method resize] to create an array with a given size and initialized elements. *)

    val resize :
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.PackedStringArray.t structure ptr ->
      BuiltinClass0.Int.t structure ptr
    (** Sets the size of the array. If the array is grown, reserves elements at the end of the array. If the array is shrunk, truncates the array to the new size. Calling [method resize] once and assigning the new values is faster than adding new elements one by one. *)

    val clear : BuiltinClass0.PackedStringArray.t structure ptr -> unit
    (** Clears the array. This is equivalent to using [method resize] with a size of [code]0[/code]. *)

    val has :
      BuiltinClass0.String.t structure ptr ->
      BuiltinClass0.PackedStringArray.t structure ptr ->
      BuiltinClass0.Bool.t structure ptr
    (** Returns [code]true[/code] if the array contains [param value]. *)

    val reverse : BuiltinClass0.PackedStringArray.t structure ptr -> unit
    (** Reverses the order of the elements in the array. *)

    val slice :
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.PackedStringArray.t structure ptr ->
      BuiltinClass0.PackedStringArray.t structure ptr
    (** Returns the slice of the [PackedStringArray], from [param begin] (inclusive) to [param end] (exclusive), as a new [PackedStringArray].
The absolute value of [param begin] and [param end] will be clamped to the array size, so the default value for [param end] makes it slice to the size of the array by default (i.e. [code]arr.slice(1)[/code] is a shorthand for [code]arr.slice(1, arr.size())[/code]).
If either [param begin] or [param end] are negative, they will be relative to the end of the array (i.e. [code]arr.slice(0, -2)[/code] is a shorthand for [code]arr.slice(0, arr.size() - 2)[/code]). *)

    val to_byte_array :
      BuiltinClass0.PackedStringArray.t structure ptr ->
      BuiltinClass0.PackedByteArray.t structure ptr
    (** Returns a [PackedByteArray] with each string encoded as bytes. *)

    val sort : BuiltinClass0.PackedStringArray.t structure ptr -> unit
    (** Sorts the elements of the array in ascending order. *)

    val bsearch :
      BuiltinClass0.String.t structure ptr ->
      BuiltinClass0.Bool.t structure ptr ->
      BuiltinClass0.PackedStringArray.t structure ptr ->
      BuiltinClass0.Int.t structure ptr
    (** Finds the index of an existing value (or the insertion index that maintains sorting order, if the value is not yet present in the array) using binary search. Optionally, a [param before] specifier can be passed. If [code]false[/code], the returned index comes after all existing entries of the value in the array.
[b]Note:[/b] Calling [method bsearch] on an unsorted array results in unexpected behavior. *)

    val duplicate :
      BuiltinClass0.PackedStringArray.t structure ptr ->
      BuiltinClass0.PackedStringArray.t structure ptr
    (** Creates a copy of the array, and returns it. *)

    val find :
      BuiltinClass0.String.t structure ptr ->
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.PackedStringArray.t structure ptr ->
      BuiltinClass0.Int.t structure ptr
    (** Searches the array for a value and returns its index or [code]-1[/code] if not found. Optionally, the initial search index can be passed. *)

    val rfind :
      BuiltinClass0.String.t structure ptr ->
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.PackedStringArray.t structure ptr ->
      BuiltinClass0.Int.t structure ptr
    (** Searches the array in reverse order. Optionally, a start search index can be passed. If negative, the start index is considered relative to the end of the array. *)

    val count :
      BuiltinClass0.String.t structure ptr ->
      BuiltinClass0.PackedStringArray.t structure ptr ->
      BuiltinClass0.Int.t structure ptr
    (** Returns the number of times an element is in the array. *)

    val not :
      PackedStringArray.t structure ptr ->
      PackedStringArray.t structure ptr ->
      Bool.t structure ptr ->
      unit

    val _PackedStringArray_elem_Dictionary :
      PackedStringArray.t structure ptr ->
      Dictionary.t structure ptr ->
      Bool.t structure ptr ->
      unit

    val _PackedStringArray_elem_Array :
      PackedStringArray.t structure ptr ->
      Array.t structure ptr ->
      Bool.t structure ptr ->
      unit

    val ( = ) :
      PackedStringArray.t structure ptr ->
      PackedStringArray.t structure ptr ->
      Bool.t structure ptr ->
      unit
    (** Returns [code]true[/code] if contents of both arrays are the same, i.e. they have all equal [String]s at the corresponding indices. *)

    val ( <> ) :
      PackedStringArray.t structure ptr ->
      PackedStringArray.t structure ptr ->
      Bool.t structure ptr ->
      unit
    (** Returns [code]true[/code] if contents of the arrays differ. *)

    val ( + ) :
      PackedStringArray.t structure ptr ->
      PackedStringArray.t structure ptr ->
      PackedStringArray.t structure ptr ->
      unit
    (** Returns a new [PackedStringArray] with contents of [param right] added at the end of this array. For better performance, consider using [method append_array] instead. *)
  end

  module type PACKEDVECTOR2ARRAY = sig
    type t

    include Api_types.API_TYPE with type t := t

    val size :
      BuiltinClass0.PackedVector2Array.t structure ptr ->
      BuiltinClass0.Int.t structure ptr
    (** Returns the number of elements in the array. *)

    val is_empty :
      BuiltinClass0.PackedVector2Array.t structure ptr ->
      BuiltinClass0.Bool.t structure ptr
    (** Returns [code]true[/code] if the array is empty. *)

    val set :
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.Vector2.t structure ptr ->
      BuiltinClass0.PackedVector2Array.t structure ptr ->
      unit
    (** Changes the [Vector2] at the given index. *)

    val push_back :
      BuiltinClass0.Vector2.t structure ptr ->
      BuiltinClass0.PackedVector2Array.t structure ptr ->
      BuiltinClass0.Bool.t structure ptr
    (** Inserts a [Vector2] at the end. *)

    val append :
      BuiltinClass0.Vector2.t structure ptr ->
      BuiltinClass0.PackedVector2Array.t structure ptr ->
      BuiltinClass0.Bool.t structure ptr
    (** Appends an element at the end of the array (alias of [method push_back]). *)

    val append_array :
      BuiltinClass0.PackedVector2Array.t structure ptr ->
      BuiltinClass0.PackedVector2Array.t structure ptr ->
      unit
    (** Appends a [PackedVector2Array] at the end of this array. *)

    val remove_at :
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.PackedVector2Array.t structure ptr ->
      unit
    (** Removes an element from the array by index. *)

    val insert :
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.Vector2.t structure ptr ->
      BuiltinClass0.PackedVector2Array.t structure ptr ->
      BuiltinClass0.Int.t structure ptr
    (** Inserts a new element at a given position in the array. The position must be valid, or at the end of the array ([code]idx == size()[/code]). *)

    val fill :
      BuiltinClass0.Vector2.t structure ptr ->
      BuiltinClass0.PackedVector2Array.t structure ptr ->
      unit
    (** Assigns the given value to all elements in the array. This can typically be used together with [method resize] to create an array with a given size and initialized elements. *)

    val resize :
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.PackedVector2Array.t structure ptr ->
      BuiltinClass0.Int.t structure ptr
    (** Sets the size of the array. If the array is grown, reserves elements at the end of the array. If the array is shrunk, truncates the array to the new size. Calling [method resize] once and assigning the new values is faster than adding new elements one by one. *)

    val clear : BuiltinClass0.PackedVector2Array.t structure ptr -> unit
    (** Clears the array. This is equivalent to using [method resize] with a size of [code]0[/code]. *)

    val has :
      BuiltinClass0.Vector2.t structure ptr ->
      BuiltinClass0.PackedVector2Array.t structure ptr ->
      BuiltinClass0.Bool.t structure ptr
    (** Returns [code]true[/code] if the array contains [param value].
[b]Note:[/b] Vectors with [constant @GDScript.NAN] elements don't behave the same as other vectors. Therefore, the results from this method may not be accurate if NaNs are included. *)

    val reverse : BuiltinClass0.PackedVector2Array.t structure ptr -> unit
    (** Reverses the order of the elements in the array. *)

    val slice :
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.PackedVector2Array.t structure ptr ->
      BuiltinClass0.PackedVector2Array.t structure ptr
    (** Returns the slice of the [PackedVector2Array], from [param begin] (inclusive) to [param end] (exclusive), as a new [PackedVector2Array].
The absolute value of [param begin] and [param end] will be clamped to the array size, so the default value for [param end] makes it slice to the size of the array by default (i.e. [code]arr.slice(1)[/code] is a shorthand for [code]arr.slice(1, arr.size())[/code]).
If either [param begin] or [param end] are negative, they will be relative to the end of the array (i.e. [code]arr.slice(0, -2)[/code] is a shorthand for [code]arr.slice(0, arr.size() - 2)[/code]). *)

    val to_byte_array :
      BuiltinClass0.PackedVector2Array.t structure ptr ->
      BuiltinClass0.PackedByteArray.t structure ptr
    (** Returns a [PackedByteArray] with each vector encoded as bytes. *)

    val sort : BuiltinClass0.PackedVector2Array.t structure ptr -> unit
    (** Sorts the elements of the array in ascending order.
[b]Note:[/b] Vectors with [constant @GDScript.NAN] elements don't behave the same as other vectors. Therefore, the results from this method may not be accurate if NaNs are included. *)

    val bsearch :
      BuiltinClass0.Vector2.t structure ptr ->
      BuiltinClass0.Bool.t structure ptr ->
      BuiltinClass0.PackedVector2Array.t structure ptr ->
      BuiltinClass0.Int.t structure ptr
    (** Finds the index of an existing value (or the insertion index that maintains sorting order, if the value is not yet present in the array) using binary search. Optionally, a [param before] specifier can be passed. If [code]false[/code], the returned index comes after all existing entries of the value in the array.
[b]Note:[/b] Calling [method bsearch] on an unsorted array results in unexpected behavior.
[b]Note:[/b] Vectors with [constant @GDScript.NAN] elements don't behave the same as other vectors. Therefore, the results from this method may not be accurate if NaNs are included. *)

    val duplicate :
      BuiltinClass0.PackedVector2Array.t structure ptr ->
      BuiltinClass0.PackedVector2Array.t structure ptr
    (** Creates a copy of the array, and returns it. *)

    val find :
      BuiltinClass0.Vector2.t structure ptr ->
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.PackedVector2Array.t structure ptr ->
      BuiltinClass0.Int.t structure ptr
    (** Searches the array for a value and returns its index or [code]-1[/code] if not found. Optionally, the initial search index can be passed.
[b]Note:[/b] Vectors with [constant @GDScript.NAN] elements don't behave the same as other vectors. Therefore, the results from this method may not be accurate if NaNs are included. *)

    val rfind :
      BuiltinClass0.Vector2.t structure ptr ->
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.PackedVector2Array.t structure ptr ->
      BuiltinClass0.Int.t structure ptr
    (** Searches the array in reverse order. Optionally, a start search index can be passed. If negative, the start index is considered relative to the end of the array.
[b]Note:[/b] Vectors with [constant @GDScript.NAN] elements don't behave the same as other vectors. Therefore, the results from this method may not be accurate if NaNs are included. *)

    val count :
      BuiltinClass0.Vector2.t structure ptr ->
      BuiltinClass0.PackedVector2Array.t structure ptr ->
      BuiltinClass0.Int.t structure ptr
    (** Returns the number of times an element is in the array.
[b]Note:[/b] Vectors with [constant @GDScript.NAN] elements don't behave the same as other vectors. Therefore, the results from this method may not be accurate if NaNs are included. *)

    val not :
      PackedVector2Array.t structure ptr ->
      PackedVector2Array.t structure ptr ->
      Bool.t structure ptr ->
      unit

    val _PackedVector2Array_elem_Dictionary :
      PackedVector2Array.t structure ptr ->
      Dictionary.t structure ptr ->
      Bool.t structure ptr ->
      unit

    val _PackedVector2Array_elem_Array :
      PackedVector2Array.t structure ptr ->
      Array.t structure ptr ->
      Bool.t structure ptr ->
      unit

    val ( = ) :
      PackedVector2Array.t structure ptr ->
      PackedVector2Array.t structure ptr ->
      Bool.t structure ptr ->
      unit
    (** Returns [code]true[/code] if contents of both arrays are the same, i.e. they have all equal [Vector2]s at the corresponding indices. *)

    val ( <> ) :
      PackedVector2Array.t structure ptr ->
      PackedVector2Array.t structure ptr ->
      Bool.t structure ptr ->
      unit
    (** Returns [code]true[/code] if contents of the arrays differ. *)

    val ( + ) :
      PackedVector2Array.t structure ptr ->
      PackedVector2Array.t structure ptr ->
      PackedVector2Array.t structure ptr ->
      unit
    (** Returns a new [PackedVector2Array] with contents of [param right] added at the end of this array. For better performance, consider using [method append_array] instead. *)
  end

  module type PACKEDVECTOR3ARRAY = sig
    type t

    include Api_types.API_TYPE with type t := t

    val size :
      BuiltinClass0.PackedVector3Array.t structure ptr ->
      BuiltinClass0.Int.t structure ptr
    (** Returns the number of elements in the array. *)

    val is_empty :
      BuiltinClass0.PackedVector3Array.t structure ptr ->
      BuiltinClass0.Bool.t structure ptr
    (** Returns [code]true[/code] if the array is empty. *)

    val set :
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.Vector3.t structure ptr ->
      BuiltinClass0.PackedVector3Array.t structure ptr ->
      unit
    (** Changes the [Vector3] at the given index. *)

    val push_back :
      BuiltinClass0.Vector3.t structure ptr ->
      BuiltinClass0.PackedVector3Array.t structure ptr ->
      BuiltinClass0.Bool.t structure ptr
    (** Inserts a [Vector3] at the end. *)

    val append :
      BuiltinClass0.Vector3.t structure ptr ->
      BuiltinClass0.PackedVector3Array.t structure ptr ->
      BuiltinClass0.Bool.t structure ptr
    (** Appends an element at the end of the array (alias of [method push_back]). *)

    val append_array :
      BuiltinClass0.PackedVector3Array.t structure ptr ->
      BuiltinClass0.PackedVector3Array.t structure ptr ->
      unit
    (** Appends a [PackedVector3Array] at the end of this array. *)

    val remove_at :
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.PackedVector3Array.t structure ptr ->
      unit
    (** Removes an element from the array by index. *)

    val insert :
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.Vector3.t structure ptr ->
      BuiltinClass0.PackedVector3Array.t structure ptr ->
      BuiltinClass0.Int.t structure ptr
    (** Inserts a new element at a given position in the array. The position must be valid, or at the end of the array ([code]idx == size()[/code]). *)

    val fill :
      BuiltinClass0.Vector3.t structure ptr ->
      BuiltinClass0.PackedVector3Array.t structure ptr ->
      unit
    (** Assigns the given value to all elements in the array. This can typically be used together with [method resize] to create an array with a given size and initialized elements. *)

    val resize :
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.PackedVector3Array.t structure ptr ->
      BuiltinClass0.Int.t structure ptr
    (** Sets the size of the array. If the array is grown, reserves elements at the end of the array. If the array is shrunk, truncates the array to the new size. Calling [method resize] once and assigning the new values is faster than adding new elements one by one. *)

    val clear : BuiltinClass0.PackedVector3Array.t structure ptr -> unit
    (** Clears the array. This is equivalent to using [method resize] with a size of [code]0[/code]. *)

    val has :
      BuiltinClass0.Vector3.t structure ptr ->
      BuiltinClass0.PackedVector3Array.t structure ptr ->
      BuiltinClass0.Bool.t structure ptr
    (** Returns [code]true[/code] if the array contains [param value].
[b]Note:[/b] Vectors with [constant @GDScript.NAN] elements don't behave the same as other vectors. Therefore, the results from this method may not be accurate if NaNs are included. *)

    val reverse : BuiltinClass0.PackedVector3Array.t structure ptr -> unit
    (** Reverses the order of the elements in the array. *)

    val slice :
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.PackedVector3Array.t structure ptr ->
      BuiltinClass0.PackedVector3Array.t structure ptr
    (** Returns the slice of the [PackedVector3Array], from [param begin] (inclusive) to [param end] (exclusive), as a new [PackedVector3Array].
The absolute value of [param begin] and [param end] will be clamped to the array size, so the default value for [param end] makes it slice to the size of the array by default (i.e. [code]arr.slice(1)[/code] is a shorthand for [code]arr.slice(1, arr.size())[/code]).
If either [param begin] or [param end] are negative, they will be relative to the end of the array (i.e. [code]arr.slice(0, -2)[/code] is a shorthand for [code]arr.slice(0, arr.size() - 2)[/code]). *)

    val to_byte_array :
      BuiltinClass0.PackedVector3Array.t structure ptr ->
      BuiltinClass0.PackedByteArray.t structure ptr
    (** Returns a [PackedByteArray] with each vector encoded as bytes. *)

    val sort : BuiltinClass0.PackedVector3Array.t structure ptr -> unit
    (** Sorts the elements of the array in ascending order.
[b]Note:[/b] Vectors with [constant @GDScript.NAN] elements don't behave the same as other vectors. Therefore, the results from this method may not be accurate if NaNs are included. *)

    val bsearch :
      BuiltinClass0.Vector3.t structure ptr ->
      BuiltinClass0.Bool.t structure ptr ->
      BuiltinClass0.PackedVector3Array.t structure ptr ->
      BuiltinClass0.Int.t structure ptr
    (** Finds the index of an existing value (or the insertion index that maintains sorting order, if the value is not yet present in the array) using binary search. Optionally, a [param before] specifier can be passed. If [code]false[/code], the returned index comes after all existing entries of the value in the array.
[b]Note:[/b] Calling [method bsearch] on an unsorted array results in unexpected behavior.
[b]Note:[/b] Vectors with [constant @GDScript.NAN] elements don't behave the same as other vectors. Therefore, the results from this method may not be accurate if NaNs are included. *)

    val duplicate :
      BuiltinClass0.PackedVector3Array.t structure ptr ->
      BuiltinClass0.PackedVector3Array.t structure ptr
    (** Creates a copy of the array, and returns it. *)

    val find :
      BuiltinClass0.Vector3.t structure ptr ->
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.PackedVector3Array.t structure ptr ->
      BuiltinClass0.Int.t structure ptr
    (** Searches the array for a value and returns its index or [code]-1[/code] if not found. Optionally, the initial search index can be passed.
[b]Note:[/b] Vectors with [constant @GDScript.NAN] elements don't behave the same as other vectors. Therefore, the results from this method may not be accurate if NaNs are included. *)

    val rfind :
      BuiltinClass0.Vector3.t structure ptr ->
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.PackedVector3Array.t structure ptr ->
      BuiltinClass0.Int.t structure ptr
    (** Searches the array in reverse order. Optionally, a start search index can be passed. If negative, the start index is considered relative to the end of the array.
[b]Note:[/b] Vectors with [constant @GDScript.NAN] elements don't behave the same as other vectors. Therefore, the results from this method may not be accurate if NaNs are included. *)

    val count :
      BuiltinClass0.Vector3.t structure ptr ->
      BuiltinClass0.PackedVector3Array.t structure ptr ->
      BuiltinClass0.Int.t structure ptr
    (** Returns the number of times an element is in the array.
[b]Note:[/b] Vectors with [constant @GDScript.NAN] elements don't behave the same as other vectors. Therefore, the results from this method may not be accurate if NaNs are included. *)

    val not :
      PackedVector3Array.t structure ptr ->
      PackedVector3Array.t structure ptr ->
      Bool.t structure ptr ->
      unit

    val _PackedVector3Array_elem_Dictionary :
      PackedVector3Array.t structure ptr ->
      Dictionary.t structure ptr ->
      Bool.t structure ptr ->
      unit

    val _PackedVector3Array_elem_Array :
      PackedVector3Array.t structure ptr ->
      Array.t structure ptr ->
      Bool.t structure ptr ->
      unit

    val ( = ) :
      PackedVector3Array.t structure ptr ->
      PackedVector3Array.t structure ptr ->
      Bool.t structure ptr ->
      unit
    (** Returns [code]true[/code] if contents of both arrays are the same, i.e. they have all equal [Vector3]s at the corresponding indices. *)

    val ( <> ) :
      PackedVector3Array.t structure ptr ->
      PackedVector3Array.t structure ptr ->
      Bool.t structure ptr ->
      unit
    (** Returns [code]true[/code] if contents of the arrays differ. *)

    val ( + ) :
      PackedVector3Array.t structure ptr ->
      PackedVector3Array.t structure ptr ->
      PackedVector3Array.t structure ptr ->
      unit
    (** Returns a new [PackedVector3Array] with contents of [param right] added at the end of this array. For better performance, consider using [method append_array] instead. *)
  end

  module type PACKEDCOLORARRAY = sig
    type t

    include Api_types.API_TYPE with type t := t

    val size :
      BuiltinClass0.PackedColorArray.t structure ptr ->
      BuiltinClass0.Int.t structure ptr
    (** Returns the number of elements in the array. *)

    val is_empty :
      BuiltinClass0.PackedColorArray.t structure ptr ->
      BuiltinClass0.Bool.t structure ptr
    (** Returns [code]true[/code] if the array is empty. *)

    val set :
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.Color.t structure ptr ->
      BuiltinClass0.PackedColorArray.t structure ptr ->
      unit
    (** Changes the [Color] at the given index. *)

    val push_back :
      BuiltinClass0.Color.t structure ptr ->
      BuiltinClass0.PackedColorArray.t structure ptr ->
      BuiltinClass0.Bool.t structure ptr
    (** Appends a value to the array. *)

    val append :
      BuiltinClass0.Color.t structure ptr ->
      BuiltinClass0.PackedColorArray.t structure ptr ->
      BuiltinClass0.Bool.t structure ptr
    (** Appends an element at the end of the array (alias of [method push_back]). *)

    val append_array :
      BuiltinClass0.PackedColorArray.t structure ptr ->
      BuiltinClass0.PackedColorArray.t structure ptr ->
      unit
    (** Appends a [PackedColorArray] at the end of this array. *)

    val remove_at :
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.PackedColorArray.t structure ptr ->
      unit
    (** Removes an element from the array by index. *)

    val insert :
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.Color.t structure ptr ->
      BuiltinClass0.PackedColorArray.t structure ptr ->
      BuiltinClass0.Int.t structure ptr
    (** Inserts a new element at a given position in the array. The position must be valid, or at the end of the array ([code]idx == size()[/code]). *)

    val fill :
      BuiltinClass0.Color.t structure ptr ->
      BuiltinClass0.PackedColorArray.t structure ptr ->
      unit
    (** Assigns the given value to all elements in the array. This can typically be used together with [method resize] to create an array with a given size and initialized elements. *)

    val resize :
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.PackedColorArray.t structure ptr ->
      BuiltinClass0.Int.t structure ptr
    (** Sets the size of the array. If the array is grown, reserves elements at the end of the array. If the array is shrunk, truncates the array to the new size. Calling [method resize] once and assigning the new values is faster than adding new elements one by one. *)

    val clear : BuiltinClass0.PackedColorArray.t structure ptr -> unit
    (** Clears the array. This is equivalent to using [method resize] with a size of [code]0[/code]. *)

    val has :
      BuiltinClass0.Color.t structure ptr ->
      BuiltinClass0.PackedColorArray.t structure ptr ->
      BuiltinClass0.Bool.t structure ptr
    (** Returns [code]true[/code] if the array contains [param value]. *)

    val reverse : BuiltinClass0.PackedColorArray.t structure ptr -> unit
    (** Reverses the order of the elements in the array. *)

    val slice :
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.PackedColorArray.t structure ptr ->
      BuiltinClass0.PackedColorArray.t structure ptr
    (** Returns the slice of the [PackedColorArray], from [param begin] (inclusive) to [param end] (exclusive), as a new [PackedColorArray].
The absolute value of [param begin] and [param end] will be clamped to the array size, so the default value for [param end] makes it slice to the size of the array by default (i.e. [code]arr.slice(1)[/code] is a shorthand for [code]arr.slice(1, arr.size())[/code]).
If either [param begin] or [param end] are negative, they will be relative to the end of the array (i.e. [code]arr.slice(0, -2)[/code] is a shorthand for [code]arr.slice(0, arr.size() - 2)[/code]). *)

    val to_byte_array :
      BuiltinClass0.PackedColorArray.t structure ptr ->
      BuiltinClass0.PackedByteArray.t structure ptr
    (** Returns a [PackedByteArray] with each color encoded as bytes. *)

    val sort : BuiltinClass0.PackedColorArray.t structure ptr -> unit
    (** Sorts the elements of the array in ascending order. *)

    val bsearch :
      BuiltinClass0.Color.t structure ptr ->
      BuiltinClass0.Bool.t structure ptr ->
      BuiltinClass0.PackedColorArray.t structure ptr ->
      BuiltinClass0.Int.t structure ptr
    (** Finds the index of an existing value (or the insertion index that maintains sorting order, if the value is not yet present in the array) using binary search. Optionally, a [param before] specifier can be passed. If [code]false[/code], the returned index comes after all existing entries of the value in the array.
[b]Note:[/b] Calling [method bsearch] on an unsorted array results in unexpected behavior. *)

    val duplicate :
      BuiltinClass0.PackedColorArray.t structure ptr ->
      BuiltinClass0.PackedColorArray.t structure ptr
    (** Creates a copy of the array, and returns it. *)

    val find :
      BuiltinClass0.Color.t structure ptr ->
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.PackedColorArray.t structure ptr ->
      BuiltinClass0.Int.t structure ptr
    (** Searches the array for a value and returns its index or [code]-1[/code] if not found. Optionally, the initial search index can be passed. *)

    val rfind :
      BuiltinClass0.Color.t structure ptr ->
      BuiltinClass0.Int.t structure ptr ->
      BuiltinClass0.PackedColorArray.t structure ptr ->
      BuiltinClass0.Int.t structure ptr
    (** Searches the array in reverse order. Optionally, a start search index can be passed. If negative, the start index is considered relative to the end of the array. *)

    val count :
      BuiltinClass0.Color.t structure ptr ->
      BuiltinClass0.PackedColorArray.t structure ptr ->
      BuiltinClass0.Int.t structure ptr
    (** Returns the number of times an element is in the array. *)

    val not :
      PackedColorArray.t structure ptr ->
      PackedColorArray.t structure ptr ->
      Bool.t structure ptr ->
      unit

    val _PackedColorArray_elem_Dictionary :
      PackedColorArray.t structure ptr ->
      Dictionary.t structure ptr ->
      Bool.t structure ptr ->
      unit

    val _PackedColorArray_elem_Array :
      PackedColorArray.t structure ptr ->
      Array.t structure ptr ->
      Bool.t structure ptr ->
      unit

    val ( = ) :
      PackedColorArray.t structure ptr ->
      PackedColorArray.t structure ptr ->
      Bool.t structure ptr ->
      unit
    (** Returns [code]true[/code] if contents of both arrays are the same, i.e. they have all equal [Color]s at the corresponding indices. *)

    val ( <> ) :
      PackedColorArray.t structure ptr ->
      PackedColorArray.t structure ptr ->
      Bool.t structure ptr ->
      unit
    (** Returns [code]true[/code] if contents of the arrays differ. *)

    val ( + ) :
      PackedColorArray.t structure ptr ->
      PackedColorArray.t structure ptr ->
      PackedColorArray.t structure ptr ->
      unit
    (** Returns a new [PackedColorArray] with contents of [param right] added at the end of this array. For better performance, consider using [method append_array] instead. *)
  end

  module Nil = struct
    include M.Nil

    let not =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_NIL None
        GlobalEnum.VariantOperator._OP_NOT
        (funptr (Nil.typ @-> Nil.typ @-> Bool.typ @-> returning void))

    let _Nil_elem_Dictionary =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_NIL
        (Some GlobalEnum.VariantType._TYPE_DICTIONARY)
        GlobalEnum.VariantOperator._OP_IN
        (funptr (Nil.typ @-> Dictionary.typ @-> Bool.typ @-> returning void))

    let _Nil_elem_Array =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_NIL
        (Some GlobalEnum.VariantType._TYPE_ARRAY)
        GlobalEnum.VariantOperator._OP_IN
        (funptr (Nil.typ @-> Array.typ @-> Bool.typ @-> returning void))
  end

  module Bool = struct
    include M.Bool

    let not =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_BOOL None
        GlobalEnum.VariantOperator._OP_NOT
        (funptr (Bool.typ @-> Bool.typ @-> Bool.typ @-> returning void))

    (** Returns [code]true[/code] if the two booleans are equal. That is, both are [code]true[/code] or both are [code]false[/code]. This operation can be seen as a logical EQ or XNOR. *)
    let ( = ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_BOOL
        (Some GlobalEnum.VariantType._TYPE_BOOL)
        GlobalEnum.VariantOperator._OP_EQUAL
        (funptr (Bool.typ @-> Bool.typ @-> Bool.typ @-> returning void))

    (** Returns [code]true[/code] if the two booleans are not equal. That is, one is [code]true[/code] and the other is [code]false[/code]. This operation can be seen as a logical XOR. *)
    let ( <> ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_BOOL
        (Some GlobalEnum.VariantType._TYPE_BOOL)
        GlobalEnum.VariantOperator._OP_NOT_EQUAL
        (funptr (Bool.typ @-> Bool.typ @-> Bool.typ @-> returning void))

    (** Returns [code]true[/code] if the left operand is [code]false[/code] and the right operand is [code]true[/code]. *)
    let ( < ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_BOOL
        (Some GlobalEnum.VariantType._TYPE_BOOL)
        GlobalEnum.VariantOperator._OP_LESS
        (funptr (Bool.typ @-> Bool.typ @-> Bool.typ @-> returning void))

    (** Returns [code]true[/code] if the left operand is [code]true[/code] and the right operand is [code]false[/code]. *)
    let ( > ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_BOOL
        (Some GlobalEnum.VariantType._TYPE_BOOL)
        GlobalEnum.VariantOperator._OP_GREATER
        (funptr (Bool.typ @-> Bool.typ @-> Bool.typ @-> returning void))

    let ( && ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_BOOL
        (Some GlobalEnum.VariantType._TYPE_BOOL)
        GlobalEnum.VariantOperator._OP_AND
        (funptr (Bool.typ @-> Bool.typ @-> Bool.typ @-> returning void))

    let ( || ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_BOOL
        (Some GlobalEnum.VariantType._TYPE_BOOL)
        GlobalEnum.VariantOperator._OP_OR
        (funptr (Bool.typ @-> Bool.typ @-> Bool.typ @-> returning void))

    let ( ~^^ ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_BOOL
        (Some GlobalEnum.VariantType._TYPE_BOOL)
        GlobalEnum.VariantOperator._OP_XOR
        (funptr (Bool.typ @-> Bool.typ @-> Bool.typ @-> returning void))

    let bool_elem_Dictionary =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_BOOL
        (Some GlobalEnum.VariantType._TYPE_DICTIONARY)
        GlobalEnum.VariantOperator._OP_IN
        (funptr (Bool.typ @-> Dictionary.typ @-> Bool.typ @-> returning void))

    let bool_elem_Array =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_BOOL
        (Some GlobalEnum.VariantType._TYPE_ARRAY)
        GlobalEnum.VariantOperator._OP_IN
        (funptr (Bool.typ @-> Array.typ @-> Bool.typ @-> returning void))
  end

  module Int = struct
    include M.Int

    (** Returns the negated value of the [int]. If positive, turns the number negative. If negative, turns the number positive. If zero, does nothing. *)
    let ( ~- ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_INT None
        GlobalEnum.VariantOperator._OP_NEGATE
        (funptr (Int.typ @-> Int.typ @-> Int.typ @-> returning void))

    (** Returns the same value as if the [code]+[/code] was not there. Unary [code]+[/code] does nothing, but sometimes it can make your code more readable. *)
    let ( ~+ ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_INT None
        GlobalEnum.VariantOperator._OP_POSITIVE
        (funptr (Int.typ @-> Int.typ @-> Int.typ @-> returning void))

    (** Performs the bitwise [code]NOT[/code] operation on the [int]. Due to [url=https://en.wikipedia.org/wiki/Two%27s_complement]2's complement[/url], it's effectively equal to [code]-(int + 1)[/code].
[codeblock]
print(~4) # Prints -5
print(~(-7)) # Prints 6
[/codeblock] *)
    let ( ~~~ ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_INT None
        GlobalEnum.VariantOperator._OP_BIT_NEGATE
        (funptr (Int.typ @-> Int.typ @-> Int.typ @-> returning void))

    let not =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_INT None
        GlobalEnum.VariantOperator._OP_NOT
        (funptr (Int.typ @-> Int.typ @-> Bool.typ @-> returning void))

    (** Returns [code]true[/code] if the two [int]s are equal. *)
    let ( = ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_INT
        (Some GlobalEnum.VariantType._TYPE_INT)
        GlobalEnum.VariantOperator._OP_EQUAL
        (funptr (Int.typ @-> Int.typ @-> Bool.typ @-> returning void))

    (** Returns [code]true[/code] if the [int]s are not equal. *)
    let ( <> ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_INT
        (Some GlobalEnum.VariantType._TYPE_INT)
        GlobalEnum.VariantOperator._OP_NOT_EQUAL
        (funptr (Int.typ @-> Int.typ @-> Bool.typ @-> returning void))

    (** Returns [code]true[/code] if the left [int] is less than the right [int]. *)
    let ( < ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_INT
        (Some GlobalEnum.VariantType._TYPE_INT)
        GlobalEnum.VariantOperator._OP_LESS
        (funptr (Int.typ @-> Int.typ @-> Bool.typ @-> returning void))

    (** Returns [code]true[/code] if the left [int] is less than or equal to the right [int]. *)
    let ( <= ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_INT
        (Some GlobalEnum.VariantType._TYPE_INT)
        GlobalEnum.VariantOperator._OP_LESS_EQUAL
        (funptr (Int.typ @-> Int.typ @-> Bool.typ @-> returning void))

    (** Returns [code]true[/code] if the left [int] is greater than the right [int]. *)
    let ( > ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_INT
        (Some GlobalEnum.VariantType._TYPE_INT)
        GlobalEnum.VariantOperator._OP_GREATER
        (funptr (Int.typ @-> Int.typ @-> Bool.typ @-> returning void))

    (** Returns [code]true[/code] if the left [int] is greater than or equal to the right [int]. *)
    let ( >= ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_INT
        (Some GlobalEnum.VariantType._TYPE_INT)
        GlobalEnum.VariantOperator._OP_GREATER_EQUAL
        (funptr (Int.typ @-> Int.typ @-> Bool.typ @-> returning void))

    (** Adds the two [int]s. *)
    let ( + ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_INT
        (Some GlobalEnum.VariantType._TYPE_INT)
        GlobalEnum.VariantOperator._OP_ADD
        (funptr (Int.typ @-> Int.typ @-> Int.typ @-> returning void))

    (** Subtracts the two [int]s. *)
    let ( - ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_INT
        (Some GlobalEnum.VariantType._TYPE_INT)
        GlobalEnum.VariantOperator._OP_SUBTRACT
        (funptr (Int.typ @-> Int.typ @-> Int.typ @-> returning void))

    (** Multiplies the two [int]s. *)
    let ( * ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_INT
        (Some GlobalEnum.VariantType._TYPE_INT)
        GlobalEnum.VariantOperator._OP_MULTIPLY
        (funptr (Int.typ @-> Int.typ @-> Int.typ @-> returning void))

    (** Divides the two [int]s. The result is an [int]. This will truncate the [float], discarding anything after the floating point.
[codeblock]
print(6 / 2) # Prints 3
print(5 / 3) # Prints 1
[/codeblock] *)
    let ( / ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_INT
        (Some GlobalEnum.VariantType._TYPE_INT)
        GlobalEnum.VariantOperator._OP_DIVIDE
        (funptr (Int.typ @-> Int.typ @-> Int.typ @-> returning void))

    (** Returns the remainder after dividing two [int]s. Uses truncated division, which returns a negative number if the dividend is negative. If this is not desired, consider using [method @GlobalScope.posmod].
[codeblock]
print(6 % 2) # Prints 0
print(11 % 4) # Prints 3
print(-5 % 3) # Prints -2
[/codeblock] *)
    let ( % ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_INT
        (Some GlobalEnum.VariantType._TYPE_INT)
        GlobalEnum.VariantOperator._OP_MODULE
        (funptr (Int.typ @-> Int.typ @-> Int.typ @-> returning void))

    (** Raises the left [int] to a power of the right [int].
[codeblock]
print(3  *  *  4) # Prints 81
[/codeblock] *)
    let ( ** ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_INT
        (Some GlobalEnum.VariantType._TYPE_INT)
        GlobalEnum.VariantOperator._OP_POWER
        (funptr (Int.typ @-> Int.typ @-> Int.typ @-> returning void))

    (** Performs the bitwise shift left operation. Effectively the same as multiplying by a power of 2.
[codeblock]
print(0b1010 << 1) # Prints 20 (binary 10100)
print(0b1010 << 3) # Prints 80 (binary 1010000)
[/codeblock] *)
    let ( <<< ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_INT
        (Some GlobalEnum.VariantType._TYPE_INT)
        GlobalEnum.VariantOperator._OP_SHIFT_LEFT
        (funptr (Int.typ @-> Int.typ @-> Int.typ @-> returning void))

    (** Performs the bitwise shift right operation. Effectively the same as dividing by a power of 2.
[codeblock]
print(0b1010 >> 1) # Prints 5 (binary 101)
print(0b1010 >> 2) # Prints 2 (binary 10)
[/codeblock] *)
    let ( >>> ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_INT
        (Some GlobalEnum.VariantType._TYPE_INT)
        GlobalEnum.VariantOperator._OP_SHIFT_RIGHT
        (funptr (Int.typ @-> Int.typ @-> Int.typ @-> returning void))

    (** Performs the bitwise [code]AND[/code] operation.
[codeblock]
print(0b1100 & 0b1010) # Prints 8 (binary 1000)
[/codeblock]
This is useful for retrieving binary flags from a variable.
[codeblock]
var flags = 0b101
# Check if the first or second bit are enabled.
if flags & 0b011:
    do_stuff() # This line will run.
[/codeblock] *)
    let ( &&& ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_INT
        (Some GlobalEnum.VariantType._TYPE_INT)
        GlobalEnum.VariantOperator._OP_BIT_AND
        (funptr (Int.typ @-> Int.typ @-> Int.typ @-> returning void))

    (** Performs the bitwise [code]OR[/code] operation.
[codeblock]
print(0b1100 | 0b1010) # Prints 14 (binary 1110)
[/codeblock]
This is useful for storing binary flags in a variable.
[codeblock]
var flags = 0
flags |= 0b101 # Turn the first and third bits on.
[/codeblock] *)
    let ( ||| ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_INT
        (Some GlobalEnum.VariantType._TYPE_INT)
        GlobalEnum.VariantOperator._OP_BIT_OR
        (funptr (Int.typ @-> Int.typ @-> Int.typ @-> returning void))

    (** Performs the bitwise [code]XOR[/code] operation.
[codeblock]
print(0b1100 ^ 0b1010) # Prints 6 (binary 110)
[/codeblock] *)
    let ( ^^^ ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_INT
        (Some GlobalEnum.VariantType._TYPE_INT)
        GlobalEnum.VariantOperator._OP_BIT_XOR
        (funptr (Int.typ @-> Int.typ @-> Int.typ @-> returning void))

    let ( && ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_INT
        (Some GlobalEnum.VariantType._TYPE_INT)
        GlobalEnum.VariantOperator._OP_AND
        (funptr (Int.typ @-> Int.typ @-> Bool.typ @-> returning void))

    let ( || ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_INT
        (Some GlobalEnum.VariantType._TYPE_INT)
        GlobalEnum.VariantOperator._OP_OR
        (funptr (Int.typ @-> Int.typ @-> Bool.typ @-> returning void))

    let ( ~^^ ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_INT
        (Some GlobalEnum.VariantType._TYPE_INT)
        GlobalEnum.VariantOperator._OP_XOR
        (funptr (Int.typ @-> Int.typ @-> Bool.typ @-> returning void))

    let int_elem_Dictionary =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_INT
        (Some GlobalEnum.VariantType._TYPE_DICTIONARY)
        GlobalEnum.VariantOperator._OP_IN
        (funptr (Int.typ @-> Dictionary.typ @-> Bool.typ @-> returning void))

    let int_elem_Array =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_INT
        (Some GlobalEnum.VariantType._TYPE_ARRAY)
        GlobalEnum.VariantOperator._OP_IN
        (funptr (Int.typ @-> Array.typ @-> Bool.typ @-> returning void))

    let int_elem_PackedByteArray =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_INT
        (Some GlobalEnum.VariantType._TYPE_PACKED_BYTE_ARRAY)
        GlobalEnum.VariantOperator._OP_IN
        (funptr
           (Int.typ @-> PackedByteArray.typ @-> Bool.typ @-> returning void))

    let int_elem_PackedInt32Array =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_INT
        (Some GlobalEnum.VariantType._TYPE_PACKED_INT32_ARRAY)
        GlobalEnum.VariantOperator._OP_IN
        (funptr
           (Int.typ @-> PackedInt32Array.typ @-> Bool.typ @-> returning void))

    let int_elem_PackedInt64Array =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_INT
        (Some GlobalEnum.VariantType._TYPE_PACKED_INT64_ARRAY)
        GlobalEnum.VariantOperator._OP_IN
        (funptr
           (Int.typ @-> PackedInt64Array.typ @-> Bool.typ @-> returning void))

    let int_elem_PackedFloat32Array =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_INT
        (Some GlobalEnum.VariantType._TYPE_PACKED_FLOAT32_ARRAY)
        GlobalEnum.VariantOperator._OP_IN
        (funptr
           (Int.typ @-> PackedFloat32Array.typ @-> Bool.typ @-> returning void))

    let int_elem_PackedFloat64Array =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_INT
        (Some GlobalEnum.VariantType._TYPE_PACKED_FLOAT64_ARRAY)
        GlobalEnum.VariantOperator._OP_IN
        (funptr
           (Int.typ @-> PackedFloat64Array.typ @-> Bool.typ @-> returning void))
  end

  module Float = struct
    include M.Float

    (** Returns the negative value of the [float]. If positive, turns the number negative. If negative, turns the number positive. With floats, the number zero can be either positive or negative. *)
    let ( ~- ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_FLOAT None
        GlobalEnum.VariantOperator._OP_NEGATE
        (funptr (Float.typ @-> Float.typ @-> Float.typ @-> returning void))

    (** Returns the same value as if the [code]+[/code] was not there. Unary [code]+[/code] does nothing, but sometimes it can make your code more readable. *)
    let ( ~+ ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_FLOAT None
        GlobalEnum.VariantOperator._OP_POSITIVE
        (funptr (Float.typ @-> Float.typ @-> Float.typ @-> returning void))

    let not =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_FLOAT None
        GlobalEnum.VariantOperator._OP_NOT
        (funptr (Float.typ @-> Float.typ @-> Bool.typ @-> returning void))

    (** Returns [code]true[/code] if both floats are exactly equal.
[b]Note:[/b] Due to floating-point precision errors, consider using [method @GlobalScope.is_equal_approx] or [method @GlobalScope.is_zero_approx] instead, which are more reliable.
[b]Note:[/b] [constant @GDScript.NAN] doesn't behave the same as other numbers. Therefore, the results from this operator may not be accurate if NaNs are included. *)
    let ( = ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_FLOAT
        (Some GlobalEnum.VariantType._TYPE_FLOAT)
        GlobalEnum.VariantOperator._OP_EQUAL
        (funptr (Float.typ @-> Float.typ @-> Bool.typ @-> returning void))

    (** Returns [code]true[/code] if two floats are different from each other.
[b]Note:[/b] [constant @GDScript.NAN] doesn't behave the same as other numbers. Therefore, the results from this operator may not be accurate if NaNs are included. *)
    let ( <> ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_FLOAT
        (Some GlobalEnum.VariantType._TYPE_FLOAT)
        GlobalEnum.VariantOperator._OP_NOT_EQUAL
        (funptr (Float.typ @-> Float.typ @-> Bool.typ @-> returning void))

    (** Returns [code]true[/code] if the left float is less than the right one.
[b]Note:[/b] [constant @GDScript.NAN] doesn't behave the same as other numbers. Therefore, the results from this operator may not be accurate if NaNs are included. *)
    let ( < ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_FLOAT
        (Some GlobalEnum.VariantType._TYPE_FLOAT)
        GlobalEnum.VariantOperator._OP_LESS
        (funptr (Float.typ @-> Float.typ @-> Bool.typ @-> returning void))

    (** Returns [code]true[/code] if the left float is less than or equal to the right one.
[b]Note:[/b] [constant @GDScript.NAN] doesn't behave the same as other numbers. Therefore, the results from this operator may not be accurate if NaNs are included. *)
    let ( <= ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_FLOAT
        (Some GlobalEnum.VariantType._TYPE_FLOAT)
        GlobalEnum.VariantOperator._OP_LESS_EQUAL
        (funptr (Float.typ @-> Float.typ @-> Bool.typ @-> returning void))

    (** Returns [code]true[/code] if the left float is greater than the right one.
[b]Note:[/b] [constant @GDScript.NAN] doesn't behave the same as other numbers. Therefore, the results from this operator may not be accurate if NaNs are included. *)
    let ( > ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_FLOAT
        (Some GlobalEnum.VariantType._TYPE_FLOAT)
        GlobalEnum.VariantOperator._OP_GREATER
        (funptr (Float.typ @-> Float.typ @-> Bool.typ @-> returning void))

    (** Returns [code]true[/code] if the left float is greater than or equal to the right one.
[b]Note:[/b] [constant @GDScript.NAN] doesn't behave the same as other numbers. Therefore, the results from this operator may not be accurate if NaNs are included. *)
    let ( >= ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_FLOAT
        (Some GlobalEnum.VariantType._TYPE_FLOAT)
        GlobalEnum.VariantOperator._OP_GREATER_EQUAL
        (funptr (Float.typ @-> Float.typ @-> Bool.typ @-> returning void))

    (** Adds two floats. *)
    let ( + ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_FLOAT
        (Some GlobalEnum.VariantType._TYPE_FLOAT)
        GlobalEnum.VariantOperator._OP_ADD
        (funptr (Float.typ @-> Float.typ @-> Float.typ @-> returning void))

    (** Subtracts a float from a float. *)
    let ( - ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_FLOAT
        (Some GlobalEnum.VariantType._TYPE_FLOAT)
        GlobalEnum.VariantOperator._OP_SUBTRACT
        (funptr (Float.typ @-> Float.typ @-> Float.typ @-> returning void))

    (** Multiplies two [float]s. *)
    let ( * ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_FLOAT
        (Some GlobalEnum.VariantType._TYPE_FLOAT)
        GlobalEnum.VariantOperator._OP_MULTIPLY
        (funptr (Float.typ @-> Float.typ @-> Float.typ @-> returning void))

    (** Divides two floats. *)
    let ( / ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_FLOAT
        (Some GlobalEnum.VariantType._TYPE_FLOAT)
        GlobalEnum.VariantOperator._OP_DIVIDE
        (funptr (Float.typ @-> Float.typ @-> Float.typ @-> returning void))

    (** Raises a [float] to a power of a [float].
[codeblock]
print(39.0625 *  * 0.25) # 2.5
[/codeblock] *)
    let ( ** ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_FLOAT
        (Some GlobalEnum.VariantType._TYPE_FLOAT)
        GlobalEnum.VariantOperator._OP_POWER
        (funptr (Float.typ @-> Float.typ @-> Float.typ @-> returning void))

    let ( && ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_FLOAT
        (Some GlobalEnum.VariantType._TYPE_FLOAT)
        GlobalEnum.VariantOperator._OP_AND
        (funptr (Float.typ @-> Float.typ @-> Bool.typ @-> returning void))

    let ( || ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_FLOAT
        (Some GlobalEnum.VariantType._TYPE_FLOAT)
        GlobalEnum.VariantOperator._OP_OR
        (funptr (Float.typ @-> Float.typ @-> Bool.typ @-> returning void))

    let ( ~^^ ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_FLOAT
        (Some GlobalEnum.VariantType._TYPE_FLOAT)
        GlobalEnum.VariantOperator._OP_XOR
        (funptr (Float.typ @-> Float.typ @-> Bool.typ @-> returning void))

    let float_elem_Dictionary =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_FLOAT
        (Some GlobalEnum.VariantType._TYPE_DICTIONARY)
        GlobalEnum.VariantOperator._OP_IN
        (funptr (Float.typ @-> Dictionary.typ @-> Bool.typ @-> returning void))

    let float_elem_Array =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_FLOAT
        (Some GlobalEnum.VariantType._TYPE_ARRAY)
        GlobalEnum.VariantOperator._OP_IN
        (funptr (Float.typ @-> Array.typ @-> Bool.typ @-> returning void))

    let float_elem_PackedByteArray =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_FLOAT
        (Some GlobalEnum.VariantType._TYPE_PACKED_BYTE_ARRAY)
        GlobalEnum.VariantOperator._OP_IN
        (funptr
           (Float.typ @-> PackedByteArray.typ @-> Bool.typ @-> returning void))

    let float_elem_PackedInt32Array =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_FLOAT
        (Some GlobalEnum.VariantType._TYPE_PACKED_INT32_ARRAY)
        GlobalEnum.VariantOperator._OP_IN
        (funptr
           (Float.typ @-> PackedInt32Array.typ @-> Bool.typ @-> returning void))

    let float_elem_PackedInt64Array =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_FLOAT
        (Some GlobalEnum.VariantType._TYPE_PACKED_INT64_ARRAY)
        GlobalEnum.VariantOperator._OP_IN
        (funptr
           (Float.typ @-> PackedInt64Array.typ @-> Bool.typ @-> returning void))

    let float_elem_PackedFloat32Array =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_FLOAT
        (Some GlobalEnum.VariantType._TYPE_PACKED_FLOAT32_ARRAY)
        GlobalEnum.VariantOperator._OP_IN
        (funptr
           (Float.typ @-> PackedFloat32Array.typ @-> Bool.typ @-> returning void))

    let float_elem_PackedFloat64Array =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_FLOAT
        (Some GlobalEnum.VariantType._TYPE_PACKED_FLOAT64_ARRAY)
        GlobalEnum.VariantOperator._OP_IN
        (funptr
           (Float.typ @-> PackedFloat64Array.typ @-> Bool.typ @-> returning void))
  end

  module String = struct
    include M.String

    (** Performs a case-sensitive comparison to another string. Returns [code]-1[/code] if less than, [code]1[/code] if greater than, or [code]0[/code] if equal. ""Less than"" and ""greater than"" are determined by the [url=https://en.wikipedia.org/wiki/List_of_Unicode_characters]Unicode code points[/url] of each string, which roughly matches the alphabetical order.
With different string lengths, returns [code]1[/code] if this string is longer than the [param to] string, or [code]-1[/code] if shorter. Note that the length of empty strings is [i]always[/i] [code]0[/code].
To get a [bool] result from a string comparison, use the [code]==[/code] operator instead. See also [method nocasecmp_to], [method naturalcasecmp_to], and [method naturalnocasecmp_to]. *)
    let casecmp_to =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_STRING "casecmp_to"
        (Base.Int64.of_string "2920860731")
        (String.typ @-> String.typ @-> returning Int.typ)
        Int.s

    (** Performs a [b]case-insensitive[/b] comparison to another string. Returns [code]-1[/code] if less than, [code]1[/code] if greater than, or [code]0[/code] if equal. ""Less than"" or ""greater than"" are determined by the [url=https://en.wikipedia.org/wiki/List_of_Unicode_characters]Unicode code points[/url] of each string, which roughly matches the alphabetical order. Internally, lowercase characters are converted to uppercase for the comparison.
With different string lengths, returns [code]1[/code] if this string is longer than the [param to] string, or [code]-1[/code] if shorter. Note that the length of empty strings is [i]always[/i] [code]0[/code].
To get a [bool] result from a string comparison, use the [code]==[/code] operator instead. See also [method casecmp_to], [method naturalcasecmp_to], and [method naturalnocasecmp_to]. *)
    let nocasecmp_to =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_STRING "nocasecmp_to"
        (Base.Int64.of_string "2920860731")
        (String.typ @-> String.typ @-> returning Int.typ)
        Int.s

    (** Performs a [b]case-sensitive[/b], [i]natural order[/i] comparison to another string. Returns [code]-1[/code] if less than, [code]1[/code] if greater than, or [code]0[/code] if equal. ""Less than"" or ""greater than"" are determined by the [url=https://en.wikipedia.org/wiki/List_of_Unicode_characters]Unicode code points[/url] of each string, which roughly matches the alphabetical order.
When used for sorting, natural order comparison orders sequences of numbers by the combined value of each digit as is often expected, instead of the single digit's value. A sorted sequence of numbered strings will be [code][""1"", ""2"", ""3"", ...][/code], not [code][""1"", ""10"", ""2"", ""3"", ...][/code].
With different string lengths, returns [code]1[/code] if this string is longer than the [param to] string, or [code]-1[/code] if shorter. Note that the length of empty strings is [i]always[/i] [code]0[/code].
To get a [bool] result from a string comparison, use the [code]==[/code] operator instead. See also [method naturalnocasecmp_to], [method nocasecmp_to], and [method casecmp_to]. *)
    let naturalcasecmp_to =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_STRING
        "naturalcasecmp_to"
        (Base.Int64.of_string "2920860731")
        (String.typ @-> String.typ @-> returning Int.typ)
        Int.s

    (** Performs a [b]case-insensitive[/b], [i]natural order[/i] comparison to another string. Returns [code]-1[/code] if less than, [code]1[/code] if greater than, or [code]0[/code] if equal. ""Less than"" or ""greater than"" are determined by the [url=https://en.wikipedia.org/wiki/List_of_Unicode_characters]Unicode code points[/url] of each string, which roughly matches the alphabetical order. Internally, lowercase characters are converted to uppercase for the comparison.
When used for sorting, natural order comparison orders sequences of numbers by the combined value of each digit as is often expected, instead of the single digit's value. A sorted sequence of numbered strings will be [code][""1"", ""2"", ""3"", ...][/code], not [code][""1"", ""10"", ""2"", ""3"", ...][/code].
With different string lengths, returns [code]1[/code] if this string is longer than the [param to] string, or [code]-1[/code] if shorter. Note that the length of empty strings is [i]always[/i] [code]0[/code].
To get a [bool] result from a string comparison, use the [code]==[/code] operator instead. See also [method naturalcasecmp_to], [method nocasecmp_to], and [method casecmp_to]. *)
    let naturalnocasecmp_to =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_STRING
        "naturalnocasecmp_to"
        (Base.Int64.of_string "2920860731")
        (String.typ @-> String.typ @-> returning Int.typ)
        Int.s

    (** Returns the number of characters in the string. Empty strings ([code]""""[/code]) always return [code]0[/code]. See also [method is_empty]. *)
    let length =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_STRING "length"
        (Base.Int64.of_string "3173160232")
        (String.typ @-> returning Int.typ)
        Int.s

    (** Returns part of the string from the position [param from] with length [param len]. If [param len] is [code]-1[/code] (as by default), returns the rest of the string starting from the given position. *)
    let substr =
      foreign_builtin_method2 GlobalEnum.VariantType._TYPE_STRING "substr"
        (Base.Int64.of_string "787537301")
        (Int.typ @-> Int.typ @-> String.typ @-> returning String.typ)
        String.s

    (** Splits the string using a [param delimiter] and returns the substring at index [param slice]. Returns the original string if [param delimiter] does not occur in the string. Returns an empty string if the [param slice] does not exist.
This is faster than [method split], if you only need one substring.
[b]Example:[/b]
[codeblock]
print(""i/am/example/hi"".get_slice(""/"", 2)) # Prints ""example""
[/codeblock] *)
    let get_slice =
      foreign_builtin_method2 GlobalEnum.VariantType._TYPE_STRING "get_slice"
        (Base.Int64.of_string "3535100402")
        (String.typ @-> Int.typ @-> String.typ @-> returning String.typ)
        String.s

    (** Splits the string using a Unicode character with code [param delimiter] and returns the substring at index [param slice]. Returns an empty string if the [param slice] does not exist.
This is faster than [method split], if you only need one substring. *)
    let get_slicec =
      foreign_builtin_method2 GlobalEnum.VariantType._TYPE_STRING "get_slicec"
        (Base.Int64.of_string "787537301")
        (Int.typ @-> Int.typ @-> String.typ @-> returning String.typ)
        String.s

    (** Returns the total number of slices when the string is split with the given [param delimiter] (see [method split]). *)
    let get_slice_count =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_STRING
        "get_slice_count"
        (Base.Int64.of_string "2920860731")
        (String.typ @-> String.typ @-> returning Int.typ)
        Int.s

    (** Returns the index of the [b]first[/b] occurrence of [param what] in this string, or [code]-1[/code] if there are none. The search's start can be specified with [param from], continuing to the end of the string.
[codeblocks]
[gdscript]
print(""Team"".find(""I"")) # Prints -1

print(""Potato"".find(""t""))    # Prints 2
print(""Potato"".find(""t"", 3)) # Prints 4
print(""Potato"".find(""t"", 5)) # Prints -1
[/gdscript]
[csharp]
GD.Print(""Team"".Find(""I"")); // Prints -1

GD.Print(""Potato"".Find(""t""));    // Prints 2
GD.Print(""Potato"".Find(""t"", 3)); // Prints 4
GD.Print(""Potato"".Find(""t"", 5)); // Prints -1
[/csharp]
[/codeblocks]
[b]Note:[/b] If you just want to know whether the string contains [param what], use [method contains]. In GDScript, you may also use the [code]in[/code] operator. *)
    let find =
      foreign_builtin_method2 GlobalEnum.VariantType._TYPE_STRING "find"
        (Base.Int64.of_string "1760645412")
        (String.typ @-> Int.typ @-> String.typ @-> returning Int.typ)
        Int.s

    (** Returns the number of occurrences of the substring [param what] between [param from] and [param to] positions. If [param to] is 0, the search continues until the end of the string. *)
    let count =
      foreign_builtin_method3 GlobalEnum.VariantType._TYPE_STRING "count"
        (Base.Int64.of_string "2343087891")
        (String.typ @-> Int.typ @-> Int.typ @-> String.typ @-> returning Int.typ)
        Int.s

    (** Returns the number of occurrences of the substring [param what] between [param from] and [param to] positions, [b]ignoring case[/b]. If [param to] is 0, the search continues until the end of the string. *)
    let countn =
      foreign_builtin_method3 GlobalEnum.VariantType._TYPE_STRING "countn"
        (Base.Int64.of_string "2343087891")
        (String.typ @-> Int.typ @-> Int.typ @-> String.typ @-> returning Int.typ)
        Int.s

    (** Returns the index of the [b]first[/b] [b]case-insensitive[/b] occurrence of [param what] in this string, or [code]-1[/code] if there are none. The starting search index can be specified with [param from], continuing to the end of the string. *)
    let findn =
      foreign_builtin_method2 GlobalEnum.VariantType._TYPE_STRING "findn"
        (Base.Int64.of_string "1760645412")
        (String.typ @-> Int.typ @-> String.typ @-> returning Int.typ)
        Int.s

    (** Returns the index of the [b]last[/b] occurrence of [param what] in this string, or [code]-1[/code] if there are none. The search's start can be specified with [param from], continuing to the beginning of the string. This method is the reverse of [method find]. *)
    let rfind =
      foreign_builtin_method2 GlobalEnum.VariantType._TYPE_STRING "rfind"
        (Base.Int64.of_string "1760645412")
        (String.typ @-> Int.typ @-> String.typ @-> returning Int.typ)
        Int.s

    (** Returns the index of the [b]last[/b] [b]case-insensitive[/b] occurrence of [param what] in this string, or [code]-1[/code] if there are none. The starting search index can be specified with [param from], continuing to the beginning of the string. This method is the reverse of [method findn]. *)
    let rfindn =
      foreign_builtin_method2 GlobalEnum.VariantType._TYPE_STRING "rfindn"
        (Base.Int64.of_string "1760645412")
        (String.typ @-> Int.typ @-> String.typ @-> returning Int.typ)
        Int.s

    (** Does a simple expression match (also called ""glob"" or ""globbing""), where [code] * [/code] matches zero or more arbitrary characters and [code]?[/code] matches any single character except a period ([code].[/code]). An empty string or empty expression always evaluates to [code]false[/code]. *)
    let match_ =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_STRING "match_"
        (Base.Int64.of_string "2566493496")
        (String.typ @-> String.typ @-> returning Bool.typ)
        Bool.s

    (** Does a simple [b]case-insensitive[/b] expression match, where [code] * [/code] matches zero or more arbitrary characters and [code]?[/code] matches any single character except a period ([code].[/code]). An empty string or empty expression always evaluates to [code]false[/code]. *)
    let matchn =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_STRING "matchn"
        (Base.Int64.of_string "2566493496")
        (String.typ @-> String.typ @-> returning Bool.typ)
        Bool.s

    (** Returns [code]true[/code] if the string begins with the given [param text]. See also [method ends_with]. *)
    let begins_with =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_STRING "begins_with"
        (Base.Int64.of_string "2566493496")
        (String.typ @-> String.typ @-> returning Bool.typ)
        Bool.s

    (** Returns [code]true[/code] if the string ends with the given [param text]. See also [method begins_with]. *)
    let ends_with =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_STRING "ends_with"
        (Base.Int64.of_string "2566493496")
        (String.typ @-> String.typ @-> returning Bool.typ)
        Bool.s

    (** Returns [code]true[/code] if all characters of this string can be found in [param text] in their original order.
[codeblock]
var text = ""Wow, incredible!""

print(""inedible"".is_subsequence_of(text)) # Prints true
print(""Word!"".is_subsequence_of(text))    # Prints true
print(""Window"".is_subsequence_of(text))   # Prints false
print("""".is_subsequence_of(text))         # Prints true
[/codeblock] *)
    let is_subsequence_of =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_STRING
        "is_subsequence_of"
        (Base.Int64.of_string "2566493496")
        (String.typ @-> String.typ @-> returning Bool.typ)
        Bool.s

    (** Returns [code]true[/code] if all characters of this string can be found in [param text] in their original order, [b]ignoring case[/b]. *)
    let is_subsequence_ofn =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_STRING
        "is_subsequence_ofn"
        (Base.Int64.of_string "2566493496")
        (String.typ @-> String.typ @-> returning Bool.typ)
        Bool.s

    (** Returns an array containing the bigrams (pairs of consecutive characters) of this string.
[codeblock]
print(""Get up!"".bigrams()) # Prints [""Ge"", ""et"", ""t "", "" u"", ""up"", ""p!""]
[/codeblock] *)
    let bigrams =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_STRING "bigrams"
        (Base.Int64.of_string "747180633")
        (String.typ @-> returning PackedStringArray.typ)
        PackedStringArray.s

    (** Returns the similarity index ([url=https://en.wikipedia.org/wiki/S%C3%B8rensen%E2%80%93Dice_coefficient]Sorensen-Dice coefficient[/url]) of this string compared to another. A result of [code]1.0[/code] means totally similar, while [code]0.0[/code] means totally dissimilar.
[codeblock]
print(""ABC123"".similarity(""ABC123"")) # Prints 1.0
print(""ABC123"".similarity(""XYZ456"")) # Prints 0.0
print(""ABC123"".similarity(""123ABC"")) # Prints 0.8
print(""ABC123"".similarity(""abc123"")) # Prints 0.4
[/codeblock] *)
    let similarity =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_STRING "similarity"
        (Base.Int64.of_string "2697460964")
        (String.typ @-> String.typ @-> returning Float.typ)
        Float.s

    (** Formats the string by replacing all occurrences of [param placeholder] with the elements of [param values].
[param values] can be a [Dictionary] or an [Array]. Any underscores in [param placeholder] will be replaced with the corresponding keys in advance. Array elements use their index as keys.
[codeblock]
# Prints ""Waiting for Godot is a play by Samuel Beckett, and Godot Engine is named after it.""
var use_array_values = ""Waiting for {0} is a play by {1}, and {0} Engine is named after it.""
print(use_array_values.format([""Godot"", ""Samuel Beckett""]))

# Prints ""User 42 is Godot.""
print(""User {id} is {name}."".format({""id"": 42, ""name"": ""Godot""}))
[/codeblock]
Some additional handling is performed when [param values] is an [Array]. If [param placeholder] does not contain an underscore, the elements of the [param values] array will be used to replace one occurrence of the placeholder in order; If an element of [param values] is another 2-element array, it'll be interpreted as a key-value pair.
[codeblock]
# Prints ""User 42 is Godot.""
print(""User {} is {}."".format([42, ""Godot""], ""{}""))
print(""User {id} is {name}."".format([[""id"", 42], [""name"", ""Godot""]]))
[/codeblock]
See also the [url=$DOCS_URL/tutorials/scripting/gdscript/gdscript_format_string.html]GDScript format string[/url] tutorial.
[b]Note:[/b] The replacement of placeholders is not done all at once, instead each placeholder is replaced in the order they are passed, this means that if one of the replacement strings contains a key it will also be replaced. This can be very powerful, but can also cause unexpected results if you are not careful. If you do not need to perform replacement in the replacement strings, make sure your replacements do not contain placeholders to ensure reliable results.
[codeblock]
print(""{0} {1}"".format([""{1}"", ""x""]))                       # Prints ""x x"".
print(""{0} {1}"".format([""x"", ""{0}""]))                       # Prints ""x {0}"".
print(""{foo} {bar}"".format({""foo"": ""{bar}"", ""bar"": ""baz""})) # Prints ""baz baz"".
print(""{foo} {bar}"".format({""bar"": ""baz"", ""foo"": ""{bar}""})) # Prints ""{bar} baz"".
[/codeblock]
[b]Note:[/b] In C#, it's recommended to [url=https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/tokens/interpolated]interpolate strings with ""$""[/url], instead. *)
    let format =
      foreign_builtin_method2 GlobalEnum.VariantType._TYPE_STRING "format"
        (Base.Int64.of_string "3212199029")
        (Variant.typ @-> String.typ @-> String.typ @-> returning String.typ)
        String.s

    (** Replaces all occurrences of [param what] inside the string with the given [param forwhat]. *)
    let replace =
      foreign_builtin_method2 GlobalEnum.VariantType._TYPE_STRING "replace"
        (Base.Int64.of_string "1340436205")
        (String.typ @-> String.typ @-> String.typ @-> returning String.typ)
        String.s

    (** Replaces all [b]case-insensitive[/b] occurrences of [param what] inside the string with the given [param forwhat]. *)
    let replacen =
      foreign_builtin_method2 GlobalEnum.VariantType._TYPE_STRING "replacen"
        (Base.Int64.of_string "1340436205")
        (String.typ @-> String.typ @-> String.typ @-> returning String.typ)
        String.s

    (** Repeats this string a number of times. [param count] needs to be greater than [code]0[/code]. Otherwise, returns an empty string. *)
    let repeat =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_STRING "repeat"
        (Base.Int64.of_string "2162347432")
        (Int.typ @-> String.typ @-> returning String.typ)
        String.s

    (** Returns the copy of this string in reverse order. *)
    let reverse =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_STRING "reverse"
        (Base.Int64.of_string "3942272618")
        (String.typ @-> returning String.typ)
        String.s

    (** Inserts [param what] at the given [param position] in the string. *)
    let insert =
      foreign_builtin_method2 GlobalEnum.VariantType._TYPE_STRING "insert"
        (Base.Int64.of_string "248737229")
        (Int.typ @-> String.typ @-> String.typ @-> returning String.typ)
        String.s

    (** Returns a string with [param chars] characters erased starting from [param position]. If [param chars] goes beyond the string's length given the specified [param position], fewer characters will be erased from the returned string. Returns an empty string if either [param position] or [param chars] is negative. Returns the original string unmodified if [param chars] is [code]0[/code]. *)
    let erase =
      foreign_builtin_method2 GlobalEnum.VariantType._TYPE_STRING "erase"
        (Base.Int64.of_string "787537301")
        (Int.typ @-> Int.typ @-> String.typ @-> returning String.typ)
        String.s

    (** Changes the appearance of the string: replaces underscores ([code]_[/code]) with spaces, adds spaces before uppercase letters in the middle of a word, converts all letters to lowercase, then converts the first one and each one following a space to uppercase.
[codeblocks]
[gdscript]
""move_local_x"".capitalize()   # Returns ""Move Local X""
""sceneFile_path"".capitalize() # Returns ""Scene File Path""
""2D, FPS, PNG"".capitalize()   # Returns ""2d, Fps, Png""
[/gdscript]
[csharp]
""move_local_x"".Capitalize();   // Returns ""Move Local X""
""sceneFile_path"".Capitalize(); // Returns ""Scene File Path""
""2D, FPS, PNG"".Capitalize();   // Returns ""2d, Fps, Png""
[/csharp]
[/codeblocks] *)
    let capitalize =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_STRING "capitalize"
        (Base.Int64.of_string "3942272618")
        (String.typ @-> returning String.typ)
        String.s

    (** Returns the string converted to [code]camelCase[/code]. *)
    let to_camel_case =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_STRING
        "to_camel_case"
        (Base.Int64.of_string "3942272618")
        (String.typ @-> returning String.typ)
        String.s

    (** Returns the string converted to [code]PascalCase[/code]. *)
    let to_pascal_case =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_STRING
        "to_pascal_case"
        (Base.Int64.of_string "3942272618")
        (String.typ @-> returning String.typ)
        String.s

    (** Returns the string converted to [code]snake_case[/code].
[b]Note:[/b] Numbers followed by a [i]single[/i] letter are not separated in the conversion to keep some words (such as ""2D"") together.
[codeblocks]
[gdscript]
""Node2D"".to_snake_case()               # Returns ""node_2d""
""2nd place"".to_snake_case()            # Returns ""2_nd_place""
""Texture3DAssetFolder"".to_snake_case() # Returns ""texture_3d_asset_folder""
[/gdscript]
[csharp]
""Node2D"".ToSnakeCase();               // Returns ""node_2d""
""2nd place"".ToSnakeCase();            // Returns ""2_nd_place""
""Texture3DAssetFolder"".ToSnakeCase(); // Returns ""texture_3d_asset_folder""
[/csharp]
[/codeblocks] *)
    let to_snake_case =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_STRING
        "to_snake_case"
        (Base.Int64.of_string "3942272618")
        (String.typ @-> returning String.typ)
        String.s

    (** Splits the string using a [param delimiter] and returns an array of the substrings. If [param delimiter] is an empty string, each substring will be a single character. This method is the opposite of [method join].
If [param allow_empty] is [code]false[/code], empty strings between adjacent delimiters are excluded from the array.
If [param maxsplit] is greater than [code]0[/code], the number of splits may not exceed [param maxsplit]. By default, the entire string is split.
[b]Example:[/b]
[codeblocks]
[gdscript]
var some_array = ""One,Two,Three,Four"".split("","", true, 2)

print(some_array.size()) # Prints 3
print(some_array[0])     # Prints ""One""
print(some_array[1])     # Prints ""Two""
print(some_array[2])     # Prints ""Three,Four""
[/gdscript]
[csharp]
// C#'s `Split()` does not support the `maxsplit` parameter.
var someArray = ""One,Two,Three"".Split("","");

GD.Print(someArray[0]); // Prints ""One""
GD.Print(someArray[1]); // Prints ""Two""
GD.Print(someArray[2]); // Prints ""Three""
[/csharp]
[/codeblocks]
[b]Note:[/b] If you only need one substring from the array, consider using [method get_slice] which is faster. If you need to split strings with more complex rules, use the [RegEx] class instead. *)
    let split =
      foreign_builtin_method3 GlobalEnum.VariantType._TYPE_STRING "split"
        (Base.Int64.of_string "1252735785")
        (String.typ @-> Bool.typ @-> Int.typ @-> String.typ
        @-> returning PackedStringArray.typ)
        PackedStringArray.s

    (** Splits the string using a [param delimiter] and returns an array of the substrings, starting from the end of the string. The splits in the returned array appear in the same order as the original string. If [param delimiter] is an empty string, each substring will be a single character.
If [param allow_empty] is [code]false[/code], empty strings between adjacent delimiters are excluded from the array.
If [param maxsplit] is greater than [code]0[/code], the number of splits may not exceed [param maxsplit]. By default, the entire string is split, which is mostly identical to [method split].
[b]Example:[/b]
[codeblocks]
[gdscript]
var some_string = ""One,Two,Three,Four""
var some_array = some_string.rsplit("","", true, 1)

print(some_array.size()) # Prints 2
print(some_array[0])     # Prints ""One,Two,Three""
print(some_array[1])     # Prints ""Four""
[/gdscript]
[csharp]
// In C#, there is no String.RSplit() method.
[/csharp]
[/codeblocks] *)
    let rsplit =
      foreign_builtin_method3 GlobalEnum.VariantType._TYPE_STRING "rsplit"
        (Base.Int64.of_string "1252735785")
        (String.typ @-> Bool.typ @-> Int.typ @-> String.typ
        @-> returning PackedStringArray.typ)
        PackedStringArray.s

    (** Splits the string into floats by using a [param delimiter] and returns a [PackedFloat64Array].
If [param allow_empty] is [code]false[/code], empty or invalid [float] conversions between adjacent delimiters are excluded.
[codeblock]
var a = ""1,2,4.5"".split_floats("","")         # a is [1.0, 2.0, 4.5]
var c = ""1| ||4.5"".split_floats(""|"")        # c is [1.0, 0.0, 0.0, 4.5]
var b = ""1| ||4.5"".split_floats(""|"", false) # b is [1.0, 4.5]
[/codeblock] *)
    let split_floats =
      foreign_builtin_method2 GlobalEnum.VariantType._TYPE_STRING "split_floats"
        (Base.Int64.of_string "2092079095")
        (String.typ @-> Bool.typ @-> String.typ
        @-> returning PackedFloat64Array.typ)
        PackedFloat64Array.s

    (** Returns the concatenation of [param parts]' elements, with each element separated by the string calling this method. This method is the opposite of [method split].
[b]Example:[/b]
[codeblocks]
[gdscript]
var fruits = [""Apple"", ""Orange"", ""Pear"", ""Kiwi""]

print("", "".join(fruits))  # Prints ""Apple, Orange, Pear, Kiwi""
print(""---"".join(fruits)) # Prints ""Apple---Orange---Pear---Kiwi""
[/gdscript]
[csharp]
var fruits = new string[] {""Apple"", ""Orange"", ""Pear"", ""Kiwi""};

// In C#, this method is static.
GD.Print(string.Join("", "", fruits));  // Prints ""Apple, Orange, Pear, Kiwi""
GD.Print(string.Join(""---"", fruits)); // Prints ""Apple---Orange---Pear---Kiwi""
[/csharp]
[/codeblocks] *)
    let join =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_STRING "join"
        (Base.Int64.of_string "3595973238")
        (PackedStringArray.typ @-> String.typ @-> returning String.typ)
        String.s

    (** Returns the string converted to [code]UPPERCASE[/code]. *)
    let to_upper =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_STRING "to_upper"
        (Base.Int64.of_string "3942272618")
        (String.typ @-> returning String.typ)
        String.s

    (** Returns the string converted to [code]lowercase[/code]. *)
    let to_lower =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_STRING "to_lower"
        (Base.Int64.of_string "3942272618")
        (String.typ @-> returning String.typ)
        String.s

    (** Returns the first [param length] characters from the beginning of the string. If [param length] is negative, strips the last [param length] characters from the string's end.
[codeblock]
print(""Hello World!"".left(3))  # Prints ""Hel""
print(""Hello World!"".left(-4)) # Prints ""Hello Wo""
[/codeblock] *)
    let left =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_STRING "left"
        (Base.Int64.of_string "2162347432")
        (Int.typ @-> String.typ @-> returning String.typ)
        String.s

    (** Returns the last [param length] characters from the end of the string. If [param length] is negative, strips the first [param length] characters from the string's beginning.
[codeblock]
print(""Hello World!"".right(3))  # Prints ""ld!""
print(""Hello World!"".right(-4)) # Prints ""o World!""
[/codeblock] *)
    let right =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_STRING "right"
        (Base.Int64.of_string "2162347432")
        (Int.typ @-> String.typ @-> returning String.typ)
        String.s

    (** Strips all non-printable characters from the beginning and the end of the string. These include spaces, tabulations ([code]\t[/code]), and newlines ([code]\n[/code] [code]\r[/code]).
If [param left] is [code]false[/code], ignores the string's beginning. Likewise, if [param right] is [code]false[/code], ignores the string's end. *)
    let strip_edges =
      foreign_builtin_method2 GlobalEnum.VariantType._TYPE_STRING "strip_edges"
        (Base.Int64.of_string "907855311")
        (Bool.typ @-> Bool.typ @-> String.typ @-> returning String.typ)
        String.s

    (** Strips all escape characters from the string. These include all non-printable control characters of the first page of the ASCII table (values from 0 to 31), such as tabulation ([code]\t[/code]) and newline ([code]\n[/code], [code]\r[/code]) characters, but [i]not[/i] spaces. *)
    let strip_escapes =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_STRING
        "strip_escapes"
        (Base.Int64.of_string "3942272618")
        (String.typ @-> returning String.typ)
        String.s

    (** Removes a set of characters defined in [param chars] from the string's beginning. See also [method rstrip].
[b]Note:[/b] [param chars] is not a prefix. Use [method trim_prefix] to remove a single prefix, rather than a set of characters. *)
    let lstrip =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_STRING "lstrip"
        (Base.Int64.of_string "3134094431")
        (String.typ @-> String.typ @-> returning String.typ)
        String.s

    (** Removes a set of characters defined in [param chars] from the string's end. See also [method lstrip].
[b]Note:[/b] [param chars] is not a suffix. Use [method trim_suffix] to remove a single suffix, rather than a set of characters. *)
    let rstrip =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_STRING "rstrip"
        (Base.Int64.of_string "3134094431")
        (String.typ @-> String.typ @-> returning String.typ)
        String.s

    (** If the string is a valid file name or path, returns the file extension without the leading period ([code].[/code]). Otherwise, returns an empty string.
[codeblock]
var a = ""/path/to/file.txt"".get_extension() # a is ""txt""
var b = ""cool.txt"".get_extension()          # b is ""txt""
var c = ""cool.font.tres"".get_extension()    # c is ""tres""
var d = "".pack1"".get_extension()            # d is ""pack1""

var e = ""file.txt."".get_extension()  # e is """"
var f = ""file.txt.."".get_extension() # f is """"
var g = ""txt"".get_extension()        # g is """"
var h = """".get_extension()           # h is """"
[/codeblock] *)
    let get_extension =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_STRING
        "get_extension"
        (Base.Int64.of_string "3942272618")
        (String.typ @-> returning String.typ)
        String.s

    (** If the string is a valid file path, returns the full file path, without the extension.
[codeblock]
var base = ""/path/to/file.txt"".get_basename() # base is ""/path/to/file""
[/codeblock] *)
    let get_basename =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_STRING "get_basename"
        (Base.Int64.of_string "3942272618")
        (String.typ @-> returning String.typ)
        String.s

    (** Concatenates [param file] at the end of the string as a subpath, adding [code]/[/code] if necessary.
[b]Example:[/b] [code]""this/is"".path_join(""path"") == ""this/is/path""[/code]. *)
    let path_join =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_STRING "path_join"
        (Base.Int64.of_string "3134094431")
        (String.typ @-> String.typ @-> returning String.typ)
        String.s

    (** Returns the character code at position [param at]. *)
    let unicode_at =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_STRING "unicode_at"
        (Base.Int64.of_string "4103005248")
        (Int.typ @-> String.typ @-> returning Int.typ)
        Int.s

    (** Indents every line of the string with the given [param prefix]. Empty lines are not indented. See also [method dedent] to remove indentation.
For example, the string can be indented with two tabulations using [code]""\t\t""[/code], or four spaces using [code]""    ""[/code]. *)
    let indent =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_STRING "indent"
        (Base.Int64.of_string "3134094431")
        (String.typ @-> String.typ @-> returning String.typ)
        String.s

    (** Returns a copy of the string with indentation (leading tabs and spaces) removed. See also [method indent] to add indentation. *)
    let dedent =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_STRING "dedent"
        (Base.Int64.of_string "3942272618")
        (String.typ @-> returning String.typ)
        String.s

    (** Returns the 32-bit hash value representing the string's contents.
[b]Note:[/b] Strings with equal hash values are [i]not[/i] guaranteed to be the same, as a result of hash collisions. On the contrary, strings with different hash values are guaranteed to be different. *)
    let hash =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_STRING "hash"
        (Base.Int64.of_string "3173160232")
        (String.typ @-> returning Int.typ)
        Int.s

    (** Returns the [url=https://en.wikipedia.org/wiki/MD5]MD5 hash[/url] of the string as another [String]. *)
    let md5_text =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_STRING "md5_text"
        (Base.Int64.of_string "3942272618")
        (String.typ @-> returning String.typ)
        String.s

    (** Returns the [url=https://en.wikipedia.org/wiki/SHA-1]SHA-1[/url] hash of the string as another [String]. *)
    let sha1_text =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_STRING "sha1_text"
        (Base.Int64.of_string "3942272618")
        (String.typ @-> returning String.typ)
        String.s

    (** Returns the [url=https://en.wikipedia.org/wiki/SHA-2]SHA-256[/url] hash of the string as another [String]. *)
    let sha256_text =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_STRING "sha256_text"
        (Base.Int64.of_string "3942272618")
        (String.typ @-> returning String.typ)
        String.s

    (** Returns the [url=https://en.wikipedia.org/wiki/MD5]MD5 hash[/url] of the string as a [PackedByteArray]. *)
    let md5_buffer =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_STRING "md5_buffer"
        (Base.Int64.of_string "247621236")
        (String.typ @-> returning PackedByteArray.typ)
        PackedByteArray.s

    (** Returns the [url=https://en.wikipedia.org/wiki/SHA-1]SHA-1[/url] hash of the string as a [PackedByteArray]. *)
    let sha1_buffer =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_STRING "sha1_buffer"
        (Base.Int64.of_string "247621236")
        (String.typ @-> returning PackedByteArray.typ)
        PackedByteArray.s

    (** Returns the [url=https://en.wikipedia.org/wiki/SHA-2]SHA-256[/url] hash of the string as a [PackedByteArray]. *)
    let sha256_buffer =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_STRING
        "sha256_buffer"
        (Base.Int64.of_string "247621236")
        (String.typ @-> returning PackedByteArray.typ)
        PackedByteArray.s

    (** Returns [code]true[/code] if the string's length is [code]0[/code] ([code]""""[/code]). See also [method length]. *)
    let is_empty =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_STRING "is_empty"
        (Base.Int64.of_string "3918633141")
        (String.typ @-> returning Bool.typ)
        Bool.s

    (** Returns [code]true[/code] if the string contains [param what]. In GDScript, this corresponds to the [code]in[/code] operator.
[codeblocks]
[gdscript]
print(""Node"".contains(""de"")) # Prints true
print(""team"".contains(""I""))  # Prints false
print(""I"" in ""team"")         # Prints false
[/gdscript]
[csharp]
GD.Print(""Node"".Contains(""de"")); // Prints true
GD.Print(""team"".Contains(""I""));  // Prints false
[/csharp]
[/codeblocks]
If you need to know where [param what] is within the string, use [method find]. *)
    let contains =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_STRING "contains"
        (Base.Int64.of_string "2566493496")
        (String.typ @-> String.typ @-> returning Bool.typ)
        Bool.s

    (** Returns [code]true[/code] if the string is a path to a file or directory, and its starting point is explicitly defined. This method is the opposite of [method is_relative_path].
This includes all paths starting with [code]""res://""[/code], [code]""user://""[/code], [code]""C:\""[/code], [code]""/""[/code], etc. *)
    let is_absolute_path =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_STRING
        "is_absolute_path"
        (Base.Int64.of_string "3918633141")
        (String.typ @-> returning Bool.typ)
        Bool.s

    (** Returns [code]true[/code] if the string is a path, and its starting point is dependent on context. The path could begin from the current directory, or the current [Node] (if the string is derived from a [NodePath]), and may sometimes be prefixed with [code]""./""[/code]. This method is the opposite of [method is_absolute_path]. *)
    let is_relative_path =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_STRING
        "is_relative_path"
        (Base.Int64.of_string "3918633141")
        (String.typ @-> returning Bool.typ)
        Bool.s

    (** If the string is a valid file path, converts the string into a canonical path. This is the shortest possible path, without [code]""./""[/code], and all the unnecessary [code]""..""[/code] and [code]""/""[/code].
[codeblock]
var simple_path = ""./path/to///../file"".simplify_path()
print(simple_path) # Prints ""path/file""
[/codeblock] *)
    let simplify_path =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_STRING
        "simplify_path"
        (Base.Int64.of_string "3942272618")
        (String.typ @-> returning String.typ)
        String.s

    (** If the string is a valid file path, returns the base directory name.
[codeblock]
var dir_path = ""/path/to/file.txt"".get_base_dir() # dir_path is ""/path/to""
[/codeblock] *)
    let get_base_dir =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_STRING "get_base_dir"
        (Base.Int64.of_string "3942272618")
        (String.typ @-> returning String.typ)
        String.s

    (** If the string is a valid file path, returns the file name, including the extension.
[codeblock]
var file = ""/path/to/icon.png"".get_file() # file is ""icon.png""
[/codeblock] *)
    let get_file =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_STRING "get_file"
        (Base.Int64.of_string "3942272618")
        (String.typ @-> returning String.typ)
        String.s

    (** Returns a copy of the string with special characters escaped using the XML standard. If [param escape_quotes] is [code]true[/code], the single quote ([code]'[/code]) and double quote ([code]""[/code]) characters are also escaped. *)
    let xml_escape =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_STRING "xml_escape"
        (Base.Int64.of_string "3429816538")
        (Bool.typ @-> String.typ @-> returning String.typ)
        String.s

    (** Returns a copy of the string with escaped characters replaced by their meanings according to the XML standard. *)
    let xml_unescape =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_STRING "xml_unescape"
        (Base.Int64.of_string "3942272618")
        (String.typ @-> returning String.typ)
        String.s

    (** Encodes the string to URL-friendly format. This method is meant to properly encode the parameters in a URL when sending an HTTP request. See also [method uri_decode].
[codeblocks]
[gdscript]
var prefix = ""$DOCS_URL/?highlight=""
var url = prefix + ""Godot Engine:docs"".uri_encode()

print(url) # Prints ""$DOCS_URL/?highlight=Godot%20Engine%3%docs""
[/gdscript]
[csharp]
var prefix = ""$DOCS_URL/?highlight="";
var url = prefix + ""Godot Engine:docs"".URIEncode();

GD.Print(url); // Prints ""$DOCS_URL/?highlight=Godot%20Engine%3%docs""
[/csharp]
[/codeblocks] *)
    let uri_encode =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_STRING "uri_encode"
        (Base.Int64.of_string "3942272618")
        (String.typ @-> returning String.typ)
        String.s

    (** Decodes the string from its URL-encoded format. This method is meant to properly decode the parameters in a URL when receiving an HTTP request. See also [method uri_encode].
[codeblocks]
[gdscript]
var url = ""$DOCS_URL/?highlight=Godot%20Engine%3%docs""
print(url.uri_decode()) # Prints ""$DOCS_URL/?highlight=Godot Engine:docs""
[/gdscript]
[csharp]
var url = ""$DOCS_URL/?highlight=Godot%20Engine%3%docs""
GD.Print(url.URIDecode()) // Prints ""$DOCS_URL/?highlight=Godot Engine:docs""
[/csharp]
[/codeblocks] *)
    let uri_decode =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_STRING "uri_decode"
        (Base.Int64.of_string "3942272618")
        (String.typ @-> returning String.typ)
        String.s

    (** Returns a copy of the string with special characters escaped using the C language standard. *)
    let c_escape =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_STRING "c_escape"
        (Base.Int64.of_string "3942272618")
        (String.typ @-> returning String.typ)
        String.s

    (** Returns a copy of the string with escaped characters replaced by their meanings. Supported escape sequences are [code]\'[/code], [code]\""[/code], [code]\\[/code], [code]\a[/code], [code]\b[/code], [code]\f[/code], [code]\n[/code], [code]\r[/code], [code]\t[/code], [code]\v[/code].
[b]Note:[/b] Unlike the GDScript parser, this method doesn't support the [code]\uXXXX[/code] escape sequence. *)
    let c_unescape =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_STRING "c_unescape"
        (Base.Int64.of_string "3942272618")
        (String.typ @-> returning String.typ)
        String.s

    (** Returns a copy of the string with special characters escaped using the JSON standard. Because it closely matches the C standard, it is possible to use [method c_unescape] to unescape the string, if necessary. *)
    let json_escape =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_STRING "json_escape"
        (Base.Int64.of_string "3942272618")
        (String.typ @-> returning String.typ)
        String.s

    (** Returns a copy of the string with all characters that are not allowed in [member Node.name] ([code].[/code] [code]:[/code] [code]@[/code] [code]/[/code] [code]""[/code] [code]%[/code]) replaced with underscores. *)
    let validate_node_name =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_STRING
        "validate_node_name"
        (Base.Int64.of_string "3942272618")
        (String.typ @-> returning String.typ)
        String.s

    (** Returns a copy of the string with all characters that are not allowed in [method is_valid_filename] replaced with underscores. *)
    let validate_filename =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_STRING
        "validate_filename"
        (Base.Int64.of_string "3942272618")
        (String.typ @-> returning String.typ)
        String.s

    (** Returns [code]true[/code] if this string is a valid identifier. A valid identifier may contain only letters, digits and underscores ([code]_[/code]), and the first character may not be a digit.
[codeblock]
print(""node_2d"".is_valid_identifier())    # Prints true
print(""TYPE_FLOAT"".is_valid_identifier()) # Prints true
print(""1st_method"".is_valid_identifier()) # Prints false
print(""MyMethod#2"".is_valid_identifier()) # Prints false
[/codeblock] *)
    let is_valid_identifier =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_STRING
        "is_valid_identifier"
        (Base.Int64.of_string "3918633141")
        (String.typ @-> returning Bool.typ)
        Bool.s

    (** Returns [code]true[/code] if this string represents a valid integer. A valid integer only contains digits, and may be prefixed with a positive ([code]+[/code]) or negative ([code]-[/code]) sign. See also [method to_int].
[codeblock]
print(""7"".is_valid_int())    # Prints true
print(""1.65"".is_valid_int()) # Prints false
print(""Hi"".is_valid_int())   # Prints false
print(""+3"".is_valid_int())   # Prints true
print(""-12"".is_valid_int())  # Prints true
[/codeblock] *)
    let is_valid_int =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_STRING "is_valid_int"
        (Base.Int64.of_string "3918633141")
        (String.typ @-> returning Bool.typ)
        Bool.s

    (** Returns [code]true[/code] if this string represents a valid floating-point number. A valid float may contain only digits, one decimal point ([code].[/code]), and the exponent letter ([code]e[/code]). It may also be prefixed with a positive ([code]+[/code]) or negative ([code]-[/code]) sign. Any valid integer is also a valid float (see [method is_valid_int]). See also [method to_float].
[codeblock]
print(""1.7"".is_valid_float())   # Prints true
print(""24"".is_valid_float())    # Prints true
print(""7e3"".is_valid_float())   # Prints true
print(""Hello"".is_valid_float()) # Prints false
[/codeblock] *)
    let is_valid_float =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_STRING
        "is_valid_float"
        (Base.Int64.of_string "3918633141")
        (String.typ @-> returning Bool.typ)
        Bool.s

    (** Returns [code]true[/code] if this string is a valid hexadecimal number. A valid hexadecimal number only contains digits or letters [code]A[/code] to [code]F[/code] (either uppercase or lowercase), and may be prefixed with a positive ([code]+[/code]) or negative ([code]-[/code]) sign.
If [param with_prefix] is [code]true[/code], the hexadecimal number needs to prefixed by [code]""0x""[/code] to be considered valid.
[codeblock]
print(""A08E"".is_valid_hex_number())    # Prints true
print(""-AbCdEf"".is_valid_hex_number()) # Prints true
print(""2.5"".is_valid_hex_number())     # Prints false

print(""0xDEADC0DE"".is_valid_hex_number(true)) # Prints true
[/codeblock] *)
    let is_valid_hex_number =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_STRING
        "is_valid_hex_number"
        (Base.Int64.of_string "593672999")
        (Bool.typ @-> String.typ @-> returning Bool.typ)
        Bool.s

    (** Returns [code]true[/code] if this string is a valid color in hexadecimal HTML notation. The string must be a hexadecimal value (see [method is_valid_hex_number]) of either 3, 4, 6 or 8 digits, and may be prefixed by a hash sign ([code]#[/code]). Other HTML notations for colors, such as names or [code]hsl()[/code], are not considered valid. See also [method Color.html]. *)
    let is_valid_html_color =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_STRING
        "is_valid_html_color"
        (Base.Int64.of_string "3918633141")
        (String.typ @-> returning Bool.typ)
        Bool.s

    (** Returns [code]true[/code] if this string represents a well-formatted IPv4 or IPv6 address. This method considers [url=https://en.wikipedia.org/wiki/Reserved_IP_addresses]reserved IP addresses[/url] such as [code]""0.0.0.0""[/code] and [code]""ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff""[/code] as valid. *)
    let is_valid_ip_address =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_STRING
        "is_valid_ip_address"
        (Base.Int64.of_string "3918633141")
        (String.typ @-> returning Bool.typ)
        Bool.s

    (** Returns [code]true[/code] if this string does not contain characters that are not allowed in file names ([code]:[/code] [code]/[/code] [code]\[/code] [code]?[/code] [code] * [/code] [code]""[/code] [code]|[/code] [code]%[/code] [code]<[/code] [code]>[/code]). *)
    let is_valid_filename =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_STRING
        "is_valid_filename"
        (Base.Int64.of_string "3918633141")
        (String.typ @-> returning Bool.typ)
        Bool.s

    (** Converts the string representing an integer number into an [int]. This method removes any non-number character and stops at the first decimal point ([code].[/code]). See also [method is_valid_int].
[codeblock]
var a = ""123"".to_int()    # a is 123
var b = ""x1y2z3"".to_int() # b is 123
var c = ""-1.2.3"".to_int() # c is -1
var d = ""Hello!"".to_int() # d is 0
[/codeblock] *)
    let to_int =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_STRING "to_int"
        (Base.Int64.of_string "3173160232")
        (String.typ @-> returning Int.typ)
        Int.s

    (** Converts the string representing a decimal number into a [float]. This method stops on the first non-number character, except the first decimal point ([code].[/code]) and the exponent letter ([code]e[/code]). See also [method is_valid_float].
[codeblock]
var a = ""12.35"".to_float()  # a is 12.35
var b = ""1.2.3"".to_float()  # b is 1.2
var c = ""12xy3"".to_float()  # c is 12.0
var d = ""1e3"".to_float()    # d is 1000.0
var e = ""Hello!"".to_float() # e is 0.0
[/codeblock] *)
    let to_float =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_STRING "to_float"
        (Base.Int64.of_string "466405837")
        (String.typ @-> returning Float.typ)
        Float.s

    (** Converts the string representing a hexadecimal number into an [int]. The string may be optionally prefixed with [code]""0x""[/code], and an additional [code]-[/code] prefix for negative numbers.
[codeblocks]
[gdscript]
print(""0xff"".hex_to_int()) # Prints 255
print(""ab"".hex_to_int())   # Prints 171
[/gdscript]
[csharp]
GD.Print(""0xff"".HexToInt()); // Prints 255
GD.Print(""ab"".HexToInt());   // Prints 171
[/csharp]
[/codeblocks] *)
    let hex_to_int =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_STRING "hex_to_int"
        (Base.Int64.of_string "3173160232")
        (String.typ @-> returning Int.typ)
        Int.s

    (** Converts the string representing a binary number into an [int]. The string may optionally be prefixed with [code]""0b""[/code], and an additional [code]-[/code] prefix for negative numbers.
[codeblocks]
[gdscript]
print(""101"".bin_to_int())   # Prints 5
print(""0b101"".bin_to_int()) # Prints 5
print(""-0b10"".bin_to_int()) # Prints -2
[/gdscript]
[csharp]
GD.Print(""101"".BinToInt());   // Prints 5
GD.Print(""0b101"".BinToInt()); // Prints 5
GD.Print(""-0b10"".BinToInt()); // Prints -2
[/csharp]
[/codeblocks] *)
    let bin_to_int =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_STRING "bin_to_int"
        (Base.Int64.of_string "3173160232")
        (String.typ @-> returning Int.typ)
        Int.s

    (** Formats the string to be at least [param min_length] long by adding [param character]s to the left of the string, if necessary. See also [method rpad]. *)
    let lpad =
      foreign_builtin_method2 GlobalEnum.VariantType._TYPE_STRING "lpad"
        (Base.Int64.of_string "248737229")
        (Int.typ @-> String.typ @-> String.typ @-> returning String.typ)
        String.s

    (** Formats the string to be at least [param min_length] long, by adding [param character]s to the right of the string, if necessary. See also [method lpad]. *)
    let rpad =
      foreign_builtin_method2 GlobalEnum.VariantType._TYPE_STRING "rpad"
        (Base.Int64.of_string "248737229")
        (Int.typ @-> String.typ @-> String.typ @-> returning String.typ)
        String.s

    (** Formats the string representing a number to have an exact number of [param digits] [i]after[/i] the decimal point. *)
    let pad_decimals =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_STRING "pad_decimals"
        (Base.Int64.of_string "2162347432")
        (Int.typ @-> String.typ @-> returning String.typ)
        String.s

    (** Formats the string representing a number to have an exact number of [param digits] [i]before[/i] the decimal point. *)
    let pad_zeros =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_STRING "pad_zeros"
        (Base.Int64.of_string "2162347432")
        (Int.typ @-> String.typ @-> returning String.typ)
        String.s

    (** Removes the given [param prefix] from the start of the string, or returns the string unchanged. *)
    let trim_prefix =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_STRING "trim_prefix"
        (Base.Int64.of_string "3134094431")
        (String.typ @-> String.typ @-> returning String.typ)
        String.s

    (** Removes the given [param suffix] from the end of the string, or returns the string unchanged. *)
    let trim_suffix =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_STRING "trim_suffix"
        (Base.Int64.of_string "3134094431")
        (String.typ @-> String.typ @-> returning String.typ)
        String.s

    (** Converts the string to an [url=https://en.wikipedia.org/wiki/ASCII]ASCII[/url]/Latin-1 encoded [PackedByteArray]. This method is slightly faster than [method to_utf8_buffer], but replaces all unsupported characters with spaces. This is the inverse of [method PackedByteArray.get_string_from_ascii]. *)
    let to_ascii_buffer =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_STRING
        "to_ascii_buffer"
        (Base.Int64.of_string "247621236")
        (String.typ @-> returning PackedByteArray.typ)
        PackedByteArray.s

    (** Converts the string to a [url=https://en.wikipedia.org/wiki/UTF-8]UTF-8[/url] encoded [PackedByteArray]. This method is slightly slower than [method to_ascii_buffer], but supports all UTF-8 characters. For most cases, prefer using this method. This is the inverse of [method PackedByteArray.get_string_from_utf8]. *)
    let to_utf8_buffer =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_STRING
        "to_utf8_buffer"
        (Base.Int64.of_string "247621236")
        (String.typ @-> returning PackedByteArray.typ)
        PackedByteArray.s

    (** Converts the string to a [url=https://en.wikipedia.org/wiki/UTF-16]UTF-16[/url] encoded [PackedByteArray]. This is the inverse of [method PackedByteArray.get_string_from_utf16]. *)
    let to_utf16_buffer =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_STRING
        "to_utf16_buffer"
        (Base.Int64.of_string "247621236")
        (String.typ @-> returning PackedByteArray.typ)
        PackedByteArray.s

    (** Converts the string to a [url=https://en.wikipedia.org/wiki/UTF-32]UTF-32[/url] encoded [PackedByteArray]. This is the inverse of [method PackedByteArray.get_string_from_utf32]. *)
    let to_utf32_buffer =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_STRING
        "to_utf32_buffer"
        (Base.Int64.of_string "247621236")
        (String.typ @-> returning PackedByteArray.typ)
        PackedByteArray.s

    (** Decodes a hexadecimal string as a [PackedByteArray].
[codeblocks]
[gdscript]
var text = ""hello world""
var encoded = text.to_utf8_buffer().hex_encode() # outputs ""68656c6c6f20776f726c64""
print(buf.hex_decode().get_string_from_utf8())
[/gdscript]
[csharp]
var text = ""hello world"";
var encoded = text.ToUtf8Buffer().HexEncode(); // outputs ""68656c6c6f20776f726c64""
GD.Print(buf.HexDecode().GetStringFromUtf8());
[/csharp]
[/codeblocks] *)
    let hex_decode =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_STRING "hex_decode"
        (Base.Int64.of_string "247621236")
        (String.typ @-> returning PackedByteArray.typ)
        PackedByteArray.s

    (** Converts the string to a [url=https://en.wikipedia.org/wiki/Wide_character]wide character[/url] ([code]wchar_t[/code], UTF-16 on Windows, UTF-32 on other platforms) encoded [PackedByteArray]. This is the inverse of [method PackedByteArray.get_string_from_wchar]. *)
    let to_wchar_buffer =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_STRING
        "to_wchar_buffer"
        (Base.Int64.of_string "247621236")
        (String.typ @-> returning PackedByteArray.typ)
        PackedByteArray.s

    (** Converts the given [param number] to a string representation, in scientific notation.
[codeblocks]
[gdscript]
var n = -5.2e8
print(n)                        # Prints -520000000
print(String.num_scientific(n)) # Prints -5.2e+08
[/gdscript]
[csharp]
// This method is not implemented in C#.
// Use `string.ToString()` with ""e"" to achieve similar results.
var n = -5.2e8f;
GD.Print(n);                // Prints -520000000
GD.Print(n.ToString(""e1"")); // Prints -5.2e+008
[/csharp]
[/codeblocks]
[b]Note:[/b] In C#, this method is not implemented. To achieve similar results, see C#'s [url=https://learn.microsoft.com/en-us/dotnet/standard/base-types/standard-numeric-format-strings]Standard numeric format strings[/url] *)
    let num_scientific =
      foreign_builtin_method1_static GlobalEnum.VariantType._TYPE_STRING
        "num_scientific"
        (Base.Int64.of_string "2710373411")
        (Float.typ @-> returning String.typ)
        String.s

    (** Converts a [float] to a string representation of a decimal number, with the number of decimal places specified in [param decimals].
If [param decimals] is [code]-1[/code] as by default, the string representation may only have up to 14 significant digits, with digits before the decimal point having priority over digits after.
Trailing zeros are not included in the string. The last digit is rounded, not truncated.
[b]Example:[/b]
[codeblock]
String.num(3.141593)     # Returns ""3.141593""
String.num(3.141593, 3)  # Returns ""3.142""
String.num(3.14159300)   # Returns ""3.141593""

# Here, the last digit will be rounded up,
# which reduces the total digit count, since trailing zeros are removed:
String.num(42.129999, 5) # Returns ""42.13""

# If `decimals` is not specified, the maximum number of significant digits is 14:
String.num(-0.0000012345432123454321)     # Returns ""-0.00000123454321""
String.num(-10000.0000012345432123454321) # Returns ""-10000.0000012345""
[/codeblock] *)
    let num =
      foreign_builtin_method2_static GlobalEnum.VariantType._TYPE_STRING "num"
        (Base.Int64.of_string "1555901022")
        (Float.typ @-> Int.typ @-> returning String.typ)
        String.s

    (** Converts the given [param number] to a string representation, with the given [param base].
By default, [param base] is set to decimal ([code]10[/code]). Other common bases in programming include binary ([code]2[/code]), [url=https://en.wikipedia.org/wiki/Octal]octal[/url] ([code]8[/code]), hexadecimal ([code]16[/code]).
If [param capitalize_hex] is [code]true[/code], digits higher than 9 are represented in uppercase. *)
    let num_int64 =
      foreign_builtin_method3_static GlobalEnum.VariantType._TYPE_STRING
        "num_int64"
        (Base.Int64.of_string "2111271071")
        (Int.typ @-> Int.typ @-> Bool.typ @-> returning String.typ)
        String.s

    (** Converts the given unsigned [int] to a string representation, with the given [param base].
By default, [param base] is set to decimal ([code]10[/code]). Other common bases in programming include binary ([code]2[/code]), [url=https://en.wikipedia.org/wiki/Octal]octal[/url] ([code]8[/code]), hexadecimal ([code]16[/code]).
If [param capitalize_hex] is [code]true[/code], digits higher than 9 are represented in uppercase. *)
    let num_uint64 =
      foreign_builtin_method3_static GlobalEnum.VariantType._TYPE_STRING
        "num_uint64"
        (Base.Int64.of_string "2111271071")
        (Int.typ @-> Int.typ @-> Bool.typ @-> returning String.typ)
        String.s

    (** Returns a single Unicode character from the decimal [param char]. You may use [url=https://unicodelookup.com/]unicodelookup.com[/url] or [url=https://www.unicode.org/charts/]unicode.org[/url] as points of reference.
[codeblock]
print(String.chr(65))     # Prints ""A""
print(String.chr(129302)) # Prints ""🤖"" (robot face emoji)
[/codeblock] *)
    let chr =
      foreign_builtin_method1_static GlobalEnum.VariantType._TYPE_STRING "chr"
        (Base.Int64.of_string "897497541")
        (Int.typ @-> returning String.typ)
        String.s

    (** Converts [param size] which represents a number of bytes into a human-readable form.
The result is in [url=https://en.wikipedia.org/wiki/Binary_prefix#IEC_prefixes]IEC prefix format[/url], which may end in either [code]""B""[/code], [code]""KiB""[/code], [code]""MiB""[/code], [code]""GiB""[/code], [code]""TiB""[/code], [code]""PiB""[/code], or [code]""EiB""[/code]. *)
    let humanize_size =
      foreign_builtin_method1_static GlobalEnum.VariantType._TYPE_STRING
        "humanize_size"
        (Base.Int64.of_string "897497541")
        (Int.typ @-> returning String.typ)
        String.s

    let not =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_STRING None
        GlobalEnum.VariantOperator._OP_NOT
        (funptr (String.typ @-> String.typ @-> Bool.typ @-> returning void))

    (** Returns [code]true[/code] if both strings contain the same sequence of characters. *)
    let ( = ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_STRING
        (Some GlobalEnum.VariantType._TYPE_STRING)
        GlobalEnum.VariantOperator._OP_EQUAL
        (funptr (String.typ @-> String.typ @-> Bool.typ @-> returning void))

    (** Returns [code]true[/code] if both strings do not contain the same sequence of characters. *)
    let ( <> ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_STRING
        (Some GlobalEnum.VariantType._TYPE_STRING)
        GlobalEnum.VariantOperator._OP_NOT_EQUAL
        (funptr (String.typ @-> String.typ @-> Bool.typ @-> returning void))

    (** Returns [code]true[/code] if the left [String] comes before [param right] in [url=https://en.wikipedia.org/wiki/List_of_Unicode_characters]Unicode order[/url], which roughly matches the alphabetical order. Useful for sorting. *)
    let ( < ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_STRING
        (Some GlobalEnum.VariantType._TYPE_STRING)
        GlobalEnum.VariantOperator._OP_LESS
        (funptr (String.typ @-> String.typ @-> Bool.typ @-> returning void))

    (** Returns [code]true[/code] if the left [String] comes before [param right] in [url=https://en.wikipedia.org/wiki/List_of_Unicode_characters]Unicode order[/url], which roughly matches the alphabetical order, or if both are equal. *)
    let ( <= ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_STRING
        (Some GlobalEnum.VariantType._TYPE_STRING)
        GlobalEnum.VariantOperator._OP_LESS_EQUAL
        (funptr (String.typ @-> String.typ @-> Bool.typ @-> returning void))

    (** Returns [code]true[/code] if the left [String] comes after [param right] in [url=https://en.wikipedia.org/wiki/List_of_Unicode_characters]Unicode order[/url], which roughly matches the alphabetical order. Useful for sorting. *)
    let ( > ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_STRING
        (Some GlobalEnum.VariantType._TYPE_STRING)
        GlobalEnum.VariantOperator._OP_GREATER
        (funptr (String.typ @-> String.typ @-> Bool.typ @-> returning void))

    (** Returns [code]true[/code] if the left [String] comes after [param right] in [url=https://en.wikipedia.org/wiki/List_of_Unicode_characters]Unicode order[/url], which roughly matches the alphabetical order, or if both are equal. *)
    let ( >= ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_STRING
        (Some GlobalEnum.VariantType._TYPE_STRING)
        GlobalEnum.VariantOperator._OP_GREATER_EQUAL
        (funptr (String.typ @-> String.typ @-> Bool.typ @-> returning void))

    (** Appends [param right] at the end of this [String], also known as a string concatenation. *)
    let ( + ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_STRING
        (Some GlobalEnum.VariantType._TYPE_STRING)
        GlobalEnum.VariantOperator._OP_ADD
        (funptr (String.typ @-> String.typ @-> String.typ @-> returning void))

    let ( % ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_STRING
        (Some GlobalEnum.VariantType._TYPE_STRING)
        GlobalEnum.VariantOperator._OP_MODULE
        (funptr (String.typ @-> String.typ @-> String.typ @-> returning void))

    let _String_elem_String =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_STRING
        (Some GlobalEnum.VariantType._TYPE_STRING)
        GlobalEnum.VariantOperator._OP_IN
        (funptr (String.typ @-> String.typ @-> Bool.typ @-> returning void))

    let _String_elem_StringName =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_STRING
        (Some GlobalEnum.VariantType._TYPE_STRING_NAME)
        GlobalEnum.VariantOperator._OP_IN
        (funptr (String.typ @-> StringName.typ @-> Bool.typ @-> returning void))

    let _String_elem_Object =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_STRING
        (Some GlobalEnum.VariantType._TYPE_OBJECT)
        GlobalEnum.VariantOperator._OP_IN
        (funptr (String.typ @-> Object.typ @-> Bool.typ @-> returning void))

    let _String_elem_Dictionary =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_STRING
        (Some GlobalEnum.VariantType._TYPE_DICTIONARY)
        GlobalEnum.VariantOperator._OP_IN
        (funptr (String.typ @-> Dictionary.typ @-> Bool.typ @-> returning void))

    let _String_elem_Array =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_STRING
        (Some GlobalEnum.VariantType._TYPE_ARRAY)
        GlobalEnum.VariantOperator._OP_IN
        (funptr (String.typ @-> Array.typ @-> Bool.typ @-> returning void))

    let _String_elem_PackedStringArray =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_STRING
        (Some GlobalEnum.VariantType._TYPE_PACKED_STRING_ARRAY)
        GlobalEnum.VariantOperator._OP_IN
        (funptr
           (String.typ @-> PackedStringArray.typ @-> Bool.typ @-> returning void))
  end

  module Vector2 = struct
    include M.Vector2

    (** Returns this vector's angle with respect to the positive X axis, or [code](1, 0)[/code] vector, in radians.
For example, [code]Vector2.RIGHT.angle()[/code] will return zero, [code]Vector2.DOWN.angle()[/code] will return [code]PI / 2[/code] (a quarter turn, or 90 degrees), and [code]Vector2(1, -1).angle()[/code] will return [code]-PI / 4[/code] (a negative eighth turn, or -45 degrees).
[url=https://raw.githubusercontent.com/godotengine/godot-docs/master/img/vector2_angle.png]Illustration of the returned angle.[/url]
Equivalent to the result of [method @GlobalScope.atan2] when called with the vector's [member y] and [member x] as parameters: [code]atan2(y, x)[/code]. *)
    let angle =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_VECTOR2 "angle"
        (Base.Int64.of_string "466405837")
        (Vector2.typ @-> returning Float.typ)
        Float.s

    (** Returns the angle to the given vector, in radians.
[url=https://raw.githubusercontent.com/godotengine/godot-docs/master/img/vector2_angle_to.png]Illustration of the returned angle.[/url] *)
    let angle_to =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_VECTOR2 "angle_to"
        (Base.Int64.of_string "3819070308")
        (Vector2.typ @-> Vector2.typ @-> returning Float.typ)
        Float.s

    (** Returns the angle between the line connecting the two points and the X axis, in radians.
[code]a.angle_to_point(b)[/code] is equivalent of doing [code](b - a).angle()[/code].
[url=https://raw.githubusercontent.com/godotengine/godot-docs/master/img/vector2_angle_to_point.png]Illustration of the returned angle.[/url] *)
    let angle_to_point =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_VECTOR2
        "angle_to_point"
        (Base.Int64.of_string "3819070308")
        (Vector2.typ @-> Vector2.typ @-> returning Float.typ)
        Float.s

    (** Returns the normalized vector pointing from this vector to [param to]. This is equivalent to using [code](b - a).normalized()[/code]. *)
    let direction_to =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_VECTOR2
        "direction_to"
        (Base.Int64.of_string "2026743667")
        (Vector2.typ @-> Vector2.typ @-> returning Vector2.typ)
        Vector2.s

    (** Returns the distance between this vector and [param to]. *)
    let distance_to =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_VECTOR2 "distance_to"
        (Base.Int64.of_string "3819070308")
        (Vector2.typ @-> Vector2.typ @-> returning Float.typ)
        Float.s

    (** Returns the squared distance between this vector and [param to].
This method runs faster than [method distance_to], so prefer it if you need to compare vectors or need the squared distance for some formula. *)
    let distance_squared_to =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_VECTOR2
        "distance_squared_to"
        (Base.Int64.of_string "3819070308")
        (Vector2.typ @-> Vector2.typ @-> returning Float.typ)
        Float.s

    (** Returns the length (magnitude) of this vector. *)
    let length =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_VECTOR2 "length"
        (Base.Int64.of_string "466405837")
        (Vector2.typ @-> returning Float.typ)
        Float.s

    (** Returns the squared length (squared magnitude) of this vector.
This method runs faster than [method length], so prefer it if you need to compare vectors or need the squared distance for some formula. *)
    let length_squared =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_VECTOR2
        "length_squared"
        (Base.Int64.of_string "466405837")
        (Vector2.typ @-> returning Float.typ)
        Float.s

    (** Returns the vector with a maximum length by limiting its length to [param length]. *)
    let limit_length =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_VECTOR2
        "limit_length"
        (Base.Int64.of_string "2544004089")
        (Float.typ @-> Vector2.typ @-> returning Vector2.typ)
        Vector2.s

    (** Returns the result of scaling the vector to unit length. Equivalent to [code]v / v.length()[/code]. See also [method is_normalized].
[b]Note:[/b] This function may return incorrect values if the input vector length is near zero. *)
    let normalized =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_VECTOR2 "normalized"
        (Base.Int64.of_string "2428350749")
        (Vector2.typ @-> returning Vector2.typ)
        Vector2.s

    (** Returns [code]true[/code] if the vector is normalized, i.e. its length is approximately equal to 1. *)
    let is_normalized =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_VECTOR2
        "is_normalized"
        (Base.Int64.of_string "3918633141")
        (Vector2.typ @-> returning Bool.typ)
        Bool.s

    (** Returns [code]true[/code] if this vector and [param to] are approximately equal, by running [method @GlobalScope.is_equal_approx] on each component. *)
    let is_equal_approx =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_VECTOR2
        "is_equal_approx"
        (Base.Int64.of_string "3190634762")
        (Vector2.typ @-> Vector2.typ @-> returning Bool.typ)
        Bool.s

    (** Returns [code]true[/code] if this vector's values are approximately zero, by running [method @GlobalScope.is_zero_approx] on each component.
This method is faster than using [method is_equal_approx] with one value as a zero vector. *)
    let is_zero_approx =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_VECTOR2
        "is_zero_approx"
        (Base.Int64.of_string "3918633141")
        (Vector2.typ @-> returning Bool.typ)
        Bool.s

    (** Returns [code]true[/code] if this vector is finite, by calling [method @GlobalScope.is_finite] on each component. *)
    let is_finite =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_VECTOR2 "is_finite"
        (Base.Int64.of_string "3918633141")
        (Vector2.typ @-> returning Bool.typ)
        Bool.s

    (** Returns a vector composed of the [method @GlobalScope.fposmod] of this vector's components and [param mod]. *)
    let posmod =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_VECTOR2 "posmod"
        (Base.Int64.of_string "2544004089")
        (Float.typ @-> Vector2.typ @-> returning Vector2.typ)
        Vector2.s

    (** Returns a vector composed of the [method @GlobalScope.fposmod] of this vector's components and [param modv]'s components. *)
    let posmodv =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_VECTOR2 "posmodv"
        (Base.Int64.of_string "2026743667")
        (Vector2.typ @-> Vector2.typ @-> returning Vector2.typ)
        Vector2.s

    (** Returns the result of projecting the vector onto the given vector [param b]. *)
    let project =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_VECTOR2 "project"
        (Base.Int64.of_string "2026743667")
        (Vector2.typ @-> Vector2.typ @-> returning Vector2.typ)
        Vector2.s

    (** Returns the result of the linear interpolation between this vector and [param to] by amount [param weight]. [param weight] is on the range of [code]0.0[/code] to [code]1.0[/code], representing the amount of interpolation. *)
    let lerp =
      foreign_builtin_method2 GlobalEnum.VariantType._TYPE_VECTOR2 "lerp"
        (Base.Int64.of_string "4250033116")
        (Vector2.typ @-> Float.typ @-> Vector2.typ @-> returning Vector2.typ)
        Vector2.s

    (** Returns the result of spherical linear interpolation between this vector and [param to], by amount [param weight]. [param weight] is on the range of 0.0 to 1.0, representing the amount of interpolation.
This method also handles interpolating the lengths if the input vectors have different lengths. For the special case of one or both input vectors having zero length, this method behaves like [method lerp]. *)
    let slerp =
      foreign_builtin_method2 GlobalEnum.VariantType._TYPE_VECTOR2 "slerp"
        (Base.Int64.of_string "4250033116")
        (Vector2.typ @-> Float.typ @-> Vector2.typ @-> returning Vector2.typ)
        Vector2.s

    (** Performs a cubic interpolation between this vector and [param b] using [param pre_a] and [param post_b] as handles, and returns the result at position [param weight]. [param weight] is on the range of 0.0 to 1.0, representing the amount of interpolation. *)
    let cubic_interpolate =
      foreign_builtin_method4 GlobalEnum.VariantType._TYPE_VECTOR2
        "cubic_interpolate"
        (Base.Int64.of_string "193522989")
        (Vector2.typ @-> Vector2.typ @-> Vector2.typ @-> Float.typ
       @-> Vector2.typ @-> returning Vector2.typ)
        Vector2.s

    (** Performs a cubic interpolation between this vector and [param b] using [param pre_a] and [param post_b] as handles, and returns the result at position [param weight]. [param weight] is on the range of 0.0 to 1.0, representing the amount of interpolation.
It can perform smoother interpolation than [method cubic_interpolate] by the time values. *)
    let cubic_interpolate_in_time =
      foreign_builtin_method7 GlobalEnum.VariantType._TYPE_VECTOR2
        "cubic_interpolate_in_time"
        (Base.Int64.of_string "1957055074")
        (Vector2.typ @-> Vector2.typ @-> Vector2.typ @-> Float.typ @-> Float.typ
       @-> Float.typ @-> Float.typ @-> Vector2.typ @-> returning Vector2.typ)
        Vector2.s

    (** Returns the point at the given [param t] on the [url=https://en.wikipedia.org/wiki/B%C3%A9zier_curve]Bézier curve[/url] defined by this vector and the given [param control_1], [param control_2], and [param end] points. *)
    let bezier_interpolate =
      foreign_builtin_method4 GlobalEnum.VariantType._TYPE_VECTOR2
        "bezier_interpolate"
        (Base.Int64.of_string "193522989")
        (Vector2.typ @-> Vector2.typ @-> Vector2.typ @-> Float.typ
       @-> Vector2.typ @-> returning Vector2.typ)
        Vector2.s

    (** Returns the derivative at the given [param t] on the [url=https://en.wikipedia.org/wiki/B%C3%A9zier_curve]Bézier curve[/url] defined by this vector and the given [param control_1], [param control_2], and [param end] points. *)
    let bezier_derivative =
      foreign_builtin_method4 GlobalEnum.VariantType._TYPE_VECTOR2
        "bezier_derivative"
        (Base.Int64.of_string "193522989")
        (Vector2.typ @-> Vector2.typ @-> Vector2.typ @-> Float.typ
       @-> Vector2.typ @-> returning Vector2.typ)
        Vector2.s

    (** Returns the axis of the vector's highest value. See [code]AXIS_ * [/code] constants. If all components are equal, this method returns [constant AXIS_X]. *)
    let max_axis_index =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_VECTOR2
        "max_axis_index"
        (Base.Int64.of_string "3173160232")
        (Vector2.typ @-> returning Int.typ)
        Int.s

    (** Returns the axis of the vector's lowest value. See [code]AXIS_ * [/code] constants. If all components are equal, this method returns [constant AXIS_Y]. *)
    let min_axis_index =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_VECTOR2
        "min_axis_index"
        (Base.Int64.of_string "3173160232")
        (Vector2.typ @-> returning Int.typ)
        Int.s

    (** Returns a new vector moved toward [param to] by the fixed [param delta] amount. Will not go past the final value. *)
    let move_toward =
      foreign_builtin_method2 GlobalEnum.VariantType._TYPE_VECTOR2 "move_toward"
        (Base.Int64.of_string "4250033116")
        (Vector2.typ @-> Float.typ @-> Vector2.typ @-> returning Vector2.typ)
        Vector2.s

    (** Returns the result of rotating this vector by [param angle] (in radians). See also [method @GlobalScope.deg_to_rad]. *)
    let rotated =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_VECTOR2 "rotated"
        (Base.Int64.of_string "2544004089")
        (Float.typ @-> Vector2.typ @-> returning Vector2.typ)
        Vector2.s

    (** Returns a perpendicular vector rotated 90 degrees counter-clockwise compared to the original, with the same length. *)
    let orthogonal =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_VECTOR2 "orthogonal"
        (Base.Int64.of_string "2428350749")
        (Vector2.typ @-> returning Vector2.typ)
        Vector2.s

    (** Returns a new vector with all components rounded down (towards negative infinity). *)
    let floor =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_VECTOR2 "floor"
        (Base.Int64.of_string "2428350749")
        (Vector2.typ @-> returning Vector2.typ)
        Vector2.s

    (** Returns a new vector with all components rounded up (towards positive infinity). *)
    let ceil =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_VECTOR2 "ceil"
        (Base.Int64.of_string "2428350749")
        (Vector2.typ @-> returning Vector2.typ)
        Vector2.s

    (** Returns a new vector with all components rounded to the nearest integer, with halfway cases rounded away from zero. *)
    let round =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_VECTOR2 "round"
        (Base.Int64.of_string "2428350749")
        (Vector2.typ @-> returning Vector2.typ)
        Vector2.s

    (** Returns the aspect ratio of this vector, the ratio of [member x] to [member y]. *)
    let aspect =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_VECTOR2 "aspect"
        (Base.Int64.of_string "466405837")
        (Vector2.typ @-> returning Float.typ)
        Float.s

    (** Returns the dot product of this vector and [param with]. This can be used to compare the angle between two vectors. For example, this can be used to determine whether an enemy is facing the player.
The dot product will be [code]0[/code] for a straight angle (90 degrees), greater than 0 for angles narrower than 90 degrees and lower than 0 for angles wider than 90 degrees.
When using unit (normalized) vectors, the result will always be between [code]-1.0[/code] (180 degree angle) when the vectors are facing opposite directions, and [code]1.0[/code] (0 degree angle) when the vectors are aligned.
[b]Note:[/b] [code]a.dot(b)[/code] is equivalent to [code]b.dot(a)[/code]. *)
    let dot =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_VECTOR2 "dot"
        (Base.Int64.of_string "3819070308")
        (Vector2.typ @-> Vector2.typ @-> returning Float.typ)
        Float.s

    (** Returns the result of sliding the vector along a plane defined by the given normal. *)
    let slide =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_VECTOR2 "slide"
        (Base.Int64.of_string "2026743667")
        (Vector2.typ @-> Vector2.typ @-> returning Vector2.typ)
        Vector2.s

    (** Returns a new vector ""bounced off"" from a plane defined by the given normal. *)
    let bounce =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_VECTOR2 "bounce"
        (Base.Int64.of_string "2026743667")
        (Vector2.typ @-> Vector2.typ @-> returning Vector2.typ)
        Vector2.s

    (** Returns the result of reflecting the vector from a line defined by the given direction vector [param n]. *)
    let reflect =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_VECTOR2 "reflect"
        (Base.Int64.of_string "2026743667")
        (Vector2.typ @-> Vector2.typ @-> returning Vector2.typ)
        Vector2.s

    (** Returns the 2D analog of the cross product for this vector and [param with].
This is the signed area of the parallelogram formed by the two vectors. If the second vector is clockwise from the first vector, then the cross product is the positive area. If counter-clockwise, the cross product is the negative area. If the two vectors are parallel this returns zero, making it useful for testing if two vectors are parallel.
[b]Note:[/b] Cross product is not defined in 2D mathematically. This method embeds the 2D vectors in the XY plane of 3D space and uses their cross product's Z component as the analog. *)
    let cross =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_VECTOR2 "cross"
        (Base.Int64.of_string "3819070308")
        (Vector2.typ @-> Vector2.typ @-> returning Float.typ)
        Float.s

    (** Returns a new vector with all components in absolute values (i.e. positive). *)
    let abs =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_VECTOR2 "abs"
        (Base.Int64.of_string "2428350749")
        (Vector2.typ @-> returning Vector2.typ)
        Vector2.s

    (** Returns a new vector with each component set to [code]1.0[/code] if it's positive, [code]-1.0[/code] if it's negative, and [code]0.0[/code] if it's zero. The result is identical to calling [method @GlobalScope.sign] on each component. *)
    let sign =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_VECTOR2 "sign"
        (Base.Int64.of_string "2428350749")
        (Vector2.typ @-> returning Vector2.typ)
        Vector2.s

    (** Returns a new vector with all components clamped between the components of [param min] and [param max], by running [method @GlobalScope.clamp] on each component. *)
    let clamp =
      foreign_builtin_method2 GlobalEnum.VariantType._TYPE_VECTOR2 "clamp"
        (Base.Int64.of_string "318031021")
        (Vector2.typ @-> Vector2.typ @-> Vector2.typ @-> returning Vector2.typ)
        Vector2.s

    (** Returns a new vector with each component snapped to the nearest multiple of the corresponding component in [param step]. This can also be used to round the components to an arbitrary number of decimals. *)
    let snapped =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_VECTOR2 "snapped"
        (Base.Int64.of_string "2026743667")
        (Vector2.typ @-> Vector2.typ @-> returning Vector2.typ)
        Vector2.s

    (** Creates a unit [Vector2] rotated to the given [param angle] in radians. This is equivalent to doing [code]Vector2(cos(angle), sin(angle))[/code] or [code]Vector2.RIGHT.rotated(angle)[/code].
[codeblock]
print(Vector2.from_angle(0)) # Prints (1, 0).
print(Vector2(1, 0).angle()) # Prints 0, which is the angle used above.
print(Vector2.from_angle(PI / 2)) # Prints (0, 1).
[/codeblock] *)
    let from_angle =
      foreign_builtin_method1_static GlobalEnum.VariantType._TYPE_VECTOR2
        "from_angle"
        (Base.Int64.of_string "889263119")
        (Float.typ @-> returning Vector2.typ)
        Vector2.s

    (** Returns the negative value of the [Vector2]. This is the same as writing [code]Vector2(-v.x, -v.y)[/code]. This operation flips the direction of the vector while keeping the same magnitude. With floats, the number zero can be either positive or negative. *)
    let ( ~- ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_VECTOR2 None
        GlobalEnum.VariantOperator._OP_NEGATE
        (funptr
           (Vector2.typ @-> Vector2.typ @-> Vector2.typ @-> returning void))

    (** Returns the same value as if the [code]+[/code] was not there. Unary [code]+[/code] does nothing, but sometimes it can make your code more readable. *)
    let ( ~+ ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_VECTOR2 None
        GlobalEnum.VariantOperator._OP_POSITIVE
        (funptr
           (Vector2.typ @-> Vector2.typ @-> Vector2.typ @-> returning void))

    let not =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_VECTOR2 None
        GlobalEnum.VariantOperator._OP_NOT
        (funptr (Vector2.typ @-> Vector2.typ @-> Bool.typ @-> returning void))

    (** Returns [code]true[/code] if the vectors are exactly equal.
[b]Note:[/b] Due to floating-point precision errors, consider using [method is_equal_approx] instead, which is more reliable.
[b]Note:[/b] Vectors with [constant @GDScript.NAN] elements don't behave the same as other vectors. Therefore, the results from this operator may not be accurate if NaNs are included. *)
    let ( = ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_VECTOR2
        (Some GlobalEnum.VariantType._TYPE_VECTOR2)
        GlobalEnum.VariantOperator._OP_EQUAL
        (funptr (Vector2.typ @-> Vector2.typ @-> Bool.typ @-> returning void))

    (** Returns [code]true[/code] if the vectors are not equal.
[b]Note:[/b] Due to floating-point precision errors, consider using [method is_equal_approx] instead, which is more reliable.
[b]Note:[/b] Vectors with [constant @GDScript.NAN] elements don't behave the same as other vectors. Therefore, the results from this operator may not be accurate if NaNs are included. *)
    let ( <> ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_VECTOR2
        (Some GlobalEnum.VariantType._TYPE_VECTOR2)
        GlobalEnum.VariantOperator._OP_NOT_EQUAL
        (funptr (Vector2.typ @-> Vector2.typ @-> Bool.typ @-> returning void))

    (** Compares two [Vector2] vectors by first checking if the X value of the left vector is less than the X value of the [param right] vector. If the X values are exactly equal, then it repeats this check with the Y values of the two vectors. This operator is useful for sorting vectors.
[b]Note:[/b] Vectors with [constant @GDScript.NAN] elements don't behave the same as other vectors. Therefore, the results from this operator may not be accurate if NaNs are included. *)
    let ( < ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_VECTOR2
        (Some GlobalEnum.VariantType._TYPE_VECTOR2)
        GlobalEnum.VariantOperator._OP_LESS
        (funptr (Vector2.typ @-> Vector2.typ @-> Bool.typ @-> returning void))

    (** Compares two [Vector2] vectors by first checking if the X value of the left vector is less than or equal to the X value of the [param right] vector. If the X values are exactly equal, then it repeats this check with the Y values of the two vectors. This operator is useful for sorting vectors.
[b]Note:[/b] Vectors with [constant @GDScript.NAN] elements don't behave the same as other vectors. Therefore, the results from this operator may not be accurate if NaNs are included. *)
    let ( <= ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_VECTOR2
        (Some GlobalEnum.VariantType._TYPE_VECTOR2)
        GlobalEnum.VariantOperator._OP_LESS_EQUAL
        (funptr (Vector2.typ @-> Vector2.typ @-> Bool.typ @-> returning void))

    (** Compares two [Vector2] vectors by first checking if the X value of the left vector is greater than the X value of the [param right] vector. If the X values are exactly equal, then it repeats this check with the Y values of the two vectors. This operator is useful for sorting vectors.
[b]Note:[/b] Vectors with [constant @GDScript.NAN] elements don't behave the same as other vectors. Therefore, the results from this operator may not be accurate if NaNs are included. *)
    let ( > ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_VECTOR2
        (Some GlobalEnum.VariantType._TYPE_VECTOR2)
        GlobalEnum.VariantOperator._OP_GREATER
        (funptr (Vector2.typ @-> Vector2.typ @-> Bool.typ @-> returning void))

    (** Compares two [Vector2] vectors by first checking if the X value of the left vector is greater than or equal to the X value of the [param right] vector. If the X values are exactly equal, then it repeats this check with the Y values of the two vectors. This operator is useful for sorting vectors.
[b]Note:[/b] Vectors with [constant @GDScript.NAN] elements don't behave the same as other vectors. Therefore, the results from this operator may not be accurate if NaNs are included. *)
    let ( >= ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_VECTOR2
        (Some GlobalEnum.VariantType._TYPE_VECTOR2)
        GlobalEnum.VariantOperator._OP_GREATER_EQUAL
        (funptr (Vector2.typ @-> Vector2.typ @-> Bool.typ @-> returning void))

    (** Adds each component of the [Vector2] by the components of the given [Vector2].
[codeblock]
print(Vector2(10, 20) + Vector2(3, 4)) # Prints ""(13, 24)""
[/codeblock] *)
    let ( + ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_VECTOR2
        (Some GlobalEnum.VariantType._TYPE_VECTOR2)
        GlobalEnum.VariantOperator._OP_ADD
        (funptr
           (Vector2.typ @-> Vector2.typ @-> Vector2.typ @-> returning void))

    (** Subtracts each component of the [Vector2] by the components of the given [Vector2].
[codeblock]
print(Vector2(10, 20) - Vector2(3, 4)) # Prints ""(7, 16)""
[/codeblock] *)
    let ( - ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_VECTOR2
        (Some GlobalEnum.VariantType._TYPE_VECTOR2)
        GlobalEnum.VariantOperator._OP_SUBTRACT
        (funptr
           (Vector2.typ @-> Vector2.typ @-> Vector2.typ @-> returning void))

    (** Multiplies each component of the [Vector2] by the components of the given [Vector2].
[codeblock]
print(Vector2(10, 20)  *  Vector2(3, 4)) # Prints ""(30, 80)""
[/codeblock] *)
    let ( * ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_VECTOR2
        (Some GlobalEnum.VariantType._TYPE_VECTOR2)
        GlobalEnum.VariantOperator._OP_MULTIPLY
        (funptr
           (Vector2.typ @-> Vector2.typ @-> Vector2.typ @-> returning void))

    (** Divides each component of the [Vector2] by the components of the given [Vector2].
[codeblock]
print(Vector2(10, 20) / Vector2(2, 5)) # Prints ""(5, 4)""
[/codeblock] *)
    let ( / ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_VECTOR2
        (Some GlobalEnum.VariantType._TYPE_VECTOR2)
        GlobalEnum.VariantOperator._OP_DIVIDE
        (funptr
           (Vector2.typ @-> Vector2.typ @-> Vector2.typ @-> returning void))

    let _Vector2_elem_Dictionary =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_VECTOR2
        (Some GlobalEnum.VariantType._TYPE_DICTIONARY)
        GlobalEnum.VariantOperator._OP_IN
        (funptr
           (Vector2.typ @-> Dictionary.typ @-> Bool.typ @-> returning void))

    let _Vector2_elem_Array =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_VECTOR2
        (Some GlobalEnum.VariantType._TYPE_ARRAY)
        GlobalEnum.VariantOperator._OP_IN
        (funptr (Vector2.typ @-> Array.typ @-> Bool.typ @-> returning void))

    let _Vector2_elem_PackedVector2Array =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_VECTOR2
        (Some GlobalEnum.VariantType._TYPE_PACKED_VECTOR2_ARRAY)
        GlobalEnum.VariantOperator._OP_IN
        (funptr
           (Vector2.typ @-> PackedVector2Array.typ @-> Bool.typ
          @-> returning void))

    module Axis = struct
      type t = Int.t

      let typ = Int.typ

      (** Enumerated value for the X axis. Returned by [method max_axis_index] and [method min_axis_index]. *)
      let _AXIS_X = 0

      (** Enumerated value for the Y axis. Returned by [method max_axis_index] and [method min_axis_index]. *)
      let _AXIS_Y = 1
    end
  end

  module Vector2i = struct
    include M.Vector2i

    (** Returns the aspect ratio of this vector, the ratio of [member x] to [member y]. *)
    let aspect =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_VECTOR2I "aspect"
        (Base.Int64.of_string "466405837")
        (Vector2i.typ @-> returning Float.typ)
        Float.s

    (** Returns the axis of the vector's highest value. See [code]AXIS_ * [/code] constants. If all components are equal, this method returns [constant AXIS_X]. *)
    let max_axis_index =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_VECTOR2I
        "max_axis_index"
        (Base.Int64.of_string "3173160232")
        (Vector2i.typ @-> returning Int.typ)
        Int.s

    (** Returns the axis of the vector's lowest value. See [code]AXIS_ * [/code] constants. If all components are equal, this method returns [constant AXIS_Y]. *)
    let min_axis_index =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_VECTOR2I
        "min_axis_index"
        (Base.Int64.of_string "3173160232")
        (Vector2i.typ @-> returning Int.typ)
        Int.s

    (** Returns the length (magnitude) of this vector. *)
    let length =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_VECTOR2I "length"
        (Base.Int64.of_string "466405837")
        (Vector2i.typ @-> returning Float.typ)
        Float.s

    (** Returns the squared length (squared magnitude) of this vector.
This method runs faster than [method length], so prefer it if you need to compare vectors or need the squared distance for some formula. *)
    let length_squared =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_VECTOR2I
        "length_squared"
        (Base.Int64.of_string "3173160232")
        (Vector2i.typ @-> returning Int.typ)
        Int.s

    (** Returns a new vector with each component set to [code]1[/code] if it's positive, [code]-1[/code] if it's negative, and [code]0[/code] if it's zero. The result is identical to calling [method @GlobalScope.sign] on each component. *)
    let sign =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_VECTOR2I "sign"
        (Base.Int64.of_string "3444277866")
        (Vector2i.typ @-> returning Vector2i.typ)
        Vector2i.s

    (** Returns a new vector with all components in absolute values (i.e. positive). *)
    let abs =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_VECTOR2I "abs"
        (Base.Int64.of_string "3444277866")
        (Vector2i.typ @-> returning Vector2i.typ)
        Vector2i.s

    (** Returns a new vector with all components clamped between the components of [param min] and [param max], by running [method @GlobalScope.clamp] on each component. *)
    let clamp =
      foreign_builtin_method2 GlobalEnum.VariantType._TYPE_VECTOR2I "clamp"
        (Base.Int64.of_string "186568249")
        (Vector2i.typ @-> Vector2i.typ @-> Vector2i.typ
       @-> returning Vector2i.typ)
        Vector2i.s

    (** Returns a new vector with each component snapped to the closest multiple of the corresponding component in [param step]. *)
    let snapped =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_VECTOR2I "snapped"
        (Base.Int64.of_string "1735278196")
        (Vector2i.typ @-> Vector2i.typ @-> returning Vector2i.typ)
        Vector2i.s

    (** Returns the negative value of the [Vector2i]. This is the same as writing [code]Vector2i(-v.x, -v.y)[/code]. This operation flips the direction of the vector while keeping the same magnitude. *)
    let ( ~- ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_VECTOR2I None
        GlobalEnum.VariantOperator._OP_NEGATE
        (funptr
           (Vector2i.typ @-> Vector2i.typ @-> Vector2i.typ @-> returning void))

    (** Returns the same value as if the [code]+[/code] was not there. Unary [code]+[/code] does nothing, but sometimes it can make your code more readable. *)
    let ( ~+ ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_VECTOR2I None
        GlobalEnum.VariantOperator._OP_POSITIVE
        (funptr
           (Vector2i.typ @-> Vector2i.typ @-> Vector2i.typ @-> returning void))

    let not =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_VECTOR2I None
        GlobalEnum.VariantOperator._OP_NOT
        (funptr (Vector2i.typ @-> Vector2i.typ @-> Bool.typ @-> returning void))

    (** Returns [code]true[/code] if the vectors are equal. *)
    let ( = ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_VECTOR2I
        (Some GlobalEnum.VariantType._TYPE_VECTOR2I)
        GlobalEnum.VariantOperator._OP_EQUAL
        (funptr (Vector2i.typ @-> Vector2i.typ @-> Bool.typ @-> returning void))

    (** Returns [code]true[/code] if the vectors are not equal. *)
    let ( <> ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_VECTOR2I
        (Some GlobalEnum.VariantType._TYPE_VECTOR2I)
        GlobalEnum.VariantOperator._OP_NOT_EQUAL
        (funptr (Vector2i.typ @-> Vector2i.typ @-> Bool.typ @-> returning void))

    (** Compares two [Vector2i] vectors by first checking if the X value of the left vector is less than the X value of the [param right] vector. If the X values are exactly equal, then it repeats this check with the Y values of the two vectors. This operator is useful for sorting vectors. *)
    let ( < ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_VECTOR2I
        (Some GlobalEnum.VariantType._TYPE_VECTOR2I)
        GlobalEnum.VariantOperator._OP_LESS
        (funptr (Vector2i.typ @-> Vector2i.typ @-> Bool.typ @-> returning void))

    (** Compares two [Vector2i] vectors by first checking if the X value of the left vector is less than or equal to the X value of the [param right] vector. If the X values are exactly equal, then it repeats this check with the Y values of the two vectors. This operator is useful for sorting vectors. *)
    let ( <= ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_VECTOR2I
        (Some GlobalEnum.VariantType._TYPE_VECTOR2I)
        GlobalEnum.VariantOperator._OP_LESS_EQUAL
        (funptr (Vector2i.typ @-> Vector2i.typ @-> Bool.typ @-> returning void))

    (** Compares two [Vector2i] vectors by first checking if the X value of the left vector is greater than the X value of the [param right] vector. If the X values are exactly equal, then it repeats this check with the Y values of the two vectors. This operator is useful for sorting vectors. *)
    let ( > ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_VECTOR2I
        (Some GlobalEnum.VariantType._TYPE_VECTOR2I)
        GlobalEnum.VariantOperator._OP_GREATER
        (funptr (Vector2i.typ @-> Vector2i.typ @-> Bool.typ @-> returning void))

    (** Compares two [Vector2i] vectors by first checking if the X value of the left vector is greater than or equal to the X value of the [param right] vector. If the X values are exactly equal, then it repeats this check with the Y values of the two vectors. This operator is useful for sorting vectors. *)
    let ( >= ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_VECTOR2I
        (Some GlobalEnum.VariantType._TYPE_VECTOR2I)
        GlobalEnum.VariantOperator._OP_GREATER_EQUAL
        (funptr (Vector2i.typ @-> Vector2i.typ @-> Bool.typ @-> returning void))

    (** Adds each component of the [Vector2i] by the components of the given [Vector2i].
[codeblock]
print(Vector2i(10, 20) + Vector2i(3, 4)) # Prints ""(13, 24)""
[/codeblock] *)
    let ( + ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_VECTOR2I
        (Some GlobalEnum.VariantType._TYPE_VECTOR2I)
        GlobalEnum.VariantOperator._OP_ADD
        (funptr
           (Vector2i.typ @-> Vector2i.typ @-> Vector2i.typ @-> returning void))

    (** Subtracts each component of the [Vector2i] by the components of the given [Vector2i].
[codeblock]
print(Vector2i(10, 20) - Vector2i(3, 4)) # Prints ""(7, 16)""
[/codeblock] *)
    let ( - ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_VECTOR2I
        (Some GlobalEnum.VariantType._TYPE_VECTOR2I)
        GlobalEnum.VariantOperator._OP_SUBTRACT
        (funptr
           (Vector2i.typ @-> Vector2i.typ @-> Vector2i.typ @-> returning void))

    (** Multiplies each component of the [Vector2i] by the components of the given [Vector2i].
[codeblock]
print(Vector2i(10, 20)  *  Vector2i(3, 4)) # Prints ""(30, 80)""
[/codeblock] *)
    let ( * ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_VECTOR2I
        (Some GlobalEnum.VariantType._TYPE_VECTOR2I)
        GlobalEnum.VariantOperator._OP_MULTIPLY
        (funptr
           (Vector2i.typ @-> Vector2i.typ @-> Vector2i.typ @-> returning void))

    (** Divides each component of the [Vector2i] by the components of the given [Vector2i].
[codeblock]
print(Vector2i(10, 20) / Vector2i(2, 5)) # Prints ""(5, 4)""
[/codeblock] *)
    let ( / ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_VECTOR2I
        (Some GlobalEnum.VariantType._TYPE_VECTOR2I)
        GlobalEnum.VariantOperator._OP_DIVIDE
        (funptr
           (Vector2i.typ @-> Vector2i.typ @-> Vector2i.typ @-> returning void))

    (** Gets the remainder of each component of the [Vector2i] with the components of the given [Vector2i]. This operation uses truncated division, which is often not desired as it does not work well with negative numbers. Consider using [method @GlobalScope.posmod] instead if you want to handle negative numbers.
[codeblock]
print(Vector2i(10, -20) % Vector2i(7, 8)) # Prints ""(3, -4)""
[/codeblock] *)
    let ( % ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_VECTOR2I
        (Some GlobalEnum.VariantType._TYPE_VECTOR2I)
        GlobalEnum.VariantOperator._OP_MODULE
        (funptr
           (Vector2i.typ @-> Vector2i.typ @-> Vector2i.typ @-> returning void))

    let _Vector2i_elem_Dictionary =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_VECTOR2I
        (Some GlobalEnum.VariantType._TYPE_DICTIONARY)
        GlobalEnum.VariantOperator._OP_IN
        (funptr
           (Vector2i.typ @-> Dictionary.typ @-> Bool.typ @-> returning void))

    let _Vector2i_elem_Array =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_VECTOR2I
        (Some GlobalEnum.VariantType._TYPE_ARRAY)
        GlobalEnum.VariantOperator._OP_IN
        (funptr (Vector2i.typ @-> Array.typ @-> Bool.typ @-> returning void))

    module Axis = struct
      type t = Int.t

      let typ = Int.typ

      (** Enumerated value for the X axis. Returned by [method max_axis_index] and [method min_axis_index]. *)
      let _AXIS_X = 0

      (** Enumerated value for the Y axis. Returned by [method max_axis_index] and [method min_axis_index]. *)
      let _AXIS_Y = 1
    end
  end

  module Rect2 = struct
    include M.Rect2

    (** Returns the center point of the rectangle. This is the same as [code]position + (size / 2.0)[/code]. *)
    let get_center =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_RECT2 "get_center"
        (Base.Int64.of_string "2428350749")
        (Rect2.typ @-> returning Vector2.typ)
        Vector2.s

    (** Returns the rectangle's area. This is equivalent to [code]size.x  *  size.y[/code]. See also [method has_area]. *)
    let get_area =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_RECT2 "get_area"
        (Base.Int64.of_string "466405837")
        (Rect2.typ @-> returning Float.typ)
        Float.s

    (** Returns [code]true[/code] if this rectangle has positive width and height. See also [method get_area]. *)
    let has_area =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_RECT2 "has_area"
        (Base.Int64.of_string "3918633141")
        (Rect2.typ @-> returning Bool.typ)
        Bool.s

    (** Returns [code]true[/code] if the rectangle contains the given [param point]. By convention, points on the right and bottom edges are [b]not[/b] included.
[b]Note:[/b] This method is not reliable for [Rect2] with a [i]negative[/i] [member size]. Use [method abs] first to get a valid rectangle. *)
    let has_point =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_RECT2 "has_point"
        (Base.Int64.of_string "3190634762")
        (Vector2.typ @-> Rect2.typ @-> returning Bool.typ)
        Bool.s

    (** Returns [code]true[/code] if this rectangle and [param rect] are approximately equal, by calling [method Vector2.is_equal_approx] on the [member position] and the [member size]. *)
    let is_equal_approx =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_RECT2
        "is_equal_approx"
        (Base.Int64.of_string "1908192260")
        (Rect2.typ @-> Rect2.typ @-> returning Bool.typ)
        Bool.s

    (** Returns [code]true[/code] if this rectangle's values are finite, by calling [method Vector2.is_finite] on the [member position] and the [member size]. *)
    let is_finite =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_RECT2 "is_finite"
        (Base.Int64.of_string "3918633141")
        (Rect2.typ @-> returning Bool.typ)
        Bool.s

    (** Returns [code]true[/code] if this rectangle overlaps with the [param b] rectangle. The edges of both rectangles are excluded, unless [param include_borders] is [code]true[/code]. *)
    let intersects =
      foreign_builtin_method2 GlobalEnum.VariantType._TYPE_RECT2 "intersects"
        (Base.Int64.of_string "819294880")
        (Rect2.typ @-> Bool.typ @-> Rect2.typ @-> returning Bool.typ)
        Bool.s

    (** Returns [code]true[/code] if this rectangle [i]completely[/i] encloses the [param b] rectangle. *)
    let encloses =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_RECT2 "encloses"
        (Base.Int64.of_string "1908192260")
        (Rect2.typ @-> Rect2.typ @-> returning Bool.typ)
        Bool.s

    (** Returns the intersection between this rectangle and [param b]. If the rectangles do not intersect, returns an empty [Rect2].
[codeblocks]
[gdscript]
var rect1 = Rect2(0, 0, 5, 10)
var rect2 = Rect2(2, 0, 8, 4)

var a = rect1.intersection(rect2) # a is Rect2(2, 0, 3, 4)
[/gdscript]
[csharp]
var rect1 = new Rect2(0, 0, 5, 10);
var rect2 = new Rect2(2, 0, 8, 4);

var a = rect1.Intersection(rect2); // a is Rect2(2, 0, 3, 4)
[/csharp]
[/codeblocks]
[b]Note:[/b] If you only need to know whether two rectangles are overlapping, use [method intersects], instead. *)
    let intersection =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_RECT2 "intersection"
        (Base.Int64.of_string "2282977743")
        (Rect2.typ @-> Rect2.typ @-> returning Rect2.typ)
        Rect2.s

    (** Returns a [Rect2] that encloses both this rectangle and [param b] around the edges. See also [method encloses]. *)
    let merge =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_RECT2 "merge"
        (Base.Int64.of_string "2282977743")
        (Rect2.typ @-> Rect2.typ @-> returning Rect2.typ)
        Rect2.s

    (** Returns a copy of this rectangle expanded to align the edges with the given [param to] point, if necessary.
[codeblocks]
[gdscript]
var rect = Rect2(0, 0, 5, 2)

rect = rect.expand(Vector2(10, 0)) # rect is Rect2(0, 0, 10, 2)
rect = rect.expand(Vector2(-5, 5)) # rect is Rect2(-5, 0, 10, 5)
[/gdscript]
[csharp]
var rect = new Rect2(0, 0, 5, 2);

rect = rect.Expand(new Vector2(10, 0)); // rect is Rect2(0, 0, 10, 2)
rect = rect.Expand(new Vector2(-5, 5)); // rect is Rect2(-5, 0, 10, 5)
[/csharp]
[/codeblocks] *)
    let expand =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_RECT2 "expand"
        (Base.Int64.of_string "293272265")
        (Vector2.typ @-> Rect2.typ @-> returning Rect2.typ)
        Rect2.s

    (** Returns a copy of this rectangle extended on all sides by the given [param amount]. A negative [param amount] shrinks the rectangle instead. See also [method grow_individual] and [method grow_side].
[codeblocks]
[gdscript]
var a = Rect2(4, 4, 8, 8).grow(4) # a is Rect2(0, 0, 16, 16)
var b = Rect2(0, 0, 8, 4).grow(2) # b is Rect2(-2, -2, 12, 8)
[/gdscript]
[csharp]
var a = new Rect2(4, 4, 8, 8).Grow(4); // a is Rect2(0, 0, 16, 16)
var b = new Rect2(0, 0, 8, 4).Grow(2); // b is Rect2(-2, -2, 12, 8)
[/csharp]
[/codeblocks] *)
    let grow =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_RECT2 "grow"
        (Base.Int64.of_string "39664498")
        (Float.typ @-> Rect2.typ @-> returning Rect2.typ)
        Rect2.s

    (** Returns a copy of this rectangle with its [param side] extended by the given [param amount] (see [enum Side] constants). A negative [param amount] shrinks the rectangle, instead. See also [method grow] and [method grow_individual]. *)
    let grow_side =
      foreign_builtin_method2 GlobalEnum.VariantType._TYPE_RECT2 "grow_side"
        (Base.Int64.of_string "4177736158")
        (Int.typ @-> Float.typ @-> Rect2.typ @-> returning Rect2.typ)
        Rect2.s

    (** Returns a copy of this rectangle with its [param left], [param top], [param right], and [param bottom] sides extended by the given amounts. Negative values shrink the sides, instead. See also [method grow] and [method grow_side]. *)
    let grow_individual =
      foreign_builtin_method4 GlobalEnum.VariantType._TYPE_RECT2
        "grow_individual"
        (Base.Int64.of_string "3203390369")
        (Float.typ @-> Float.typ @-> Float.typ @-> Float.typ @-> Rect2.typ
       @-> returning Rect2.typ)
        Rect2.s

    (** Returns a [Rect2] equivalent to this rectangle, with its width and height modified to be non-negative values, and with its [member position] being the top-left corner of the rectangle.
[codeblocks]
[gdscript]
var rect = Rect2(25, 25, -100, -50)
var absolute = rect.abs() # absolute is Rect2(-75, -25, 100, 50)
[/gdscript]
[csharp]
var rect = new Rect2(25, 25, -100, -50);
var absolute = rect.Abs(); // absolute is Rect2(-75, -25, 100, 50)
[/csharp]
[/codeblocks]
[b]Note:[/b] It's recommended to use this method when [member size] is negative, as most other methods in Godot assume that the [member position] is the top-left corner, and the [member end] is the bottom-right corner. *)
    let abs =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_RECT2 "abs"
        (Base.Int64.of_string "3107653634")
        (Rect2.typ @-> returning Rect2.typ)
        Rect2.s

    let not =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_RECT2 None
        GlobalEnum.VariantOperator._OP_NOT
        (funptr (Rect2.typ @-> Rect2.typ @-> Bool.typ @-> returning void))

    (** Returns [code]true[/code] if both [member position] and [member size] of the rectangles are exactly equal, respectively.
[b]Note:[/b] Due to floating-point precision errors, consider using [method is_equal_approx] instead, which is more reliable. *)
    let ( = ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_RECT2
        (Some GlobalEnum.VariantType._TYPE_RECT2)
        GlobalEnum.VariantOperator._OP_EQUAL
        (funptr (Rect2.typ @-> Rect2.typ @-> Bool.typ @-> returning void))

    (** Returns [code]true[/code] if the [member position] or [member size] of both rectangles are not equal.
[b]Note:[/b] Due to floating-point precision errors, consider using [method is_equal_approx] instead, which is more reliable. *)
    let ( <> ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_RECT2
        (Some GlobalEnum.VariantType._TYPE_RECT2)
        GlobalEnum.VariantOperator._OP_NOT_EQUAL
        (funptr (Rect2.typ @-> Rect2.typ @-> Bool.typ @-> returning void))

    let _Rect2_elem_Dictionary =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_RECT2
        (Some GlobalEnum.VariantType._TYPE_DICTIONARY)
        GlobalEnum.VariantOperator._OP_IN
        (funptr (Rect2.typ @-> Dictionary.typ @-> Bool.typ @-> returning void))

    let _Rect2_elem_Array =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_RECT2
        (Some GlobalEnum.VariantType._TYPE_ARRAY)
        GlobalEnum.VariantOperator._OP_IN
        (funptr (Rect2.typ @-> Array.typ @-> Bool.typ @-> returning void))
  end

  module Rect2i = struct
    include M.Rect2i

    (** Returns the center point of the rectangle. This is the same as [code]position + (size / 2)[/code].
[b]Note:[/b] If the [member size] is odd, the result will be rounded towards [member position]. *)
    let get_center =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_RECT2I "get_center"
        (Base.Int64.of_string "3444277866")
        (Rect2i.typ @-> returning Vector2i.typ)
        Vector2i.s

    (** Returns the rectangle's area. This is equivalent to [code]size.x  *  size.y[/code]. See also [method has_area]. *)
    let get_area =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_RECT2I "get_area"
        (Base.Int64.of_string "3173160232")
        (Rect2i.typ @-> returning Int.typ)
        Int.s

    (** Returns [code]true[/code] if this rectangle has positive width and height. See also [method get_area]. *)
    let has_area =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_RECT2I "has_area"
        (Base.Int64.of_string "3918633141")
        (Rect2i.typ @-> returning Bool.typ)
        Bool.s

    (** Returns [code]true[/code] if the rectangle contains the given [param point]. By convention, points on the right and bottom edges are [b]not[/b] included.
[b]Note:[/b] This method is not reliable for [Rect2i] with a [i]negative[/i] [member size]. Use [method abs] first to get a valid rectangle. *)
    let has_point =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_RECT2I "has_point"
        (Base.Int64.of_string "328189994")
        (Vector2i.typ @-> Rect2i.typ @-> returning Bool.typ)
        Bool.s

    (** Returns [code]true[/code] if this rectangle overlaps with the [param b] rectangle. The edges of both rectangles are excluded. *)
    let intersects =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_RECT2I "intersects"
        (Base.Int64.of_string "3434691493")
        (Rect2i.typ @-> Rect2i.typ @-> returning Bool.typ)
        Bool.s

    (** Returns [code]true[/code] if this [Rect2i] completely encloses another one. *)
    let encloses =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_RECT2I "encloses"
        (Base.Int64.of_string "3434691493")
        (Rect2i.typ @-> Rect2i.typ @-> returning Bool.typ)
        Bool.s

    (** Returns the intersection between this rectangle and [param b]. If the rectangles do not intersect, returns an empty [Rect2i].
[codeblocks]
[gdscript]
var a = Rect2i(0, 0, 5, 10)
var b = Rect2i(2, 0, 8, 4)

var c = a.intersection(b) # c is Rect2i(2, 0, 3, 4)
[/gdscript]
[csharp]
var a = new Rect2I(0, 0, 5, 10);
var b = new Rect2I(2, 0, 8, 4);

var c = rect1.Intersection(rect2); // c is Rect2I(2, 0, 3, 4)
[/csharp]
[/codeblocks]
[b]Note:[/b] If you only need to know whether two rectangles are overlapping, use [method intersects], instead. *)
    let intersection =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_RECT2I "intersection"
        (Base.Int64.of_string "717431873")
        (Rect2i.typ @-> Rect2i.typ @-> returning Rect2i.typ)
        Rect2i.s

    (** Returns a [Rect2i] that encloses both this rectangle and [param b] around the edges. See also [method encloses]. *)
    let merge =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_RECT2I "merge"
        (Base.Int64.of_string "717431873")
        (Rect2i.typ @-> Rect2i.typ @-> returning Rect2i.typ)
        Rect2i.s

    (** Returns a copy of this rectangle expanded to align the edges with the given [param to] point, if necessary.
[codeblocks]
[gdscript]
var rect = Rect2i(0, 0, 5, 2)

rect = rect.expand(Vector2i(10, 0)) # rect is Rect2i(0, 0, 10, 2)
rect = rect.expand(Vector2i(-5, 5)) # rect is Rect2i(-5, 0, 10, 5)
[/gdscript]
[csharp]
var rect = new Rect2I(0, 0, 5, 2);

rect = rect.Expand(new Vector2I(10, 0)); // rect is Rect2I(0, 0, 10, 2)
rect = rect.Expand(new Vector2I(-5, 5)); // rect is Rect2I(-5, 0, 10, 5)
[/csharp]
[/codeblocks] *)
    let expand =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_RECT2I "expand"
        (Base.Int64.of_string "1355196872")
        (Vector2i.typ @-> Rect2i.typ @-> returning Rect2i.typ)
        Rect2i.s

    (** Returns a copy of this rectangle extended on all sides by the given [param amount]. A negative [param amount] shrinks the rectangle instead. See also [method grow_individual] and [method grow_side].
[codeblocks]
[gdscript]
var a = Rect2i(4, 4, 8, 8).grow(4) # a is Rect2i(0, 0, 16, 16)
var b = Rect2i(0, 0, 8, 4).grow(2) # b is Rect2i(-2, -2, 12, 8)
[/gdscript]
[csharp]
var a = new Rect2I(4, 4, 8, 8).Grow(4); // a is Rect2I(0, 0, 16, 16)
var b = new Rect2I(0, 0, 8, 4).Grow(2); // b is Rect2I(-2, -2, 12, 8)
[/csharp]
[/codeblocks] *)
    let grow =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_RECT2I "grow"
        (Base.Int64.of_string "1578070074")
        (Int.typ @-> Rect2i.typ @-> returning Rect2i.typ)
        Rect2i.s

    (** Returns a copy of this rectangle with its [param side] extended by the given [param amount] (see [enum Side] constants). A negative [param amount] shrinks the rectangle, instead. See also [method grow] and [method grow_individual]. *)
    let grow_side =
      foreign_builtin_method2 GlobalEnum.VariantType._TYPE_RECT2I "grow_side"
        (Base.Int64.of_string "3191154199")
        (Int.typ @-> Int.typ @-> Rect2i.typ @-> returning Rect2i.typ)
        Rect2i.s

    (** Returns a copy of this rectangle with its [param left], [param top], [param right], and [param bottom] sides extended by the given amounts. Negative values shrink the sides, instead. See also [method grow] and [method grow_side]. *)
    let grow_individual =
      foreign_builtin_method4 GlobalEnum.VariantType._TYPE_RECT2I
        "grow_individual"
        (Base.Int64.of_string "1893743416")
        (Int.typ @-> Int.typ @-> Int.typ @-> Int.typ @-> Rect2i.typ
       @-> returning Rect2i.typ)
        Rect2i.s

    (** Returns a [Rect2i] equivalent to this rectangle, with its width and height modified to be non-negative values, and with its [member position] being the top-left corner of the rectangle.
[codeblocks]
[gdscript]
var rect = Rect2i(25, 25, -100, -50)
var absolute = rect.abs() # absolute is Rect2i(-75, -25, 100, 50)
[/gdscript]
[csharp]
var rect = new Rect2I(25, 25, -100, -50);
var absolute = rect.Abs(); // absolute is Rect2I(-75, -25, 100, 50)
[/csharp]
[/codeblocks]
[b]Note:[/b] It's recommended to use this method when [member size] is negative, as most other methods in Godot assume that the [member position] is the top-left corner, and the [member end] is the bottom-right corner. *)
    let abs =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_RECT2I "abs"
        (Base.Int64.of_string "1469025700")
        (Rect2i.typ @-> returning Rect2i.typ)
        Rect2i.s

    let not =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_RECT2I None
        GlobalEnum.VariantOperator._OP_NOT
        (funptr (Rect2i.typ @-> Rect2i.typ @-> Bool.typ @-> returning void))

    (** Returns [code]true[/code] if both [member position] and [member size] of the rectangles are equal, respectively. *)
    let ( = ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_RECT2I
        (Some GlobalEnum.VariantType._TYPE_RECT2I)
        GlobalEnum.VariantOperator._OP_EQUAL
        (funptr (Rect2i.typ @-> Rect2i.typ @-> Bool.typ @-> returning void))

    (** Returns [code]true[/code] if the [member position] or [member size] of both rectangles are not equal. *)
    let ( <> ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_RECT2I
        (Some GlobalEnum.VariantType._TYPE_RECT2I)
        GlobalEnum.VariantOperator._OP_NOT_EQUAL
        (funptr (Rect2i.typ @-> Rect2i.typ @-> Bool.typ @-> returning void))

    let _Rect2i_elem_Dictionary =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_RECT2I
        (Some GlobalEnum.VariantType._TYPE_DICTIONARY)
        GlobalEnum.VariantOperator._OP_IN
        (funptr (Rect2i.typ @-> Dictionary.typ @-> Bool.typ @-> returning void))

    let _Rect2i_elem_Array =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_RECT2I
        (Some GlobalEnum.VariantType._TYPE_ARRAY)
        GlobalEnum.VariantOperator._OP_IN
        (funptr (Rect2i.typ @-> Array.typ @-> Bool.typ @-> returning void))
  end

  module Vector3 = struct
    include M.Vector3

    (** Returns the axis of the vector's lowest value. See [code]AXIS_ * [/code] constants. If all components are equal, this method returns [constant AXIS_Z]. *)
    let min_axis_index =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_VECTOR3
        "min_axis_index"
        (Base.Int64.of_string "3173160232")
        (Vector3.typ @-> returning Int.typ)
        Int.s

    (** Returns the axis of the vector's highest value. See [code]AXIS_ * [/code] constants. If all components are equal, this method returns [constant AXIS_X]. *)
    let max_axis_index =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_VECTOR3
        "max_axis_index"
        (Base.Int64.of_string "3173160232")
        (Vector3.typ @-> returning Int.typ)
        Int.s

    (** Returns the unsigned minimum angle to the given vector, in radians. *)
    let angle_to =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_VECTOR3 "angle_to"
        (Base.Int64.of_string "1047977935")
        (Vector3.typ @-> Vector3.typ @-> returning Float.typ)
        Float.s

    (** Returns the signed angle to the given vector, in radians. The sign of the angle is positive in a counter-clockwise direction and negative in a clockwise direction when viewed from the side specified by the [param axis]. *)
    let signed_angle_to =
      foreign_builtin_method2 GlobalEnum.VariantType._TYPE_VECTOR3
        "signed_angle_to"
        (Base.Int64.of_string "2781412522")
        (Vector3.typ @-> Vector3.typ @-> Vector3.typ @-> returning Float.typ)
        Float.s

    (** Returns the normalized vector pointing from this vector to [param to]. This is equivalent to using [code](b - a).normalized()[/code]. *)
    let direction_to =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_VECTOR3
        "direction_to"
        (Base.Int64.of_string "2923479887")
        (Vector3.typ @-> Vector3.typ @-> returning Vector3.typ)
        Vector3.s

    (** Returns the distance between this vector and [param to]. *)
    let distance_to =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_VECTOR3 "distance_to"
        (Base.Int64.of_string "1047977935")
        (Vector3.typ @-> Vector3.typ @-> returning Float.typ)
        Float.s

    (** Returns the squared distance between this vector and [param to].
This method runs faster than [method distance_to], so prefer it if you need to compare vectors or need the squared distance for some formula. *)
    let distance_squared_to =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_VECTOR3
        "distance_squared_to"
        (Base.Int64.of_string "1047977935")
        (Vector3.typ @-> Vector3.typ @-> returning Float.typ)
        Float.s

    (** Returns the length (magnitude) of this vector. *)
    let length =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_VECTOR3 "length"
        (Base.Int64.of_string "466405837")
        (Vector3.typ @-> returning Float.typ)
        Float.s

    (** Returns the squared length (squared magnitude) of this vector.
This method runs faster than [method length], so prefer it if you need to compare vectors or need the squared distance for some formula. *)
    let length_squared =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_VECTOR3
        "length_squared"
        (Base.Int64.of_string "466405837")
        (Vector3.typ @-> returning Float.typ)
        Float.s

    (** Returns the vector with a maximum length by limiting its length to [param length]. *)
    let limit_length =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_VECTOR3
        "limit_length"
        (Base.Int64.of_string "514930144")
        (Float.typ @-> Vector3.typ @-> returning Vector3.typ)
        Vector3.s

    (** Returns the result of scaling the vector to unit length. Equivalent to [code]v / v.length()[/code]. See also [method is_normalized].
[b]Note:[/b] This function may return incorrect values if the input vector length is near zero. *)
    let normalized =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_VECTOR3 "normalized"
        (Base.Int64.of_string "1776574132")
        (Vector3.typ @-> returning Vector3.typ)
        Vector3.s

    (** Returns [code]true[/code] if the vector is normalized, i.e. its length is approximately equal to 1. *)
    let is_normalized =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_VECTOR3
        "is_normalized"
        (Base.Int64.of_string "3918633141")
        (Vector3.typ @-> returning Bool.typ)
        Bool.s

    (** Returns [code]true[/code] if this vector and [param to] are approximately equal, by running [method @GlobalScope.is_equal_approx] on each component. *)
    let is_equal_approx =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_VECTOR3
        "is_equal_approx"
        (Base.Int64.of_string "1749054343")
        (Vector3.typ @-> Vector3.typ @-> returning Bool.typ)
        Bool.s

    (** Returns [code]true[/code] if this vector's values are approximately zero, by running [method @GlobalScope.is_zero_approx] on each component.
This method is faster than using [method is_equal_approx] with one value as a zero vector. *)
    let is_zero_approx =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_VECTOR3
        "is_zero_approx"
        (Base.Int64.of_string "3918633141")
        (Vector3.typ @-> returning Bool.typ)
        Bool.s

    (** Returns [code]true[/code] if this vector is finite, by calling [method @GlobalScope.is_finite] on each component. *)
    let is_finite =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_VECTOR3 "is_finite"
        (Base.Int64.of_string "3918633141")
        (Vector3.typ @-> returning Bool.typ)
        Bool.s

    (** Returns the inverse of the vector. This is the same as [code]Vector3(1.0 / v.x, 1.0 / v.y, 1.0 / v.z)[/code]. *)
    let inverse =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_VECTOR3 "inverse"
        (Base.Int64.of_string "1776574132")
        (Vector3.typ @-> returning Vector3.typ)
        Vector3.s

    (** Returns a new vector with all components clamped between the components of [param min] and [param max], by running [method @GlobalScope.clamp] on each component. *)
    let clamp =
      foreign_builtin_method2 GlobalEnum.VariantType._TYPE_VECTOR3 "clamp"
        (Base.Int64.of_string "4145107892")
        (Vector3.typ @-> Vector3.typ @-> Vector3.typ @-> returning Vector3.typ)
        Vector3.s

    (** Returns a new vector with each component snapped to the nearest multiple of the corresponding component in [param step]. This can also be used to round the components to an arbitrary number of decimals. *)
    let snapped =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_VECTOR3 "snapped"
        (Base.Int64.of_string "2923479887")
        (Vector3.typ @-> Vector3.typ @-> returning Vector3.typ)
        Vector3.s

    (** Returns the result of rotating this vector around a given axis by [param angle] (in radians). The axis must be a normalized vector. See also [method @GlobalScope.deg_to_rad]. *)
    let rotated =
      foreign_builtin_method2 GlobalEnum.VariantType._TYPE_VECTOR3 "rotated"
        (Base.Int64.of_string "1682608829")
        (Vector3.typ @-> Float.typ @-> Vector3.typ @-> returning Vector3.typ)
        Vector3.s

    (** Returns the result of the linear interpolation between this vector and [param to] by amount [param weight]. [param weight] is on the range of [code]0.0[/code] to [code]1.0[/code], representing the amount of interpolation. *)
    let lerp =
      foreign_builtin_method2 GlobalEnum.VariantType._TYPE_VECTOR3 "lerp"
        (Base.Int64.of_string "1682608829")
        (Vector3.typ @-> Float.typ @-> Vector3.typ @-> returning Vector3.typ)
        Vector3.s

    (** Returns the result of spherical linear interpolation between this vector and [param to], by amount [param weight]. [param weight] is on the range of 0.0 to 1.0, representing the amount of interpolation.
This method also handles interpolating the lengths if the input vectors have different lengths. For the special case of one or both input vectors having zero length, this method behaves like [method lerp]. *)
    let slerp =
      foreign_builtin_method2 GlobalEnum.VariantType._TYPE_VECTOR3 "slerp"
        (Base.Int64.of_string "1682608829")
        (Vector3.typ @-> Float.typ @-> Vector3.typ @-> returning Vector3.typ)
        Vector3.s

    (** Performs a cubic interpolation between this vector and [param b] using [param pre_a] and [param post_b] as handles, and returns the result at position [param weight]. [param weight] is on the range of 0.0 to 1.0, representing the amount of interpolation. *)
    let cubic_interpolate =
      foreign_builtin_method4 GlobalEnum.VariantType._TYPE_VECTOR3
        "cubic_interpolate"
        (Base.Int64.of_string "2597922253")
        (Vector3.typ @-> Vector3.typ @-> Vector3.typ @-> Float.typ
       @-> Vector3.typ @-> returning Vector3.typ)
        Vector3.s

    (** Performs a cubic interpolation between this vector and [param b] using [param pre_a] and [param post_b] as handles, and returns the result at position [param weight]. [param weight] is on the range of 0.0 to 1.0, representing the amount of interpolation.
It can perform smoother interpolation than [method cubic_interpolate] by the time values. *)
    let cubic_interpolate_in_time =
      foreign_builtin_method7 GlobalEnum.VariantType._TYPE_VECTOR3
        "cubic_interpolate_in_time"
        (Base.Int64.of_string "3256682901")
        (Vector3.typ @-> Vector3.typ @-> Vector3.typ @-> Float.typ @-> Float.typ
       @-> Float.typ @-> Float.typ @-> Vector3.typ @-> returning Vector3.typ)
        Vector3.s

    (** Returns the point at the given [param t] on the [url=https://en.wikipedia.org/wiki/B%C3%A9zier_curve]Bézier curve[/url] defined by this vector and the given [param control_1], [param control_2], and [param end] points. *)
    let bezier_interpolate =
      foreign_builtin_method4 GlobalEnum.VariantType._TYPE_VECTOR3
        "bezier_interpolate"
        (Base.Int64.of_string "2597922253")
        (Vector3.typ @-> Vector3.typ @-> Vector3.typ @-> Float.typ
       @-> Vector3.typ @-> returning Vector3.typ)
        Vector3.s

    (** Returns the derivative at the given [param t] on the [url=https://en.wikipedia.org/wiki/B%C3%A9zier_curve]Bézier curve[/url] defined by this vector and the given [param control_1], [param control_2], and [param end] points. *)
    let bezier_derivative =
      foreign_builtin_method4 GlobalEnum.VariantType._TYPE_VECTOR3
        "bezier_derivative"
        (Base.Int64.of_string "2597922253")
        (Vector3.typ @-> Vector3.typ @-> Vector3.typ @-> Float.typ
       @-> Vector3.typ @-> returning Vector3.typ)
        Vector3.s

    (** Returns a new vector moved toward [param to] by the fixed [param delta] amount. Will not go past the final value. *)
    let move_toward =
      foreign_builtin_method2 GlobalEnum.VariantType._TYPE_VECTOR3 "move_toward"
        (Base.Int64.of_string "1682608829")
        (Vector3.typ @-> Float.typ @-> Vector3.typ @-> returning Vector3.typ)
        Vector3.s

    (** Returns the dot product of this vector and [param with]. This can be used to compare the angle between two vectors. For example, this can be used to determine whether an enemy is facing the player.
The dot product will be [code]0[/code] for a straight angle (90 degrees), greater than 0 for angles narrower than 90 degrees and lower than 0 for angles wider than 90 degrees.
When using unit (normalized) vectors, the result will always be between [code]-1.0[/code] (180 degree angle) when the vectors are facing opposite directions, and [code]1.0[/code] (0 degree angle) when the vectors are aligned.
[b]Note:[/b] [code]a.dot(b)[/code] is equivalent to [code]b.dot(a)[/code]. *)
    let dot =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_VECTOR3 "dot"
        (Base.Int64.of_string "1047977935")
        (Vector3.typ @-> Vector3.typ @-> returning Float.typ)
        Float.s

    (** Returns the cross product of this vector and [param with].
This returns a vector perpendicular to both this and [param with], which would be the normal vector of the plane defined by the two vectors. As there are two such vectors, in opposite directions, this method returns the vector defined by a right-handed coordinate system. If the two vectors are parallel this returns an empty vector, making it useful for testing if two vectors are parallel. *)
    let cross =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_VECTOR3 "cross"
        (Base.Int64.of_string "2923479887")
        (Vector3.typ @-> Vector3.typ @-> returning Vector3.typ)
        Vector3.s

    (** Returns the outer product with [param with]. *)
    let outer =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_VECTOR3 "outer"
        (Base.Int64.of_string "3934786792")
        (Vector3.typ @-> Vector3.typ @-> returning Basis.typ)
        Basis.s

    (** Returns a new vector with all components in absolute values (i.e. positive). *)
    let abs =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_VECTOR3 "abs"
        (Base.Int64.of_string "1776574132")
        (Vector3.typ @-> returning Vector3.typ)
        Vector3.s

    (** Returns a new vector with all components rounded down (towards negative infinity). *)
    let floor =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_VECTOR3 "floor"
        (Base.Int64.of_string "1776574132")
        (Vector3.typ @-> returning Vector3.typ)
        Vector3.s

    (** Returns a new vector with all components rounded up (towards positive infinity). *)
    let ceil =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_VECTOR3 "ceil"
        (Base.Int64.of_string "1776574132")
        (Vector3.typ @-> returning Vector3.typ)
        Vector3.s

    (** Returns a new vector with all components rounded to the nearest integer, with halfway cases rounded away from zero. *)
    let round =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_VECTOR3 "round"
        (Base.Int64.of_string "1776574132")
        (Vector3.typ @-> returning Vector3.typ)
        Vector3.s

    (** Returns a vector composed of the [method @GlobalScope.fposmod] of this vector's components and [param mod]. *)
    let posmod =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_VECTOR3 "posmod"
        (Base.Int64.of_string "514930144")
        (Float.typ @-> Vector3.typ @-> returning Vector3.typ)
        Vector3.s

    (** Returns a vector composed of the [method @GlobalScope.fposmod] of this vector's components and [param modv]'s components. *)
    let posmodv =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_VECTOR3 "posmodv"
        (Base.Int64.of_string "2923479887")
        (Vector3.typ @-> Vector3.typ @-> returning Vector3.typ)
        Vector3.s

    (** Returns the result of projecting the vector onto the given vector [param b]. *)
    let project =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_VECTOR3 "project"
        (Base.Int64.of_string "2923479887")
        (Vector3.typ @-> Vector3.typ @-> returning Vector3.typ)
        Vector3.s

    (** Returns a new vector slid along a plane defined by the given normal. *)
    let slide =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_VECTOR3 "slide"
        (Base.Int64.of_string "2923479887")
        (Vector3.typ @-> Vector3.typ @-> returning Vector3.typ)
        Vector3.s

    (** Returns the vector ""bounced off"" from a plane defined by the given normal. *)
    let bounce =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_VECTOR3 "bounce"
        (Base.Int64.of_string "2923479887")
        (Vector3.typ @-> Vector3.typ @-> returning Vector3.typ)
        Vector3.s

    (** Returns the result of reflecting the vector from a plane defined by the given normal [param n]. *)
    let reflect =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_VECTOR3 "reflect"
        (Base.Int64.of_string "2923479887")
        (Vector3.typ @-> Vector3.typ @-> returning Vector3.typ)
        Vector3.s

    (** Returns a new vector with each component set to [code]1.0[/code] if it's positive, [code]-1.0[/code] if it's negative, and [code]0.0[/code] if it's zero. The result is identical to calling [method @GlobalScope.sign] on each component. *)
    let sign =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_VECTOR3 "sign"
        (Base.Int64.of_string "1776574132")
        (Vector3.typ @-> returning Vector3.typ)
        Vector3.s

    (** Returns the octahedral-encoded (oct32) form of this [Vector3] as a [Vector2]. Since a [Vector2] occupies 1/3 less memory compared to [Vector3], this form of compression can be used to pass greater amounts of [method normalized] [Vector3]s without increasing storage or memory requirements. See also [method octahedron_decode].
[b]Note:[/b] [method octahedron_encode] can only be used for [method normalized] vectors. [method octahedron_encode] does [i]not[/i] check whether this [Vector3] is normalized, and will return a value that does not decompress to the original value if the [Vector3] is not normalized.
[b]Note:[/b] Octahedral compression is [i]lossy[/i], although visual differences are rarely perceptible in real world scenarios. *)
    let octahedron_encode =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_VECTOR3
        "octahedron_encode"
        (Base.Int64.of_string "2428350749")
        (Vector3.typ @-> returning Vector2.typ)
        Vector2.s

    (** Returns the [Vector3] from an octahedral-compressed form created using [method octahedron_encode] (stored as a [Vector2]). *)
    let octahedron_decode =
      foreign_builtin_method1_static GlobalEnum.VariantType._TYPE_VECTOR3
        "octahedron_decode"
        (Base.Int64.of_string "3991820552")
        (Vector2.typ @-> returning Vector3.typ)
        Vector3.s

    (** Returns the negative value of the [Vector3]. This is the same as writing [code]Vector3(-v.x, -v.y, -v.z)[/code]. This operation flips the direction of the vector while keeping the same magnitude. With floats, the number zero can be either positive or negative. *)
    let ( ~- ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_VECTOR3 None
        GlobalEnum.VariantOperator._OP_NEGATE
        (funptr
           (Vector3.typ @-> Vector3.typ @-> Vector3.typ @-> returning void))

    (** Returns the same value as if the [code]+[/code] was not there. Unary [code]+[/code] does nothing, but sometimes it can make your code more readable. *)
    let ( ~+ ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_VECTOR3 None
        GlobalEnum.VariantOperator._OP_POSITIVE
        (funptr
           (Vector3.typ @-> Vector3.typ @-> Vector3.typ @-> returning void))

    let not =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_VECTOR3 None
        GlobalEnum.VariantOperator._OP_NOT
        (funptr (Vector3.typ @-> Vector3.typ @-> Bool.typ @-> returning void))

    (** Returns [code]true[/code] if the vectors are exactly equal.
[b]Note:[/b] Due to floating-point precision errors, consider using [method is_equal_approx] instead, which is more reliable.
[b]Note:[/b] Vectors with [constant @GDScript.NAN] elements don't behave the same as other vectors. Therefore, the results from this operator may not be accurate if NaNs are included. *)
    let ( = ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_VECTOR3
        (Some GlobalEnum.VariantType._TYPE_VECTOR3)
        GlobalEnum.VariantOperator._OP_EQUAL
        (funptr (Vector3.typ @-> Vector3.typ @-> Bool.typ @-> returning void))

    (** Returns [code]true[/code] if the vectors are not equal.
[b]Note:[/b] Due to floating-point precision errors, consider using [method is_equal_approx] instead, which is more reliable.
[b]Note:[/b] Vectors with [constant @GDScript.NAN] elements don't behave the same as other vectors. Therefore, the results from this operator may not be accurate if NaNs are included. *)
    let ( <> ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_VECTOR3
        (Some GlobalEnum.VariantType._TYPE_VECTOR3)
        GlobalEnum.VariantOperator._OP_NOT_EQUAL
        (funptr (Vector3.typ @-> Vector3.typ @-> Bool.typ @-> returning void))

    (** Compares two [Vector3] vectors by first checking if the X value of the left vector is less than the X value of the [param right] vector. If the X values are exactly equal, then it repeats this check with the Y values of the two vectors, and then with the Z values. This operator is useful for sorting vectors.
[b]Note:[/b] Vectors with [constant @GDScript.NAN] elements don't behave the same as other vectors. Therefore, the results from this operator may not be accurate if NaNs are included. *)
    let ( < ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_VECTOR3
        (Some GlobalEnum.VariantType._TYPE_VECTOR3)
        GlobalEnum.VariantOperator._OP_LESS
        (funptr (Vector3.typ @-> Vector3.typ @-> Bool.typ @-> returning void))

    (** Compares two [Vector3] vectors by first checking if the X value of the left vector is less than or equal to the X value of the [param right] vector. If the X values are exactly equal, then it repeats this check with the Y values of the two vectors, and then with the Z values. This operator is useful for sorting vectors.
[b]Note:[/b] Vectors with [constant @GDScript.NAN] elements don't behave the same as other vectors. Therefore, the results from this operator may not be accurate if NaNs are included. *)
    let ( <= ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_VECTOR3
        (Some GlobalEnum.VariantType._TYPE_VECTOR3)
        GlobalEnum.VariantOperator._OP_LESS_EQUAL
        (funptr (Vector3.typ @-> Vector3.typ @-> Bool.typ @-> returning void))

    (** Compares two [Vector3] vectors by first checking if the X value of the left vector is greater than the X value of the [param right] vector. If the X values are exactly equal, then it repeats this check with the Y values of the two vectors, and then with the Z values. This operator is useful for sorting vectors.
[b]Note:[/b] Vectors with [constant @GDScript.NAN] elements don't behave the same as other vectors. Therefore, the results from this operator may not be accurate if NaNs are included. *)
    let ( > ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_VECTOR3
        (Some GlobalEnum.VariantType._TYPE_VECTOR3)
        GlobalEnum.VariantOperator._OP_GREATER
        (funptr (Vector3.typ @-> Vector3.typ @-> Bool.typ @-> returning void))

    (** Compares two [Vector3] vectors by first checking if the X value of the left vector is greater than or equal to the X value of the [param right] vector. If the X values are exactly equal, then it repeats this check with the Y values of the two vectors, and then with the Z values. This operator is useful for sorting vectors.
[b]Note:[/b] Vectors with [constant @GDScript.NAN] elements don't behave the same as other vectors. Therefore, the results from this operator may not be accurate if NaNs are included. *)
    let ( >= ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_VECTOR3
        (Some GlobalEnum.VariantType._TYPE_VECTOR3)
        GlobalEnum.VariantOperator._OP_GREATER_EQUAL
        (funptr (Vector3.typ @-> Vector3.typ @-> Bool.typ @-> returning void))

    (** Adds each component of the [Vector3] by the components of the given [Vector3].
[codeblock]
print(Vector3(10, 20, 30) + Vector3(3, 4, 5)) # Prints ""(13, 24, 35)""
[/codeblock] *)
    let ( + ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_VECTOR3
        (Some GlobalEnum.VariantType._TYPE_VECTOR3)
        GlobalEnum.VariantOperator._OP_ADD
        (funptr
           (Vector3.typ @-> Vector3.typ @-> Vector3.typ @-> returning void))

    (** Subtracts each component of the [Vector3] by the components of the given [Vector3].
[codeblock]
print(Vector3(10, 20, 30) - Vector3(3, 4, 5)) # Prints ""(7, 16, 25)""
[/codeblock] *)
    let ( - ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_VECTOR3
        (Some GlobalEnum.VariantType._TYPE_VECTOR3)
        GlobalEnum.VariantOperator._OP_SUBTRACT
        (funptr
           (Vector3.typ @-> Vector3.typ @-> Vector3.typ @-> returning void))

    (** Multiplies each component of the [Vector3] by the components of the given [Vector3].
[codeblock]
print(Vector3(10, 20, 30)  *  Vector3(3, 4, 5)) # Prints ""(30, 80, 150)""
[/codeblock] *)
    let ( * ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_VECTOR3
        (Some GlobalEnum.VariantType._TYPE_VECTOR3)
        GlobalEnum.VariantOperator._OP_MULTIPLY
        (funptr
           (Vector3.typ @-> Vector3.typ @-> Vector3.typ @-> returning void))

    (** Divides each component of the [Vector3] by the components of the given [Vector3].
[codeblock]
print(Vector3(10, 20, 30) / Vector3(2, 5, 3)) # Prints ""(5, 4, 10)""
[/codeblock] *)
    let ( / ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_VECTOR3
        (Some GlobalEnum.VariantType._TYPE_VECTOR3)
        GlobalEnum.VariantOperator._OP_DIVIDE
        (funptr
           (Vector3.typ @-> Vector3.typ @-> Vector3.typ @-> returning void))

    let _Vector3_elem_Dictionary =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_VECTOR3
        (Some GlobalEnum.VariantType._TYPE_DICTIONARY)
        GlobalEnum.VariantOperator._OP_IN
        (funptr
           (Vector3.typ @-> Dictionary.typ @-> Bool.typ @-> returning void))

    let _Vector3_elem_Array =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_VECTOR3
        (Some GlobalEnum.VariantType._TYPE_ARRAY)
        GlobalEnum.VariantOperator._OP_IN
        (funptr (Vector3.typ @-> Array.typ @-> Bool.typ @-> returning void))

    let _Vector3_elem_PackedVector3Array =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_VECTOR3
        (Some GlobalEnum.VariantType._TYPE_PACKED_VECTOR3_ARRAY)
        GlobalEnum.VariantOperator._OP_IN
        (funptr
           (Vector3.typ @-> PackedVector3Array.typ @-> Bool.typ
          @-> returning void))

    module Axis = struct
      type t = Int.t

      let typ = Int.typ

      (** Enumerated value for the X axis. Returned by [method max_axis_index] and [method min_axis_index]. *)
      let _AXIS_X = 0

      (** Enumerated value for the Y axis. Returned by [method max_axis_index] and [method min_axis_index]. *)
      let _AXIS_Y = 1

      (** Enumerated value for the Z axis. Returned by [method max_axis_index] and [method min_axis_index]. *)
      let _AXIS_Z = 2
    end
  end

  module Vector3i = struct
    include M.Vector3i

    (** Returns the axis of the vector's lowest value. See [code]AXIS_ * [/code] constants. If all components are equal, this method returns [constant AXIS_Z]. *)
    let min_axis_index =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_VECTOR3I
        "min_axis_index"
        (Base.Int64.of_string "3173160232")
        (Vector3i.typ @-> returning Int.typ)
        Int.s

    (** Returns the axis of the vector's highest value. See [code]AXIS_ * [/code] constants. If all components are equal, this method returns [constant AXIS_X]. *)
    let max_axis_index =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_VECTOR3I
        "max_axis_index"
        (Base.Int64.of_string "3173160232")
        (Vector3i.typ @-> returning Int.typ)
        Int.s

    (** Returns the length (magnitude) of this vector. *)
    let length =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_VECTOR3I "length"
        (Base.Int64.of_string "466405837")
        (Vector3i.typ @-> returning Float.typ)
        Float.s

    (** Returns the squared length (squared magnitude) of this vector.
This method runs faster than [method length], so prefer it if you need to compare vectors or need the squared distance for some formula. *)
    let length_squared =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_VECTOR3I
        "length_squared"
        (Base.Int64.of_string "3173160232")
        (Vector3i.typ @-> returning Int.typ)
        Int.s

    (** Returns a new vector with each component set to [code]1[/code] if it's positive, [code]-1[/code] if it's negative, and [code]0[/code] if it's zero. The result is identical to calling [method @GlobalScope.sign] on each component. *)
    let sign =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_VECTOR3I "sign"
        (Base.Int64.of_string "3729604559")
        (Vector3i.typ @-> returning Vector3i.typ)
        Vector3i.s

    (** Returns a new vector with all components in absolute values (i.e. positive). *)
    let abs =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_VECTOR3I "abs"
        (Base.Int64.of_string "3729604559")
        (Vector3i.typ @-> returning Vector3i.typ)
        Vector3i.s

    (** Returns a new vector with all components clamped between the components of [param min] and [param max], by running [method @GlobalScope.clamp] on each component. *)
    let clamp =
      foreign_builtin_method2 GlobalEnum.VariantType._TYPE_VECTOR3I "clamp"
        (Base.Int64.of_string "1086892323")
        (Vector3i.typ @-> Vector3i.typ @-> Vector3i.typ
       @-> returning Vector3i.typ)
        Vector3i.s

    (** Returns a new vector with each component snapped to the closest multiple of the corresponding component in [param step]. *)
    let snapped =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_VECTOR3I "snapped"
        (Base.Int64.of_string "1989319750")
        (Vector3i.typ @-> Vector3i.typ @-> returning Vector3i.typ)
        Vector3i.s

    (** Returns the negative value of the [Vector3i]. This is the same as writing [code]Vector3i(-v.x, -v.y, -v.z)[/code]. This operation flips the direction of the vector while keeping the same magnitude. *)
    let ( ~- ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_VECTOR3I None
        GlobalEnum.VariantOperator._OP_NEGATE
        (funptr
           (Vector3i.typ @-> Vector3i.typ @-> Vector3i.typ @-> returning void))

    (** Returns the same value as if the [code]+[/code] was not there. Unary [code]+[/code] does nothing, but sometimes it can make your code more readable. *)
    let ( ~+ ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_VECTOR3I None
        GlobalEnum.VariantOperator._OP_POSITIVE
        (funptr
           (Vector3i.typ @-> Vector3i.typ @-> Vector3i.typ @-> returning void))

    let not =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_VECTOR3I None
        GlobalEnum.VariantOperator._OP_NOT
        (funptr (Vector3i.typ @-> Vector3i.typ @-> Bool.typ @-> returning void))

    (** Returns [code]true[/code] if the vectors are equal. *)
    let ( = ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_VECTOR3I
        (Some GlobalEnum.VariantType._TYPE_VECTOR3I)
        GlobalEnum.VariantOperator._OP_EQUAL
        (funptr (Vector3i.typ @-> Vector3i.typ @-> Bool.typ @-> returning void))

    (** Returns [code]true[/code] if the vectors are not equal. *)
    let ( <> ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_VECTOR3I
        (Some GlobalEnum.VariantType._TYPE_VECTOR3I)
        GlobalEnum.VariantOperator._OP_NOT_EQUAL
        (funptr (Vector3i.typ @-> Vector3i.typ @-> Bool.typ @-> returning void))

    (** Compares two [Vector3i] vectors by first checking if the X value of the left vector is less than the X value of the [param right] vector. If the X values are exactly equal, then it repeats this check with the Y values of the two vectors, and then with the Z values. This operator is useful for sorting vectors. *)
    let ( < ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_VECTOR3I
        (Some GlobalEnum.VariantType._TYPE_VECTOR3I)
        GlobalEnum.VariantOperator._OP_LESS
        (funptr (Vector3i.typ @-> Vector3i.typ @-> Bool.typ @-> returning void))

    (** Compares two [Vector3i] vectors by first checking if the X value of the left vector is less than or equal to the X value of the [param right] vector. If the X values are exactly equal, then it repeats this check with the Y values of the two vectors, and then with the Z values. This operator is useful for sorting vectors. *)
    let ( <= ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_VECTOR3I
        (Some GlobalEnum.VariantType._TYPE_VECTOR3I)
        GlobalEnum.VariantOperator._OP_LESS_EQUAL
        (funptr (Vector3i.typ @-> Vector3i.typ @-> Bool.typ @-> returning void))

    (** Compares two [Vector3i] vectors by first checking if the X value of the left vector is greater than the X value of the [param right] vector. If the X values are exactly equal, then it repeats this check with the Y values of the two vectors, and then with the Z values. This operator is useful for sorting vectors. *)
    let ( > ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_VECTOR3I
        (Some GlobalEnum.VariantType._TYPE_VECTOR3I)
        GlobalEnum.VariantOperator._OP_GREATER
        (funptr (Vector3i.typ @-> Vector3i.typ @-> Bool.typ @-> returning void))

    (** Compares two [Vector3i] vectors by first checking if the X value of the left vector is greater than or equal to the X value of the [param right] vector. If the X values are exactly equal, then it repeats this check with the Y values of the two vectors, and then with the Z values. This operator is useful for sorting vectors. *)
    let ( >= ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_VECTOR3I
        (Some GlobalEnum.VariantType._TYPE_VECTOR3I)
        GlobalEnum.VariantOperator._OP_GREATER_EQUAL
        (funptr (Vector3i.typ @-> Vector3i.typ @-> Bool.typ @-> returning void))

    (** Adds each component of the [Vector3i] by the components of the given [Vector3i].
[codeblock]
print(Vector3i(10, 20, 30) + Vector3i(3, 4, 5)) # Prints ""(13, 24, 35)""
[/codeblock] *)
    let ( + ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_VECTOR3I
        (Some GlobalEnum.VariantType._TYPE_VECTOR3I)
        GlobalEnum.VariantOperator._OP_ADD
        (funptr
           (Vector3i.typ @-> Vector3i.typ @-> Vector3i.typ @-> returning void))

    (** Subtracts each component of the [Vector3i] by the components of the given [Vector3i].
[codeblock]
print(Vector3i(10, 20, 30) - Vector3i(3, 4, 5)) # Prints ""(7, 16, 25)""
[/codeblock] *)
    let ( - ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_VECTOR3I
        (Some GlobalEnum.VariantType._TYPE_VECTOR3I)
        GlobalEnum.VariantOperator._OP_SUBTRACT
        (funptr
           (Vector3i.typ @-> Vector3i.typ @-> Vector3i.typ @-> returning void))

    (** Multiplies each component of the [Vector3i] by the components of the given [Vector3i].
[codeblock]
print(Vector3i(10, 20, 30)  *  Vector3i(3, 4, 5)) # Prints ""(30, 80, 150)""
[/codeblock] *)
    let ( * ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_VECTOR3I
        (Some GlobalEnum.VariantType._TYPE_VECTOR3I)
        GlobalEnum.VariantOperator._OP_MULTIPLY
        (funptr
           (Vector3i.typ @-> Vector3i.typ @-> Vector3i.typ @-> returning void))

    (** Divides each component of the [Vector3i] by the components of the given [Vector3i].
[codeblock]
print(Vector3i(10, 20, 30) / Vector3i(2, 5, 3)) # Prints ""(5, 4, 10)""
[/codeblock] *)
    let ( / ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_VECTOR3I
        (Some GlobalEnum.VariantType._TYPE_VECTOR3I)
        GlobalEnum.VariantOperator._OP_DIVIDE
        (funptr
           (Vector3i.typ @-> Vector3i.typ @-> Vector3i.typ @-> returning void))

    (** Gets the remainder of each component of the [Vector3i] with the components of the given [Vector3i]. This operation uses truncated division, which is often not desired as it does not work well with negative numbers. Consider using [method @GlobalScope.posmod] instead if you want to handle negative numbers.
[codeblock]
print(Vector3i(10, -20, 30) % Vector3i(7, 8, 9)) # Prints ""(3, -4, 3)""
[/codeblock] *)
    let ( % ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_VECTOR3I
        (Some GlobalEnum.VariantType._TYPE_VECTOR3I)
        GlobalEnum.VariantOperator._OP_MODULE
        (funptr
           (Vector3i.typ @-> Vector3i.typ @-> Vector3i.typ @-> returning void))

    let _Vector3i_elem_Dictionary =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_VECTOR3I
        (Some GlobalEnum.VariantType._TYPE_DICTIONARY)
        GlobalEnum.VariantOperator._OP_IN
        (funptr
           (Vector3i.typ @-> Dictionary.typ @-> Bool.typ @-> returning void))

    let _Vector3i_elem_Array =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_VECTOR3I
        (Some GlobalEnum.VariantType._TYPE_ARRAY)
        GlobalEnum.VariantOperator._OP_IN
        (funptr (Vector3i.typ @-> Array.typ @-> Bool.typ @-> returning void))

    module Axis = struct
      type t = Int.t

      let typ = Int.typ

      (** Enumerated value for the X axis. Returned by [method max_axis_index] and [method min_axis_index]. *)
      let _AXIS_X = 0

      (** Enumerated value for the Y axis. Returned by [method max_axis_index] and [method min_axis_index]. *)
      let _AXIS_Y = 1

      (** Enumerated value for the Z axis. Returned by [method max_axis_index] and [method min_axis_index]. *)
      let _AXIS_Z = 2
    end
  end

  module Transform2D = struct
    include M.Transform2D

    (** Returns the inverse of the transform, under the assumption that the transformation basis is orthonormal (i.e. rotation/reflection is fine, scaling/skew is not). Use [method affine_inverse] for non-orthonormal transforms (e.g. with scaling). *)
    let inverse =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_TRANSFORM2D "inverse"
        (Base.Int64.of_string "1420440541")
        (Transform2D.typ @-> returning Transform2D.typ)
        Transform2D.s

    (** Returns the inverse of the transform, under the assumption that the basis is invertible (must have non-zero determinant). *)
    let affine_inverse =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_TRANSFORM2D
        "affine_inverse"
        (Base.Int64.of_string "1420440541")
        (Transform2D.typ @-> returning Transform2D.typ)
        Transform2D.s

    (** Returns the transform's rotation (in radians). *)
    let get_rotation =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_TRANSFORM2D
        "get_rotation"
        (Base.Int64.of_string "466405837")
        (Transform2D.typ @-> returning Float.typ)
        Float.s

    (** Returns the transform's origin (translation). *)
    let get_origin =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_TRANSFORM2D
        "get_origin"
        (Base.Int64.of_string "2428350749")
        (Transform2D.typ @-> returning Vector2.typ)
        Vector2.s

    (** Returns the scale. *)
    let get_scale =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_TRANSFORM2D
        "get_scale"
        (Base.Int64.of_string "2428350749")
        (Transform2D.typ @-> returning Vector2.typ)
        Vector2.s

    (** Returns the transform's skew (in radians). *)
    let get_skew =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_TRANSFORM2D
        "get_skew"
        (Base.Int64.of_string "466405837")
        (Transform2D.typ @-> returning Float.typ)
        Float.s

    (** Returns the transform with the basis orthogonal (90 degrees), and normalized axis vectors (scale of 1 or -1). *)
    let orthonormalized =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_TRANSFORM2D
        "orthonormalized"
        (Base.Int64.of_string "1420440541")
        (Transform2D.typ @-> returning Transform2D.typ)
        Transform2D.s

    (** Returns a copy of the transform rotated by the given [param angle] (in radians).
This method is an optimized version of multiplying the given transform [code]X[/code] with a corresponding rotation transform [code]R[/code] from the left, i.e., [code]R  *  X[/code].
This can be seen as transforming with respect to the global/parent frame. *)
    let rotated =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_TRANSFORM2D "rotated"
        (Base.Int64.of_string "729597514")
        (Float.typ @-> Transform2D.typ @-> returning Transform2D.typ)
        Transform2D.s

    (** Returns a copy of the transform rotated by the given [param angle] (in radians).
This method is an optimized version of multiplying the given transform [code]X[/code] with a corresponding rotation transform [code]R[/code] from the right, i.e., [code]X  *  R[/code].
This can be seen as transforming with respect to the local frame. *)
    let rotated_local =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_TRANSFORM2D
        "rotated_local"
        (Base.Int64.of_string "729597514")
        (Float.typ @-> Transform2D.typ @-> returning Transform2D.typ)
        Transform2D.s

    (** Returns a copy of the transform scaled by the given [param scale] factor.
This method is an optimized version of multiplying the given transform [code]X[/code] with a corresponding scaling transform [code]S[/code] from the left, i.e., [code]S  *  X[/code].
This can be seen as transforming with respect to the global/parent frame. *)
    let scaled =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_TRANSFORM2D "scaled"
        (Base.Int64.of_string "1446323263")
        (Vector2.typ @-> Transform2D.typ @-> returning Transform2D.typ)
        Transform2D.s

    (** Returns a copy of the transform scaled by the given [param scale] factor.
This method is an optimized version of multiplying the given transform [code]X[/code] with a corresponding scaling transform [code]S[/code] from the right, i.e., [code]X  *  S[/code].
This can be seen as transforming with respect to the local frame. *)
    let scaled_local =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_TRANSFORM2D
        "scaled_local"
        (Base.Int64.of_string "1446323263")
        (Vector2.typ @-> Transform2D.typ @-> returning Transform2D.typ)
        Transform2D.s

    (** Returns a copy of the transform translated by the given [param offset].
This method is an optimized version of multiplying the given transform [code]X[/code] with a corresponding translation transform [code]T[/code] from the left, i.e., [code]T  *  X[/code].
This can be seen as transforming with respect to the global/parent frame. *)
    let translated =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_TRANSFORM2D
        "translated"
        (Base.Int64.of_string "1446323263")
        (Vector2.typ @-> Transform2D.typ @-> returning Transform2D.typ)
        Transform2D.s

    (** Returns a copy of the transform translated by the given [param offset].
This method is an optimized version of multiplying the given transform [code]X[/code] with a corresponding translation transform [code]T[/code] from the right, i.e., [code]X  *  T[/code].
This can be seen as transforming with respect to the local frame. *)
    let translated_local =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_TRANSFORM2D
        "translated_local"
        (Base.Int64.of_string "1446323263")
        (Vector2.typ @-> Transform2D.typ @-> returning Transform2D.typ)
        Transform2D.s

    (** Returns the determinant of the basis matrix. If the basis is uniformly scaled, then its determinant equals the square of the scale factor.
A negative determinant means the basis was flipped, so one part of the scale is negative. A zero determinant means the basis isn't invertible, and is usually considered invalid. *)
    let determinant =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_TRANSFORM2D
        "determinant"
        (Base.Int64.of_string "466405837")
        (Transform2D.typ @-> returning Float.typ)
        Float.s

    (** Returns a vector transformed (multiplied) by the basis matrix.
This method does not account for translation (the [member origin] vector). *)
    let basis_xform =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_TRANSFORM2D
        "basis_xform"
        (Base.Int64.of_string "2026743667")
        (Vector2.typ @-> Transform2D.typ @-> returning Vector2.typ)
        Vector2.s

    (** Returns a vector transformed (multiplied) by the inverse basis matrix, under the assumption that the basis is orthonormal (i.e. rotation/reflection is fine, scaling/skew is not).
This method does not account for translation (the [member origin] vector).
[code]transform.basis_xform_inv(vector)[/code] is equivalent to [code]transform.inverse().basis_xform(vector)[/code]. See [method inverse].
For non-orthonormal transforms (e.g. with scaling) [code]transform.affine_inverse().basis_xform(vector)[/code] can be used instead. See [method affine_inverse]. *)
    let basis_xform_inv =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_TRANSFORM2D
        "basis_xform_inv"
        (Base.Int64.of_string "2026743667")
        (Vector2.typ @-> Transform2D.typ @-> returning Vector2.typ)
        Vector2.s

    (** Returns a transform interpolated between this transform and another by a given [param weight] (on the range of 0.0 to 1.0). *)
    let interpolate_with =
      foreign_builtin_method2 GlobalEnum.VariantType._TYPE_TRANSFORM2D
        "interpolate_with"
        (Base.Int64.of_string "359399686")
        (Transform2D.typ @-> Float.typ @-> Transform2D.typ
       @-> returning Transform2D.typ)
        Transform2D.s

    (** Returns [code]true[/code] if the transform's basis is conformal, meaning it preserves angles and distance ratios, and may only be composed of rotation and uniform scale. Returns [code]false[/code] if the transform's basis has non-uniform scale or shear/skew. This can be used to validate if the transform is non-distorted, which is important for physics and other use cases. *)
    let is_conformal =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_TRANSFORM2D
        "is_conformal"
        (Base.Int64.of_string "3918633141")
        (Transform2D.typ @-> returning Bool.typ)
        Bool.s

    (** Returns [code]true[/code] if this transform and [param xform] are approximately equal, by running [method @GlobalScope.is_equal_approx] on each component. *)
    let is_equal_approx =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_TRANSFORM2D
        "is_equal_approx"
        (Base.Int64.of_string "3837431929")
        (Transform2D.typ @-> Transform2D.typ @-> returning Bool.typ)
        Bool.s

    (** Returns [code]true[/code] if this transform is finite, by calling [method @GlobalScope.is_finite] on each component. *)
    let is_finite =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_TRANSFORM2D
        "is_finite"
        (Base.Int64.of_string "3918633141")
        (Transform2D.typ @-> returning Bool.typ)
        Bool.s

    (** Returns a copy of the transform rotated such that the rotated X-axis points towards the [param target] position.
Operations take place in global space. *)
    let looking_at =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_TRANSFORM2D
        "looking_at"
        (Base.Int64.of_string "1446323263")
        (Vector2.typ @-> Transform2D.typ @-> returning Transform2D.typ)
        Transform2D.s

    let not =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_TRANSFORM2D None
        GlobalEnum.VariantOperator._OP_NOT
        (funptr
           (Transform2D.typ @-> Transform2D.typ @-> Bool.typ @-> returning void))

    (** Returns [code]true[/code] if the transforms are exactly equal.
[b]Note:[/b] Due to floating-point precision errors, consider using [method is_equal_approx] instead, which is more reliable. *)
    let ( = ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_TRANSFORM2D
        (Some GlobalEnum.VariantType._TYPE_TRANSFORM2D)
        GlobalEnum.VariantOperator._OP_EQUAL
        (funptr
           (Transform2D.typ @-> Transform2D.typ @-> Bool.typ @-> returning void))

    (** Returns [code]true[/code] if the transforms are not equal.
[b]Note:[/b] Due to floating-point precision errors, consider using [method is_equal_approx] instead, which is more reliable. *)
    let ( <> ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_TRANSFORM2D
        (Some GlobalEnum.VariantType._TYPE_TRANSFORM2D)
        GlobalEnum.VariantOperator._OP_NOT_EQUAL
        (funptr
           (Transform2D.typ @-> Transform2D.typ @-> Bool.typ @-> returning void))

    (** Composes these two transformation matrices by multiplying them together. This has the effect of transforming the second transform (the child) by the first transform (the parent). *)
    let ( * ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_TRANSFORM2D
        (Some GlobalEnum.VariantType._TYPE_TRANSFORM2D)
        GlobalEnum.VariantOperator._OP_MULTIPLY
        (funptr
           (Transform2D.typ @-> Transform2D.typ @-> Transform2D.typ
          @-> returning void))

    let _Transform2D_elem_Dictionary =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_TRANSFORM2D
        (Some GlobalEnum.VariantType._TYPE_DICTIONARY)
        GlobalEnum.VariantOperator._OP_IN
        (funptr
           (Transform2D.typ @-> Dictionary.typ @-> Bool.typ @-> returning void))

    let _Transform2D_elem_Array =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_TRANSFORM2D
        (Some GlobalEnum.VariantType._TYPE_ARRAY)
        GlobalEnum.VariantOperator._OP_IN
        (funptr (Transform2D.typ @-> Array.typ @-> Bool.typ @-> returning void))
  end

  module Vector4 = struct
    include M.Vector4

    (** Returns the axis of the vector's lowest value. See [code]AXIS_ * [/code] constants. If all components are equal, this method returns [constant AXIS_W]. *)
    let min_axis_index =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_VECTOR4
        "min_axis_index"
        (Base.Int64.of_string "3173160232")
        (Vector4.typ @-> returning Int.typ)
        Int.s

    (** Returns the axis of the vector's highest value. See [code]AXIS_ * [/code] constants. If all components are equal, this method returns [constant AXIS_X]. *)
    let max_axis_index =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_VECTOR4
        "max_axis_index"
        (Base.Int64.of_string "3173160232")
        (Vector4.typ @-> returning Int.typ)
        Int.s

    (** Returns the length (magnitude) of this vector. *)
    let length =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_VECTOR4 "length"
        (Base.Int64.of_string "466405837")
        (Vector4.typ @-> returning Float.typ)
        Float.s

    (** Returns the squared length (squared magnitude) of this vector.
This method runs faster than [method length], so prefer it if you need to compare vectors or need the squared distance for some formula. *)
    let length_squared =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_VECTOR4
        "length_squared"
        (Base.Int64.of_string "466405837")
        (Vector4.typ @-> returning Float.typ)
        Float.s

    (** Returns a new vector with all components in absolute values (i.e. positive). *)
    let abs =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_VECTOR4 "abs"
        (Base.Int64.of_string "80860099")
        (Vector4.typ @-> returning Vector4.typ)
        Vector4.s

    (** Returns a new vector with each component set to [code]1.0[/code] if it's positive, [code]-1.0[/code] if it's negative, and [code]0.0[/code] if it's zero. The result is identical to calling [method @GlobalScope.sign] on each component. *)
    let sign =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_VECTOR4 "sign"
        (Base.Int64.of_string "80860099")
        (Vector4.typ @-> returning Vector4.typ)
        Vector4.s

    (** Returns a new vector with all components rounded down (towards negative infinity). *)
    let floor =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_VECTOR4 "floor"
        (Base.Int64.of_string "80860099")
        (Vector4.typ @-> returning Vector4.typ)
        Vector4.s

    (** Returns a new vector with all components rounded up (towards positive infinity). *)
    let ceil =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_VECTOR4 "ceil"
        (Base.Int64.of_string "80860099")
        (Vector4.typ @-> returning Vector4.typ)
        Vector4.s

    (** Returns a new vector with all components rounded to the nearest integer, with halfway cases rounded away from zero. *)
    let round =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_VECTOR4 "round"
        (Base.Int64.of_string "80860099")
        (Vector4.typ @-> returning Vector4.typ)
        Vector4.s

    (** Returns the result of the linear interpolation between this vector and [param to] by amount [param weight]. [param weight] is on the range of [code]0.0[/code] to [code]1.0[/code], representing the amount of interpolation. *)
    let lerp =
      foreign_builtin_method2 GlobalEnum.VariantType._TYPE_VECTOR4 "lerp"
        (Base.Int64.of_string "2329757942")
        (Vector4.typ @-> Float.typ @-> Vector4.typ @-> returning Vector4.typ)
        Vector4.s

    (** Performs a cubic interpolation between this vector and [param b] using [param pre_a] and [param post_b] as handles, and returns the result at position [param weight]. [param weight] is on the range of 0.0 to 1.0, representing the amount of interpolation. *)
    let cubic_interpolate =
      foreign_builtin_method4 GlobalEnum.VariantType._TYPE_VECTOR4
        "cubic_interpolate"
        (Base.Int64.of_string "726768410")
        (Vector4.typ @-> Vector4.typ @-> Vector4.typ @-> Float.typ
       @-> Vector4.typ @-> returning Vector4.typ)
        Vector4.s

    (** Performs a cubic interpolation between this vector and [param b] using [param pre_a] and [param post_b] as handles, and returns the result at position [param weight]. [param weight] is on the range of 0.0 to 1.0, representing the amount of interpolation.
It can perform smoother interpolation than [method cubic_interpolate] by the time values. *)
    let cubic_interpolate_in_time =
      foreign_builtin_method7 GlobalEnum.VariantType._TYPE_VECTOR4
        "cubic_interpolate_in_time"
        (Base.Int64.of_string "681631873")
        (Vector4.typ @-> Vector4.typ @-> Vector4.typ @-> Float.typ @-> Float.typ
       @-> Float.typ @-> Float.typ @-> Vector4.typ @-> returning Vector4.typ)
        Vector4.s

    (** Returns a vector composed of the [method @GlobalScope.fposmod] of this vector's components and [param mod]. *)
    let posmod =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_VECTOR4 "posmod"
        (Base.Int64.of_string "3129671720")
        (Float.typ @-> Vector4.typ @-> returning Vector4.typ)
        Vector4.s

    (** Returns a vector composed of the [method @GlobalScope.fposmod] of this vector's components and [param modv]'s components. *)
    let posmodv =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_VECTOR4 "posmodv"
        (Base.Int64.of_string "2031281584")
        (Vector4.typ @-> Vector4.typ @-> returning Vector4.typ)
        Vector4.s

    (** Returns a new vector with each component snapped to the nearest multiple of the corresponding component in [param step]. This can also be used to round the components to an arbitrary number of decimals. *)
    let snapped =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_VECTOR4 "snapped"
        (Base.Int64.of_string "2031281584")
        (Vector4.typ @-> Vector4.typ @-> returning Vector4.typ)
        Vector4.s

    (** Returns a new vector with all components clamped between the components of [param min] and [param max], by running [method @GlobalScope.clamp] on each component. *)
    let clamp =
      foreign_builtin_method2 GlobalEnum.VariantType._TYPE_VECTOR4 "clamp"
        (Base.Int64.of_string "823915692")
        (Vector4.typ @-> Vector4.typ @-> Vector4.typ @-> returning Vector4.typ)
        Vector4.s

    (** Returns the result of scaling the vector to unit length. Equivalent to [code]v / v.length()[/code]. See also [method is_normalized].
[b]Note:[/b] This function may return incorrect values if the input vector length is near zero. *)
    let normalized =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_VECTOR4 "normalized"
        (Base.Int64.of_string "80860099")
        (Vector4.typ @-> returning Vector4.typ)
        Vector4.s

    (** Returns [code]true[/code] if the vector is normalized, i.e. its length is approximately equal to 1. *)
    let is_normalized =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_VECTOR4
        "is_normalized"
        (Base.Int64.of_string "3918633141")
        (Vector4.typ @-> returning Bool.typ)
        Bool.s

    (** Returns the normalized vector pointing from this vector to [param to]. This is equivalent to using [code](b - a).normalized()[/code]. *)
    let direction_to =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_VECTOR4
        "direction_to"
        (Base.Int64.of_string "2031281584")
        (Vector4.typ @-> Vector4.typ @-> returning Vector4.typ)
        Vector4.s

    (** Returns the distance between this vector and [param to]. *)
    let distance_to =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_VECTOR4 "distance_to"
        (Base.Int64.of_string "3770801042")
        (Vector4.typ @-> Vector4.typ @-> returning Float.typ)
        Float.s

    (** Returns the squared distance between this vector and [param to].
This method runs faster than [method distance_to], so prefer it if you need to compare vectors or need the squared distance for some formula. *)
    let distance_squared_to =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_VECTOR4
        "distance_squared_to"
        (Base.Int64.of_string "3770801042")
        (Vector4.typ @-> Vector4.typ @-> returning Float.typ)
        Float.s

    (** Returns the dot product of this vector and [param with]. *)
    let dot =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_VECTOR4 "dot"
        (Base.Int64.of_string "3770801042")
        (Vector4.typ @-> Vector4.typ @-> returning Float.typ)
        Float.s

    (** Returns the inverse of the vector. This is the same as [code]Vector4(1.0 / v.x, 1.0 / v.y, 1.0 / v.z, 1.0 / v.w)[/code]. *)
    let inverse =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_VECTOR4 "inverse"
        (Base.Int64.of_string "80860099")
        (Vector4.typ @-> returning Vector4.typ)
        Vector4.s

    (** Returns [code]true[/code] if this vector and [param to] are approximately equal, by running [method @GlobalScope.is_equal_approx] on each component. *)
    let is_equal_approx =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_VECTOR4
        "is_equal_approx"
        (Base.Int64.of_string "88913544")
        (Vector4.typ @-> Vector4.typ @-> returning Bool.typ)
        Bool.s

    (** Returns [code]true[/code] if this vector's values are approximately zero, by running [method @GlobalScope.is_zero_approx] on each component.
This method is faster than using [method is_equal_approx] with one value as a zero vector. *)
    let is_zero_approx =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_VECTOR4
        "is_zero_approx"
        (Base.Int64.of_string "3918633141")
        (Vector4.typ @-> returning Bool.typ)
        Bool.s

    (** Returns [code]true[/code] if this vector is finite, by calling [method @GlobalScope.is_finite] on each component. *)
    let is_finite =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_VECTOR4 "is_finite"
        (Base.Int64.of_string "3918633141")
        (Vector4.typ @-> returning Bool.typ)
        Bool.s

    (** Returns the negative value of the [Vector4]. This is the same as writing [code]Vector4(-v.x, -v.y, -v.z, -v.w)[/code]. This operation flips the direction of the vector while keeping the same magnitude. With floats, the number zero can be either positive or negative. *)
    let ( ~- ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_VECTOR4 None
        GlobalEnum.VariantOperator._OP_NEGATE
        (funptr
           (Vector4.typ @-> Vector4.typ @-> Vector4.typ @-> returning void))

    (** Returns the same value as if the [code]+[/code] was not there. Unary [code]+[/code] does nothing, but sometimes it can make your code more readable. *)
    let ( ~+ ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_VECTOR4 None
        GlobalEnum.VariantOperator._OP_POSITIVE
        (funptr
           (Vector4.typ @-> Vector4.typ @-> Vector4.typ @-> returning void))

    let not =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_VECTOR4 None
        GlobalEnum.VariantOperator._OP_NOT
        (funptr (Vector4.typ @-> Vector4.typ @-> Bool.typ @-> returning void))

    (** Returns [code]true[/code] if the vectors are exactly equal.
[b]Note:[/b] Due to floating-point precision errors, consider using [method is_equal_approx] instead, which is more reliable.
[b]Note:[/b] Vectors with [constant @GDScript.NAN] elements don't behave the same as other vectors. Therefore, the results from this operator may not be accurate if NaNs are included. *)
    let ( = ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_VECTOR4
        (Some GlobalEnum.VariantType._TYPE_VECTOR4)
        GlobalEnum.VariantOperator._OP_EQUAL
        (funptr (Vector4.typ @-> Vector4.typ @-> Bool.typ @-> returning void))

    (** Returns [code]true[/code] if the vectors are not equal.
[b]Note:[/b] Due to floating-point precision errors, consider using [method is_equal_approx] instead, which is more reliable.
[b]Note:[/b] Vectors with [constant @GDScript.NAN] elements don't behave the same as other vectors. Therefore, the results from this operator may not be accurate if NaNs are included. *)
    let ( <> ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_VECTOR4
        (Some GlobalEnum.VariantType._TYPE_VECTOR4)
        GlobalEnum.VariantOperator._OP_NOT_EQUAL
        (funptr (Vector4.typ @-> Vector4.typ @-> Bool.typ @-> returning void))

    (** Compares two [Vector4] vectors by first checking if the X value of the left vector is less than the X value of the [param right] vector. If the X values are exactly equal, then it repeats this check with the Y values of the two vectors, Z values of the two vectors, and then with the W values. This operator is useful for sorting vectors.
[b]Note:[/b] Vectors with [constant @GDScript.NAN] elements don't behave the same as other vectors. Therefore, the results from this operator may not be accurate if NaNs are included. *)
    let ( < ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_VECTOR4
        (Some GlobalEnum.VariantType._TYPE_VECTOR4)
        GlobalEnum.VariantOperator._OP_LESS
        (funptr (Vector4.typ @-> Vector4.typ @-> Bool.typ @-> returning void))

    (** Compares two [Vector4] vectors by first checking if the X value of the left vector is less than or equal to the X value of the [param right] vector. If the X values are exactly equal, then it repeats this check with the Y values of the two vectors, Z values of the two vectors, and then with the W values. This operator is useful for sorting vectors.
[b]Note:[/b] Vectors with [constant @GDScript.NAN] elements don't behave the same as other vectors. Therefore, the results from this operator may not be accurate if NaNs are included. *)
    let ( <= ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_VECTOR4
        (Some GlobalEnum.VariantType._TYPE_VECTOR4)
        GlobalEnum.VariantOperator._OP_LESS_EQUAL
        (funptr (Vector4.typ @-> Vector4.typ @-> Bool.typ @-> returning void))

    (** Compares two [Vector4] vectors by first checking if the X value of the left vector is greater than the X value of the [param right] vector. If the X values are exactly equal, then it repeats this check with the Y values of the two vectors, Z values of the two vectors, and then with the W values. This operator is useful for sorting vectors.
[b]Note:[/b] Vectors with [constant @GDScript.NAN] elements don't behave the same as other vectors. Therefore, the results from this operator may not be accurate if NaNs are included. *)
    let ( > ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_VECTOR4
        (Some GlobalEnum.VariantType._TYPE_VECTOR4)
        GlobalEnum.VariantOperator._OP_GREATER
        (funptr (Vector4.typ @-> Vector4.typ @-> Bool.typ @-> returning void))

    (** Compares two [Vector4] vectors by first checking if the X value of the left vector is greater than or equal to the X value of the [param right] vector. If the X values are exactly equal, then it repeats this check with the Y values of the two vectors, Z values of the two vectors, and then with the W values. This operator is useful for sorting vectors.
[b]Note:[/b] Vectors with [constant @GDScript.NAN] elements don't behave the same as other vectors. Therefore, the results from this operator may not be accurate if NaNs are included. *)
    let ( >= ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_VECTOR4
        (Some GlobalEnum.VariantType._TYPE_VECTOR4)
        GlobalEnum.VariantOperator._OP_GREATER_EQUAL
        (funptr (Vector4.typ @-> Vector4.typ @-> Bool.typ @-> returning void))

    (** Adds each component of the [Vector4] by the components of the given [Vector4].
[codeblock]
print(Vector4(10, 20, 30, 40) + Vector4(3, 4, 5, 6)) # Prints ""(13, 24, 35, 46)""
[/codeblock] *)
    let ( + ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_VECTOR4
        (Some GlobalEnum.VariantType._TYPE_VECTOR4)
        GlobalEnum.VariantOperator._OP_ADD
        (funptr
           (Vector4.typ @-> Vector4.typ @-> Vector4.typ @-> returning void))

    (** Subtracts each component of the [Vector4] by the components of the given [Vector4].
[codeblock]
print(Vector4(10, 20, 30, 40) - Vector4(3, 4, 5, 6)) # Prints ""(7, 16, 25, 34)""
[/codeblock] *)
    let ( - ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_VECTOR4
        (Some GlobalEnum.VariantType._TYPE_VECTOR4)
        GlobalEnum.VariantOperator._OP_SUBTRACT
        (funptr
           (Vector4.typ @-> Vector4.typ @-> Vector4.typ @-> returning void))

    (** Multiplies each component of the [Vector4] by the components of the given [Vector4].
[codeblock]
print(Vector4(10, 20, 30, 40)  *  Vector4(3, 4, 5, 6)) # Prints ""(30, 80, 150, 240)""
[/codeblock] *)
    let ( * ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_VECTOR4
        (Some GlobalEnum.VariantType._TYPE_VECTOR4)
        GlobalEnum.VariantOperator._OP_MULTIPLY
        (funptr
           (Vector4.typ @-> Vector4.typ @-> Vector4.typ @-> returning void))

    (** Divides each component of the [Vector4] by the components of the given [Vector4].
[codeblock]
print(Vector4(10, 20, 30, 40) / Vector4(2, 5, 3, 4)) # Prints ""(5, 4, 10, 10)""
[/codeblock] *)
    let ( / ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_VECTOR4
        (Some GlobalEnum.VariantType._TYPE_VECTOR4)
        GlobalEnum.VariantOperator._OP_DIVIDE
        (funptr
           (Vector4.typ @-> Vector4.typ @-> Vector4.typ @-> returning void))

    let _Vector4_elem_Dictionary =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_VECTOR4
        (Some GlobalEnum.VariantType._TYPE_DICTIONARY)
        GlobalEnum.VariantOperator._OP_IN
        (funptr
           (Vector4.typ @-> Dictionary.typ @-> Bool.typ @-> returning void))

    let _Vector4_elem_Array =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_VECTOR4
        (Some GlobalEnum.VariantType._TYPE_ARRAY)
        GlobalEnum.VariantOperator._OP_IN
        (funptr (Vector4.typ @-> Array.typ @-> Bool.typ @-> returning void))

    module Axis = struct
      type t = Int.t

      let typ = Int.typ

      (** Enumerated value for the X axis. Returned by [method max_axis_index] and [method min_axis_index]. *)
      let _AXIS_X = 0

      (** Enumerated value for the Y axis. Returned by [method max_axis_index] and [method min_axis_index]. *)
      let _AXIS_Y = 1

      (** Enumerated value for the Z axis. Returned by [method max_axis_index] and [method min_axis_index]. *)
      let _AXIS_Z = 2

      (** Enumerated value for the W axis. Returned by [method max_axis_index] and [method min_axis_index]. *)
      let _AXIS_W = 3
    end
  end

  module Vector4i = struct
    include M.Vector4i

    (** Returns the axis of the vector's lowest value. See [code]AXIS_ * [/code] constants. If all components are equal, this method returns [constant AXIS_W]. *)
    let min_axis_index =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_VECTOR4I
        "min_axis_index"
        (Base.Int64.of_string "3173160232")
        (Vector4i.typ @-> returning Int.typ)
        Int.s

    (** Returns the axis of the vector's highest value. See [code]AXIS_ * [/code] constants. If all components are equal, this method returns [constant AXIS_X]. *)
    let max_axis_index =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_VECTOR4I
        "max_axis_index"
        (Base.Int64.of_string "3173160232")
        (Vector4i.typ @-> returning Int.typ)
        Int.s

    (** Returns the length (magnitude) of this vector. *)
    let length =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_VECTOR4I "length"
        (Base.Int64.of_string "466405837")
        (Vector4i.typ @-> returning Float.typ)
        Float.s

    (** Returns the squared length (squared magnitude) of this vector.
This method runs faster than [method length], so prefer it if you need to compare vectors or need the squared distance for some formula. *)
    let length_squared =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_VECTOR4I
        "length_squared"
        (Base.Int64.of_string "3173160232")
        (Vector4i.typ @-> returning Int.typ)
        Int.s

    (** Returns a new vector with each component set to [code]1[/code] if it's positive, [code]-1[/code] if it's negative, and [code]0[/code] if it's zero. The result is identical to calling [method @GlobalScope.sign] on each component. *)
    let sign =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_VECTOR4I "sign"
        (Base.Int64.of_string "4134919947")
        (Vector4i.typ @-> returning Vector4i.typ)
        Vector4i.s

    (** Returns a new vector with all components in absolute values (i.e. positive). *)
    let abs =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_VECTOR4I "abs"
        (Base.Int64.of_string "4134919947")
        (Vector4i.typ @-> returning Vector4i.typ)
        Vector4i.s

    (** Returns a new vector with all components clamped between the components of [param min] and [param max], by running [method @GlobalScope.clamp] on each component. *)
    let clamp =
      foreign_builtin_method2 GlobalEnum.VariantType._TYPE_VECTOR4I "clamp"
        (Base.Int64.of_string "3046490913")
        (Vector4i.typ @-> Vector4i.typ @-> Vector4i.typ
       @-> returning Vector4i.typ)
        Vector4i.s

    (** Returns a new vector with each component snapped to the closest multiple of the corresponding component in [param step]. *)
    let snapped =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_VECTOR4I "snapped"
        (Base.Int64.of_string "1181693102")
        (Vector4i.typ @-> Vector4i.typ @-> returning Vector4i.typ)
        Vector4i.s

    (** Returns the negative value of the [Vector4i]. This is the same as writing [code]Vector4i(-v.x, -v.y, -v.z, -v.w)[/code]. This operation flips the direction of the vector while keeping the same magnitude. *)
    let ( ~- ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_VECTOR4I None
        GlobalEnum.VariantOperator._OP_NEGATE
        (funptr
           (Vector4i.typ @-> Vector4i.typ @-> Vector4i.typ @-> returning void))

    (** Returns the same value as if the [code]+[/code] was not there. Unary [code]+[/code] does nothing, but sometimes it can make your code more readable. *)
    let ( ~+ ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_VECTOR4I None
        GlobalEnum.VariantOperator._OP_POSITIVE
        (funptr
           (Vector4i.typ @-> Vector4i.typ @-> Vector4i.typ @-> returning void))

    let not =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_VECTOR4I None
        GlobalEnum.VariantOperator._OP_NOT
        (funptr (Vector4i.typ @-> Vector4i.typ @-> Bool.typ @-> returning void))

    (** Returns [code]true[/code] if the vectors are exactly equal. *)
    let ( = ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_VECTOR4I
        (Some GlobalEnum.VariantType._TYPE_VECTOR4I)
        GlobalEnum.VariantOperator._OP_EQUAL
        (funptr (Vector4i.typ @-> Vector4i.typ @-> Bool.typ @-> returning void))

    (** Returns [code]true[/code] if the vectors are not equal. *)
    let ( <> ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_VECTOR4I
        (Some GlobalEnum.VariantType._TYPE_VECTOR4I)
        GlobalEnum.VariantOperator._OP_NOT_EQUAL
        (funptr (Vector4i.typ @-> Vector4i.typ @-> Bool.typ @-> returning void))

    (** Compares two [Vector4i] vectors by first checking if the X value of the left vector is less than the X value of the [param right] vector. If the X values are exactly equal, then it repeats this check with the Y values of the two vectors, Z values of the two vectors, and then with the W values. This operator is useful for sorting vectors. *)
    let ( < ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_VECTOR4I
        (Some GlobalEnum.VariantType._TYPE_VECTOR4I)
        GlobalEnum.VariantOperator._OP_LESS
        (funptr (Vector4i.typ @-> Vector4i.typ @-> Bool.typ @-> returning void))

    (** Compares two [Vector4i] vectors by first checking if the X value of the left vector is less than or equal to the X value of the [param right] vector. If the X values are exactly equal, then it repeats this check with the Y values of the two vectors, Z values of the two vectors, and then with the W values. This operator is useful for sorting vectors. *)
    let ( <= ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_VECTOR4I
        (Some GlobalEnum.VariantType._TYPE_VECTOR4I)
        GlobalEnum.VariantOperator._OP_LESS_EQUAL
        (funptr (Vector4i.typ @-> Vector4i.typ @-> Bool.typ @-> returning void))

    (** Compares two [Vector4i] vectors by first checking if the X value of the left vector is greater than the X value of the [param right] vector. If the X values are exactly equal, then it repeats this check with the Y values of the two vectors, Z values of the two vectors, and then with the W values. This operator is useful for sorting vectors. *)
    let ( > ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_VECTOR4I
        (Some GlobalEnum.VariantType._TYPE_VECTOR4I)
        GlobalEnum.VariantOperator._OP_GREATER
        (funptr (Vector4i.typ @-> Vector4i.typ @-> Bool.typ @-> returning void))

    (** Compares two [Vector4i] vectors by first checking if the X value of the left vector is greater than or equal to the X value of the [param right] vector. If the X values are exactly equal, then it repeats this check with the Y values of the two vectors, Z values of the two vectors, and then with the W values. This operator is useful for sorting vectors. *)
    let ( >= ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_VECTOR4I
        (Some GlobalEnum.VariantType._TYPE_VECTOR4I)
        GlobalEnum.VariantOperator._OP_GREATER_EQUAL
        (funptr (Vector4i.typ @-> Vector4i.typ @-> Bool.typ @-> returning void))

    (** Adds each component of the [Vector4i] by the components of the given [Vector4i].
[codeblock]
print(Vector4i(10, 20, 30, 40) + Vector4i(3, 4, 5, 6)) # Prints ""(13, 24, 35, 46)""
[/codeblock] *)
    let ( + ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_VECTOR4I
        (Some GlobalEnum.VariantType._TYPE_VECTOR4I)
        GlobalEnum.VariantOperator._OP_ADD
        (funptr
           (Vector4i.typ @-> Vector4i.typ @-> Vector4i.typ @-> returning void))

    (** Subtracts each component of the [Vector4i] by the components of the given [Vector4i].
[codeblock]
print(Vector4i(10, 20, 30, 40) - Vector4i(3, 4, 5, 6)) # Prints ""(7, 16, 25, 34)""
[/codeblock] *)
    let ( - ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_VECTOR4I
        (Some GlobalEnum.VariantType._TYPE_VECTOR4I)
        GlobalEnum.VariantOperator._OP_SUBTRACT
        (funptr
           (Vector4i.typ @-> Vector4i.typ @-> Vector4i.typ @-> returning void))

    (** Multiplies each component of the [Vector4i] by the components of the given [Vector4i].
[codeblock]
print(Vector4i(10, 20, 30, 40)  *  Vector4i(3, 4, 5, 6)) # Prints ""(30, 80, 150, 240)""
[/codeblock] *)
    let ( * ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_VECTOR4I
        (Some GlobalEnum.VariantType._TYPE_VECTOR4I)
        GlobalEnum.VariantOperator._OP_MULTIPLY
        (funptr
           (Vector4i.typ @-> Vector4i.typ @-> Vector4i.typ @-> returning void))

    (** Divides each component of the [Vector4i] by the components of the given [Vector4i].
[codeblock]
print(Vector4i(10, 20, 30, 40) / Vector4i(2, 5, 3, 4)) # Prints ""(5, 4, 10, 10)""
[/codeblock] *)
    let ( / ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_VECTOR4I
        (Some GlobalEnum.VariantType._TYPE_VECTOR4I)
        GlobalEnum.VariantOperator._OP_DIVIDE
        (funptr
           (Vector4i.typ @-> Vector4i.typ @-> Vector4i.typ @-> returning void))

    (** Gets the remainder of each component of the [Vector4i] with the components of the given [Vector4i]. This operation uses truncated division, which is often not desired as it does not work well with negative numbers. Consider using [method @GlobalScope.posmod] instead if you want to handle negative numbers.
[codeblock]
print(Vector4i(10, -20, 30, -40) % Vector4i(7, 8, 9, 10))  # Prints ""(3, -4, 3, 0)""
[/codeblock] *)
    let ( % ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_VECTOR4I
        (Some GlobalEnum.VariantType._TYPE_VECTOR4I)
        GlobalEnum.VariantOperator._OP_MODULE
        (funptr
           (Vector4i.typ @-> Vector4i.typ @-> Vector4i.typ @-> returning void))

    let _Vector4i_elem_Dictionary =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_VECTOR4I
        (Some GlobalEnum.VariantType._TYPE_DICTIONARY)
        GlobalEnum.VariantOperator._OP_IN
        (funptr
           (Vector4i.typ @-> Dictionary.typ @-> Bool.typ @-> returning void))

    let _Vector4i_elem_Array =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_VECTOR4I
        (Some GlobalEnum.VariantType._TYPE_ARRAY)
        GlobalEnum.VariantOperator._OP_IN
        (funptr (Vector4i.typ @-> Array.typ @-> Bool.typ @-> returning void))

    module Axis = struct
      type t = Int.t

      let typ = Int.typ

      (** Enumerated value for the X axis. Returned by [method max_axis_index] and [method min_axis_index]. *)
      let _AXIS_X = 0

      (** Enumerated value for the Y axis. Returned by [method max_axis_index] and [method min_axis_index]. *)
      let _AXIS_Y = 1

      (** Enumerated value for the Z axis. Returned by [method max_axis_index] and [method min_axis_index]. *)
      let _AXIS_Z = 2

      (** Enumerated value for the W axis. Returned by [method max_axis_index] and [method min_axis_index]. *)
      let _AXIS_W = 3
    end
  end

  module Plane = struct
    include M.Plane

    (** Returns a copy of the plane, with normalized [member normal] (so it's a unit vector). Returns [code]Plane(0, 0, 0, 0)[/code] if [member normal] can't be normalized (it has zero length). *)
    let normalized =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_PLANE "normalized"
        (Base.Int64.of_string "1051796340")
        (Plane.typ @-> returning Plane.typ)
        Plane.s

    (** Returns the center of the plane. *)
    let get_center =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_PLANE "get_center"
        (Base.Int64.of_string "1776574132")
        (Plane.typ @-> returning Vector3.typ)
        Vector3.s

    (** Returns [code]true[/code] if this plane and [param to_plane] are approximately equal, by running [method @GlobalScope.is_equal_approx] on each component. *)
    let is_equal_approx =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_PLANE
        "is_equal_approx"
        (Base.Int64.of_string "1150170233")
        (Plane.typ @-> Plane.typ @-> returning Bool.typ)
        Bool.s

    (** Returns [code]true[/code] if this plane is finite, by calling [method @GlobalScope.is_finite] on each component. *)
    let is_finite =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_PLANE "is_finite"
        (Base.Int64.of_string "3918633141")
        (Plane.typ @-> returning Bool.typ)
        Bool.s

    (** Returns [code]true[/code] if [param point] is located above the plane. *)
    let is_point_over =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_PLANE "is_point_over"
        (Base.Int64.of_string "1749054343")
        (Vector3.typ @-> Plane.typ @-> returning Bool.typ)
        Bool.s

    (** Returns the shortest distance from the plane to the position [param point]. If the point is above the plane, the distance will be positive. If below, the distance will be negative. *)
    let distance_to =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_PLANE "distance_to"
        (Base.Int64.of_string "1047977935")
        (Vector3.typ @-> Plane.typ @-> returning Float.typ)
        Float.s

    (** Returns [code]true[/code] if [param point] is inside the plane. Comparison uses a custom minimum [param tolerance] threshold. *)
    let has_point =
      foreign_builtin_method2 GlobalEnum.VariantType._TYPE_PLANE "has_point"
        (Base.Int64.of_string "1258189072")
        (Vector3.typ @-> Float.typ @-> Plane.typ @-> returning Bool.typ)
        Bool.s

    (** Returns the orthogonal projection of [param point] into a point in the plane. *)
    let project =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_PLANE "project"
        (Base.Int64.of_string "2923479887")
        (Vector3.typ @-> Plane.typ @-> returning Vector3.typ)
        Vector3.s

    (** Returns the intersection point of the three planes [param b], [param c] and this plane. If no intersection is found, [code]null[/code] is returned. *)
    let intersect_3 =
      foreign_builtin_method2 GlobalEnum.VariantType._TYPE_PLANE "intersect_3"
        (Base.Int64.of_string "2012052692")
        (Plane.typ @-> Plane.typ @-> Plane.typ @-> returning Variant.typ)
        Variant.s

    (** Returns the intersection point of a ray consisting of the position [param from] and the direction normal [param dir] with this plane. If no intersection is found, [code]null[/code] is returned. *)
    let intersects_ray =
      foreign_builtin_method2 GlobalEnum.VariantType._TYPE_PLANE
        "intersects_ray"
        (Base.Int64.of_string "2048133369")
        (Vector3.typ @-> Vector3.typ @-> Plane.typ @-> returning Variant.typ)
        Variant.s

    (** Returns the intersection point of a segment from position [param from] to position [param to] with this plane. If no intersection is found, [code]null[/code] is returned. *)
    let intersects_segment =
      foreign_builtin_method2 GlobalEnum.VariantType._TYPE_PLANE
        "intersects_segment"
        (Base.Int64.of_string "2048133369")
        (Vector3.typ @-> Vector3.typ @-> Plane.typ @-> returning Variant.typ)
        Variant.s

    (** Returns the negative value of the [Plane]. This is the same as writing [code]Plane(-p.normal, -p.d)[/code]. This operation flips the direction of the normal vector and also flips the distance value, resulting in a Plane that is in the same place, but facing the opposite direction. *)
    let ( ~- ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_PLANE None
        GlobalEnum.VariantOperator._OP_NEGATE
        (funptr (Plane.typ @-> Plane.typ @-> Plane.typ @-> returning void))

    (** Returns the same value as if the [code]+[/code] was not there. Unary [code]+[/code] does nothing, but sometimes it can make your code more readable. *)
    let ( ~+ ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_PLANE None
        GlobalEnum.VariantOperator._OP_POSITIVE
        (funptr (Plane.typ @-> Plane.typ @-> Plane.typ @-> returning void))

    let not =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_PLANE None
        GlobalEnum.VariantOperator._OP_NOT
        (funptr (Plane.typ @-> Plane.typ @-> Bool.typ @-> returning void))

    (** Returns [code]true[/code] if the planes are exactly equal.
[b]Note:[/b] Due to floating-point precision errors, consider using [method is_equal_approx] instead, which is more reliable. *)
    let ( = ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_PLANE
        (Some GlobalEnum.VariantType._TYPE_PLANE)
        GlobalEnum.VariantOperator._OP_EQUAL
        (funptr (Plane.typ @-> Plane.typ @-> Bool.typ @-> returning void))

    (** Returns [code]true[/code] if the planes are not equal.
[b]Note:[/b] Due to floating-point precision errors, consider using [method is_equal_approx] instead, which is more reliable. *)
    let ( <> ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_PLANE
        (Some GlobalEnum.VariantType._TYPE_PLANE)
        GlobalEnum.VariantOperator._OP_NOT_EQUAL
        (funptr (Plane.typ @-> Plane.typ @-> Bool.typ @-> returning void))

    let _Plane_elem_Dictionary =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_PLANE
        (Some GlobalEnum.VariantType._TYPE_DICTIONARY)
        GlobalEnum.VariantOperator._OP_IN
        (funptr (Plane.typ @-> Dictionary.typ @-> Bool.typ @-> returning void))

    let _Plane_elem_Array =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_PLANE
        (Some GlobalEnum.VariantType._TYPE_ARRAY)
        GlobalEnum.VariantOperator._OP_IN
        (funptr (Plane.typ @-> Array.typ @-> Bool.typ @-> returning void))
  end

  module Quaternion = struct
    include M.Quaternion

    (** Returns this quaternion's length, also called magnitude. *)
    let length =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_QUATERNION "length"
        (Base.Int64.of_string "466405837")
        (Quaternion.typ @-> returning Float.typ)
        Float.s

    (** Returns this quaternion's length, squared.
[b]Note:[/b] This method is faster than [method length], so prefer it if you only need to compare quaternion lengths. *)
    let length_squared =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_QUATERNION
        "length_squared"
        (Base.Int64.of_string "466405837")
        (Quaternion.typ @-> returning Float.typ)
        Float.s

    (** Returns a copy of this quaternion, normalized so that its length is [code]1.0[/code]. See also [method is_normalized]. *)
    let normalized =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_QUATERNION
        "normalized"
        (Base.Int64.of_string "4274879941")
        (Quaternion.typ @-> returning Quaternion.typ)
        Quaternion.s

    (** Returns [code]true[/code] if this quaternion is normalized. See also [method normalized]. *)
    let is_normalized =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_QUATERNION
        "is_normalized"
        (Base.Int64.of_string "3918633141")
        (Quaternion.typ @-> returning Bool.typ)
        Bool.s

    (** Returns [code]true[/code] if this quaternion and [param to] are approximately equal, by running [method @GlobalScope.is_equal_approx] on each component. *)
    let is_equal_approx =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_QUATERNION
        "is_equal_approx"
        (Base.Int64.of_string "1682156903")
        (Quaternion.typ @-> Quaternion.typ @-> returning Bool.typ)
        Bool.s

    (** Returns [code]true[/code] if this quaternion is finite, by calling [method @GlobalScope.is_finite] on each component. *)
    let is_finite =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_QUATERNION
        "is_finite"
        (Base.Int64.of_string "3918633141")
        (Quaternion.typ @-> returning Bool.typ)
        Bool.s

    (** Returns the inverse version of this quaternion, inverting the sign of every component except [member w]. *)
    let inverse =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_QUATERNION "inverse"
        (Base.Int64.of_string "4274879941")
        (Quaternion.typ @-> returning Quaternion.typ)
        Quaternion.s

    (** Returns the logarithm of this quaternion. Multiplies this quaternion's rotation axis by its rotation angle, and stores the result in the returned quaternion's vector part ([member x], [member y], and [member z]). The returned quaternion's real part ([member w]) is always [code]0.0[/code]. *)
    let log =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_QUATERNION "log"
        (Base.Int64.of_string "4274879941")
        (Quaternion.typ @-> returning Quaternion.typ)
        Quaternion.s

    (** Returns the exponential of this quaternion. The rotation axis of the result is the normalized rotation axis of this quaternion, the angle of the result is the length of the vector part of this quaternion. *)
    let exp =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_QUATERNION "exp"
        (Base.Int64.of_string "4274879941")
        (Quaternion.typ @-> returning Quaternion.typ)
        Quaternion.s

    (** Returns the angle between this quaternion and [param to]. This is the magnitude of the angle you would need to rotate by to get from one to the other.
[b]Note:[/b] The magnitude of the floating-point error for this method is abnormally high, so methods such as [code]is_zero_approx[/code] will not work reliably. *)
    let angle_to =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_QUATERNION "angle_to"
        (Base.Int64.of_string "3244682419")
        (Quaternion.typ @-> Quaternion.typ @-> returning Float.typ)
        Float.s

    (** Returns the dot product between this quaternion and [param with].
This is equivalent to [code](quat.x  *  with.x) + (quat.y  *  with.y) + (quat.z  *  with.z) + (quat.w  *  with.w)[/code]. *)
    let dot =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_QUATERNION "dot"
        (Base.Int64.of_string "3244682419")
        (Quaternion.typ @-> Quaternion.typ @-> returning Float.typ)
        Float.s

    (** Performs a spherical-linear interpolation with the [param to] quaternion, given a [param weight] and returns the result. Both this quaternion and [param to] must be normalized. *)
    let slerp =
      foreign_builtin_method2 GlobalEnum.VariantType._TYPE_QUATERNION "slerp"
        (Base.Int64.of_string "1773590316")
        (Quaternion.typ @-> Float.typ @-> Quaternion.typ
       @-> returning Quaternion.typ)
        Quaternion.s

    (** Performs a spherical-linear interpolation with the [param to] quaternion, given a [param weight] and returns the result. Unlike [method slerp], this method does not check if the rotation path is smaller than 90 degrees. Both this quaternion and [param to] must be normalized. *)
    let slerpni =
      foreign_builtin_method2 GlobalEnum.VariantType._TYPE_QUATERNION "slerpni"
        (Base.Int64.of_string "1773590316")
        (Quaternion.typ @-> Float.typ @-> Quaternion.typ
       @-> returning Quaternion.typ)
        Quaternion.s

    (** Performs a spherical cubic interpolation between quaternions [param pre_a], this vector, [param b], and [param post_b], by the given amount [param weight]. *)
    let spherical_cubic_interpolate =
      foreign_builtin_method4 GlobalEnum.VariantType._TYPE_QUATERNION
        "spherical_cubic_interpolate"
        (Base.Int64.of_string "2150967576")
        (Quaternion.typ @-> Quaternion.typ @-> Quaternion.typ @-> Float.typ
       @-> Quaternion.typ @-> returning Quaternion.typ)
        Quaternion.s

    (** Performs a spherical cubic interpolation between quaternions [param pre_a], this vector, [param b], and [param post_b], by the given amount [param weight].
It can perform smoother interpolation than [method spherical_cubic_interpolate] by the time values. *)
    let spherical_cubic_interpolate_in_time =
      foreign_builtin_method7 GlobalEnum.VariantType._TYPE_QUATERNION
        "spherical_cubic_interpolate_in_time"
        (Base.Int64.of_string "1436023539")
        (Quaternion.typ @-> Quaternion.typ @-> Quaternion.typ @-> Float.typ
       @-> Float.typ @-> Float.typ @-> Float.typ @-> Quaternion.typ
       @-> returning Quaternion.typ)
        Quaternion.s

    (** Returns this quaternion's rotation as a [Vector3] of [url=https://en.wikipedia.org/wiki/Euler_angles]Euler angles[/url], in radians.
The order of each consecutive rotation can be changed with [param order] (see [enum EulerOrder] constants). By default, the YXZ convention is used ([constant EULER_ORDER_YXZ]): Z (roll) is calculated first, then X (pitch), and lastly Y (yaw). When using the opposite method [method from_euler], this order is reversed. *)
    let get_euler =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_QUATERNION
        "get_euler"
        (Base.Int64.of_string "1394941017")
        (Int.typ @-> Quaternion.typ @-> returning Vector3.typ)
        Vector3.s

    (** Constructs a new [Quaternion] from the given [Vector3] of [url=https://en.wikipedia.org/wiki/Euler_angles]Euler angles[/url], in radians. This method always uses the YXZ convention ([constant EULER_ORDER_YXZ]). *)
    let from_euler =
      foreign_builtin_method1_static GlobalEnum.VariantType._TYPE_QUATERNION
        "from_euler"
        (Base.Int64.of_string "4053467903")
        (Vector3.typ @-> returning Quaternion.typ)
        Quaternion.s

    (** Returns the rotation axis of the rotation represented by this quaternion. *)
    let get_axis =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_QUATERNION "get_axis"
        (Base.Int64.of_string "1776574132")
        (Quaternion.typ @-> returning Vector3.typ)
        Vector3.s

    (** Returns the angle of the rotation represented by this quaternion.
[b]Note:[/b] The quaternion must be normalized. *)
    let get_angle =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_QUATERNION
        "get_angle"
        (Base.Int64.of_string "466405837")
        (Quaternion.typ @-> returning Float.typ)
        Float.s

    (** Returns the negative value of the [Quaternion]. This is the same as multiplying all components by [code]-1[/code]. This operation results in a quaternion that represents the same rotation. *)
    let ( ~- ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_QUATERNION None
        GlobalEnum.VariantOperator._OP_NEGATE
        (funptr
           (Quaternion.typ @-> Quaternion.typ @-> Quaternion.typ
          @-> returning void))

    (** Returns the same value as if the [code]+[/code] was not there. Unary [code]+[/code] does nothing, but sometimes it can make your code more readable. *)
    let ( ~+ ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_QUATERNION None
        GlobalEnum.VariantOperator._OP_POSITIVE
        (funptr
           (Quaternion.typ @-> Quaternion.typ @-> Quaternion.typ
          @-> returning void))

    let not =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_QUATERNION None
        GlobalEnum.VariantOperator._OP_NOT
        (funptr
           (Quaternion.typ @-> Quaternion.typ @-> Bool.typ @-> returning void))

    (** Returns [code]true[/code] if the components of both quaternions are exactly equal.
[b]Note:[/b] Due to floating-point precision errors, consider using [method is_equal_approx] instead, which is more reliable. *)
    let ( = ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_QUATERNION
        (Some GlobalEnum.VariantType._TYPE_QUATERNION)
        GlobalEnum.VariantOperator._OP_EQUAL
        (funptr
           (Quaternion.typ @-> Quaternion.typ @-> Bool.typ @-> returning void))

    (** Returns [code]true[/code] if the components of both quaternions are not exactly equal.
[b]Note:[/b] Due to floating-point precision errors, consider using [method is_equal_approx] instead, which is more reliable. *)
    let ( <> ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_QUATERNION
        (Some GlobalEnum.VariantType._TYPE_QUATERNION)
        GlobalEnum.VariantOperator._OP_NOT_EQUAL
        (funptr
           (Quaternion.typ @-> Quaternion.typ @-> Bool.typ @-> returning void))

    (** Adds each component of the left [Quaternion] to the right [Quaternion].
This operation is not meaningful on its own, but it can be used as a part of a larger expression, such as approximating an intermediate rotation between two nearby rotations. *)
    let ( + ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_QUATERNION
        (Some GlobalEnum.VariantType._TYPE_QUATERNION)
        GlobalEnum.VariantOperator._OP_ADD
        (funptr
           (Quaternion.typ @-> Quaternion.typ @-> Quaternion.typ
          @-> returning void))

    (** Subtracts each component of the left [Quaternion] by the right [Quaternion].
This operation is not meaningful on its own, but it can be used as a part of a larger expression. *)
    let ( - ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_QUATERNION
        (Some GlobalEnum.VariantType._TYPE_QUATERNION)
        GlobalEnum.VariantOperator._OP_SUBTRACT
        (funptr
           (Quaternion.typ @-> Quaternion.typ @-> Quaternion.typ
          @-> returning void))

    (** Composes (multiplies) two quaternions. This rotates the [param right] quaternion (the child) by this quaternion (the parent). *)
    let ( * ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_QUATERNION
        (Some GlobalEnum.VariantType._TYPE_QUATERNION)
        GlobalEnum.VariantOperator._OP_MULTIPLY
        (funptr
           (Quaternion.typ @-> Quaternion.typ @-> Quaternion.typ
          @-> returning void))

    let _Quaternion_elem_Dictionary =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_QUATERNION
        (Some GlobalEnum.VariantType._TYPE_DICTIONARY)
        GlobalEnum.VariantOperator._OP_IN
        (funptr
           (Quaternion.typ @-> Dictionary.typ @-> Bool.typ @-> returning void))

    let _Quaternion_elem_Array =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_QUATERNION
        (Some GlobalEnum.VariantType._TYPE_ARRAY)
        GlobalEnum.VariantOperator._OP_IN
        (funptr (Quaternion.typ @-> Array.typ @-> Bool.typ @-> returning void))
  end

  module AABB = struct
    include M.AABB

    (** Returns an [AABB] equivalent to this bounding box, with its width, height, and depth modified to be non-negative values.
[codeblocks]
[gdscript]
var box = AABB(Vector3(5, 0, 5), Vector3(-20, -10, -5))
var absolute = box.abs()
print(absolute.position) # Prints (-15, -10, 0)
print(absolute.size)     # Prints (20, 10, 5)
[/gdscript]
[csharp]
var box = new Aabb(new Vector3(5, 0, 5), new Vector3(-20, -10, -5));
var absolute = box.Abs();
GD.Print(absolute.Position); // Prints (-15, -10, 0)
GD.Print(absolute.Size);     // Prints (20, 10, 5)
[/csharp]
[/codeblocks]
[b]Note:[/b] It's recommended to use this method when [member size] is negative, as most other methods in Godot assume that the [member size]'s components are greater than [code]0[/code]. *)
    let abs =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_AABB "abs"
        (Base.Int64.of_string "1576868580")
        (AABB.typ @-> returning AABB.typ)
        AABB.s

    (** Returns the center point of the bounding box. This is the same as [code]position + (size / 2.0)[/code]. *)
    let get_center =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_AABB "get_center"
        (Base.Int64.of_string "1776574132")
        (AABB.typ @-> returning Vector3.typ)
        Vector3.s

    (** Returns the bounding box's volume. This is equivalent to [code]size.x  *  size.y  *  size.z[/code]. See also [method has_volume]. *)
    let get_volume =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_AABB "get_volume"
        (Base.Int64.of_string "466405837")
        (AABB.typ @-> returning Float.typ)
        Float.s

    (** Returns [code]true[/code] if this bounding box's width, height, and depth are all positive. See also [method get_volume]. *)
    let has_volume =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_AABB "has_volume"
        (Base.Int64.of_string "3918633141")
        (AABB.typ @-> returning Bool.typ)
        Bool.s

    (** Returns [code]true[/code] if this bounding box has a surface or a length, that is, at least one component of [member size] is greater than [code]0[/code]. Otherwise, returns [code]false[/code]. *)
    let has_surface =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_AABB "has_surface"
        (Base.Int64.of_string "3918633141")
        (AABB.typ @-> returning Bool.typ)
        Bool.s

    (** Returns [code]true[/code] if the bounding box contains the given [param point]. By convention, points exactly on the right, top, and front sides are [b]not[/b] included.
[b]Note:[/b] This method is not reliable for [AABB] with a [i]negative[/i] [member size]. Use [method abs] first to get a valid bounding box. *)
    let has_point =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_AABB "has_point"
        (Base.Int64.of_string "1749054343")
        (Vector3.typ @-> AABB.typ @-> returning Bool.typ)
        Bool.s

    (** Returns [code]true[/code] if this bounding box and [param aabb] are approximately equal, by calling [method Vector2.is_equal_approx] on the [member position] and the [member size]. *)
    let is_equal_approx =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_AABB
        "is_equal_approx"
        (Base.Int64.of_string "299946684")
        (AABB.typ @-> AABB.typ @-> returning Bool.typ)
        Bool.s

    (** Returns [code]true[/code] if this bounding box's values are finite, by calling [method Vector2.is_finite] on the [member position] and the [member size]. *)
    let is_finite =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_AABB "is_finite"
        (Base.Int64.of_string "3918633141")
        (AABB.typ @-> returning Bool.typ)
        Bool.s

    (** Returns [code]true[/code] if this bounding box overlaps with the box [param with]. The edges of both boxes are [i]always[/i] excluded. *)
    let intersects =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_AABB "intersects"
        (Base.Int64.of_string "299946684")
        (AABB.typ @-> AABB.typ @-> returning Bool.typ)
        Bool.s

    (** Returns [code]true[/code] if this bounding box [i]completely[/i] encloses the [param with] box. The edges of both boxes are included.
[codeblocks]
[gdscript]
var a = AABB(Vector3(0, 0, 0), Vector3(4, 4, 4))
var b = AABB(Vector3(1, 1, 1), Vector3(3, 3, 3))
var c = AABB(Vector3(2, 2, 2), Vector3(8, 8, 8))

print(a.encloses(a)) # Prints true
print(a.encloses(b)) # Prints true
print(a.encloses(c)) # Prints false
[/gdscript]
[csharp]
var a = new Aabb(new Vector3(0, 0, 0), new Vector3(4, 4, 4));
var b = new Aabb(new Vector3(1, 1, 1), new Vector3(3, 3, 3));
var c = new Aabb(new Vector3(2, 2, 2), new Vector3(8, 8, 8));

GD.Print(a.Encloses(a)); // Prints True
GD.Print(a.Encloses(b)); // Prints True
GD.Print(a.Encloses(c)); // Prints False
[/csharp]
[/codeblocks] *)
    let encloses =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_AABB "encloses"
        (Base.Int64.of_string "299946684")
        (AABB.typ @-> AABB.typ @-> returning Bool.typ)
        Bool.s

    (** Returns [code]true[/code] if this bounding box is on both sides of the given [param plane]. *)
    let intersects_plane =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_AABB
        "intersects_plane"
        (Base.Int64.of_string "1150170233")
        (Plane.typ @-> AABB.typ @-> returning Bool.typ)
        Bool.s

    (** Returns the intersection between this bounding box and [param with]. If the boxes do not intersect, returns an empty [AABB]. If the boxes intersect at the edge, returns a flat [AABB] with no volume (see [method has_surface] and [method has_volume]).
[codeblocks]
[gdscript]
var box1 = AABB(Vector3(0, 0, 0), Vector3(5, 2, 8))
var box2 = AABB(Vector3(2, 0, 2), Vector3(8, 4, 4))

var intersection = box1.intersection(box2)
print(intersection.position) # Prints (2, 0, 2)
print(intersection.size)     # Prints (3, 2, 4)
[/gdscript]
[csharp]
var box1 = new Aabb(new Vector3(0, 0, 0), new Vector3(5, 2, 8));
var box2 = new Aabb(new Vector3(2, 0, 2), new Vector3(8, 4, 4));

var intersection = box1.Intersection(box2);
GD.Print(intersection.Position); // Prints (2, 0, 2)
GD.Print(intersection.Size);     // Prints (3, 2, 4)
[/csharp]
[/codeblocks]
[b]Note:[/b] If you only need to know whether two bounding boxes are intersecting, use [method intersects], instead. *)
    let intersection =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_AABB "intersection"
        (Base.Int64.of_string "1271470306")
        (AABB.typ @-> AABB.typ @-> returning AABB.typ)
        AABB.s

    (** Returns an [AABB] that encloses both this bounding box and [param with] around the edges. See also [method encloses]. *)
    let merge =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_AABB "merge"
        (Base.Int64.of_string "1271470306")
        (AABB.typ @-> AABB.typ @-> returning AABB.typ)
        AABB.s

    (** Returns a copy of this bounding box expanded to align the edges with the given [param to_point], if necessary.
[codeblocks]
[gdscript]
var box = AABB(Vector3(0, 0, 0), Vector3(5, 2, 5))

box = box.expand(Vector3(10, 0, 0))
print(box.position) # Prints (0, 0, 0)
print(box.size)     # Prints (10, 2, 5)

box = box.expand(Vector3(-5, 0, 5))
print(box.position) # Prints (-5, 0, 0)
print(box.size)     # Prints (15, 2, 5)
[/gdscript]
[csharp]
var box = new Aabb(new Vector3(0, 0, 0), new Vector3(5, 2, 5));

box = box.Expand(new Vector3(10, 0, 0));
GD.Print(box.Position); // Prints (0, 0, 0)
GD.Print(box.Size);     // Prints (10, 2, 5)

box = box.Expand(new Vector3(-5, 0, 5));
GD.Print(box.Position); // Prints (-5, 0, 0)
GD.Print(box.Size);     // Prints (15, 2, 5)
[/csharp]
[/codeblocks] *)
    let expand =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_AABB "expand"
        (Base.Int64.of_string "2851643018")
        (Vector3.typ @-> AABB.typ @-> returning AABB.typ)
        AABB.s

    (** Returns a copy of this bounding box extended on all sides by the given amount [param by]. A negative amount shrinks the box instead.
[codeblocks]
[gdscript]
var a = AABB(Vector3(4, 4, 4), Vector3(8, 8, 8)).grow(4)
print(a.position) # Prints (0, 0, 0)
print(a.size)     # Prints (16, 16, 16)

var b = AABB(Vector3(0, 0, 0), Vector3(8, 4, 2)).grow(2)
print(b.position) # Prints (-2, -2, -2)
print(b.size)     # Prints (12, 8, 6)
[/gdscript]
[csharp]
var a = new Aabb(new Vector3(4, 4, 4), new Vector3(8, 8, 8)).Grow(4);
GD.Print(a.Position); // Prints (0, 0, 0)
GD.Print(a.Size);     // Prints (16, 16, 16)

var b = new Aabb(new Vector3(0, 0, 0), new Vector3(8, 4, 2)).Grow(2);
GD.Print(b.Position); // Prints (-2, -2, -2)
GD.Print(b.Size);     // Prints (12, 8, 6)
[/csharp]
[/codeblocks] *)
    let grow =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_AABB "grow"
        (Base.Int64.of_string "239217291")
        (Float.typ @-> AABB.typ @-> returning AABB.typ)
        AABB.s

    (** Returns the vertex's position of this bounding box that's the farthest in the given direction. This point is commonly known as the support point in collision detection algorithms. *)
    let get_support =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_AABB "get_support"
        (Base.Int64.of_string "2923479887")
        (Vector3.typ @-> AABB.typ @-> returning Vector3.typ)
        Vector3.s

    (** Returns the longest normalized axis of this bounding box's [member size], as a [Vector3] ([constant Vector3.RIGHT], [constant Vector3.UP], or [constant Vector3.BACK]).
[codeblocks]
[gdscript]
var box = AABB(Vector3(0, 0, 0), Vector3(2, 4, 8))

print(box.get_longest_axis())       # Prints (0, 0, 1)
print(box.get_longest_axis_index()) # Prints 2
print(box.get_longest_axis_size())  # Prints 8
[/gdscript]
[csharp]
var box = new Aabb(new Vector3(0, 0, 0), new Vector3(2, 4, 8));

GD.Print(box.GetLongestAxis());      // Prints (0, 0, 1)
GD.Print(box.GetLongestAxisIndex()); // Prints 2
GD.Print(box.GetLongestAxisSize());  // Prints 8
[/csharp]
[/codeblocks]
See also [method get_longest_axis_index] and [method get_longest_axis_size]. *)
    let get_longest_axis =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_AABB
        "get_longest_axis"
        (Base.Int64.of_string "1776574132")
        (AABB.typ @-> returning Vector3.typ)
        Vector3.s

    (** Returns the index to the longest axis of this bounding box's [member size] (see [constant Vector3.AXIS_X], [constant Vector3.AXIS_Y], and [constant Vector3.AXIS_Z]).
For an example, see [method get_longest_axis]. *)
    let get_longest_axis_index =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_AABB
        "get_longest_axis_index"
        (Base.Int64.of_string "3173160232")
        (AABB.typ @-> returning Int.typ)
        Int.s

    (** Returns the longest dimension of this bounding box's [member size].
For an example, see [method get_longest_axis]. *)
    let get_longest_axis_size =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_AABB
        "get_longest_axis_size"
        (Base.Int64.of_string "466405837")
        (AABB.typ @-> returning Float.typ)
        Float.s

    (** Returns the shortest normaalized axis of this bounding box's [member size], as a [Vector3] ([constant Vector3.RIGHT], [constant Vector3.UP], or [constant Vector3.BACK]).
[codeblocks]
[gdscript]
var box = AABB(Vector3(0, 0, 0), Vector3(2, 4, 8))

print(box.get_shortest_axis())       # Prints (1, 0, 0)
print(box.get_shortest_axis_index()) # Prints 0
print(box.get_shortest_axis_size())  # Prints 2
[/gdscript]
[csharp]
var box = new Aabb(new Vector3(0, 0, 0), new Vector3(2, 4, 8));

GD.Print(box.GetShortestAxis());      // Prints (1, 0, 0)
GD.Print(box.GetShortestAxisIndex()); // Prints 0
GD.Print(box.GetShortestAxisSize());  // Prints 2
[/csharp]
[/codeblocks]
See also [method get_shortest_axis_index] and [method get_shortest_axis_size]. *)
    let get_shortest_axis =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_AABB
        "get_shortest_axis"
        (Base.Int64.of_string "1776574132")
        (AABB.typ @-> returning Vector3.typ)
        Vector3.s

    (** Returns the index to the shortest axis of this bounding box's [member size] (see [constant Vector3.AXIS_X], [constant Vector3.AXIS_Y], and [constant Vector3.AXIS_Z]).
For an example, see [method get_shortest_axis]. *)
    let get_shortest_axis_index =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_AABB
        "get_shortest_axis_index"
        (Base.Int64.of_string "3173160232")
        (AABB.typ @-> returning Int.typ)
        Int.s

    (** Returns the shortest dimension of this bounding box's [member size].
For an example, see [method get_shortest_axis]. *)
    let get_shortest_axis_size =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_AABB
        "get_shortest_axis_size"
        (Base.Int64.of_string "466405837")
        (AABB.typ @-> returning Float.typ)
        Float.s

    (** Returns the position of one of the 8 vertices that compose this bounding box. With a [param idx] of [code]0[/code] this is the same as [member position], and a [param idx] of [code]7[/code] is the same as [member end]. *)
    let get_endpoint =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_AABB "get_endpoint"
        (Base.Int64.of_string "1394941017")
        (Int.typ @-> AABB.typ @-> returning Vector3.typ)
        Vector3.s

    (** Returns the first point where this bounding box and the given segment intersect, as a [Vector3]. If no intersection occurs, returns [code]null[/code].
The segment begins at [param from] and ends at [param to]. *)
    let intersects_segment =
      foreign_builtin_method2 GlobalEnum.VariantType._TYPE_AABB
        "intersects_segment"
        (Base.Int64.of_string "2048133369")
        (Vector3.typ @-> Vector3.typ @-> AABB.typ @-> returning Variant.typ)
        Variant.s

    (** Returns the first point where this bounding box and the given ray intersect, as a [Vector3]. If no intersection occurs, returns [code]null[/code].
The ray begin at [param from], faces [param dir] and extends towards infinity. *)
    let intersects_ray =
      foreign_builtin_method2 GlobalEnum.VariantType._TYPE_AABB "intersects_ray"
        (Base.Int64.of_string "2048133369")
        (Vector3.typ @-> Vector3.typ @-> AABB.typ @-> returning Variant.typ)
        Variant.s

    let not =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_AABB None
        GlobalEnum.VariantOperator._OP_NOT
        (funptr (AABB.typ @-> AABB.typ @-> Bool.typ @-> returning void))

    (** Returns [code]true[/code] if both [member position] and [member size] of the bounding boxes are exactly equal, respectively.
[b]Note:[/b] Due to floating-point precision errors, consider using [method is_equal_approx] instead, which is more reliable. *)
    let ( = ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_AABB
        (Some GlobalEnum.VariantType._TYPE_AABB)
        GlobalEnum.VariantOperator._OP_EQUAL
        (funptr (AABB.typ @-> AABB.typ @-> Bool.typ @-> returning void))

    (** Returns [code]true[/code] if the [member position] or [member size] of both bounding boxes are not equal.
[b]Note:[/b] Due to floating-point precision errors, consider using [method is_equal_approx] instead, which is more reliable. *)
    let ( <> ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_AABB
        (Some GlobalEnum.VariantType._TYPE_AABB)
        GlobalEnum.VariantOperator._OP_NOT_EQUAL
        (funptr (AABB.typ @-> AABB.typ @-> Bool.typ @-> returning void))

    let _AABB_elem_Dictionary =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_AABB
        (Some GlobalEnum.VariantType._TYPE_DICTIONARY)
        GlobalEnum.VariantOperator._OP_IN
        (funptr (AABB.typ @-> Dictionary.typ @-> Bool.typ @-> returning void))

    let _AABB_elem_Array =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_AABB
        (Some GlobalEnum.VariantType._TYPE_ARRAY)
        GlobalEnum.VariantOperator._OP_IN
        (funptr (AABB.typ @-> Array.typ @-> Bool.typ @-> returning void))
  end

  module Basis = struct
    include M.Basis

    (** Returns the [url=https://en.wikipedia.org/wiki/Invertible_matrix]inverse of this basis's matrix[/url]. *)
    let inverse =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_BASIS "inverse"
        (Base.Int64.of_string "594669093")
        (Basis.typ @-> returning Basis.typ)
        Basis.s

    (** Returns the transposed version of this basis. This turns the basis matrix's columns into rows, and its rows into columns.
[codeblocks]
[gdscript]
var my_basis = Basis(
    Vector3(1, 2, 3),
    Vector3(4, 5, 6),
    Vector3(7, 8, 9)
)
my_basis = my_basis.transposed()

print(my_basis.x) # Prints (1, 4, 7).
print(my_basis.y) # Prints (2, 5, 8).
print(my_basis.z) # Prints (3, 6, 9).
[/gdscript]
[csharp]
var myBasis = new Basis(
    new Vector3(1.0f, 2.0f, 3.0f),
    new Vector3(4.0f, 5.0f, 6.0f),
    new Vector3(7.0f, 8.0f, 9.0f)
);
myBasis = myBasis.Transposed();

GD.Print(myBasis.X); // Prints (1, 4, 7).
GD.Print(myBasis.Y); // Prints (2, 5, 8).
GD.Print(myBasis.Z); // Prints (3, 6, 9).
[/csharp]
[/codeblocks] *)
    let transposed =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_BASIS "transposed"
        (Base.Int64.of_string "594669093")
        (Basis.typ @-> returning Basis.typ)
        Basis.s

    (** Returns the orthonormalized version of this basis. An orthonormal basis is both [i]orthogonal[/i] (the axes are perpendicular to each other) and [i]normalized[/i] (the axes have a length of [code]1[/code]), which also means it can only represent rotation.
It is often useful to call this method to avoid rounding errors on a rotating basis:
[codeblocks]
[gdscript]
# Rotate this Node3D every frame.
func _process(delta):
    basis = basis.rotated(Vector3.UP, TAU  *  delta)
    basis = basis.rotated(Vector3.RIGHT, TAU  *  delta)

    basis = basis.orthonormalized()
[/gdscript]
[csharp]
// Rotate this Node3D every frame.
public override void _Process(double delta)
{
    Basis = Basis.Rotated(Vector3.Up, Mathf.Tau  *  (float)delta)
                 .Rotated(Vector3.Right, Mathf.Tau  *  (float)delta)
                 .Orthonormalized();
}
[/csharp]
[/codeblocks] *)
    let orthonormalized =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_BASIS
        "orthonormalized"
        (Base.Int64.of_string "594669093")
        (Basis.typ @-> returning Basis.typ)
        Basis.s

    (** Returns the [url=https://en.wikipedia.org/wiki/Determinant]determinant[/url] of this basis's matrix. For advanced math, this number can be used to determine a few attributes:
- If the determinant is exactly [code]0[/code], the basis is not invertible (see [method inverse]).
- If the determinant is a negative number, the basis represents a negative scale.
[b]Note:[/b] If the basis's scale is the same for every axis, its determinant is always that scale by the power of 2. *)
    let determinant =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_BASIS "determinant"
        (Base.Int64.of_string "466405837")
        (Basis.typ @-> returning Float.typ)
        Float.s

    (** Returns this basis rotated around the given [param axis] by [param angle] (in radians). The [param axis] must be a normalized vector (see [method Vector3.normalized]).
Positive values rotate this basis clockwise around the axis, while negative values rotate it counterclockwise.
[codeblocks]
[gdscript]
var my_basis = Basis.IDENTITY
var angle = TAU / 2

my_basis = my_basis.rotated(Vector3.UP, angle)    # Rotate around the up axis (yaw).
my_basis = my_basis.rotated(Vector3.RIGHT, angle) # Rotate around the right axis (pitch).
my_basis = my_basis.rotated(Vector3.BACK, angle)  # Rotate around the back axis (roll).
[/gdscript]
[csharp]
var myBasis = Basis.Identity;
var angle = Mathf.Tau / 2.0f;

myBasis = myBasis.Rotated(Vector3.Up, angle);    // Rotate around the up axis (yaw).
myBasis = myBasis.Rotated(Vector3.Right, angle); // Rotate around the right axis (pitch).
myBasis = myBasis.Rotated(Vector3.Back, angle);  // Rotate around the back axis (roll).
[/csharp]
[/codeblocks] *)
    let rotated =
      foreign_builtin_method2 GlobalEnum.VariantType._TYPE_BASIS "rotated"
        (Base.Int64.of_string "1998708965")
        (Vector3.typ @-> Float.typ @-> Basis.typ @-> returning Basis.typ)
        Basis.s

    (** Returns this basis with each axis's components scaled by the given [param scale]'s components.
The basis matrix's rows are multiplied by [param scale]'s components. This operation is a global scale (relative to the parent).
[codeblocks]
[gdscript]
var my_basis = Basis(
    Vector3(1, 1, 1),
    Vector3(2, 2, 2),
    Vector3(3, 3, 3)
)
my_basis = my_basis.scaled(Vector3(0, 2, -2))

print(my_basis.x) # Prints (0, 2, -2).
print(my_basis.y) # Prints (0, 4, -4).
print(my_basis.z) # Prints (0, 6, -6).
[/gdscript]
[csharp]
var myBasis = new Basis(
    new Vector3(1.0f, 1.0f, 1.0f),
    new Vector3(2.0f, 2.0f, 2.0f),
    new Vector3(3.0f, 3.0f, 3.0f)
);
myBasis = myBasis.Scaled(new Vector3(0.0f, 2.0f, -2.0f));

GD.Print(myBasis.X); // Prints (0, 2, -2).
GD.Print(myBasis.Y); // Prints (0, 4, -4).
GD.Print(myBasis.Z); // Prints (0, 6, -6).
[/csharp]
[/codeblocks] *)
    let scaled =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_BASIS "scaled"
        (Base.Int64.of_string "3934786792")
        (Vector3.typ @-> Basis.typ @-> returning Basis.typ)
        Basis.s

    (** Returns the length of each axis of this basis, as a [Vector3]. If the basis is not sheared, this is the scaling factor. It is not affected by rotation.
[codeblocks]
[gdscript]
var my_basis = Basis(
    Vector3(2, 0, 0),
    Vector3(0, 4, 0),
    Vector3(0, 0, 8)
)
# Rotating the Basis in any way preserves its scale.
my_basis = my_basis.rotated(Vector3.UP, TAU / 2)
my_basis = my_basis.rotated(Vector3.RIGHT, TAU / 4)

print(my_basis.get_scale()) # Prints (2, 4, 8).
[/gdscript]
[csharp]
var myBasis = new Basis(
    Vector3(2.0f, 0.0f, 0.0f),
    Vector3(0.0f, 4.0f, 0.0f),
    Vector3(0.0f, 0.0f, 8.0f)
);
// Rotating the Basis in any way preserves its scale.
myBasis = myBasis.Rotated(Vector3.Up, Mathf.Tau / 2.0f);
myBasis = myBasis.Rotated(Vector3.Right, Mathf.Tau / 4.0f);

GD.Print(myBasis.Scale); // Prints (2, 4, 8).
[/csharp]
[/codeblocks]
[b]Note:[/b] If the value returned by [method determinant] is negative, the scale is also negative. *)
    let get_scale =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_BASIS "get_scale"
        (Base.Int64.of_string "1776574132")
        (Basis.typ @-> returning Vector3.typ)
        Vector3.s

    (** Returns this basis's rotation as a [Vector3] of [url=https://en.wikipedia.org/wiki/Euler_angles]Euler angles[/url], in radians.
- The [member Vector3.x] contains the angle around the [member x] axis (pitch);
- The [member Vector3.y] contains the angle around the [member y] axis (yaw);
- The [member Vector3.z] contains the angle around the [member z] axis (roll).
The order of each consecutive rotation can be changed with [param order] (see [enum EulerOrder] constants). By default, the YXZ convention is used ([constant EULER_ORDER_YXZ]): Z (roll) is calculated first, then X (pitch), and lastly Y (yaw). When using the opposite method [method from_euler], this order is reversed.
[b]Note:[/b] Euler angles are much more intuitive but are not suitable for 3D math. Because of this, consider using the [method get_rotation_quaternion] method instead, which returns a [Quaternion].
[b]Note:[/b] In the Inspector dock, a basis's rotation is often displayed in Euler angles (in degrees), as is the case with the [member Node3D.rotation] property. *)
    let get_euler =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_BASIS "get_euler"
        (Base.Int64.of_string "1394941017")
        (Int.typ @-> Basis.typ @-> returning Vector3.typ)
        Vector3.s

    (** Returns the transposed dot product between [param with] and the [member x] axis (see [method transposed]).
This is equivalent to [code]basis.x.dot(vector)[/code]. *)
    let tdotx =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_BASIS "tdotx"
        (Base.Int64.of_string "1047977935")
        (Vector3.typ @-> Basis.typ @-> returning Float.typ)
        Float.s

    (** Returns the transposed dot product between [param with] and the [member y] axis (see [method transposed]).
This is equivalent to [code]basis.y.dot(vector)[/code]. *)
    let tdoty =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_BASIS "tdoty"
        (Base.Int64.of_string "1047977935")
        (Vector3.typ @-> Basis.typ @-> returning Float.typ)
        Float.s

    (** Returns the transposed dot product between [param with] and the [member z] axis (see [method transposed]).
This is equivalent to [code]basis.z.dot(vector)[/code]. *)
    let tdotz =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_BASIS "tdotz"
        (Base.Int64.of_string "1047977935")
        (Vector3.typ @-> Basis.typ @-> returning Float.typ)
        Float.s

    (** Performs a spherical-linear interpolation with the [param to] basis, given a [param weight]. Both this basis and [param to] should represent a rotation.
[b]Example:[/b] Smoothly rotate a [Node3D] to the target basis over time, with a [Tween].
[codeblock]
var start_basis = Basis.IDENTITY
var target_basis = Basis.IDENTITY.rotated(Vector3.UP, TAU / 2)

func _ready():
    create_tween().tween_method(interpolate, 0.0, 1.0, 5.0).set_trans(Tween.TRANS_EXPO)

func interpolate(weight):
    basis = start_basis.slerp(target_basis, weight)
[/codeblock] *)
    let slerp =
      foreign_builtin_method2 GlobalEnum.VariantType._TYPE_BASIS "slerp"
        (Base.Int64.of_string "3118673011")
        (Basis.typ @-> Float.typ @-> Basis.typ @-> returning Basis.typ)
        Basis.s

    (** Returns [code]true[/code] if this basis is conformal. A conformal basis is both [i]orthogonal[/i] (the axes are perpendicular to each other) and [i]uniform[/i] (the axes share the same length). This method can be especially useful during physics calculations. *)
    let is_conformal =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_BASIS "is_conformal"
        (Base.Int64.of_string "3918633141")
        (Basis.typ @-> returning Bool.typ)
        Bool.s

    (** Returns [code]true[/code] if this basis and [param b] are approximately equal, by calling [method @GlobalScope.is_equal_approx] on all vector components. *)
    let is_equal_approx =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_BASIS
        "is_equal_approx"
        (Base.Int64.of_string "3165333982")
        (Basis.typ @-> Basis.typ @-> returning Bool.typ)
        Bool.s

    (** Returns [code]true[/code] if this basis is finite, by calling [method @GlobalScope.is_finite] on all vector components. *)
    let is_finite =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_BASIS "is_finite"
        (Base.Int64.of_string "3918633141")
        (Basis.typ @-> returning Bool.typ)
        Bool.s

    (** Returns this basis's rotation as a [Quaternion].
[b]Note:[/b] Quatenions are much more suitable for 3D math but are less intuitive. For user interfaces, consider using the [method get_euler] method, which returns Euler angles. *)
    let get_rotation_quaternion =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_BASIS
        "get_rotation_quaternion"
        (Base.Int64.of_string "4274879941")
        (Basis.typ @-> returning Quaternion.typ)
        Quaternion.s

    (** Creates a new [Basis] with a rotation such that the forward axis (-Z) points towards the [param target] position.
By default, the -Z axis (camera forward) is treated as forward (implies +X is right). If [param use_model_front] is [code]true[/code], the +Z axis (asset front) is treated as forward (implies +X is left) and points toward the [param target] position.
The up axis (+Y) points as close to the [param up] vector as possible while staying perpendicular to the forward axis. The returned basis is orthonormalized (see [method orthonormalized]). The [param target] and [param up] vectors cannot be [constant Vector3.ZERO], and cannot be parallel to each other. *)
    let looking_at =
      foreign_builtin_method3_static GlobalEnum.VariantType._TYPE_BASIS
        "looking_at"
        (Base.Int64.of_string "3728732505")
        (Vector3.typ @-> Vector3.typ @-> Bool.typ @-> returning Basis.typ)
        Basis.s

    (** Constructs a new [Basis] that only represents scale, with no rotation or shear, from the given [param scale] vector.
[codeblocks]
[gdscript]
var my_basis = Basis.from_scale(Vector3(2, 4, 8))

print(my_basis.x) # Prints (2, 0, 0).
print(my_basis.y) # Prints (0, 4, 0).
print(my_basis.z) # Prints (0, 0, 8).
[/gdscript]
[csharp]
var myBasis = Basis.FromScale(new Vector3(2.0f, 4.0f, 8.0f));

GD.Print(myBasis.X); // Prints (2, 0, 0).
GD.Print(myBasis.Y); // Prints (0, 4, 0).
GD.Print(myBasis.Z); // Prints (0, 0, 8).
[/csharp]
[/codeblocks]
[b]Note:[/b] In linear algebra, the matrix of this basis is also known as a [url=https://en.wikipedia.org/wiki/Diagonal_matrix]diagonal matrix[/url]. *)
    let from_scale =
      foreign_builtin_method1_static GlobalEnum.VariantType._TYPE_BASIS
        "from_scale"
        (Base.Int64.of_string "3703240166")
        (Vector3.typ @-> returning Basis.typ)
        Basis.s

    (** Constructs a new [Basis] that only represents rotation from the given [Vector3] of [url=https://en.wikipedia.org/wiki/Euler_angles]Euler angles[/url], in radians.
- The [member Vector3.x] should contain the angle around the [member x] axis (pitch).
- The [member Vector3.y] should contain the angle around the [member y] axis (yaw).
- The [member Vector3.z] should contain the angle around the [member z] axis (roll).
[codeblocks]
[gdscript]
# Creates a Basis whose z axis points down.
var my_basis = Basis.from_euler(Vector3(TAU / 4, 0, 0))

print(my_basis.z) # Prints (0, -1, 0).
[/gdscript]
[csharp]
// Creates a Basis whose z axis points down.
var myBasis = Basis.FromEuler(new Vector3(Mathf.Tau / 4.0f, 0.0f, 0.0f));

GD.Print(myBasis.Z); // Prints (0, -1, 0).
[/csharp]
[/codeblocks]
The order of each consecutive rotation can be changed with [param order] (see [enum EulerOrder] constants). By default, the YXZ convention is used ([constant EULER_ORDER_YXZ]): the basis rotates first around the Y axis (yaw), then X (pitch), and lastly Z (roll). When using the opposite method [method get_euler], this order is reversed. *)
    let from_euler =
      foreign_builtin_method2_static GlobalEnum.VariantType._TYPE_BASIS
        "from_euler"
        (Base.Int64.of_string "2802321791")
        (Vector3.typ @-> Int.typ @-> returning Basis.typ)
        Basis.s

    let not =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_BASIS None
        GlobalEnum.VariantOperator._OP_NOT
        (funptr (Basis.typ @-> Basis.typ @-> Bool.typ @-> returning void))

    (** Returns [code]true[/code] if the components of both [Basis] matrices are exactly equal.
[b]Note:[/b] Due to floating-point precision errors, consider using [method is_equal_approx] instead, which is more reliable. *)
    let ( = ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_BASIS
        (Some GlobalEnum.VariantType._TYPE_BASIS)
        GlobalEnum.VariantOperator._OP_EQUAL
        (funptr (Basis.typ @-> Basis.typ @-> Bool.typ @-> returning void))

    (** Returns [code]true[/code] if the components of both [Basis] matrices are not equal.
[b]Note:[/b] Due to floating-point precision errors, consider using [method is_equal_approx] instead, which is more reliable. *)
    let ( <> ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_BASIS
        (Some GlobalEnum.VariantType._TYPE_BASIS)
        GlobalEnum.VariantOperator._OP_NOT_EQUAL
        (funptr (Basis.typ @-> Basis.typ @-> Bool.typ @-> returning void))

    (** Transforms (multiplies) the [param right] basis by this basis.
This is the operation performed between parent and child [Node3D]s. *)
    let ( * ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_BASIS
        (Some GlobalEnum.VariantType._TYPE_BASIS)
        GlobalEnum.VariantOperator._OP_MULTIPLY
        (funptr (Basis.typ @-> Basis.typ @-> Basis.typ @-> returning void))

    let _Basis_elem_Dictionary =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_BASIS
        (Some GlobalEnum.VariantType._TYPE_DICTIONARY)
        GlobalEnum.VariantOperator._OP_IN
        (funptr (Basis.typ @-> Dictionary.typ @-> Bool.typ @-> returning void))

    let _Basis_elem_Array =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_BASIS
        (Some GlobalEnum.VariantType._TYPE_ARRAY)
        GlobalEnum.VariantOperator._OP_IN
        (funptr (Basis.typ @-> Array.typ @-> Bool.typ @-> returning void))
  end

  module Transform3D = struct
    include M.Transform3D

    (** Returns the inverted version of this transform. See also [method Basis.inverse].
[b]Note:[/b] For this method to return correctly, the transform's [member basis] needs to be [i]orthonormal[/i] (see [method Basis.orthonormalized]). That means, the basis should only represent a rotation. If it does not, use [method affine_inverse] instead. *)
    let inverse =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_TRANSFORM3D "inverse"
        (Base.Int64.of_string "3816817146")
        (Transform3D.typ @-> returning Transform3D.typ)
        Transform3D.s

    (** Returns the inverted version of this transform. Unlike [method inverse], this method works with almost any [member basis], including non-uniform ones, but is slower. See also [method Basis.inverse].
[b]Note:[/b] For this method to return correctly, the transform's [member basis] needs to have a determinant that is not exactly [code]0[/code] (see [method Basis.determinant]). *)
    let affine_inverse =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_TRANSFORM3D
        "affine_inverse"
        (Base.Int64.of_string "3816817146")
        (Transform3D.typ @-> returning Transform3D.typ)
        Transform3D.s

    (** Returns a copy of this transform with its [member basis] orthonormalized. An orthonormal basis is both [i]orthogonal[/i] (the axes are perpendicular to each other) and [i]normalized[/i] (the axes have a length of [code]1[/code]), which also means it can only represent rotation. See also [method Basis.orthonormalized]. *)
    let orthonormalized =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_TRANSFORM3D
        "orthonormalized"
        (Base.Int64.of_string "3816817146")
        (Transform3D.typ @-> returning Transform3D.typ)
        Transform3D.s

    (** Returns a copy of this transform rotated around the given [param axis] by the given [param angle] (in radians).
The [param axis] must be a normalized vector.
This method is an optimized version of multiplying the given transform [code]X[/code] with a corresponding rotation transform [code]R[/code] from the left, i.e., [code]R  *  X[/code].
This can be seen as transforming with respect to the global/parent frame. *)
    let rotated =
      foreign_builtin_method2 GlobalEnum.VariantType._TYPE_TRANSFORM3D "rotated"
        (Base.Int64.of_string "1563203923")
        (Vector3.typ @-> Float.typ @-> Transform3D.typ
       @-> returning Transform3D.typ)
        Transform3D.s

    (** Returns a copy of this transform rotated around the given [param axis] by the given [param angle] (in radians).
The [param axis] must be a normalized vector.
This method is an optimized version of multiplying the given transform [code]X[/code] with a corresponding rotation transform [code]R[/code] from the right, i.e., [code]X  *  R[/code].
This can be seen as transforming with respect to the local frame. *)
    let rotated_local =
      foreign_builtin_method2 GlobalEnum.VariantType._TYPE_TRANSFORM3D
        "rotated_local"
        (Base.Int64.of_string "1563203923")
        (Vector3.typ @-> Float.typ @-> Transform3D.typ
       @-> returning Transform3D.typ)
        Transform3D.s

    (** Returns a copy of this transform scaled by the given [param scale] factor.
This method is an optimized version of multiplying the given transform [code]X[/code] with a corresponding scaling transform [code]S[/code] from the left, i.e., [code]S  *  X[/code].
This can be seen as transforming with respect to the global/parent frame. *)
    let scaled =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_TRANSFORM3D "scaled"
        (Base.Int64.of_string "1405596198")
        (Vector3.typ @-> Transform3D.typ @-> returning Transform3D.typ)
        Transform3D.s

    (** Returns a copy of this transform scaled by the given [param scale] factor.
This method is an optimized version of multiplying the given transform [code]X[/code] with a corresponding scaling transform [code]S[/code] from the right, i.e., [code]X  *  S[/code].
This can be seen as transforming with respect to the local frame. *)
    let scaled_local =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_TRANSFORM3D
        "scaled_local"
        (Base.Int64.of_string "1405596198")
        (Vector3.typ @-> Transform3D.typ @-> returning Transform3D.typ)
        Transform3D.s

    (** Returns a copy of this transform translated by the given [param offset].
This method is an optimized version of multiplying the given transform [code]X[/code] with a corresponding translation transform [code]T[/code] from the left, i.e., [code]T  *  X[/code].
This can be seen as transforming with respect to the global/parent frame. *)
    let translated =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_TRANSFORM3D
        "translated"
        (Base.Int64.of_string "1405596198")
        (Vector3.typ @-> Transform3D.typ @-> returning Transform3D.typ)
        Transform3D.s

    (** Returns a copy of this transform translated by the given [param offset].
This method is an optimized version of multiplying the given transform [code]X[/code] with a corresponding translation transform [code]T[/code] from the right, i.e., [code]X  *  T[/code].
This can be seen as transforming with respect to the local frame. *)
    let translated_local =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_TRANSFORM3D
        "translated_local"
        (Base.Int64.of_string "1405596198")
        (Vector3.typ @-> Transform3D.typ @-> returning Transform3D.typ)
        Transform3D.s

    (** Returns a copy of this transform rotated so that the forward axis (-Z) points towards the [param target] position.
The up axis (+Y) points as close to the [param up] vector as possible while staying perpendicular to the forward axis. The resulting transform is orthonormalized. The existing rotation, scale, and skew information from the original transform is discarded. The [param target] and [param up] vectors cannot be zero, cannot be parallel to each other, and are defined in global/parent space.
If [param use_model_front] is [code]true[/code], the +Z axis (asset front) is treated as forward (implies +X is left) and points toward the [param target] position. By default, the -Z axis (camera forward) is treated as forward (implies +X is right). *)
    let looking_at =
      foreign_builtin_method3 GlobalEnum.VariantType._TYPE_TRANSFORM3D
        "looking_at"
        (Base.Int64.of_string "90889270")
        (Vector3.typ @-> Vector3.typ @-> Bool.typ @-> Transform3D.typ
       @-> returning Transform3D.typ)
        Transform3D.s

    (** Returns the result of the linear interpolation between this transform and [param xform] by the given [param weight].
The [param weight] should be between [code]0.0[/code] and [code]1.0[/code] (inclusive). Values outside this range are allowed and can be used to perform [i]extrapolation[/i] instead. *)
    let interpolate_with =
      foreign_builtin_method2 GlobalEnum.VariantType._TYPE_TRANSFORM3D
        "interpolate_with"
        (Base.Int64.of_string "1786453358")
        (Transform3D.typ @-> Float.typ @-> Transform3D.typ
       @-> returning Transform3D.typ)
        Transform3D.s

    (** Returns [code]true[/code] if this transform and [param xform] are approximately equal, by running [method @GlobalScope.is_equal_approx] on each component. *)
    let is_equal_approx =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_TRANSFORM3D
        "is_equal_approx"
        (Base.Int64.of_string "696001652")
        (Transform3D.typ @-> Transform3D.typ @-> returning Bool.typ)
        Bool.s

    (** Returns [code]true[/code] if this transform is finite, by calling [method @GlobalScope.is_finite] on each component. *)
    let is_finite =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_TRANSFORM3D
        "is_finite"
        (Base.Int64.of_string "3918633141")
        (Transform3D.typ @-> returning Bool.typ)
        Bool.s

    let not =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_TRANSFORM3D None
        GlobalEnum.VariantOperator._OP_NOT
        (funptr
           (Transform3D.typ @-> Transform3D.typ @-> Bool.typ @-> returning void))

    (** Returns [code]true[/code] if the components of both transforms are exactly equal.
[b]Note:[/b] Due to floating-point precision errors, consider using [method is_equal_approx] instead, which is more reliable. *)
    let ( = ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_TRANSFORM3D
        (Some GlobalEnum.VariantType._TYPE_TRANSFORM3D)
        GlobalEnum.VariantOperator._OP_EQUAL
        (funptr
           (Transform3D.typ @-> Transform3D.typ @-> Bool.typ @-> returning void))

    (** Returns [code]true[/code] if the components of both transforms are not equal.
[b]Note:[/b] Due to floating-point precision errors, consider using [method is_equal_approx] instead, which is more reliable. *)
    let ( <> ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_TRANSFORM3D
        (Some GlobalEnum.VariantType._TYPE_TRANSFORM3D)
        GlobalEnum.VariantOperator._OP_NOT_EQUAL
        (funptr
           (Transform3D.typ @-> Transform3D.typ @-> Bool.typ @-> returning void))

    (** Transforms (multiplies) this transform by the [param right] transform.
This is the operation performed between parent and child [Node3D]s.
[b]Note:[/b] If you need to only modify one attribute of this transform, consider using one of the following methods, instead:
- For translation, see [method translated] or [method translated_local].
- For rotation, see [method rotated] or [method rotated_local].
- For scale, see [method scaled] or [method scaled_local]. *)
    let ( * ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_TRANSFORM3D
        (Some GlobalEnum.VariantType._TYPE_TRANSFORM3D)
        GlobalEnum.VariantOperator._OP_MULTIPLY
        (funptr
           (Transform3D.typ @-> Transform3D.typ @-> Transform3D.typ
          @-> returning void))

    let _Transform3D_elem_Dictionary =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_TRANSFORM3D
        (Some GlobalEnum.VariantType._TYPE_DICTIONARY)
        GlobalEnum.VariantOperator._OP_IN
        (funptr
           (Transform3D.typ @-> Dictionary.typ @-> Bool.typ @-> returning void))

    let _Transform3D_elem_Array =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_TRANSFORM3D
        (Some GlobalEnum.VariantType._TYPE_ARRAY)
        GlobalEnum.VariantOperator._OP_IN
        (funptr (Transform3D.typ @-> Array.typ @-> Bool.typ @-> returning void))
  end

  module Projection = struct
    include M.Projection

    (** Creates a new [Projection] that projects positions from a depth range of [code]-1[/code] to [code]1[/code] to one that ranges from [code]0[/code] to [code]1[/code], and flips the projected positions vertically, according to [param flip_y]. *)
    let create_depth_correction =
      foreign_builtin_method1_static GlobalEnum.VariantType._TYPE_PROJECTION
        "create_depth_correction"
        (Base.Int64.of_string "1228516048")
        (Bool.typ @-> returning Projection.typ)
        Projection.s

    (** Creates a new [Projection] that projects positions into the given [Rect2]. *)
    let create_light_atlas_rect =
      foreign_builtin_method1_static GlobalEnum.VariantType._TYPE_PROJECTION
        "create_light_atlas_rect"
        (Base.Int64.of_string "2654950662")
        (Rect2.typ @-> returning Projection.typ)
        Projection.s

    (** Creates a new [Projection] that projects positions using a perspective projection with the given Y-axis field of view (in degrees), X:Y aspect ratio, and clipping planes.
[param flip_fov] determines whether the projection's field of view is flipped over its diagonal. *)
    let create_perspective =
      foreign_builtin_method5_static GlobalEnum.VariantType._TYPE_PROJECTION
        "create_perspective"
        (Base.Int64.of_string "390915442")
        (Float.typ @-> Float.typ @-> Float.typ @-> Float.typ @-> Bool.typ
       @-> returning Projection.typ)
        Projection.s

    (** Creates a new [Projection] that projects positions using a perspective projection with the given Y-axis field of view (in degrees), X:Y aspect ratio, and clipping distances. The projection is adjusted for a head-mounted display with the given distance between eyes and distance to a point that can be focused on.
[param eye] creates the projection for the left eye when set to 1, or the right eye when set to 2.
[param flip_fov] determines whether the projection's field of view is flipped over its diagonal. *)
    let create_perspective_hmd =
      foreign_builtin_method8_static GlobalEnum.VariantType._TYPE_PROJECTION
        "create_perspective_hmd"
        (Base.Int64.of_string "2857674800")
        (Float.typ @-> Float.typ @-> Float.typ @-> Float.typ @-> Bool.typ
       @-> Int.typ @-> Float.typ @-> Float.typ @-> returning Projection.typ)
        Projection.s

    (** Creates a new [Projection] for projecting positions onto a head-mounted display with the given X:Y aspect ratio, distance between eyes, display width, distance to lens, oversampling factor, and depth clipping planes.
[param eye] creates the projection for the left eye when set to 1, or the right eye when set to 2. *)
    let create_for_hmd =
      foreign_builtin_method8_static GlobalEnum.VariantType._TYPE_PROJECTION
        "create_for_hmd"
        (Base.Int64.of_string "4184144994")
        (Int.typ @-> Float.typ @-> Float.typ @-> Float.typ @-> Float.typ
       @-> Float.typ @-> Float.typ @-> Float.typ @-> returning Projection.typ)
        Projection.s

    (** Creates a new [Projection] that projects positions using an orthogonal projection with the given clipping planes. *)
    let create_orthogonal =
      foreign_builtin_method6_static GlobalEnum.VariantType._TYPE_PROJECTION
        "create_orthogonal"
        (Base.Int64.of_string "3707929169")
        (Float.typ @-> Float.typ @-> Float.typ @-> Float.typ @-> Float.typ
       @-> Float.typ @-> returning Projection.typ)
        Projection.s

    (** Creates a new [Projection] that projects positions using an orthogonal projection with the given size, X:Y aspect ratio, and clipping planes.
[param flip_fov] determines whether the projection's field of view is flipped over its diagonal. *)
    let create_orthogonal_aspect =
      foreign_builtin_method5_static GlobalEnum.VariantType._TYPE_PROJECTION
        "create_orthogonal_aspect"
        (Base.Int64.of_string "390915442")
        (Float.typ @-> Float.typ @-> Float.typ @-> Float.typ @-> Bool.typ
       @-> returning Projection.typ)
        Projection.s

    (** Creates a new [Projection] that projects positions in a frustum with the given clipping planes. *)
    let create_frustum =
      foreign_builtin_method6_static GlobalEnum.VariantType._TYPE_PROJECTION
        "create_frustum"
        (Base.Int64.of_string "3707929169")
        (Float.typ @-> Float.typ @-> Float.typ @-> Float.typ @-> Float.typ
       @-> Float.typ @-> returning Projection.typ)
        Projection.s

    (** Creates a new [Projection] that projects positions in a frustum with the given size, X:Y aspect ratio, offset, and clipping planes.
[param flip_fov] determines whether the projection's field of view is flipped over its diagonal. *)
    let create_frustum_aspect =
      foreign_builtin_method6_static GlobalEnum.VariantType._TYPE_PROJECTION
        "create_frustum_aspect"
        (Base.Int64.of_string "1535076251")
        (Float.typ @-> Float.typ @-> Vector2.typ @-> Float.typ @-> Float.typ
       @-> Bool.typ @-> returning Projection.typ)
        Projection.s

    (** Creates a new [Projection] that scales a given projection to fit around a given [AABB] in projection space. *)
    let create_fit_aabb =
      foreign_builtin_method1_static GlobalEnum.VariantType._TYPE_PROJECTION
        "create_fit_aabb"
        (Base.Int64.of_string "2264694907")
        (AABB.typ @-> returning Projection.typ)
        Projection.s

    (** Returns a scalar value that is the signed factor by which areas are scaled by this matrix. If the sign is negative, the matrix flips the orientation of the area.
The determinant can be used to calculate the invertibility of a matrix or solve linear systems of equations involving the matrix, among other applications. *)
    let determinant =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_PROJECTION
        "determinant"
        (Base.Int64.of_string "466405837")
        (Projection.typ @-> returning Float.typ)
        Float.s

    (** Returns a [Projection] with the near clipping distance adjusted to be [param new_znear].
[b]Note:[/b] The original [Projection] must be a perspective projection. *)
    let perspective_znear_adjusted =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_PROJECTION
        "perspective_znear_adjusted"
        (Base.Int64.of_string "3584785443")
        (Float.typ @-> Projection.typ @-> returning Projection.typ)
        Projection.s

    (** Returns the clipping plane of this [Projection] whose index is given by [param plane].
[param plane] should be equal to one of [constant PLANE_NEAR], [constant PLANE_FAR], [constant PLANE_LEFT], [constant PLANE_TOP], [constant PLANE_RIGHT], or [constant PLANE_BOTTOM]. *)
    let get_projection_plane =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_PROJECTION
        "get_projection_plane"
        (Base.Int64.of_string "1551184160")
        (Int.typ @-> Projection.typ @-> returning Plane.typ)
        Plane.s

    (** Returns a copy of this [Projection] with the signs of the values of the Y column flipped. *)
    let flipped_y =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_PROJECTION
        "flipped_y"
        (Base.Int64.of_string "4212530932")
        (Projection.typ @-> returning Projection.typ)
        Projection.s

    (** Returns a [Projection] with the X and Y values from the given [Vector2] added to the first and second values of the final column respectively. *)
    let jitter_offseted =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_PROJECTION
        "jitter_offseted"
        (Base.Int64.of_string "2448438599")
        (Vector2.typ @-> Projection.typ @-> returning Projection.typ)
        Projection.s

    (** Returns the vertical field of view of the projection (in degrees) associated with the given horizontal field of view (in degrees) and aspect ratio. *)
    let get_fovy =
      foreign_builtin_method2_static GlobalEnum.VariantType._TYPE_PROJECTION
        "get_fovy"
        (Base.Int64.of_string "3514207532")
        (Float.typ @-> Float.typ @-> returning Float.typ)
        Float.s

    (** Returns the distance for this [Projection] beyond which positions are clipped. *)
    let get_z_far =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_PROJECTION
        "get_z_far"
        (Base.Int64.of_string "466405837")
        (Projection.typ @-> returning Float.typ)
        Float.s

    (** Returns the distance for this [Projection] before which positions are clipped. *)
    let get_z_near =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_PROJECTION
        "get_z_near"
        (Base.Int64.of_string "466405837")
        (Projection.typ @-> returning Float.typ)
        Float.s

    (** Returns the X:Y aspect ratio of this [Projection]'s viewport. *)
    let get_aspect =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_PROJECTION
        "get_aspect"
        (Base.Int64.of_string "466405837")
        (Projection.typ @-> returning Float.typ)
        Float.s

    (** Returns the horizontal field of view of the projection (in degrees). *)
    let get_fov =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_PROJECTION "get_fov"
        (Base.Int64.of_string "466405837")
        (Projection.typ @-> returning Float.typ)
        Float.s

    (** Returns [code]true[/code] if this [Projection] performs an orthogonal projection. *)
    let is_orthogonal =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_PROJECTION
        "is_orthogonal"
        (Base.Int64.of_string "3918633141")
        (Projection.typ @-> returning Bool.typ)
        Bool.s

    (** Returns the dimensions of the viewport plane that this [Projection] projects positions onto, divided by two. *)
    let get_viewport_half_extents =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_PROJECTION
        "get_viewport_half_extents"
        (Base.Int64.of_string "2428350749")
        (Projection.typ @-> returning Vector2.typ)
        Vector2.s

    (** Returns the dimensions of the far clipping plane of the projection, divided by two. *)
    let get_far_plane_half_extents =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_PROJECTION
        "get_far_plane_half_extents"
        (Base.Int64.of_string "2428350749")
        (Projection.typ @-> returning Vector2.typ)
        Vector2.s

    (** Returns a [Projection] that performs the inverse of this [Projection]'s projective transformation. *)
    let inverse =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_PROJECTION "inverse"
        (Base.Int64.of_string "4212530932")
        (Projection.typ @-> returning Projection.typ)
        Projection.s

    (** Returns the number of pixels with the given pixel width displayed per meter, after this [Projection] is applied. *)
    let get_pixels_per_meter =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_PROJECTION
        "get_pixels_per_meter"
        (Base.Int64.of_string "4103005248")
        (Int.typ @-> Projection.typ @-> returning Int.typ)
        Int.s

    (** Returns the factor by which the visible level of detail is scaled by this [Projection]. *)
    let get_lod_multiplier =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_PROJECTION
        "get_lod_multiplier"
        (Base.Int64.of_string "466405837")
        (Projection.typ @-> returning Float.typ)
        Float.s

    let not =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_PROJECTION None
        GlobalEnum.VariantOperator._OP_NOT
        (funptr
           (Projection.typ @-> Projection.typ @-> Bool.typ @-> returning void))

    (** Returns [code]true[/code] if the projections are equal.
[b]Note:[/b] Due to floating-point precision errors, this may return [code]false[/code], even if the projections are virtually equal. An [code]is_equal_approx[/code] method may be added in a future version of Godot. *)
    let ( = ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_PROJECTION
        (Some GlobalEnum.VariantType._TYPE_PROJECTION)
        GlobalEnum.VariantOperator._OP_EQUAL
        (funptr
           (Projection.typ @-> Projection.typ @-> Bool.typ @-> returning void))

    (** Returns [code]true[/code] if the projections are not equal.
[b]Note:[/b] Due to floating-point precision errors, this may return [code]true[/code], even if the projections are virtually equal. An [code]is_equal_approx[/code] method may be added in a future version of Godot. *)
    let ( <> ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_PROJECTION
        (Some GlobalEnum.VariantType._TYPE_PROJECTION)
        GlobalEnum.VariantOperator._OP_NOT_EQUAL
        (funptr
           (Projection.typ @-> Projection.typ @-> Bool.typ @-> returning void))

    (** Returns a [Projection] that applies the combined transformations of this [Projection] and [param right]. *)
    let ( * ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_PROJECTION
        (Some GlobalEnum.VariantType._TYPE_PROJECTION)
        GlobalEnum.VariantOperator._OP_MULTIPLY
        (funptr
           (Projection.typ @-> Projection.typ @-> Projection.typ
          @-> returning void))

    let _Projection_elem_Dictionary =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_PROJECTION
        (Some GlobalEnum.VariantType._TYPE_DICTIONARY)
        GlobalEnum.VariantOperator._OP_IN
        (funptr
           (Projection.typ @-> Dictionary.typ @-> Bool.typ @-> returning void))

    let _Projection_elem_Array =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_PROJECTION
        (Some GlobalEnum.VariantType._TYPE_ARRAY)
        GlobalEnum.VariantOperator._OP_IN
        (funptr (Projection.typ @-> Array.typ @-> Bool.typ @-> returning void))

    module Planes = struct
      type t = Int.t

      let typ = Int.typ

      (** The index value of the projection's near clipping plane. *)
      let _PLANE_NEAR = 0

      (** The index value of the projection's far clipping plane. *)
      let _PLANE_FAR = 1

      (** The index value of the projection's left clipping plane. *)
      let _PLANE_LEFT = 2

      (** The index value of the projection's top clipping plane. *)
      let _PLANE_TOP = 3

      (** The index value of the projection's right clipping plane. *)
      let _PLANE_RIGHT = 4

      (** The index value of the projection bottom clipping plane. *)
      let _PLANE_BOTTOM = 5
    end
  end

  module Color = struct
    include M.Color

    (** Returns the color converted to a 32-bit integer in ARGB format (each component is 8 bits). ARGB is more compatible with DirectX.
[codeblocks]
[gdscript]
var color = Color(1, 0.5, 0.2)
print(color.to_argb32()) # Prints 4294934323
[/gdscript]
[csharp]
var color = new Color(1.0f, 0.5f, 0.2f);
GD.Print(color.ToArgb32()); // Prints 4294934323
[/csharp]
[/codeblocks] *)
    let to_argb32 =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_COLOR "to_argb32"
        (Base.Int64.of_string "3173160232")
        (Color.typ @-> returning Int.typ)
        Int.s

    (** Returns the color converted to a 32-bit integer in ABGR format (each component is 8 bits). ABGR is the reversed version of the default RGBA format.
[codeblocks]
[gdscript]
var color = Color(1, 0.5, 0.2)
print(color.to_abgr32()) # Prints 4281565439
[/gdscript]
[csharp]
var color = new Color(1.0f, 0.5f, 0.2f);
GD.Print(color.ToAbgr32()); // Prints 4281565439
[/csharp]
[/codeblocks] *)
    let to_abgr32 =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_COLOR "to_abgr32"
        (Base.Int64.of_string "3173160232")
        (Color.typ @-> returning Int.typ)
        Int.s

    (** Returns the color converted to a 32-bit integer in RGBA format (each component is 8 bits). RGBA is Godot's default format.
[codeblocks]
[gdscript]
var color = Color(1, 0.5, 0.2)
print(color.to_rgba32()) # Prints 4286526463
[/gdscript]
[csharp]
var color = new Color(1, 0.5f, 0.2f);
GD.Print(color.ToRgba32()); // Prints 4286526463
[/csharp]
[/codeblocks] *)
    let to_rgba32 =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_COLOR "to_rgba32"
        (Base.Int64.of_string "3173160232")
        (Color.typ @-> returning Int.typ)
        Int.s

    (** Returns the color converted to a 64-bit integer in ARGB format (each component is 16 bits). ARGB is more compatible with DirectX.
[codeblocks]
[gdscript]
var color = Color(1, 0.5, 0.2)
print(color.to_argb64()) # Prints -2147470541
[/gdscript]
[csharp]
var color = new Color(1.0f, 0.5f, 0.2f);
GD.Print(color.ToArgb64()); // Prints -2147470541
[/csharp]
[/codeblocks] *)
    let to_argb64 =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_COLOR "to_argb64"
        (Base.Int64.of_string "3173160232")
        (Color.typ @-> returning Int.typ)
        Int.s

    (** Returns the color converted to a 64-bit integer in ABGR format (each component is 16 bits). ABGR is the reversed version of the default RGBA format.
[codeblocks]
[gdscript]
var color = Color(1, 0.5, 0.2)
print(color.to_abgr64()) # Prints -225178692812801
[/gdscript]
[csharp]
var color = new Color(1.0f, 0.5f, 0.2f);
GD.Print(color.ToAbgr64()); // Prints -225178692812801
[/csharp]
[/codeblocks] *)
    let to_abgr64 =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_COLOR "to_abgr64"
        (Base.Int64.of_string "3173160232")
        (Color.typ @-> returning Int.typ)
        Int.s

    (** Returns the color converted to a 64-bit integer in RGBA format (each component is 16 bits). RGBA is Godot's default format.
[codeblocks]
[gdscript]
var color = Color(1, 0.5, 0.2)
print(color.to_rgba64()) # Prints -140736629309441
[/gdscript]
[csharp]
var color = new Color(1, 0.5f, 0.2f);
GD.Print(color.ToRgba64()); // Prints -140736629309441
[/csharp]
[/codeblocks] *)
    let to_rgba64 =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_COLOR "to_rgba64"
        (Base.Int64.of_string "3173160232")
        (Color.typ @-> returning Int.typ)
        Int.s

    (** Returns the color converted to an HTML hexadecimal color [String] in RGBA format, without the hash ([code]#[/code]) prefix.
Setting [param with_alpha] to [code]false[/code], excludes alpha from the hexadecimal string, using RGB format instead of RGBA format.
[codeblocks]
[gdscript]
var white = Color(1, 1, 1, 0.5)
var with_alpha = white.to_html() # Returns ""ffffff7f""
var without_alpha = white.to_html(false) # Returns ""ffffff""
[/gdscript]
[csharp]
var white = new Color(1, 1, 1, 0.5f);
string withAlpha = white.ToHtml(); // Returns ""ffffff7f""
string withoutAlpha = white.ToHtml(false); // Returns ""ffffff""
[/csharp]
[/codeblocks] *)
    let to_html =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_COLOR "to_html"
        (Base.Int64.of_string "3429816538")
        (Bool.typ @-> Color.typ @-> returning String.typ)
        String.s

    (** Returns a new color with all components clamped between the components of [param min] and [param max], by running [method @GlobalScope.clamp] on each component. *)
    let clamp =
      foreign_builtin_method2 GlobalEnum.VariantType._TYPE_COLOR "clamp"
        (Base.Int64.of_string "105651410")
        (Color.typ @-> Color.typ @-> Color.typ @-> returning Color.typ)
        Color.s

    (** Returns the color with its [member r], [member g], and [member b] components inverted ([code](1 - r, 1 - g, 1 - b, a)[/code]).
[codeblocks]
[gdscript]
var black = Color.WHITE.inverted()
var color = Color(0.3, 0.4, 0.9)
var inverted_color = color.inverted() # Equivalent to `Color(0.7, 0.6, 0.1)`
[/gdscript]
[csharp]
var black = Colors.White.Inverted();
var color = new Color(0.3f, 0.4f, 0.9f);
Color invertedColor = color.Inverted(); // Equivalent to `new Color(0.7f, 0.6f, 0.1f)`
[/csharp]
[/codeblocks] *)
    let inverted =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_COLOR "inverted"
        (Base.Int64.of_string "3334027602")
        (Color.typ @-> returning Color.typ)
        Color.s

    (** Returns the linear interpolation between this color's components and [param to]'s components. The interpolation factor [param weight] should be between 0.0 and 1.0 (inclusive). See also [method @GlobalScope.lerp].
[codeblocks]
[gdscript]
var red = Color(1.0, 0.0, 0.0)
var aqua = Color(0.0, 1.0, 0.8)

red.lerp(aqua, 0.2) # Returns Color(0.8, 0.2, 0.16)
red.lerp(aqua, 0.5) # Returns Color(0.5, 0.5, 0.4)
red.lerp(aqua, 1.0) # Returns Color(0.0, 1.0, 0.8)
[/gdscript]
[csharp]
var red = new Color(1.0f, 0.0f, 0.0f);
var aqua = new Color(0.0f, 1.0f, 0.8f);

red.Lerp(aqua, 0.2f); // Returns Color(0.8f, 0.2f, 0.16f)
red.Lerp(aqua, 0.5f); // Returns Color(0.5f, 0.5f, 0.4f)
red.Lerp(aqua, 1.0f); // Returns Color(0.0f, 1.0f, 0.8f)
[/csharp]
[/codeblocks] *)
    let lerp =
      foreign_builtin_method2 GlobalEnum.VariantType._TYPE_COLOR "lerp"
        (Base.Int64.of_string "402949615")
        (Color.typ @-> Float.typ @-> Color.typ @-> returning Color.typ)
        Color.s

    (** Returns a new color resulting from making this color lighter by the specified [param amount], which should be a ratio from 0.0 to 1.0. See also [method darkened].
[codeblocks]
[gdscript]
var green = Color(0.0, 1.0, 0.0)
var light_green = green.lightened(0.2) # 20% lighter than regular green
[/gdscript]
[csharp]
var green = new Color(0.0f, 1.0f, 0.0f);
Color lightGreen = green.Lightened(0.2f); // 20% lighter than regular green
[/csharp]
[/codeblocks] *)
    let lightened =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_COLOR "lightened"
        (Base.Int64.of_string "1466039168")
        (Float.typ @-> Color.typ @-> returning Color.typ)
        Color.s

    (** Returns a new color resulting from making this color darker by the specified [param amount] (ratio from 0.0 to 1.0). See also [method lightened].
[codeblocks]
[gdscript]
var green = Color(0.0, 1.0, 0.0)
var darkgreen = green.darkened(0.2) # 20% darker than regular green
[/gdscript]
[csharp]
var green = new Color(0.0f, 1.0f, 0.0f);
Color darkgreen = green.Darkened(0.2f); // 20% darker than regular green
[/csharp]
[/codeblocks] *)
    let darkened =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_COLOR "darkened"
        (Base.Int64.of_string "1466039168")
        (Float.typ @-> Color.typ @-> returning Color.typ)
        Color.s

    (** Returns a new color resulting from overlaying this color over the given color. In a painting program, you can imagine it as the [param over] color painted over this color (including alpha).
[codeblocks]
[gdscript]
var bg = Color(0.0, 1.0, 0.0, 0.5) # Green with alpha of 50%
var fg = Color(1.0, 0.0, 0.0, 0.5) # Red with alpha of 50%
var blended_color = bg.blend(fg) # Brown with alpha of 75%
[/gdscript]
[csharp]
var bg = new Color(0.0f, 1.0f, 0.0f, 0.5f); // Green with alpha of 50%
var fg = new Color(1.0f, 0.0f, 0.0f, 0.5f); // Red with alpha of 50%
Color blendedColor = bg.Blend(fg); // Brown with alpha of 75%
[/csharp]
[/codeblocks] *)
    let blend =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_COLOR "blend"
        (Base.Int64.of_string "3803690977")
        (Color.typ @-> Color.typ @-> returning Color.typ)
        Color.s

    (** Returns the light intensity of the color, as a value between 0.0 and 1.0 (inclusive). This is useful when determining light or dark color. Colors with a luminance smaller than 0.5 can be generally considered dark.
[b]Note:[/b] [method get_luminance] relies on the color being in the linear color space to return an accurate relative luminance value. If the color is in the sRGB color space, use [method srgb_to_linear] to convert it to the linear color space first. *)
    let get_luminance =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_COLOR "get_luminance"
        (Base.Int64.of_string "466405837")
        (Color.typ @-> returning Float.typ)
        Float.s

    (** Returns the color converted to the linear color space. This method assumes the original color already is in the sRGB color space. See also [method linear_to_srgb] which performs the opposite operation. *)
    let srgb_to_linear =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_COLOR
        "srgb_to_linear"
        (Base.Int64.of_string "3334027602")
        (Color.typ @-> returning Color.typ)
        Color.s

    (** Returns the color converted to the [url=https://en.wikipedia.org/wiki/SRGB]sRGB[/url] color space. This method assumes the original color is in the linear color space. See also [method srgb_to_linear] which performs the opposite operation. *)
    let linear_to_srgb =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_COLOR
        "linear_to_srgb"
        (Base.Int64.of_string "3334027602")
        (Color.typ @-> returning Color.typ)
        Color.s

    (** Returns [code]true[/code] if this color and [param to] are approximately equal, by running [method @GlobalScope.is_equal_approx] on each component. *)
    let is_equal_approx =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_COLOR
        "is_equal_approx"
        (Base.Int64.of_string "3167426256")
        (Color.typ @-> Color.typ @-> returning Bool.typ)
        Bool.s

    (** Returns the [Color] associated with the provided [param hex] integer in 32-bit RGBA format (8 bits per channel).
In GDScript and C#, the [int] is best visualized with hexadecimal notation ([code]""0x""[/code] prefix, making it [code]""0xRRGGBBAA""[/code]).
[codeblocks]
[gdscript]
var red = Color.hex(0xff0000ff)
var dark_cyan = Color.hex(0x008b8bff)
var my_color = Color.hex(0xbbefd2a4)
[/gdscript]
[csharp]
var red = new Color(0xff0000ff);
var dark_cyan = new Color(0x008b8bff);
var my_color = new Color(0xbbefd2a4);
[/csharp]
[/codeblocks] *)
    let hex =
      foreign_builtin_method1_static GlobalEnum.VariantType._TYPE_COLOR "hex"
        (Base.Int64.of_string "351421375")
        (Int.typ @-> returning Color.typ)
        Color.s

    (** Returns the [Color] associated with the provided [param hex] integer in 64-bit RGBA format (16 bits per channel).
In GDScript and C#, the [int] is best visualized with hexadecimal notation ([code]""0x""[/code] prefix, making it [code]""0xRRRRGGGGBBBBAAAA""[/code]). *)
    let hex64 =
      foreign_builtin_method1_static GlobalEnum.VariantType._TYPE_COLOR "hex64"
        (Base.Int64.of_string "351421375")
        (Int.typ @-> returning Color.typ)
        Color.s

    (** Returns a new color from [param rgba], an HTML hexadecimal color string. [param rgba] is not case-sensitive, and may be prefixed by a hash sign ([code]#[/code]).
[param rgba] must be a valid three-digit or six-digit hexadecimal color string, and may contain an alpha channel value. If [param rgba] does not contain an alpha channel value, an alpha channel value of 1.0 is applied. If [param rgba] is invalid, returns an empty color.
[codeblocks]
[gdscript]
var blue = Color.html(""#0000ff"") # blue is Color(0.0, 0.0, 1.0, 1.0)
var green = Color.html(""#0F0"")   # green is Color(0.0, 1.0, 0.0, 1.0)
var col = Color.html(""663399cc"") # col is Color(0.4, 0.2, 0.6, 0.8)
[/gdscript]
[csharp]
var blue = Color.FromHtml(""#0000ff""); // blue is Color(0.0, 0.0, 1.0, 1.0)
var green = Color.FromHtml(""#0F0"");   // green is Color(0.0, 1.0, 0.0, 1.0)
var col = Color.FromHtml(""663399cc""); // col is Color(0.4, 0.2, 0.6, 0.8)
[/csharp]
[/codeblocks] *)
    let html =
      foreign_builtin_method1_static GlobalEnum.VariantType._TYPE_COLOR "html"
        (Base.Int64.of_string "2500054655")
        (String.typ @-> returning Color.typ)
        Color.s

    (** Returns [code]true[/code] if [param color] is a valid HTML hexadecimal color string. The string must be a hexadecimal value (case-insensitive) of either 3, 4, 6 or 8 digits, and may be prefixed by a hash sign ([code]#[/code]). This method is identical to [method String.is_valid_html_color].
[codeblocks]
[gdscript]
Color.html_is_valid(""#55aaFF"")   # Returns true
Color.html_is_valid(""#55AAFF20"") # Returns true
Color.html_is_valid(""55AAFF"")    # Returns true
Color.html_is_valid(""#F2C"")      # Returns true

Color.html_is_valid(""#AABBC"")    # Returns false
Color.html_is_valid(""#55aaFF5"")  # Returns false
[/gdscript]
[csharp]
Color.HtmlIsValid(""#55AAFF"");   // Returns true
Color.HtmlIsValid(""#55AAFF20""); // Returns true
Color.HtmlIsValid(""55AAFF"");    // Returns true
Color.HtmlIsValid(""#F2C"");      // Returns true

Color.HtmlIsValid(""#AABBC"");    // Returns false
Color.HtmlIsValid(""#55aaFF5"");  // Returns false
[/csharp]
[/codeblocks] *)
    let html_is_valid =
      foreign_builtin_method1_static GlobalEnum.VariantType._TYPE_COLOR
        "html_is_valid"
        (Base.Int64.of_string "2942997125")
        (String.typ @-> returning Bool.typ)
        Bool.s

    (** Creates a [Color] from the given string, which can be either an HTML color code or a named color (case-insensitive). Returns [param default] if the color cannot be inferred from the string. *)
    let from_string =
      foreign_builtin_method2_static GlobalEnum.VariantType._TYPE_COLOR
        "from_string"
        (Base.Int64.of_string "3755044230")
        (String.typ @-> Color.typ @-> returning Color.typ)
        Color.s

    (** Constructs a color from an [url=https://en.wikipedia.org/wiki/HSL_and_HSV]HSV profile[/url]. The hue ([param h]), saturation ([param s]), and value ([param v]) are typically between 0.0 and 1.0.
[codeblocks]
[gdscript]
var color = Color.from_hsv(0.58, 0.5, 0.79, 0.8)
[/gdscript]
[csharp]
var color = Color.FromHsv(0.58f, 0.5f, 0.79f, 0.8f);
[/csharp]
[/codeblocks] *)
    let from_hsv =
      foreign_builtin_method4_static GlobalEnum.VariantType._TYPE_COLOR
        "from_hsv"
        (Base.Int64.of_string "1573799446")
        (Float.typ @-> Float.typ @-> Float.typ @-> Float.typ
       @-> returning Color.typ)
        Color.s

    (** Constructs a color from an [url=https://bottosson.github.io/posts/colorpicker/]OK HSL profile[/url]. The hue ([param h]), saturation ([param s]), and lightness ([param l]) are typically between 0.0 and 1.0.
[codeblocks]
[gdscript]
var color = Color.from_ok_hsl(0.58, 0.5, 0.79, 0.8)
[/gdscript]
[csharp]
var color = Color.FromOkHsl(0.58f, 0.5f, 0.79f, 0.8f);
[/csharp]
[/codeblocks] *)
    let from_ok_hsl =
      foreign_builtin_method4_static GlobalEnum.VariantType._TYPE_COLOR
        "from_ok_hsl"
        (Base.Int64.of_string "1573799446")
        (Float.typ @-> Float.typ @-> Float.typ @-> Float.typ
       @-> returning Color.typ)
        Color.s

    (** Decodes a [Color] from a RGBE9995 format integer. See [constant Image.FORMAT_RGBE9995]. *)
    let from_rgbe9995 =
      foreign_builtin_method1_static GlobalEnum.VariantType._TYPE_COLOR
        "from_rgbe9995"
        (Base.Int64.of_string "351421375")
        (Int.typ @-> returning Color.typ)
        Color.s

    (** Inverts the given color. This is equivalent to [code]Color.WHITE - c[/code] or [code]Color(1 - c.r, 1 - c.g, 1 - c.b, 1 - c.a)[/code]. Unlike with [method inverted], the [member a] component is inverted, too. *)
    let ( ~- ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_COLOR None
        GlobalEnum.VariantOperator._OP_NEGATE
        (funptr (Color.typ @-> Color.typ @-> Color.typ @-> returning void))

    (** Returns the same value as if the [code]+[/code] was not there. Unary [code]+[/code] does nothing, but sometimes it can make your code more readable. *)
    let ( ~+ ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_COLOR None
        GlobalEnum.VariantOperator._OP_POSITIVE
        (funptr (Color.typ @-> Color.typ @-> Color.typ @-> returning void))

    let not =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_COLOR None
        GlobalEnum.VariantOperator._OP_NOT
        (funptr (Color.typ @-> Color.typ @-> Bool.typ @-> returning void))

    (** Returns [code]true[/code] if the colors are exactly equal.
[b]Note:[/b] Due to floating-point precision errors, consider using [method is_equal_approx] instead, which is more reliable. *)
    let ( = ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_COLOR
        (Some GlobalEnum.VariantType._TYPE_COLOR)
        GlobalEnum.VariantOperator._OP_EQUAL
        (funptr (Color.typ @-> Color.typ @-> Bool.typ @-> returning void))

    (** Returns [code]true[/code] if the colors are not exactly equal.
[b]Note:[/b] Due to floating-point precision errors, consider using [method is_equal_approx] instead, which is more reliable. *)
    let ( <> ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_COLOR
        (Some GlobalEnum.VariantType._TYPE_COLOR)
        GlobalEnum.VariantOperator._OP_NOT_EQUAL
        (funptr (Color.typ @-> Color.typ @-> Bool.typ @-> returning void))

    (** Adds each component of the [Color] with the components of the given [Color]. *)
    let ( + ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_COLOR
        (Some GlobalEnum.VariantType._TYPE_COLOR)
        GlobalEnum.VariantOperator._OP_ADD
        (funptr (Color.typ @-> Color.typ @-> Color.typ @-> returning void))

    (** Subtracts each component of the [Color] by the components of the given [Color]. *)
    let ( - ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_COLOR
        (Some GlobalEnum.VariantType._TYPE_COLOR)
        GlobalEnum.VariantOperator._OP_SUBTRACT
        (funptr (Color.typ @-> Color.typ @-> Color.typ @-> returning void))

    (** Multiplies each component of the [Color] by the components of the given [Color]. *)
    let ( * ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_COLOR
        (Some GlobalEnum.VariantType._TYPE_COLOR)
        GlobalEnum.VariantOperator._OP_MULTIPLY
        (funptr (Color.typ @-> Color.typ @-> Color.typ @-> returning void))

    (** Divides each component of the [Color] by the components of the given [Color]. *)
    let ( / ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_COLOR
        (Some GlobalEnum.VariantType._TYPE_COLOR)
        GlobalEnum.VariantOperator._OP_DIVIDE
        (funptr (Color.typ @-> Color.typ @-> Color.typ @-> returning void))

    let _Color_elem_Dictionary =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_COLOR
        (Some GlobalEnum.VariantType._TYPE_DICTIONARY)
        GlobalEnum.VariantOperator._OP_IN
        (funptr (Color.typ @-> Dictionary.typ @-> Bool.typ @-> returning void))

    let _Color_elem_Array =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_COLOR
        (Some GlobalEnum.VariantType._TYPE_ARRAY)
        GlobalEnum.VariantOperator._OP_IN
        (funptr (Color.typ @-> Array.typ @-> Bool.typ @-> returning void))

    let _Color_elem_PackedColorArray =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_COLOR
        (Some GlobalEnum.VariantType._TYPE_PACKED_COLOR_ARRAY)
        GlobalEnum.VariantOperator._OP_IN
        (funptr
           (Color.typ @-> PackedColorArray.typ @-> Bool.typ @-> returning void))
  end

  module StringName = struct
    include M.StringName

    (** Performs a case-sensitive comparison to another string. Returns [code]-1[/code] if less than, [code]1[/code] if greater than, or [code]0[/code] if equal. ""Less than"" and ""greater than"" are determined by the [url=https://en.wikipedia.org/wiki/List_of_Unicode_characters]Unicode code points[/url] of each string, which roughly matches the alphabetical order.
With different string lengths, returns [code]1[/code] if this string is longer than the [param to] string, or [code]-1[/code] if shorter. Note that the length of empty strings is [i]always[/i] [code]0[/code].
To get a [bool] result from a string comparison, use the [code]==[/code] operator instead. See also [method nocasecmp_to], [method naturalcasecmp_to], and [method naturalnocasecmp_to]. *)
    let casecmp_to =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_STRING_NAME
        "casecmp_to"
        (Base.Int64.of_string "2920860731")
        (String.typ @-> StringName.typ @-> returning Int.typ)
        Int.s

    (** Performs a [b]case-insensitive[/b] comparison to another string. Returns [code]-1[/code] if less than, [code]1[/code] if greater than, or [code]0[/code] if equal. ""Less than"" or ""greater than"" are determined by the [url=https://en.wikipedia.org/wiki/List_of_Unicode_characters]Unicode code points[/url] of each string, which roughly matches the alphabetical order. Internally, lowercase characters are converted to uppercase for the comparison.
With different string lengths, returns [code]1[/code] if this string is longer than the [param to] string, or [code]-1[/code] if shorter. Note that the length of empty strings is [i]always[/i] [code]0[/code].
To get a [bool] result from a string comparison, use the [code]==[/code] operator instead. See also [method casecmp_to], [method naturalcasecmp_to], and [method naturalnocasecmp_to]. *)
    let nocasecmp_to =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_STRING_NAME
        "nocasecmp_to"
        (Base.Int64.of_string "2920860731")
        (String.typ @-> StringName.typ @-> returning Int.typ)
        Int.s

    (** Performs a [b]case-sensitive[/b], [i]natural order[/i] comparison to another string. Returns [code]-1[/code] if less than, [code]1[/code] if greater than, or [code]0[/code] if equal. ""Less than"" or ""greater than"" are determined by the [url=https://en.wikipedia.org/wiki/List_of_Unicode_characters]Unicode code points[/url] of each string, which roughly matches the alphabetical order.
When used for sorting, natural order comparison orders sequences of numbers by the combined value of each digit as is often expected, instead of the single digit's value. A sorted sequence of numbered strings will be [code][""1"", ""2"", ""3"", ...][/code], not [code][""1"", ""10"", ""2"", ""3"", ...][/code].
With different string lengths, returns [code]1[/code] if this string is longer than the [param to] string, or [code]-1[/code] if shorter. Note that the length of empty strings is [i]always[/i] [code]0[/code].
To get a [bool] result from a string comparison, use the [code]==[/code] operator instead. See also [method naturalnocasecmp_to], [method nocasecmp_to], and [method casecmp_to]. *)
    let naturalcasecmp_to =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_STRING_NAME
        "naturalcasecmp_to"
        (Base.Int64.of_string "2920860731")
        (String.typ @-> StringName.typ @-> returning Int.typ)
        Int.s

    (** Performs a [b]case-insensitive[/b], [i]natural order[/i] comparison to another string. Returns [code]-1[/code] if less than, [code]1[/code] if greater than, or [code]0[/code] if equal. ""Less than"" or ""greater than"" are determined by the [url=https://en.wikipedia.org/wiki/List_of_Unicode_characters]Unicode code points[/url] of each string, which roughly matches the alphabetical order. Internally, lowercase characters are converted to uppercase for the comparison.
When used for sorting, natural order comparison orders sequences of numbers by the combined value of each digit as is often expected, instead of the single digit's value. A sorted sequence of numbered strings will be [code][""1"", ""2"", ""3"", ...][/code], not [code][""1"", ""10"", ""2"", ""3"", ...][/code].
With different string lengths, returns [code]1[/code] if this string is longer than the [param to] string, or [code]-1[/code] if shorter. Note that the length of empty strings is [i]always[/i] [code]0[/code].
To get a [bool] result from a string comparison, use the [code]==[/code] operator instead. See also [method naturalcasecmp_to], [method nocasecmp_to], and [method casecmp_to]. *)
    let naturalnocasecmp_to =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_STRING_NAME
        "naturalnocasecmp_to"
        (Base.Int64.of_string "2920860731")
        (String.typ @-> StringName.typ @-> returning Int.typ)
        Int.s

    (** Returns the number of characters in the string. Empty strings ([code]""""[/code]) always return [code]0[/code]. See also [method is_empty]. *)
    let length =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_STRING_NAME "length"
        (Base.Int64.of_string "3173160232")
        (StringName.typ @-> returning Int.typ)
        Int.s

    (** Returns part of the string from the position [param from] with length [param len]. If [param len] is [code]-1[/code] (as by default), returns the rest of the string starting from the given position. *)
    let substr =
      foreign_builtin_method2 GlobalEnum.VariantType._TYPE_STRING_NAME "substr"
        (Base.Int64.of_string "787537301")
        (Int.typ @-> Int.typ @-> StringName.typ @-> returning String.typ)
        String.s

    (** Splits the string using a [param delimiter] and returns the substring at index [param slice]. Returns an empty string if the [param slice] does not exist.
This is faster than [method split], if you only need one substring.
[b]Example:[/b]
[codeblock]
print(""i/am/example/hi"".get_slice(""/"", 2)) # Prints ""example""
[/codeblock] *)
    let get_slice =
      foreign_builtin_method2 GlobalEnum.VariantType._TYPE_STRING_NAME
        "get_slice"
        (Base.Int64.of_string "3535100402")
        (String.typ @-> Int.typ @-> StringName.typ @-> returning String.typ)
        String.s

    (** Splits the string using a Unicode character with code [param delimiter] and returns the substring at index [param slice]. Returns an empty string if the [param slice] does not exist.
This is faster than [method split], if you only need one substring. *)
    let get_slicec =
      foreign_builtin_method2 GlobalEnum.VariantType._TYPE_STRING_NAME
        "get_slicec"
        (Base.Int64.of_string "787537301")
        (Int.typ @-> Int.typ @-> StringName.typ @-> returning String.typ)
        String.s

    (** Returns the total number of slices when the string is split with the given [param delimiter] (see [method split]). *)
    let get_slice_count =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_STRING_NAME
        "get_slice_count"
        (Base.Int64.of_string "2920860731")
        (String.typ @-> StringName.typ @-> returning Int.typ)
        Int.s

    (** Returns the index of the [b]first[/b] occurrence of [param what] in this string, or [code]-1[/code] if there are none. The search's start can be specified with [param from], continuing to the end of the string.
[codeblocks]
[gdscript]
print(""Team"".find(""I"")) # Prints -1

print(""Potato"".find(""t""))    # Prints 2
print(""Potato"".find(""t"", 3)) # Prints 4
print(""Potato"".find(""t"", 5)) # Prints -1
[/gdscript]
[csharp]
GD.Print(""Team"".Find(""I"")); // Prints -1

GD.Print(""Potato"".Find(""t""));    // Prints 2
GD.Print(""Potato"".Find(""t"", 3)); // Prints 4
GD.Print(""Potato"".Find(""t"", 5)); // Prints -1
[/csharp]
[/codeblocks]
[b]Note:[/b] If you just want to know whether the string contains [param what], use [method contains]. In GDScript, you may also use the [code]in[/code] operator. *)
    let find =
      foreign_builtin_method2 GlobalEnum.VariantType._TYPE_STRING_NAME "find"
        (Base.Int64.of_string "1760645412")
        (String.typ @-> Int.typ @-> StringName.typ @-> returning Int.typ)
        Int.s

    (** Returns the number of occurrences of the substring [param what] between [param from] and [param to] positions. If [param to] is 0, the search continues until the end of the string. *)
    let count =
      foreign_builtin_method3 GlobalEnum.VariantType._TYPE_STRING_NAME "count"
        (Base.Int64.of_string "2343087891")
        (String.typ @-> Int.typ @-> Int.typ @-> StringName.typ
       @-> returning Int.typ)
        Int.s

    (** Returns the number of occurrences of the substring [param what] between [param from] and [param to] positions, [b]ignoring case[/b]. If [param to] is 0, the search continues until the end of the string. *)
    let countn =
      foreign_builtin_method3 GlobalEnum.VariantType._TYPE_STRING_NAME "countn"
        (Base.Int64.of_string "2343087891")
        (String.typ @-> Int.typ @-> Int.typ @-> StringName.typ
       @-> returning Int.typ)
        Int.s

    (** Returns the index of the [b]first[/b] [b]case-insensitive[/b] occurrence of [param what] in this string, or [code]-1[/code] if there are none. The starting search index can be specified with [param from], continuing to the end of the string. *)
    let findn =
      foreign_builtin_method2 GlobalEnum.VariantType._TYPE_STRING_NAME "findn"
        (Base.Int64.of_string "1760645412")
        (String.typ @-> Int.typ @-> StringName.typ @-> returning Int.typ)
        Int.s

    (** Returns the index of the [b]last[/b] occurrence of [param what] in this string, or [code]-1[/code] if there are none. The search's start can be specified with [param from], continuing to the beginning of the string. This method is the reverse of [method find]. *)
    let rfind =
      foreign_builtin_method2 GlobalEnum.VariantType._TYPE_STRING_NAME "rfind"
        (Base.Int64.of_string "1760645412")
        (String.typ @-> Int.typ @-> StringName.typ @-> returning Int.typ)
        Int.s

    (** Returns the index of the [b]last[/b] [b]case-insensitive[/b] occurrence of [param what] in this string, or [code]-1[/code] if there are none. The starting search index can be specified with [param from], continuing to the beginning of the string. This method is the reverse of [method findn]. *)
    let rfindn =
      foreign_builtin_method2 GlobalEnum.VariantType._TYPE_STRING_NAME "rfindn"
        (Base.Int64.of_string "1760645412")
        (String.typ @-> Int.typ @-> StringName.typ @-> returning Int.typ)
        Int.s

    (** Does a simple expression match (also called ""glob"" or ""globbing""), where [code] * [/code] matches zero or more arbitrary characters and [code]?[/code] matches any single character except a period ([code].[/code]). An empty string or empty expression always evaluates to [code]false[/code]. *)
    let match_ =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_STRING_NAME "match_"
        (Base.Int64.of_string "2566493496")
        (String.typ @-> StringName.typ @-> returning Bool.typ)
        Bool.s

    (** Does a simple [b]case-insensitive[/b] expression match, where [code] * [/code] matches zero or more arbitrary characters and [code]?[/code] matches any single character except a period ([code].[/code]). An empty string or empty expression always evaluates to [code]false[/code]. *)
    let matchn =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_STRING_NAME "matchn"
        (Base.Int64.of_string "2566493496")
        (String.typ @-> StringName.typ @-> returning Bool.typ)
        Bool.s

    (** Returns [code]true[/code] if the string begins with the given [param text]. See also [method ends_with]. *)
    let begins_with =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_STRING_NAME
        "begins_with"
        (Base.Int64.of_string "2566493496")
        (String.typ @-> StringName.typ @-> returning Bool.typ)
        Bool.s

    (** Returns [code]true[/code] if the string ends with the given [param text]. See also [method begins_with]. *)
    let ends_with =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_STRING_NAME
        "ends_with"
        (Base.Int64.of_string "2566493496")
        (String.typ @-> StringName.typ @-> returning Bool.typ)
        Bool.s

    (** Returns [code]true[/code] if all characters of this string can be found in [param text] in their original order.
[codeblock]
var text = ""Wow, incredible!""

print(""inedible"".is_subsequence_of(text)) # Prints true
print(""Word!"".is_subsequence_of(text))    # Prints true
print(""Window"".is_subsequence_of(text))   # Prints false
print("""".is_subsequence_of(text))         # Prints true
[/codeblock] *)
    let is_subsequence_of =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_STRING_NAME
        "is_subsequence_of"
        (Base.Int64.of_string "2566493496")
        (String.typ @-> StringName.typ @-> returning Bool.typ)
        Bool.s

    (** Returns [code]true[/code] if all characters of this string can be found in [param text] in their original order, [b]ignoring case[/b]. *)
    let is_subsequence_ofn =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_STRING_NAME
        "is_subsequence_ofn"
        (Base.Int64.of_string "2566493496")
        (String.typ @-> StringName.typ @-> returning Bool.typ)
        Bool.s

    (** Returns an array containing the bigrams (pairs of consecutive characters) of this string.
[codeblock]
print(""Get up!"".bigrams()) # Prints [""Ge"", ""et"", ""t "", "" u"", ""up"", ""p!""]
[/codeblock] *)
    let bigrams =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_STRING_NAME "bigrams"
        (Base.Int64.of_string "747180633")
        (StringName.typ @-> returning PackedStringArray.typ)
        PackedStringArray.s

    (** Returns the similarity index ([url=https://en.wikipedia.org/wiki/S%C3%B8rensen%E2%80%93Dice_coefficient]Sorensen-Dice coefficient[/url]) of this string compared to another. A result of [code]1.0[/code] means totally similar, while [code]0.0[/code] means totally dissimilar.
[codeblock]
print(""ABC123"".similarity(""ABC123"")) # Prints 1.0
print(""ABC123"".similarity(""XYZ456"")) # Prints 0.0
print(""ABC123"".similarity(""123ABC"")) # Prints 0.8
print(""ABC123"".similarity(""abc123"")) # Prints 0.4
[/codeblock] *)
    let similarity =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_STRING_NAME
        "similarity"
        (Base.Int64.of_string "2697460964")
        (String.typ @-> StringName.typ @-> returning Float.typ)
        Float.s

    (** Formats the string by replacing all occurrences of [param placeholder] with the elements of [param values].
[param values] can be a [Dictionary] or an [Array]. Any underscores in [param placeholder] will be replaced with the corresponding keys in advance. Array elements use their index as keys.
[codeblock]
# Prints ""Waiting for Godot is a play by Samuel Beckett, and Godot Engine is named after it.""
var use_array_values = ""Waiting for {0} is a play by {1}, and {0} Engine is named after it.""
print(use_array_values.format([""Godot"", ""Samuel Beckett""]))

# Prints ""User 42 is Godot.""
print(""User {id} is {name}."".format({""id"": 42, ""name"": ""Godot""}))
[/codeblock]
Some additional handling is performed when [param values] is an [Array]. If [param placeholder] does not contain an underscore, the elements of the [param values] array will be used to replace one occurrence of the placeholder in order; If an element of [param values] is another 2-element array, it'll be interpreted as a key-value pair.
[codeblock]
# Prints ""User 42 is Godot.""
print(""User {} is {}."".format([42, ""Godot""], ""{}""))
print(""User {id} is {name}."".format([[""id"", 42], [""name"", ""Godot""]]))
[/codeblock]
See also the [url=$DOCS_URL/tutorials/scripting/gdscript/gdscript_format_string.html]GDScript format string[/url] tutorial.
[b]Note:[/b] In C#, it's recommended to [url=https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/tokens/interpolated]interpolate strings with ""$""[/url], instead. *)
    let format =
      foreign_builtin_method2 GlobalEnum.VariantType._TYPE_STRING_NAME "format"
        (Base.Int64.of_string "3212199029")
        (Variant.typ @-> String.typ @-> StringName.typ @-> returning String.typ)
        String.s

    (** Replaces all occurrences of [param what] inside the string with the given [param forwhat]. *)
    let replace =
      foreign_builtin_method2 GlobalEnum.VariantType._TYPE_STRING_NAME "replace"
        (Base.Int64.of_string "1340436205")
        (String.typ @-> String.typ @-> StringName.typ @-> returning String.typ)
        String.s

    (** Replaces all [b]case-insensitive[/b] occurrences of [param what] inside the string with the given [param forwhat]. *)
    let replacen =
      foreign_builtin_method2 GlobalEnum.VariantType._TYPE_STRING_NAME
        "replacen"
        (Base.Int64.of_string "1340436205")
        (String.typ @-> String.typ @-> StringName.typ @-> returning String.typ)
        String.s

    (** Repeats this string a number of times. [param count] needs to be greater than [code]0[/code]. Otherwise, returns an empty string. *)
    let repeat =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_STRING_NAME "repeat"
        (Base.Int64.of_string "2162347432")
        (Int.typ @-> StringName.typ @-> returning String.typ)
        String.s

    (** Returns the copy of this string in reverse order. *)
    let reverse =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_STRING_NAME "reverse"
        (Base.Int64.of_string "3942272618")
        (StringName.typ @-> returning String.typ)
        String.s

    (** Inserts [param what] at the given [param position] in the string. *)
    let insert =
      foreign_builtin_method2 GlobalEnum.VariantType._TYPE_STRING_NAME "insert"
        (Base.Int64.of_string "248737229")
        (Int.typ @-> String.typ @-> StringName.typ @-> returning String.typ)
        String.s

    (** Returns a string with [param chars] characters erased starting from [param position]. If [param chars] goes beyond the string's length given the specified [param position], fewer characters will be erased from the returned string. Returns an empty string if either [param position] or [param chars] is negative. Returns the original string unmodified if [param chars] is [code]0[/code]. *)
    let erase =
      foreign_builtin_method2 GlobalEnum.VariantType._TYPE_STRING_NAME "erase"
        (Base.Int64.of_string "787537301")
        (Int.typ @-> Int.typ @-> StringName.typ @-> returning String.typ)
        String.s

    (** Changes the appearance of the string: replaces underscores ([code]_[/code]) with spaces, adds spaces before uppercase letters in the middle of a word, converts all letters to lowercase, then converts the first one and each one following a space to uppercase.
[codeblocks]
[gdscript]
""move_local_x"".capitalize()   # Returns ""Move Local X""
""sceneFile_path"".capitalize() # Returns ""Scene File Path""
""2D, FPS, PNG"".capitalize()   # Returns ""2d, Fps, Png""
[/gdscript]
[csharp]
""move_local_x"".Capitalize();   // Returns ""Move Local X""
""sceneFile_path"".Capitalize(); // Returns ""Scene File Path""
""2D, FPS, PNG"".Capitalize();   // Returns ""2d, Fps, Png""
[/csharp]
[/codeblocks] *)
    let capitalize =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_STRING_NAME
        "capitalize"
        (Base.Int64.of_string "3942272618")
        (StringName.typ @-> returning String.typ)
        String.s

    (** Returns the string converted to [code]camelCase[/code]. *)
    let to_camel_case =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_STRING_NAME
        "to_camel_case"
        (Base.Int64.of_string "3942272618")
        (StringName.typ @-> returning String.typ)
        String.s

    (** Returns the string converted to [code]PascalCase[/code]. *)
    let to_pascal_case =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_STRING_NAME
        "to_pascal_case"
        (Base.Int64.of_string "3942272618")
        (StringName.typ @-> returning String.typ)
        String.s

    (** Returns the string converted to [code]snake_case[/code].
[b]Note:[/b] Numbers followed by a [i]single[/i] letter are not separated in the conversion to keep some words (such as ""2D"") together.
[codeblocks]
[gdscript]
""Node2D"".to_snake_case()               # Returns ""node_2d""
""2nd place"".to_snake_case()            # Returns ""2_nd_place""
""Texture3DAssetFolder"".to_snake_case() # Returns ""texture_3d_asset_folder""
[/gdscript]
[csharp]
""Node2D"".ToSnakeCase();               // Returns ""node_2d""
""2nd place"".ToSnakeCase();            // Returns ""2_nd_place""
""Texture3DAssetFolder"".ToSnakeCase(); // Returns ""texture_3d_asset_folder""
[/csharp]
[/codeblocks] *)
    let to_snake_case =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_STRING_NAME
        "to_snake_case"
        (Base.Int64.of_string "3942272618")
        (StringName.typ @-> returning String.typ)
        String.s

    (** Splits the string using a [param delimiter] and returns an array of the substrings. If [param delimiter] is an empty string, each substring will be a single character. This method is the opposite of [method join].
If [param allow_empty] is [code]false[/code], empty strings between adjacent delimiters are excluded from the array.
If [param maxsplit] is greater than [code]0[/code], the number of splits may not exceed [param maxsplit]. By default, the entire string is split.
[b]Example:[/b]
[codeblocks]
[gdscript]
var some_array = ""One,Two,Three,Four"".split("","", true, 2)

print(some_array.size()) # Prints 3
print(some_array[0])     # Prints ""One""
print(some_array[1])     # Prints ""Two""
print(some_array[2])     # Prints ""Three,Four""
[/gdscript]
[csharp]
// C#'s `Split()` does not support the `maxsplit` parameter.
var someArray = ""One,Two,Three"".Split("","");

GD.Print(someArray[0]); // Prints ""One""
GD.Print(someArray[1]); // Prints ""Two""
GD.Print(someArray[2]); // Prints ""Three""
[/csharp]
[/codeblocks]
[b]Note:[/b] If you only need one substring from the array, consider using [method get_slice] which is faster. If you need to split strings with more complex rules, use the [RegEx] class instead. *)
    let split =
      foreign_builtin_method3 GlobalEnum.VariantType._TYPE_STRING_NAME "split"
        (Base.Int64.of_string "1252735785")
        (String.typ @-> Bool.typ @-> Int.typ @-> StringName.typ
        @-> returning PackedStringArray.typ)
        PackedStringArray.s

    (** Splits the string using a [param delimiter] and returns an array of the substrings, starting from the end of the string. The splits in the returned array appear in the same order as the original string. If [param delimiter] is an empty string, each substring will be a single character.
If [param allow_empty] is [code]false[/code], empty strings between adjacent delimiters are excluded from the array.
If [param maxsplit] is greater than [code]0[/code], the number of splits may not exceed [param maxsplit]. By default, the entire string is split, which is mostly identical to [method split].
[b]Example:[/b]
[codeblocks]
[gdscript]
var some_string = ""One,Two,Three,Four""
var some_array = some_string.rsplit("","", true, 1)

print(some_array.size()) # Prints 2
print(some_array[0])     # Prints ""One,Two,Three""
print(some_array[1])     # Prints ""Four""
[/gdscript]
[csharp]
// In C#, there is no String.RSplit() method.
[/csharp]
[/codeblocks] *)
    let rsplit =
      foreign_builtin_method3 GlobalEnum.VariantType._TYPE_STRING_NAME "rsplit"
        (Base.Int64.of_string "1252735785")
        (String.typ @-> Bool.typ @-> Int.typ @-> StringName.typ
        @-> returning PackedStringArray.typ)
        PackedStringArray.s

    (** Splits the string into floats by using a [param delimiter] and returns a [PackedFloat64Array].
If [param allow_empty] is [code]false[/code], empty or invalid [float] conversions between adjacent delimiters are excluded.
[codeblock]
var a = ""1,2,4.5"".split_floats("","")         # a is [1.0, 2.0, 4.5]
var c = ""1| ||4.5"".split_floats(""|"")        # c is [1.0, 0.0, 0.0, 4.5]
var b = ""1| ||4.5"".split_floats(""|"", false) # b is [1.0, 4.5]
[/codeblock] *)
    let split_floats =
      foreign_builtin_method2 GlobalEnum.VariantType._TYPE_STRING_NAME
        "split_floats"
        (Base.Int64.of_string "2092079095")
        (String.typ @-> Bool.typ @-> StringName.typ
        @-> returning PackedFloat64Array.typ)
        PackedFloat64Array.s

    (** Returns the concatenation of [param parts]' elements, with each element separated by the string calling this method. This method is the opposite of [method split].
[b]Example:[/b]
[codeblocks]
[gdscript]
var fruits = [""Apple"", ""Orange"", ""Pear"", ""Kiwi""]

print("", "".join(fruits))  # Prints ""Apple, Orange, Pear, Kiwi""
print(""---"".join(fruits)) # Prints ""Apple---Orange---Pear---Kiwi""
[/gdscript]
[csharp]
var fruits = new string[] {""Apple"", ""Orange"", ""Pear"", ""Kiwi""};

// In C#, this method is static.
GD.Print(string.Join("", "", fruits));  // Prints ""Apple, Orange, Pear, Kiwi""
GD.Print(string.Join(""---"", fruits)); // Prints ""Apple---Orange---Pear---Kiwi""
[/csharp]
[/codeblocks] *)
    let join =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_STRING_NAME "join"
        (Base.Int64.of_string "3595973238")
        (PackedStringArray.typ @-> StringName.typ @-> returning String.typ)
        String.s

    (** Returns the string converted to [code]UPPERCASE[/code]. *)
    let to_upper =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_STRING_NAME
        "to_upper"
        (Base.Int64.of_string "3942272618")
        (StringName.typ @-> returning String.typ)
        String.s

    (** Returns the string converted to [code]lowercase[/code]. *)
    let to_lower =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_STRING_NAME
        "to_lower"
        (Base.Int64.of_string "3942272618")
        (StringName.typ @-> returning String.typ)
        String.s

    (** Returns the first [param length] characters from the beginning of the string. If [param length] is negative, strips the last [param length] characters from the string's end.
[codeblock]
print(""Hello World!"".left(3))  # Prints ""Hel""
print(""Hello World!"".left(-4)) # Prints ""Hello Wo""
[/codeblock] *)
    let left =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_STRING_NAME "left"
        (Base.Int64.of_string "2162347432")
        (Int.typ @-> StringName.typ @-> returning String.typ)
        String.s

    (** Returns the last [param length] characters from the end of the string. If [param length] is negative, strips the first [param length] characters from the string's beginning.
[codeblock]
print(""Hello World!"".right(3))  # Prints ""ld!""
print(""Hello World!"".right(-4)) # Prints ""o World!""
[/codeblock] *)
    let right =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_STRING_NAME "right"
        (Base.Int64.of_string "2162347432")
        (Int.typ @-> StringName.typ @-> returning String.typ)
        String.s

    (** Strips all non-printable characters from the beginning and the end of the string. These include spaces, tabulations ([code]\t[/code]), and newlines ([code]\n[/code] [code]\r[/code]).
If [param left] is [code]false[/code], ignores the string's beginning. Likewise, if [param right] is [code]false[/code], ignores the string's end. *)
    let strip_edges =
      foreign_builtin_method2 GlobalEnum.VariantType._TYPE_STRING_NAME
        "strip_edges"
        (Base.Int64.of_string "907855311")
        (Bool.typ @-> Bool.typ @-> StringName.typ @-> returning String.typ)
        String.s

    (** Strips all escape characters from the string. These include all non-printable control characters of the first page of the ASCII table (values from 0 to 31), such as tabulation ([code]\t[/code]) and newline ([code]\n[/code], [code]\r[/code]) characters, but [i]not[/i] spaces. *)
    let strip_escapes =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_STRING_NAME
        "strip_escapes"
        (Base.Int64.of_string "3942272618")
        (StringName.typ @-> returning String.typ)
        String.s

    (** Removes a set of characters defined in [param chars] from the string's beginning. See also [method rstrip].
[b]Note:[/b] [param chars] is not a prefix. Use [method trim_prefix] to remove a single prefix, rather than a set of characters. *)
    let lstrip =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_STRING_NAME "lstrip"
        (Base.Int64.of_string "3134094431")
        (String.typ @-> StringName.typ @-> returning String.typ)
        String.s

    (** Removes a set of characters defined in [param chars] from the string's end. See also [method lstrip].
[b]Note:[/b] [param chars] is not a suffix. Use [method trim_suffix] to remove a single suffix, rather than a set of characters. *)
    let rstrip =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_STRING_NAME "rstrip"
        (Base.Int64.of_string "3134094431")
        (String.typ @-> StringName.typ @-> returning String.typ)
        String.s

    (** If the string is a valid file name or path, returns the file extension without the leading period ([code].[/code]). Otherwise, returns an empty string.
[codeblock]
var a = ""/path/to/file.txt"".get_extension() # a is ""txt""
var b = ""cool.txt"".get_extension()          # b is ""txt""
var c = ""cool.font.tres"".get_extension()    # c is ""tres""
var d = "".pack1"".get_extension()            # d is ""pack1""

var e = ""file.txt."".get_extension()  # e is """"
var f = ""file.txt.."".get_extension() # f is """"
var g = ""txt"".get_extension()        # g is """"
var h = """".get_extension()           # h is """"
[/codeblock] *)
    let get_extension =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_STRING_NAME
        "get_extension"
        (Base.Int64.of_string "3942272618")
        (StringName.typ @-> returning String.typ)
        String.s

    (** If the string is a valid file path, returns the full file path, without the extension.
[codeblock]
var base = ""/path/to/file.txt"".get_basename() # base is ""/path/to/file""
[/codeblock] *)
    let get_basename =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_STRING_NAME
        "get_basename"
        (Base.Int64.of_string "3942272618")
        (StringName.typ @-> returning String.typ)
        String.s

    (** Concatenates [param file] at the end of the string as a subpath, adding [code]/[/code] if necessary.
[b]Example:[/b] [code]""this/is"".path_join(""path"") == ""this/is/path""[/code]. *)
    let path_join =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_STRING_NAME
        "path_join"
        (Base.Int64.of_string "3134094431")
        (String.typ @-> StringName.typ @-> returning String.typ)
        String.s

    (** Returns the character code at position [param at]. *)
    let unicode_at =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_STRING_NAME
        "unicode_at"
        (Base.Int64.of_string "4103005248")
        (Int.typ @-> StringName.typ @-> returning Int.typ)
        Int.s

    (** Indents every line of the string with the given [param prefix]. Empty lines are not indented. See also [method dedent] to remove indentation.
For example, the string can be indented with two tabulations using [code]""\t\t""[/code], or four spaces using [code]""    ""[/code]. *)
    let indent =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_STRING_NAME "indent"
        (Base.Int64.of_string "3134094431")
        (String.typ @-> StringName.typ @-> returning String.typ)
        String.s

    (** Returns a copy of the string with indentation (leading tabs and spaces) removed. See also [method indent] to add indentation. *)
    let dedent =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_STRING_NAME "dedent"
        (Base.Int64.of_string "3942272618")
        (StringName.typ @-> returning String.typ)
        String.s

    (** Returns the [url=https://en.wikipedia.org/wiki/MD5]MD5 hash[/url] of the string as another [String]. *)
    let md5_text =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_STRING_NAME
        "md5_text"
        (Base.Int64.of_string "3942272618")
        (StringName.typ @-> returning String.typ)
        String.s

    (** Returns the [url=https://en.wikipedia.org/wiki/SHA-1]SHA-1[/url] hash of the string as another [String]. *)
    let sha1_text =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_STRING_NAME
        "sha1_text"
        (Base.Int64.of_string "3942272618")
        (StringName.typ @-> returning String.typ)
        String.s

    (** Returns the [url=https://en.wikipedia.org/wiki/SHA-2]SHA-256[/url] hash of the string as another [String]. *)
    let sha256_text =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_STRING_NAME
        "sha256_text"
        (Base.Int64.of_string "3942272618")
        (StringName.typ @-> returning String.typ)
        String.s

    (** Returns the [url=https://en.wikipedia.org/wiki/MD5]MD5 hash[/url] of the string as a [PackedByteArray]. *)
    let md5_buffer =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_STRING_NAME
        "md5_buffer"
        (Base.Int64.of_string "247621236")
        (StringName.typ @-> returning PackedByteArray.typ)
        PackedByteArray.s

    (** Returns the [url=https://en.wikipedia.org/wiki/SHA-1]SHA-1[/url] hash of the string as a [PackedByteArray]. *)
    let sha1_buffer =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_STRING_NAME
        "sha1_buffer"
        (Base.Int64.of_string "247621236")
        (StringName.typ @-> returning PackedByteArray.typ)
        PackedByteArray.s

    (** Returns the [url=https://en.wikipedia.org/wiki/SHA-2]SHA-256[/url] hash of the string as a [PackedByteArray]. *)
    let sha256_buffer =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_STRING_NAME
        "sha256_buffer"
        (Base.Int64.of_string "247621236")
        (StringName.typ @-> returning PackedByteArray.typ)
        PackedByteArray.s

    (** Returns [code]true[/code] if the string's length is [code]0[/code] ([code]""""[/code]). See also [method length]. *)
    let is_empty =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_STRING_NAME
        "is_empty"
        (Base.Int64.of_string "3918633141")
        (StringName.typ @-> returning Bool.typ)
        Bool.s

    (** Returns [code]true[/code] if the string contains [param what]. In GDScript, this corresponds to the [code]in[/code] operator.
[codeblocks]
[gdscript]
print(""Node"".contains(""de"")) # Prints true
print(""team"".contains(""I""))  # Prints false
print(""I"" in ""team"")         # Prints false
[/gdscript]
[csharp]
GD.Print(""Node"".Contains(""de"")); // Prints true
GD.Print(""team"".Contains(""I""));  // Prints false
[/csharp]
[/codeblocks]
If you need to know where [param what] is within the string, use [method find]. *)
    let contains =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_STRING_NAME
        "contains"
        (Base.Int64.of_string "2566493496")
        (String.typ @-> StringName.typ @-> returning Bool.typ)
        Bool.s

    (** Returns [code]true[/code] if the string is a path to a file or directory, and its starting point is explicitly defined. This method is the opposite of [method is_relative_path].
This includes all paths starting with [code]""res://""[/code], [code]""user://""[/code], [code]""C:\""[/code], [code]""/""[/code], etc. *)
    let is_absolute_path =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_STRING_NAME
        "is_absolute_path"
        (Base.Int64.of_string "3918633141")
        (StringName.typ @-> returning Bool.typ)
        Bool.s

    (** Returns [code]true[/code] if the string is a path, and its starting point is dependent on context. The path could begin from the current directory, or the current [Node] (if the string is derived from a [NodePath]), and may sometimes be prefixed with [code]""./""[/code]. This method is the opposite of [method is_absolute_path]. *)
    let is_relative_path =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_STRING_NAME
        "is_relative_path"
        (Base.Int64.of_string "3918633141")
        (StringName.typ @-> returning Bool.typ)
        Bool.s

    (** If the string is a valid file path, converts the string into a canonical path. This is the shortest possible path, without [code]""./""[/code], and all the unnecessary [code]""..""[/code] and [code]""/""[/code].
[codeblock]
var simple_path = ""./path/to///../file"".simplify_path()
print(simple_path) # Prints ""path/file""
[/codeblock] *)
    let simplify_path =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_STRING_NAME
        "simplify_path"
        (Base.Int64.of_string "3942272618")
        (StringName.typ @-> returning String.typ)
        String.s

    (** If the string is a valid file path, returns the base directory name.
[codeblock]
var dir_path = ""/path/to/file.txt"".get_base_dir() # dir_path is ""/path/to""
[/codeblock] *)
    let get_base_dir =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_STRING_NAME
        "get_base_dir"
        (Base.Int64.of_string "3942272618")
        (StringName.typ @-> returning String.typ)
        String.s

    (** If the string is a valid file path, returns the file name, including the extension.
[codeblock]
var file = ""/path/to/icon.png"".get_file() # file is ""icon.png""
[/codeblock] *)
    let get_file =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_STRING_NAME
        "get_file"
        (Base.Int64.of_string "3942272618")
        (StringName.typ @-> returning String.typ)
        String.s

    (** Returns a copy of the string with special characters escaped using the XML standard. If [param escape_quotes] is [code]true[/code], the single quote ([code]'[/code]) and double quote ([code]""[/code]) characters are also escaped. *)
    let xml_escape =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_STRING_NAME
        "xml_escape"
        (Base.Int64.of_string "3429816538")
        (Bool.typ @-> StringName.typ @-> returning String.typ)
        String.s

    (** Returns a copy of the string with escaped characters replaced by their meanings according to the XML standard. *)
    let xml_unescape =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_STRING_NAME
        "xml_unescape"
        (Base.Int64.of_string "3942272618")
        (StringName.typ @-> returning String.typ)
        String.s

    (** Encodes the string to URL-friendly format. This method is meant to properly encode the parameters in a URL when sending an HTTP request.
[codeblocks]
[gdscript]
var prefix = ""$DOCS_URL/?highlight=""
var url = prefix + ""Godot Engine:docs"".uri_encode()

print(url) # Prints ""$DOCS_URL/?highlight=Godot%20Engine%3%docs""
[/gdscript]
[csharp]
var prefix = ""$DOCS_URL/?highlight="";
var url = prefix + ""Godot Engine:docs"".URIEncode();

GD.Print(url); // Prints ""$DOCS_URL/?highlight=Godot%20Engine%3%docs""
[/csharp]
[/codeblocks] *)
    let uri_encode =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_STRING_NAME
        "uri_encode"
        (Base.Int64.of_string "3942272618")
        (StringName.typ @-> returning String.typ)
        String.s

    (** Decodes the string from its URL-encoded format. This method is meant to properly decode the parameters in a URL when receiving an HTTP request.
[codeblocks]
[gdscript]
var url = ""$DOCS_URL/?highlight=Godot%20Engine%3%docs""
print(url.uri_decode()) # Prints ""$DOCS_URL/?highlight=Godot Engine:docs""
[/gdscript]
[csharp]
var url = ""$DOCS_URL/?highlight=Godot%20Engine%3%docs""
GD.Print(url.URIDecode()) // Prints ""$DOCS_URL/?highlight=Godot Engine:docs""
[/csharp]
[/codeblocks] *)
    let uri_decode =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_STRING_NAME
        "uri_decode"
        (Base.Int64.of_string "3942272618")
        (StringName.typ @-> returning String.typ)
        String.s

    (** Returns a copy of the string with special characters escaped using the C language standard. *)
    let c_escape =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_STRING_NAME
        "c_escape"
        (Base.Int64.of_string "3942272618")
        (StringName.typ @-> returning String.typ)
        String.s

    (** Returns a copy of the string with escaped characters replaced by their meanings. Supported escape sequences are [code]\'[/code], [code]\""[/code], [code]\\[/code], [code]\a[/code], [code]\b[/code], [code]\f[/code], [code]\n[/code], [code]\r[/code], [code]\t[/code], [code]\v[/code].
[b]Note:[/b] Unlike the GDScript parser, this method doesn't support the [code]\uXXXX[/code] escape sequence. *)
    let c_unescape =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_STRING_NAME
        "c_unescape"
        (Base.Int64.of_string "3942272618")
        (StringName.typ @-> returning String.typ)
        String.s

    (** Returns a copy of the string with special characters escaped using the JSON standard. Because it closely matches the C standard, it is possible to use [method c_unescape] to unescape the string, if necessary. *)
    let json_escape =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_STRING_NAME
        "json_escape"
        (Base.Int64.of_string "3942272618")
        (StringName.typ @-> returning String.typ)
        String.s

    (** Returns a copy of the string with all characters that are not allowed in [member Node.name] ([code].[/code] [code]:[/code] [code]@[/code] [code]/[/code] [code]""[/code] [code]%[/code]) replaced with underscores. *)
    let validate_node_name =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_STRING_NAME
        "validate_node_name"
        (Base.Int64.of_string "3942272618")
        (StringName.typ @-> returning String.typ)
        String.s

    (** Returns a copy of the string with all characters that are not allowed in [method is_valid_filename] replaced with underscores. *)
    let validate_filename =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_STRING_NAME
        "validate_filename"
        (Base.Int64.of_string "3942272618")
        (StringName.typ @-> returning String.typ)
        String.s

    (** Returns [code]true[/code] if this string is a valid identifier. A valid identifier may contain only letters, digits and underscores ([code]_[/code]), and the first character may not be a digit.
[codeblock]
print(""node_2d"".is_valid_identifier())    # Prints true
print(""TYPE_FLOAT"".is_valid_identifier()) # Prints true
print(""1st_method"".is_valid_identifier()) # Prints false
print(""MyMethod#2"".is_valid_identifier()) # Prints false
[/codeblock] *)
    let is_valid_identifier =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_STRING_NAME
        "is_valid_identifier"
        (Base.Int64.of_string "3918633141")
        (StringName.typ @-> returning Bool.typ)
        Bool.s

    (** Returns [code]true[/code] if this string represents a valid integer. A valid integer only contains digits, and may be prefixed with a positive ([code]+[/code]) or negative ([code]-[/code]) sign. See also [method to_int].
[codeblock]
print(""7"".is_valid_int())    # Prints true
print(""1.65"".is_valid_int()) # Prints false
print(""Hi"".is_valid_int())   # Prints false
print(""+3"".is_valid_int())   # Prints true
print(""-12"".is_valid_int())  # Prints true
[/codeblock] *)
    let is_valid_int =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_STRING_NAME
        "is_valid_int"
        (Base.Int64.of_string "3918633141")
        (StringName.typ @-> returning Bool.typ)
        Bool.s

    (** Returns [code]true[/code] if this string represents a valid floating-point number. A valid float may contain only digits, one decimal point ([code].[/code]), and the exponent letter ([code]e[/code]). It may also be prefixed with a positive ([code]+[/code]) or negative ([code]-[/code]) sign. Any valid integer is also a valid float (see [method is_valid_int]). See also [method to_float].
[codeblock]
print(""1.7"".is_valid_float())   # Prints true
print(""24"".is_valid_float())    # Prints true
print(""7e3"".is_valid_float())   # Prints true
print(""Hello"".is_valid_float()) # Prints false
[/codeblock] *)
    let is_valid_float =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_STRING_NAME
        "is_valid_float"
        (Base.Int64.of_string "3918633141")
        (StringName.typ @-> returning Bool.typ)
        Bool.s

    (** Returns [code]true[/code] if this string is a valid hexadecimal number. A valid hexadecimal number only contains digits or letters [code]A[/code] to [code]F[/code] (either uppercase or lowercase), and may be prefixed with a positive ([code]+[/code]) or negative ([code]-[/code]) sign.
If [param with_prefix] is [code]true[/code], the hexadecimal number needs to prefixed by [code]""0x""[/code] to be considered valid.
[codeblock]
print(""A08E"".is_valid_hex_number())    # Prints true
print(""-AbCdEf"".is_valid_hex_number()) # Prints true
print(""2.5"".is_valid_hex_number())     # Prints false

print(""0xDEADC0DE"".is_valid_hex_number(true)) # Prints true
[/codeblock] *)
    let is_valid_hex_number =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_STRING_NAME
        "is_valid_hex_number"
        (Base.Int64.of_string "593672999")
        (Bool.typ @-> StringName.typ @-> returning Bool.typ)
        Bool.s

    (** Returns [code]true[/code] if this string is a valid color in hexadecimal HTML notation. The string must be a hexadecimal value (see [method is_valid_hex_number]) of either 3, 4, 6 or 8 digits, and may be prefixed by a hash sign ([code]#[/code]). Other HTML notations for colors, such as names or [code]hsl()[/code], are not considered valid. See also [method Color.html]. *)
    let is_valid_html_color =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_STRING_NAME
        "is_valid_html_color"
        (Base.Int64.of_string "3918633141")
        (StringName.typ @-> returning Bool.typ)
        Bool.s

    (** Returns [code]true[/code] if this string represents a well-formatted IPv4 or IPv6 address. This method considers [url=https://en.wikipedia.org/wiki/Reserved_IP_addresses]reserved IP addresses[/url] such as [code]""0.0.0.0""[/code] and [code]""ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff""[/code] as valid. *)
    let is_valid_ip_address =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_STRING_NAME
        "is_valid_ip_address"
        (Base.Int64.of_string "3918633141")
        (StringName.typ @-> returning Bool.typ)
        Bool.s

    (** Returns [code]true[/code] if this string does not contain characters that are not allowed in file names ([code]:[/code] [code]/[/code] [code]\[/code] [code]?[/code] [code] * [/code] [code]""[/code] [code]|[/code] [code]%[/code] [code]<[/code] [code]>[/code]). *)
    let is_valid_filename =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_STRING_NAME
        "is_valid_filename"
        (Base.Int64.of_string "3918633141")
        (StringName.typ @-> returning Bool.typ)
        Bool.s

    (** Converts the string representing an integer number into an [int]. This method removes any non-number character and stops at the first decimal point ([code].[/code]). See also [method is_valid_int].
[codeblock]
var a = ""123"".to_int()    # a is 123
var b = ""x1y2z3"".to_int() # b is 123
var c = ""-1.2.3"".to_int() # c is -1
var d = ""Hello!"".to_int() # d is 0
[/codeblock] *)
    let to_int =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_STRING_NAME "to_int"
        (Base.Int64.of_string "3173160232")
        (StringName.typ @-> returning Int.typ)
        Int.s

    (** Converts the string representing a decimal number into a [float]. This method stops on the first non-number character, except the first decimal point ([code].[/code]) and the exponent letter ([code]e[/code]). See also [method is_valid_float].
[codeblock]
var a = ""12.35"".to_float() # a is 12.35
var b = ""1.2.3"".to_float() # b is 1.2
var c = ""12xy3"".to_float() # c is 12.0
var d = ""1e3"".to_float()   # d is 1000.0
var e = ""Hello!"".to_int()  # e is 0.0
[/codeblock] *)
    let to_float =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_STRING_NAME
        "to_float"
        (Base.Int64.of_string "466405837")
        (StringName.typ @-> returning Float.typ)
        Float.s

    (** Converts the string representing a hexadecimal number into an [int]. The string may be optionally prefixed with [code]""0x""[/code], and an additional [code]-[/code] prefix for negative numbers.
[codeblocks]
[gdscript]
print(""0xff"".hex_to_int()) # Prints 255
print(""ab"".hex_to_int())   # Prints 171
[/gdscript]
[csharp]
GD.Print(""0xff"".HexToInt()); // Prints 255
GD.Print(""ab"".HexToInt());   // Prints 171
[/csharp]
[/codeblocks] *)
    let hex_to_int =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_STRING_NAME
        "hex_to_int"
        (Base.Int64.of_string "3173160232")
        (StringName.typ @-> returning Int.typ)
        Int.s

    (** Converts the string representing a binary number into an [int]. The string may optionally be prefixed with [code]""0b""[/code], and an additional [code]-[/code] prefix for negative numbers.
[codeblocks]
[gdscript]
print(""101"".bin_to_int())   # Prints 5
print(""0b101"".bin_to_int()) # Prints 5
print(""-0b10"".bin_to_int()) # Prints -2
[/gdscript]
[csharp]
GD.Print(""101"".BinToInt());   // Prints 5
GD.Print(""0b101"".BinToInt()); // Prints 5
GD.Print(""-0b10"".BinToInt()); // Prints -2
[/csharp]
[/codeblocks] *)
    let bin_to_int =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_STRING_NAME
        "bin_to_int"
        (Base.Int64.of_string "3173160232")
        (StringName.typ @-> returning Int.typ)
        Int.s

    (** Formats the string to be at least [param min_length] long by adding [param character]s to the left of the string, if necessary. See also [method rpad]. *)
    let lpad =
      foreign_builtin_method2 GlobalEnum.VariantType._TYPE_STRING_NAME "lpad"
        (Base.Int64.of_string "248737229")
        (Int.typ @-> String.typ @-> StringName.typ @-> returning String.typ)
        String.s

    (** Formats the string to be at least [param min_length] long, by adding [param character]s to the right of the string, if necessary. See also [method lpad]. *)
    let rpad =
      foreign_builtin_method2 GlobalEnum.VariantType._TYPE_STRING_NAME "rpad"
        (Base.Int64.of_string "248737229")
        (Int.typ @-> String.typ @-> StringName.typ @-> returning String.typ)
        String.s

    (** Formats the string representing a number to have an exact number of [param digits] [i]after[/i] the decimal point. *)
    let pad_decimals =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_STRING_NAME
        "pad_decimals"
        (Base.Int64.of_string "2162347432")
        (Int.typ @-> StringName.typ @-> returning String.typ)
        String.s

    (** Formats the string representing a number to have an exact number of [param digits] [i]before[/i] the decimal point. *)
    let pad_zeros =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_STRING_NAME
        "pad_zeros"
        (Base.Int64.of_string "2162347432")
        (Int.typ @-> StringName.typ @-> returning String.typ)
        String.s

    (** Removes the given [param prefix] from the start of the string, or returns the string unchanged. *)
    let trim_prefix =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_STRING_NAME
        "trim_prefix"
        (Base.Int64.of_string "3134094431")
        (String.typ @-> StringName.typ @-> returning String.typ)
        String.s

    (** Removes the given [param suffix] from the end of the string, or returns the string unchanged. *)
    let trim_suffix =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_STRING_NAME
        "trim_suffix"
        (Base.Int64.of_string "3134094431")
        (String.typ @-> StringName.typ @-> returning String.typ)
        String.s

    (** Converts the string to an [url=https://en.wikipedia.org/wiki/ASCII]ASCII[/url]/Latin-1 encoded [PackedByteArray]. This method is slightly faster than [method to_utf8_buffer], but replaces all unsupported characters with spaces. *)
    let to_ascii_buffer =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_STRING_NAME
        "to_ascii_buffer"
        (Base.Int64.of_string "247621236")
        (StringName.typ @-> returning PackedByteArray.typ)
        PackedByteArray.s

    (** Converts the string to a [url=https://en.wikipedia.org/wiki/UTF-8]UTF-8[/url] encoded [PackedByteArray]. This method is slightly slower than [method to_ascii_buffer], but supports all UTF-8 characters. For most cases, prefer using this method. *)
    let to_utf8_buffer =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_STRING_NAME
        "to_utf8_buffer"
        (Base.Int64.of_string "247621236")
        (StringName.typ @-> returning PackedByteArray.typ)
        PackedByteArray.s

    (** Converts the string to a [url=https://en.wikipedia.org/wiki/UTF-16]UTF-16[/url] encoded [PackedByteArray]. *)
    let to_utf16_buffer =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_STRING_NAME
        "to_utf16_buffer"
        (Base.Int64.of_string "247621236")
        (StringName.typ @-> returning PackedByteArray.typ)
        PackedByteArray.s

    (** Converts the string to a [url=https://en.wikipedia.org/wiki/UTF-32]UTF-32[/url] encoded [PackedByteArray]. *)
    let to_utf32_buffer =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_STRING_NAME
        "to_utf32_buffer"
        (Base.Int64.of_string "247621236")
        (StringName.typ @-> returning PackedByteArray.typ)
        PackedByteArray.s

    (** Decodes a hexadecimal string as a [PackedByteArray].
[codeblocks]
[gdscript]
var text = ""hello world""
var encoded = text.to_utf8_buffer().hex_encode() # outputs ""68656c6c6f20776f726c64""
print(buf.hex_decode().get_string_from_utf8())
[/gdscript]
[csharp]
var text = ""hello world"";
var encoded = text.ToUtf8Buffer().HexEncode(); // outputs ""68656c6c6f20776f726c64""
GD.Print(buf.HexDecode().GetStringFromUtf8());
[/csharp]
[/codeblocks] *)
    let hex_decode =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_STRING_NAME
        "hex_decode"
        (Base.Int64.of_string "247621236")
        (StringName.typ @-> returning PackedByteArray.typ)
        PackedByteArray.s

    (** Converts the string to a [url=https://en.wikipedia.org/wiki/Wide_character]wide character[/url] ([code]wchar_t[/code], UTF-16 on Windows, UTF-32 on other platforms) encoded [PackedByteArray]. *)
    let to_wchar_buffer =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_STRING_NAME
        "to_wchar_buffer"
        (Base.Int64.of_string "247621236")
        (StringName.typ @-> returning PackedByteArray.typ)
        PackedByteArray.s

    (** Returns the 32-bit hash value representing the string's contents.
[b]Note:[/b] Strings with equal hash values are [i]not[/i] guaranteed to be the same, as a result of hash collisions. On the contrary, strings with different hash values are guaranteed to be different. *)
    let hash =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_STRING_NAME "hash"
        (Base.Int64.of_string "3173160232")
        (StringName.typ @-> returning Int.typ)
        Int.s

    let not =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_STRING_NAME None
        GlobalEnum.VariantOperator._OP_NOT
        (funptr
           (StringName.typ @-> StringName.typ @-> Bool.typ @-> returning void))

    let _StringName_elem_String =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_STRING_NAME
        (Some GlobalEnum.VariantType._TYPE_STRING)
        GlobalEnum.VariantOperator._OP_IN
        (funptr (StringName.typ @-> String.typ @-> Bool.typ @-> returning void))

    (** Returns [code]true[/code] if the [StringName] and [param right] refer to the same name. Comparisons between [StringName]s are much faster than regular [String] comparisons. *)
    let ( = ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_STRING_NAME
        (Some GlobalEnum.VariantType._TYPE_STRING_NAME)
        GlobalEnum.VariantOperator._OP_EQUAL
        (funptr
           (StringName.typ @-> StringName.typ @-> Bool.typ @-> returning void))

    (** Returns [code]true[/code] if the [StringName] and [param right] do not refer to the same name. Comparisons between [StringName]s are much faster than regular [String] comparisons. *)
    let ( <> ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_STRING_NAME
        (Some GlobalEnum.VariantType._TYPE_STRING_NAME)
        GlobalEnum.VariantOperator._OP_NOT_EQUAL
        (funptr
           (StringName.typ @-> StringName.typ @-> Bool.typ @-> returning void))

    (** Returns [code]true[/code] if the left [StringName]'s pointer comes before [param right]. Note that this will not match their [url=https://en.wikipedia.org/wiki/List_of_Unicode_characters]Unicode order[/url]. *)
    let ( < ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_STRING_NAME
        (Some GlobalEnum.VariantType._TYPE_STRING_NAME)
        GlobalEnum.VariantOperator._OP_LESS
        (funptr
           (StringName.typ @-> StringName.typ @-> Bool.typ @-> returning void))

    (** Returns [code]true[/code] if the left [StringName]'s pointer comes before [param right] or if they are the same. Note that this will not match their [url=https://en.wikipedia.org/wiki/List_of_Unicode_characters]Unicode order[/url]. *)
    let ( <= ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_STRING_NAME
        (Some GlobalEnum.VariantType._TYPE_STRING_NAME)
        GlobalEnum.VariantOperator._OP_LESS_EQUAL
        (funptr
           (StringName.typ @-> StringName.typ @-> Bool.typ @-> returning void))

    (** Returns [code]true[/code] if the left [StringName]'s pointer comes after [param right]. Note that this will not match their [url=https://en.wikipedia.org/wiki/List_of_Unicode_characters]Unicode order[/url]. *)
    let ( > ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_STRING_NAME
        (Some GlobalEnum.VariantType._TYPE_STRING_NAME)
        GlobalEnum.VariantOperator._OP_GREATER
        (funptr
           (StringName.typ @-> StringName.typ @-> Bool.typ @-> returning void))

    (** Returns [code]true[/code] if the left [StringName]'s pointer comes after [param right] or if they are the same. Note that this will not match their [url=https://en.wikipedia.org/wiki/List_of_Unicode_characters]Unicode order[/url]. *)
    let ( >= ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_STRING_NAME
        (Some GlobalEnum.VariantType._TYPE_STRING_NAME)
        GlobalEnum.VariantOperator._OP_GREATER_EQUAL
        (funptr
           (StringName.typ @-> StringName.typ @-> Bool.typ @-> returning void))

    (** Appends [param right] at the end of this [StringName], returning a [String]. This is also known as a string concatenation. *)
    let ( + ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_STRING_NAME
        (Some GlobalEnum.VariantType._TYPE_STRING_NAME)
        GlobalEnum.VariantOperator._OP_ADD
        (funptr
           (StringName.typ @-> StringName.typ @-> String.typ @-> returning void))

    let ( % ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_STRING_NAME
        (Some GlobalEnum.VariantType._TYPE_STRING_NAME)
        GlobalEnum.VariantOperator._OP_MODULE
        (funptr
           (StringName.typ @-> StringName.typ @-> String.typ @-> returning void))

    let _StringName_elem_StringName =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_STRING_NAME
        (Some GlobalEnum.VariantType._TYPE_STRING_NAME)
        GlobalEnum.VariantOperator._OP_IN
        (funptr
           (StringName.typ @-> StringName.typ @-> Bool.typ @-> returning void))

    let _StringName_elem_Object =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_STRING_NAME
        (Some GlobalEnum.VariantType._TYPE_OBJECT)
        GlobalEnum.VariantOperator._OP_IN
        (funptr (StringName.typ @-> Object.typ @-> Bool.typ @-> returning void))

    let _StringName_elem_Dictionary =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_STRING_NAME
        (Some GlobalEnum.VariantType._TYPE_DICTIONARY)
        GlobalEnum.VariantOperator._OP_IN
        (funptr
           (StringName.typ @-> Dictionary.typ @-> Bool.typ @-> returning void))

    let _StringName_elem_Array =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_STRING_NAME
        (Some GlobalEnum.VariantType._TYPE_ARRAY)
        GlobalEnum.VariantOperator._OP_IN
        (funptr (StringName.typ @-> Array.typ @-> Bool.typ @-> returning void))

    let _StringName_elem_PackedStringArray =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_STRING_NAME
        (Some GlobalEnum.VariantType._TYPE_PACKED_STRING_ARRAY)
        GlobalEnum.VariantOperator._OP_IN
        (funptr
           (StringName.typ @-> PackedStringArray.typ @-> Bool.typ
          @-> returning void))
  end

  module NodePath = struct
    include M.NodePath

    (** Returns [code]true[/code] if the node path is absolute (as opposed to relative), which means that it starts with a slash character ([code]/[/code]). Absolute node paths can be used to access the root node ([code]""/root""[/code]) or autoloads (e.g. [code]""/global""[/code] if a ""global"" autoload was registered). *)
    let is_absolute =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_NODE_PATH
        "is_absolute"
        (Base.Int64.of_string "3918633141")
        (NodePath.typ @-> returning Bool.typ)
        Bool.s

    (** Gets the number of node names which make up the path. Subnames (see [method get_subname_count]) are not included.
For example, [code]""Path2D/PathFollow2D/Sprite2D""[/code] has 3 names. *)
    let get_name_count =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_NODE_PATH
        "get_name_count"
        (Base.Int64.of_string "3173160232")
        (NodePath.typ @-> returning Int.typ)
        Int.s

    (** Gets the node name indicated by [param idx] (0 to [method get_name_count] - 1).
[codeblocks]
[gdscript]
var node_path = NodePath(""Path2D/PathFollow2D/Sprite2D"")
print(node_path.get_name(0)) # Path2D
print(node_path.get_name(1)) # PathFollow2D
print(node_path.get_name(2)) # Sprite
[/gdscript]
[csharp]
var nodePath = new NodePath(""Path2D/PathFollow2D/Sprite2D"");
GD.Print(nodePath.GetName(0)); // Path2D
GD.Print(nodePath.GetName(1)); // PathFollow2D
GD.Print(nodePath.GetName(2)); // Sprite
[/csharp]
[/codeblocks] *)
    let get_name =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_NODE_PATH "get_name"
        (Base.Int64.of_string "2948586938")
        (Int.typ @-> NodePath.typ @-> returning StringName.typ)
        StringName.s

    (** Gets the number of resource or property names (""subnames"") in the path. Each subname is listed after a colon character ([code]:[/code]) in the node path.
For example, [code]""Path2D/PathFollow2D/Sprite2D:texture:load_path""[/code] has 2 subnames. *)
    let get_subname_count =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_NODE_PATH
        "get_subname_count"
        (Base.Int64.of_string "3173160232")
        (NodePath.typ @-> returning Int.typ)
        Int.s

    (** Returns the 32-bit hash value representing the [NodePath]'s contents. *)
    let hash =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_NODE_PATH "hash"
        (Base.Int64.of_string "3173160232")
        (NodePath.typ @-> returning Int.typ)
        Int.s

    (** Gets the resource or property name indicated by [param idx] (0 to [method get_subname_count] - 1).
[codeblocks]
[gdscript]
var node_path = NodePath(""Path2D/PathFollow2D/Sprite2D:texture:load_path"")
print(node_path.get_subname(0)) # texture
print(node_path.get_subname(1)) # load_path
[/gdscript]
[csharp]
var nodePath = new NodePath(""Path2D/PathFollow2D/Sprite2D:texture:load_path"");
GD.Print(nodePath.GetSubname(0)); // texture
GD.Print(nodePath.GetSubname(1)); // load_path
[/csharp]
[/codeblocks] *)
    let get_subname =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_NODE_PATH
        "get_subname"
        (Base.Int64.of_string "2948586938")
        (Int.typ @-> NodePath.typ @-> returning StringName.typ)
        StringName.s

    (** Returns all paths concatenated with a slash character ([code]/[/code]) as separator without subnames. *)
    let get_concatenated_names =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_NODE_PATH
        "get_concatenated_names"
        (Base.Int64.of_string "1825232092")
        (NodePath.typ @-> returning StringName.typ)
        StringName.s

    (** Returns all subnames concatenated with a colon character ([code]:[/code]) as separator, i.e. the right side of the first colon in a node path.
[codeblocks]
[gdscript]
var node_path = NodePath(""Path2D/PathFollow2D/Sprite2D:texture:load_path"")
print(node_path.get_concatenated_subnames()) # texture:load_path
[/gdscript]
[csharp]
var nodePath = new NodePath(""Path2D/PathFollow2D/Sprite2D:texture:load_path"");
GD.Print(nodePath.GetConcatenatedSubnames()); // texture:load_path
[/csharp]
[/codeblocks] *)
    let get_concatenated_subnames =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_NODE_PATH
        "get_concatenated_subnames"
        (Base.Int64.of_string "1825232092")
        (NodePath.typ @-> returning StringName.typ)
        StringName.s

    (** Returns a node path with a colon character ([code]:[/code]) prepended, transforming it to a pure property path with no node name (defaults to resolving from the current node).
[codeblocks]
[gdscript]
# This will be parsed as a node path to the ""x"" property in the ""position"" node.
var node_path = NodePath(""position:x"")
# This will be parsed as a node path to the ""x"" component of the ""position"" property in the current node.
var property_path = node_path.get_as_property_path()
print(property_path) # :position:x
[/gdscript]
[csharp]
// This will be parsed as a node path to the ""x"" property in the ""position"" node.
var nodePath = new NodePath(""position:x"");
// This will be parsed as a node path to the ""x"" component of the ""position"" property in the current node.
NodePath propertyPath = nodePath.GetAsPropertyPath();
GD.Print(propertyPath); // :position:x
[/csharp]
[/codeblocks] *)
    let get_as_property_path =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_NODE_PATH
        "get_as_property_path"
        (Base.Int64.of_string "1598598043")
        (NodePath.typ @-> returning NodePath.typ)
        NodePath.s

    (** Returns [code]true[/code] if the node path is empty. *)
    let is_empty =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_NODE_PATH "is_empty"
        (Base.Int64.of_string "3918633141")
        (NodePath.typ @-> returning Bool.typ)
        Bool.s

    let not =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_NODE_PATH None
        GlobalEnum.VariantOperator._OP_NOT
        (funptr (NodePath.typ @-> NodePath.typ @-> Bool.typ @-> returning void))

    (** Returns [code]true[/code] if two node paths are equal, i.e. all node names in the path are the same and in the same order. *)
    let ( = ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_NODE_PATH
        (Some GlobalEnum.VariantType._TYPE_NODE_PATH)
        GlobalEnum.VariantOperator._OP_EQUAL
        (funptr (NodePath.typ @-> NodePath.typ @-> Bool.typ @-> returning void))

    (** Returns [code]true[/code] if two node paths are not equal. *)
    let ( <> ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_NODE_PATH
        (Some GlobalEnum.VariantType._TYPE_NODE_PATH)
        GlobalEnum.VariantOperator._OP_NOT_EQUAL
        (funptr (NodePath.typ @-> NodePath.typ @-> Bool.typ @-> returning void))

    let _NodePath_elem_Dictionary =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_NODE_PATH
        (Some GlobalEnum.VariantType._TYPE_DICTIONARY)
        GlobalEnum.VariantOperator._OP_IN
        (funptr
           (NodePath.typ @-> Dictionary.typ @-> Bool.typ @-> returning void))

    let _NodePath_elem_Array =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_NODE_PATH
        (Some GlobalEnum.VariantType._TYPE_ARRAY)
        GlobalEnum.VariantOperator._OP_IN
        (funptr (NodePath.typ @-> Array.typ @-> Bool.typ @-> returning void))
  end

  module RID = struct
    include M.RID

    (** Returns [code]true[/code] if the [RID] is not [code]0[/code]. *)
    let is_valid =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_RID "is_valid"
        (Base.Int64.of_string "3918633141")
        (RID.typ @-> returning Bool.typ)
        Bool.s

    (** Returns the ID of the referenced low-level resource. *)
    let get_id =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_RID "get_id"
        (Base.Int64.of_string "3173160232")
        (RID.typ @-> returning Int.typ)
        Int.s

    let not =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_RID None
        GlobalEnum.VariantOperator._OP_NOT
        (funptr (RID.typ @-> RID.typ @-> Bool.typ @-> returning void))

    (** Returns [code]true[/code] if both [RID]s are equal, which means they both refer to the same low-level resource. *)
    let ( = ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_RID
        (Some GlobalEnum.VariantType._TYPE_RID)
        GlobalEnum.VariantOperator._OP_EQUAL
        (funptr (RID.typ @-> RID.typ @-> Bool.typ @-> returning void))

    (** Returns [code]true[/code] if the [RID]s are not equal. *)
    let ( <> ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_RID
        (Some GlobalEnum.VariantType._TYPE_RID)
        GlobalEnum.VariantOperator._OP_NOT_EQUAL
        (funptr (RID.typ @-> RID.typ @-> Bool.typ @-> returning void))

    (** Returns [code]true[/code] if the [RID]'s ID is less than [param right]'s ID. *)
    let ( < ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_RID
        (Some GlobalEnum.VariantType._TYPE_RID)
        GlobalEnum.VariantOperator._OP_LESS
        (funptr (RID.typ @-> RID.typ @-> Bool.typ @-> returning void))

    (** Returns [code]true[/code] if the [RID]'s ID is less than or equal to [param right]'s ID. *)
    let ( <= ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_RID
        (Some GlobalEnum.VariantType._TYPE_RID)
        GlobalEnum.VariantOperator._OP_LESS_EQUAL
        (funptr (RID.typ @-> RID.typ @-> Bool.typ @-> returning void))

    (** Returns [code]true[/code] if the [RID]'s ID is greater than [param right]'s ID. *)
    let ( > ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_RID
        (Some GlobalEnum.VariantType._TYPE_RID)
        GlobalEnum.VariantOperator._OP_GREATER
        (funptr (RID.typ @-> RID.typ @-> Bool.typ @-> returning void))

    (** Returns [code]true[/code] if the [RID]'s ID is greater than or equal to [param right]'s ID. *)
    let ( >= ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_RID
        (Some GlobalEnum.VariantType._TYPE_RID)
        GlobalEnum.VariantOperator._OP_GREATER_EQUAL
        (funptr (RID.typ @-> RID.typ @-> Bool.typ @-> returning void))
  end

  module Callable = struct
    include M.Callable

    (** Calls the method represented by this [Callable]. Unlike [method call], this method expects all arguments to be contained inside the [param arguments] [Array]. *)
    let callv =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_CALLABLE "callv"
        (Base.Int64.of_string "413578926")
        (Array.typ @-> Callable.typ @-> returning Variant.typ)
        Variant.s

    (** Returns [code]true[/code] if this [Callable] has no target to call the method on. *)
    let is_null =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_CALLABLE "is_null"
        (Base.Int64.of_string "3918633141")
        (Callable.typ @-> returning Bool.typ)
        Bool.s

    (** Returns [code]true[/code] if this [Callable] is a custom callable. Custom callables are created from [method bind] or [method unbind]. In GDScript, lambda functions are also custom callables. *)
    let is_custom =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_CALLABLE "is_custom"
        (Base.Int64.of_string "3918633141")
        (Callable.typ @-> returning Bool.typ)
        Bool.s

    (** Returns [code]true[/code] if this [Callable] is a standard callable. This method is the opposite of [method is_custom]. Returns [code]false[/code] if this callable is a lambda function. *)
    let is_standard =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_CALLABLE
        "is_standard"
        (Base.Int64.of_string "3918633141")
        (Callable.typ @-> returning Bool.typ)
        Bool.s

    (** Returns [code]true[/code] if the callable's object exists and has a valid method name assigned, or is a custom callable. *)
    let is_valid =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_CALLABLE "is_valid"
        (Base.Int64.of_string "3918633141")
        (Callable.typ @-> returning Bool.typ)
        Bool.s

    (** Returns the object on which this [Callable] is called. *)
    let get_object =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_CALLABLE "get_object"
        (Base.Int64.of_string "4008621732")
        (Callable.typ @-> returning Object.typ)
        Object.s

    (** Returns the ID of this [Callable]'s object (see [method Object.get_instance_id]). *)
    let get_object_id =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_CALLABLE
        "get_object_id"
        (Base.Int64.of_string "3173160232")
        (Callable.typ @-> returning Int.typ)
        Int.s

    (** Returns the name of the method represented by this [Callable]. If the callable is a GDScript lambda function, returns the function's name or [code]""<anonymous lambda>""[/code]. *)
    let get_method =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_CALLABLE "get_method"
        (Base.Int64.of_string "1825232092")
        (Callable.typ @-> returning StringName.typ)
        StringName.s

    (** Returns the total amount of arguments bound (or unbound) via successive [method bind] or [method unbind] calls. If the amount of arguments unbound is greater than the ones bound, this function returns a value less than zero. *)
    let get_bound_arguments_count =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_CALLABLE
        "get_bound_arguments_count"
        (Base.Int64.of_string "3173160232")
        (Callable.typ @-> returning Int.typ)
        Int.s

    (** Return the bound arguments (as long as [method get_bound_arguments_count] is greater than zero), or empty (if [method get_bound_arguments_count] is less than or equal to zero). *)
    let get_bound_arguments =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_CALLABLE
        "get_bound_arguments"
        (Base.Int64.of_string "4144163970")
        (Callable.typ @-> returning Array.typ)
        Array.s

    (** Returns the 32-bit hash value of this [Callable]'s object.
[b]Note:[/b] [Callable]s with equal content will always produce identical hash values. However, the reverse is not true. Returning identical hash values does [i]not[/i] imply the callables are equal, because different callables can have identical hash values due to hash collisions. The engine uses a 32-bit hash algorithm for [method hash]. *)
    let hash =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_CALLABLE "hash"
        (Base.Int64.of_string "3173160232")
        (Callable.typ @-> returning Int.typ)
        Int.s

    (** Returns a copy of this [Callable] with one or more arguments bound, reading them from an array. When called, the bound arguments are passed [i]after[/i] the arguments supplied by [method call]. See also [method unbind].
[b]Note:[/b] When this method is chained with other similar methods, the order in which the argument list is modified is read from right to left. *)
    let bindv =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_CALLABLE "bindv"
        (Base.Int64.of_string "3564560322")
        (Array.typ @-> Callable.typ @-> returning Callable.typ)
        Callable.s

    (** Returns a copy of this [Callable] with a number of arguments unbound. In other words, when the new callable is called the last few arguments supplied by the user are ignored, according to [param argcount]. The remaining arguments are passed to the callable. This allows to use the original callable in a context that attempts to pass more arguments than this callable can handle, e.g. a signal with a fixed number of arguments. See also [method bind].
[b]Note:[/b] When this method is chained with other similar methods, the order in which the argument list is modified is read from right to left.
[codeblock]
func _ready():
    foo.unbind(1).call(1, 2) # Calls foo(1).
    foo.bind(3, 4).unbind(1).call(1, 2) # Calls foo(1, 3, 4), note that it does not change the arguments from bind.
[/codeblock] *)
    let unbind =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_CALLABLE "unbind"
        (Base.Int64.of_string "755001590")
        (Int.typ @-> Callable.typ @-> returning Callable.typ)
        Callable.s

    (** Calls the method represented by this [Callable]. Arguments can be passed and should match the method's signature. *)
    let call =
      foreign_builtin_method0v GlobalEnum.VariantType._TYPE_CALLABLE "call"
        (Base.Int64.of_string "3643564216")
        (Variadic.typ @-> Callable.typ @-> returning Variant.typ)
        Variant.s

    (** Calls the method represented by this [Callable] in deferred mode, i.e. at the end of the current frame. Arguments can be passed and should match the method's signature.
[codeblock]
func _ready():
    grab_focus.call_deferred()
[/codeblock]
[b]Note:[/b] Deferred calls are processed at idle time. Idle time happens mainly at the end of process and physics frames. In it, deferred calls will be run until there are none left, which means you can defer calls from other deferred calls and they'll still be run in the current idle time cycle. This means you should not call a method deferred from itself (or from a method called by it), as this causes infinite recursion the same way as if you had called the method directly.
See also [method Object.call_deferred]. *)
    let call_deferred =
      foreign_builtin_method0v_void GlobalEnum.VariantType._TYPE_CALLABLE
        "call_deferred"
        (Base.Int64.of_string "3286317445")
        (Variadic.typ @-> Callable.typ @-> returning Void.typ)
        Void.s

    (** Perform an RPC (Remote Procedure Call) on all connected peers. This is used for multiplayer and is normally not available, unless the function being called has been marked as [i]RPC[/i] (using [annotation @GDScript.@rpc] or [method Node.rpc_config]). Calling this method on unsupported functions will result in an error. See [method Node.rpc]. *)
    let rpc =
      foreign_builtin_method0v_void GlobalEnum.VariantType._TYPE_CALLABLE "rpc"
        (Base.Int64.of_string "3286317445")
        (Variadic.typ @-> Callable.typ @-> returning Void.typ)
        Void.s

    (** Perform an RPC (Remote Procedure Call) on a specific peer ID (see multiplayer documentation for reference). This is used for multiplayer and is normally not available unless the function being called has been marked as [i]RPC[/i] (using [annotation @GDScript.@rpc] or [method Node.rpc_config]). Calling this method on unsupported functions will result in an error. See [method Node.rpc_id]. *)
    let rpc_id =
      foreign_builtin_method1v_void GlobalEnum.VariantType._TYPE_CALLABLE
        "rpc_id"
        (Base.Int64.of_string "2270047679")
        (Int.typ @-> Variadic.typ @-> Callable.typ @-> returning Void.typ)
        Void.s

    (** Returns a copy of this [Callable] with one or more arguments bound. When called, the bound arguments are passed [i]after[/i] the arguments supplied by [method call]. See also [method unbind].
[b]Note:[/b] When this method is chained with other similar methods, the order in which the argument list is modified is read from right to left. *)
    let bind =
      foreign_builtin_method0v GlobalEnum.VariantType._TYPE_CALLABLE "bind"
        (Base.Int64.of_string "3224143119")
        (Variadic.typ @-> Callable.typ @-> returning Callable.typ)
        Callable.s

    let not =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_CALLABLE None
        GlobalEnum.VariantOperator._OP_NOT
        (funptr (Callable.typ @-> Callable.typ @-> Bool.typ @-> returning void))

    (** Returns [code]true[/code] if both [Callable]s invoke the same custom target. *)
    let ( = ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_CALLABLE
        (Some GlobalEnum.VariantType._TYPE_CALLABLE)
        GlobalEnum.VariantOperator._OP_EQUAL
        (funptr (Callable.typ @-> Callable.typ @-> Bool.typ @-> returning void))

    (** Returns [code]true[/code] if both [Callable]s invoke different targets. *)
    let ( <> ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_CALLABLE
        (Some GlobalEnum.VariantType._TYPE_CALLABLE)
        GlobalEnum.VariantOperator._OP_NOT_EQUAL
        (funptr (Callable.typ @-> Callable.typ @-> Bool.typ @-> returning void))

    let _Callable_elem_Dictionary =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_CALLABLE
        (Some GlobalEnum.VariantType._TYPE_DICTIONARY)
        GlobalEnum.VariantOperator._OP_IN
        (funptr
           (Callable.typ @-> Dictionary.typ @-> Bool.typ @-> returning void))

    let _Callable_elem_Array =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_CALLABLE
        (Some GlobalEnum.VariantType._TYPE_ARRAY)
        GlobalEnum.VariantOperator._OP_IN
        (funptr (Callable.typ @-> Array.typ @-> Bool.typ @-> returning void))
  end

  module Signal = struct
    include M.Signal

    (** Returns [code]true[/code] if the signal's name does not exist in its object, or the object is not valid. *)
    let is_null =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_SIGNAL "is_null"
        (Base.Int64.of_string "3918633141")
        (Signal.typ @-> returning Bool.typ)
        Bool.s

    (** Returns the object emitting this signal. *)
    let get_object =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_SIGNAL "get_object"
        (Base.Int64.of_string "4008621732")
        (Signal.typ @-> returning Object.typ)
        Object.s

    (** Returns the ID of the object emitting this signal (see [method Object.get_instance_id]). *)
    let get_object_id =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_SIGNAL
        "get_object_id"
        (Base.Int64.of_string "3173160232")
        (Signal.typ @-> returning Int.typ)
        Int.s

    (** Returns the name of this signal. *)
    let get_name =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_SIGNAL "get_name"
        (Base.Int64.of_string "1825232092")
        (Signal.typ @-> returning StringName.typ)
        StringName.s

    (** Connects this signal to the specified [param callable]. Optional [param flags] can be also added to configure the connection's behavior (see [enum Object.ConnectFlags] constants). You can provide additional arguments to the connected [param callable] by using [method Callable.bind].
A signal can only be connected once to the same [Callable]. If the signal is already connected, returns [constant ERR_INVALID_PARAMETER] and pushes an error message, unless the signal is connected with [constant Object.CONNECT_REFERENCE_COUNTED]. To prevent this, use [method is_connected] first to check for existing connections.
[codeblock]
for button in $Buttons.get_children():
    button.pressed.connect(_on_pressed.bind(button))

func _on_pressed(button):
    print(button.name, "" was pressed"")
[/codeblock] *)
    let connect =
      foreign_builtin_method2 GlobalEnum.VariantType._TYPE_SIGNAL "connect"
        (Base.Int64.of_string "979702392")
        (Callable.typ @-> Int.typ @-> Signal.typ @-> returning Int.typ)
        Int.s

    (** Disconnects this signal from the specified [Callable]. If the connection does not exist, generates an error. Use [method is_connected] to make sure that the connection exists. *)
    let disconnect =
      foreign_builtin_method1_void GlobalEnum.VariantType._TYPE_SIGNAL
        "disconnect"
        (Base.Int64.of_string "3470848906")
        (Callable.typ @-> Signal.typ @-> returning Void.typ)
        Void.s

    (** Returns [code]true[/code] if the specified [Callable] is connected to this signal. *)
    let is_connected =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_SIGNAL "is_connected"
        (Base.Int64.of_string "4129521963")
        (Callable.typ @-> Signal.typ @-> returning Bool.typ)
        Bool.s

    (** Returns an [Array] of connections for this signal. Each connection is represented as a [Dictionary] that contains three entries:
- [code]signal[/code] is a reference to this signal;
- [code]callable[/code] is a reference to the connected [Callable];
- [code]flags[/code] is a combination of [enum Object.ConnectFlags]. *)
    let get_connections =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_SIGNAL
        "get_connections"
        (Base.Int64.of_string "4144163970")
        (Signal.typ @-> returning Array.typ)
        Array.s

    (** Emits this signal. All [Callable]s connected to this signal will be triggered. This method supports a variable number of arguments, so parameters can be passed as a comma separated list. *)
    let emit =
      foreign_builtin_method0v_void GlobalEnum.VariantType._TYPE_SIGNAL "emit"
        (Base.Int64.of_string "3286317445")
        (Variadic.typ @-> Signal.typ @-> returning Void.typ)
        Void.s

    let not =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_SIGNAL None
        GlobalEnum.VariantOperator._OP_NOT
        (funptr (Signal.typ @-> Signal.typ @-> Bool.typ @-> returning void))

    (** Returns [code]true[/code] if both signals share the same object and name. *)
    let ( = ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_SIGNAL
        (Some GlobalEnum.VariantType._TYPE_SIGNAL)
        GlobalEnum.VariantOperator._OP_EQUAL
        (funptr (Signal.typ @-> Signal.typ @-> Bool.typ @-> returning void))

    (** Returns [code]true[/code] if the signals do not share the same object and name. *)
    let ( <> ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_SIGNAL
        (Some GlobalEnum.VariantType._TYPE_SIGNAL)
        GlobalEnum.VariantOperator._OP_NOT_EQUAL
        (funptr (Signal.typ @-> Signal.typ @-> Bool.typ @-> returning void))

    let _Signal_elem_Dictionary =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_SIGNAL
        (Some GlobalEnum.VariantType._TYPE_DICTIONARY)
        GlobalEnum.VariantOperator._OP_IN
        (funptr (Signal.typ @-> Dictionary.typ @-> Bool.typ @-> returning void))

    let _Signal_elem_Array =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_SIGNAL
        (Some GlobalEnum.VariantType._TYPE_ARRAY)
        GlobalEnum.VariantOperator._OP_IN
        (funptr (Signal.typ @-> Array.typ @-> Bool.typ @-> returning void))
  end

  module Dictionary = struct
    include M.Dictionary

    (** Returns the number of entries in the dictionary. Empty dictionaries ([code]{ }[/code]) always return [code]0[/code]. See also [method is_empty]. *)
    let size =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_DICTIONARY "size"
        (Base.Int64.of_string "3173160232")
        (Dictionary.typ @-> returning Int.typ)
        Int.s

    (** Returns [code]true[/code] if the dictionary is empty (its size is [code]0[/code]). See also [method size]. *)
    let is_empty =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_DICTIONARY "is_empty"
        (Base.Int64.of_string "3918633141")
        (Dictionary.typ @-> returning Bool.typ)
        Bool.s

    (** Clears the dictionary, removing all entries from it. *)
    let clear =
      foreign_builtin_method0_void GlobalEnum.VariantType._TYPE_DICTIONARY
        "clear"
        (Base.Int64.of_string "3218959716")
        (Dictionary.typ @-> returning Void.typ)
        Void.s

    (** Adds entries from [param dictionary] to this dictionary. By default, duplicate keys are not copied over, unless [param overwrite] is [code]true[/code].
[codeblocks]
[gdscript]
var dict = { ""item"": ""sword"", ""quantity"": 2 }
var other_dict = { ""quantity"": 15, ""color"": ""silver"" }

# Overwriting of existing keys is disabled by default.
dict.merge(other_dict)
print(dict)  # { ""item"": ""sword"", ""quantity"": 2, ""color"": ""silver"" }

# With overwriting of existing keys enabled.
dict.merge(other_dict, true)
print(dict)  # { ""item"": ""sword"", ""quantity"": 15, ""color"": ""silver"" }
[/gdscript]
[csharp]
var dict = new Godot.Collections.Dictionary
{
    [""item""] = ""sword"",
    [""quantity""] = 2,
};

var otherDict = new Godot.Collections.Dictionary
{
    [""quantity""] = 15,
    [""color""] = ""silver"",
};

// Overwriting of existing keys is disabled by default.
dict.Merge(otherDict);
GD.Print(dict); // { ""item"": ""sword"", ""quantity"": 2, ""color"": ""silver"" }

// With overwriting of existing keys enabled.
dict.Merge(otherDict, true);
GD.Print(dict); // { ""item"": ""sword"", ""quantity"": 15, ""color"": ""silver"" }
[/csharp]
[/codeblocks]
[b]Note:[/b] [method merge] is [i]not[/i] recursive. Nested dictionaries are considered as keys that can be overwritten or not depending on the value of [param overwrite], but they will never be merged together. *)
    let merge =
      foreign_builtin_method2_void GlobalEnum.VariantType._TYPE_DICTIONARY
        "merge"
        (Base.Int64.of_string "2079548978")
        (Dictionary.typ @-> Bool.typ @-> Dictionary.typ @-> returning Void.typ)
        Void.s

    (** Returns [code]true[/code] if the dictionary contains an entry with the given [param key].
[codeblocks]
[gdscript]
var my_dict = {
    ""Godot"" : 4,
    210 : null,
}

print(my_dict.has(""Godot"")) # Prints true
print(my_dict.has(210))     # Prints true
print(my_dict.has(4))       # Prints false
[/gdscript]
[csharp]
var myDict = new Godot.Collections.Dictionary
{
    { ""Godot"", 4 },
    { 210, default },
};

GD.Print(myDict.ContainsKey(""Godot"")); // Prints true
GD.Print(myDict.ContainsKey(210));     // Prints true
GD.Print(myDict.ContainsKey(4));       // Prints false
[/csharp]
[/codeblocks]
In GDScript, this is equivalent to the [code]in[/code] operator:
[codeblock]
if ""Godot"" in {""Godot"": 4}:
    print(""The key is here!"") # Will be printed.
[/codeblock]
[b]Note:[/b] This method returns [code]true[/code] as long as the [param key] exists, even if its corresponding value is [code]null[/code]. *)
    let has =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_DICTIONARY "has"
        (Base.Int64.of_string "3680194679")
        (Variant.typ @-> Dictionary.typ @-> returning Bool.typ)
        Bool.s

    (** Returns [code]true[/code] if the dictionary contains all keys in the given [param keys] array.
[codeblock]
var data = {""width"" : 10, ""height"" : 20}
data.has_all([""height"", ""width""]) # Returns true
[/codeblock] *)
    let has_all =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_DICTIONARY "has_all"
        (Base.Int64.of_string "2988181878")
        (Array.typ @-> Dictionary.typ @-> returning Bool.typ)
        Bool.s

    (** Finds and returns the first key whose associated value is equal to [param value], or [code]null[/code] if it is not found.
[b]Note:[/b] [code]null[/code] is also a valid key. If inside the dictionary, [method find_key] may give misleading results. *)
    let find_key =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_DICTIONARY "find_key"
        (Base.Int64.of_string "1988825835")
        (Variant.typ @-> Dictionary.typ @-> returning Variant.typ)
        Variant.s

    (** Removes the dictionary entry by key, if it exists. Returns [code]true[/code] if the given [param key] existed in the dictionary, otherwise [code]false[/code].
[b]Note:[/b] Do not erase entries while iterating over the dictionary. You can iterate over the [method keys] array instead. *)
    let erase =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_DICTIONARY "erase"
        (Base.Int64.of_string "1776646889")
        (Variant.typ @-> Dictionary.typ @-> returning Bool.typ)
        Bool.s

    (** Returns a hashed 32-bit integer value representing the dictionary contents.
[codeblocks]
[gdscript]
var dict1 = {""A"": 10, ""B"": 2}
var dict2 = {""A"": 10, ""B"": 2}

print(dict1.hash() == dict2.hash()) # Prints true
[/gdscript]
[csharp]
var dict1 = new Godot.Collections.Dictionary{{""A"", 10}, {""B"", 2}};
var dict2 = new Godot.Collections.Dictionary{{""A"", 10}, {""B"", 2}};

// Godot.Collections.Dictionary has no Hash() method. Use GD.Hash() instead.
GD.Print(GD.Hash(dict1) == GD.Hash(dict2)); // Prints true
[/csharp]
[/codeblocks]
[b]Note:[/b] Dictionaries with the same entries but in a different order will not have the same hash.
[b]Note:[/b] Dictionaries with equal hash values are [i]not[/i] guaranteed to be the same, because of hash collisions. On the contrary, dictionaries with different hash values are guaranteed to be different. *)
    let hash =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_DICTIONARY "hash"
        (Base.Int64.of_string "3173160232")
        (Dictionary.typ @-> returning Int.typ)
        Int.s

    (** Returns the list of keys in the dictionary. *)
    let keys =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_DICTIONARY "keys"
        (Base.Int64.of_string "4144163970")
        (Dictionary.typ @-> returning Array.typ)
        Array.s

    (** Returns the list of values in this dictionary. *)
    let values =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_DICTIONARY "values"
        (Base.Int64.of_string "4144163970")
        (Dictionary.typ @-> returning Array.typ)
        Array.s

    (** Creates and returns a new copy of the dictionary. If [param deep] is [code]true[/code], inner [Dictionary] and [Array] keys and values are also copied, recursively. *)
    let duplicate =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_DICTIONARY
        "duplicate"
        (Base.Int64.of_string "830099069")
        (Bool.typ @-> Dictionary.typ @-> returning Dictionary.typ)
        Dictionary.s

    (** Returns the corresponding value for the given [param key] in the dictionary. If the [param key] does not exist, returns [param default], or [code]null[/code] if the parameter is omitted. *)
    let get =
      foreign_builtin_method2 GlobalEnum.VariantType._TYPE_DICTIONARY "get"
        (Base.Int64.of_string "2205440559")
        (Variant.typ @-> Variant.typ @-> Dictionary.typ
       @-> returning Variant.typ)
        Variant.s

    (** Makes the dictionary read-only, i.e. disables modification of the dictionary's contents. Does not apply to nested content, e.g. content of nested dictionaries. *)
    let make_read_only =
      foreign_builtin_method0_void GlobalEnum.VariantType._TYPE_DICTIONARY
        "make_read_only"
        (Base.Int64.of_string "3218959716")
        (Dictionary.typ @-> returning Void.typ)
        Void.s

    (** Returns [code]true[/code] if the dictionary is read-only. See [method make_read_only]. Dictionaries are automatically read-only if declared with [code]const[/code] keyword. *)
    let is_read_only =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_DICTIONARY
        "is_read_only"
        (Base.Int64.of_string "3918633141")
        (Dictionary.typ @-> returning Bool.typ)
        Bool.s

    let not =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_DICTIONARY None
        GlobalEnum.VariantOperator._OP_NOT
        (funptr
           (Dictionary.typ @-> Dictionary.typ @-> Bool.typ @-> returning void))

    (** Returns [code]true[/code] if the two dictionaries contain the same keys and values. The order of the entries does not matter.
[b]Note:[/b] In C#, by convention, this operator compares by [b]reference[/b]. If you need to compare by value, iterate over both dictionaries. *)
    let ( = ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_DICTIONARY
        (Some GlobalEnum.VariantType._TYPE_DICTIONARY)
        GlobalEnum.VariantOperator._OP_EQUAL
        (funptr
           (Dictionary.typ @-> Dictionary.typ @-> Bool.typ @-> returning void))

    (** Returns [code]true[/code] if the two dictionaries do not contain the same keys and values. *)
    let ( <> ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_DICTIONARY
        (Some GlobalEnum.VariantType._TYPE_DICTIONARY)
        GlobalEnum.VariantOperator._OP_NOT_EQUAL
        (funptr
           (Dictionary.typ @-> Dictionary.typ @-> Bool.typ @-> returning void))

    let _Dictionary_elem_Dictionary =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_DICTIONARY
        (Some GlobalEnum.VariantType._TYPE_DICTIONARY)
        GlobalEnum.VariantOperator._OP_IN
        (funptr
           (Dictionary.typ @-> Dictionary.typ @-> Bool.typ @-> returning void))

    let _Dictionary_elem_Array =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_DICTIONARY
        (Some GlobalEnum.VariantType._TYPE_ARRAY)
        GlobalEnum.VariantOperator._OP_IN
        (funptr (Dictionary.typ @-> Array.typ @-> Bool.typ @-> returning void))
  end

  module Array = struct
    include M.Array

    (** Returns the number of elements in the array. *)
    let size =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_ARRAY "size"
        (Base.Int64.of_string "3173160232")
        (Array.typ @-> returning Int.typ)
        Int.s

    (** Returns [code]true[/code] if the array is empty. *)
    let is_empty =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_ARRAY "is_empty"
        (Base.Int64.of_string "3918633141")
        (Array.typ @-> returning Bool.typ)
        Bool.s

    (** Clears the array. This is equivalent to using [method resize] with a size of [code]0[/code]. *)
    let clear =
      foreign_builtin_method0_void GlobalEnum.VariantType._TYPE_ARRAY "clear"
        (Base.Int64.of_string "3218959716")
        (Array.typ @-> returning Void.typ)
        Void.s

    (** Returns a hashed 32-bit integer value representing the array and its contents.
[b]Note:[/b] [Array]s with equal content will always produce identical hash values. However, the reverse is not true. Returning identical hash values does [i]not[/i] imply the arrays are equal, because different arrays can have identical hash values due to hash collisions. *)
    let hash =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_ARRAY "hash"
        (Base.Int64.of_string "3173160232")
        (Array.typ @-> returning Int.typ)
        Int.s

    (** Assigns elements of another [param array] into the array. Resizes the array to match [param array]. Performs type conversions if the array is typed. *)
    let assign =
      foreign_builtin_method1_void GlobalEnum.VariantType._TYPE_ARRAY "assign"
        (Base.Int64.of_string "2307260970")
        (Array.typ @-> Array.typ @-> returning Void.typ)
        Void.s

    (** Appends an element at the end of the array. See also [method push_front]. *)
    let push_back =
      foreign_builtin_method1_void GlobalEnum.VariantType._TYPE_ARRAY
        "push_back"
        (Base.Int64.of_string "3316032543")
        (Variant.typ @-> Array.typ @-> returning Void.typ)
        Void.s

    (** Adds an element at the beginning of the array. See also [method push_back].
[b]Note:[/b] On large arrays, this method is much slower than [method push_back] as it will reindex all the array's elements every time it's called. The larger the array, the slower [method push_front] will be. *)
    let push_front =
      foreign_builtin_method1_void GlobalEnum.VariantType._TYPE_ARRAY
        "push_front"
        (Base.Int64.of_string "3316032543")
        (Variant.typ @-> Array.typ @-> returning Void.typ)
        Void.s

    (** Appends an element at the end of the array (alias of [method push_back]). *)
    let append =
      foreign_builtin_method1_void GlobalEnum.VariantType._TYPE_ARRAY "append"
        (Base.Int64.of_string "3316032543")
        (Variant.typ @-> Array.typ @-> returning Void.typ)
        Void.s

    (** Appends another array at the end of this array.
[codeblock]
var array1 = [1, 2, 3]
var array2 = [4, 5, 6]
array1.append_array(array2)
print(array1) # Prints [1, 2, 3, 4, 5, 6].
[/codeblock] *)
    let append_array =
      foreign_builtin_method1_void GlobalEnum.VariantType._TYPE_ARRAY
        "append_array"
        (Base.Int64.of_string "2307260970")
        (Array.typ @-> Array.typ @-> returning Void.typ)
        Void.s

    (** Resizes the array to contain a different number of elements. If the array size is smaller, elements are cleared, if bigger, new elements are [code]null[/code]. Returns [constant OK] on success, or one of the other [enum Error] values if the operation failed.
Calling [method resize] once and assigning the new values is faster than adding new elements one by one.
[b]Note:[/b] This method acts in-place and doesn't return a modified array. *)
    let resize =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_ARRAY "resize"
        (Base.Int64.of_string "848867239")
        (Int.typ @-> Array.typ @-> returning Int.typ)
        Int.s

    (** Inserts a new element at a given position in the array. The position must be valid, or at the end of the array ([code]pos == size()[/code]). Returns [constant OK] on success, or one of the other [enum Error] values if the operation failed.
[b]Note:[/b] This method acts in-place and doesn't return a modified array.
[b]Note:[/b] On large arrays, this method will be slower if the inserted element is close to the beginning of the array (index 0). This is because all elements placed after the newly inserted element have to be reindexed. *)
    let insert =
      foreign_builtin_method2 GlobalEnum.VariantType._TYPE_ARRAY "insert"
        (Base.Int64.of_string "3176316662")
        (Int.typ @-> Variant.typ @-> Array.typ @-> returning Int.typ)
        Int.s

    (** Removes an element from the array by index. If the index does not exist in the array, nothing happens. To remove an element by searching for its value, use [method erase] instead.
[b]Note:[/b] This method acts in-place and doesn't return a modified array.
[b]Note:[/b] On large arrays, this method will be slower if the removed element is close to the beginning of the array (index 0). This is because all elements placed after the removed element have to be reindexed.
[b]Note:[/b] [param position] cannot be negative. To remove an element relative to the end of the array, use [code]arr.remove_at(arr.size() - (i + 1))[/code]. To remove the last element from the array without returning the value, use [code]arr.resize(arr.size() - 1)[/code]. *)
    let remove_at =
      foreign_builtin_method1_void GlobalEnum.VariantType._TYPE_ARRAY
        "remove_at"
        (Base.Int64.of_string "2823966027")
        (Int.typ @-> Array.typ @-> returning Void.typ)
        Void.s

    (** Assigns the given value to all elements in the array. This can typically be used together with [method resize] to create an array with a given size and initialized elements:
[codeblocks]
[gdscript]
var array = []
array.resize(10)
array.fill(0) # Initialize the 10 elements to 0.
[/gdscript]
[csharp]
var array = new Godot.Collections.Array();
array.Resize(10);
array.Fill(0); // Initialize the 10 elements to 0.
[/csharp]
[/codeblocks]
[b]Note:[/b] If [param value] is of a reference type ([Object]-derived, [Array], [Dictionary], etc.) then the array is filled with the references to the same object, i.e. no duplicates are created. *)
    let fill =
      foreign_builtin_method1_void GlobalEnum.VariantType._TYPE_ARRAY "fill"
        (Base.Int64.of_string "3316032543")
        (Variant.typ @-> Array.typ @-> returning Void.typ)
        Void.s

    (** Removes the first occurrence of a value from the array. If the value does not exist in the array, nothing happens. To remove an element by index, use [method remove_at] instead.
[b]Note:[/b] This method acts in-place and doesn't return a modified array.
[b]Note:[/b] On large arrays, this method will be slower if the removed element is close to the beginning of the array (index 0). This is because all elements placed after the removed element have to be reindexed.
[b]Note:[/b] Do not erase entries while iterating over the array. *)
    let erase =
      foreign_builtin_method1_void GlobalEnum.VariantType._TYPE_ARRAY "erase"
        (Base.Int64.of_string "3316032543")
        (Variant.typ @-> Array.typ @-> returning Void.typ)
        Void.s

    (** Returns the first element of the array. Prints an error and returns [code]null[/code] if the array is empty.
[b]Note:[/b] Calling this function is not the same as writing [code]array[0][/code]. If the array is empty, accessing by index will pause project execution when running from the editor. *)
    let front =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_ARRAY "front"
        (Base.Int64.of_string "1460142086")
        (Array.typ @-> returning Variant.typ)
        Variant.s

    (** Returns the last element of the array. Prints an error and returns [code]null[/code] if the array is empty.
[b]Note:[/b] Calling this function is not the same as writing [code]array[-1][/code]. If the array is empty, accessing by index will pause project execution when running from the editor. *)
    let back =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_ARRAY "back"
        (Base.Int64.of_string "1460142086")
        (Array.typ @-> returning Variant.typ)
        Variant.s

    (** Returns a random value from the target array. Prints an error and returns [code]null[/code] if the array is empty.
[codeblocks]
[gdscript]
var array: Array[int] = [1, 2, 3, 4]
print(array.pick_random())  # Prints either of the four numbers.
[/gdscript]
[csharp]
var array = new Godot.Collections.Array { 1, 2, 3, 4 };
GD.Print(array.PickRandom()); // Prints either of the four numbers.
[/csharp]
[/codeblocks] *)
    let pick_random =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_ARRAY "pick_random"
        (Base.Int64.of_string "1460142086")
        (Array.typ @-> returning Variant.typ)
        Variant.s

    (** Searches the array for a value and returns its index or [code]-1[/code] if not found. Optionally, the initial search index can be passed. *)
    let find =
      foreign_builtin_method2 GlobalEnum.VariantType._TYPE_ARRAY "find"
        (Base.Int64.of_string "2336346817")
        (Variant.typ @-> Int.typ @-> Array.typ @-> returning Int.typ)
        Int.s

    (** Searches the array in reverse order. Optionally, a start search index can be passed. If negative, the start index is considered relative to the end of the array. *)
    let rfind =
      foreign_builtin_method2 GlobalEnum.VariantType._TYPE_ARRAY "rfind"
        (Base.Int64.of_string "2336346817")
        (Variant.typ @-> Int.typ @-> Array.typ @-> returning Int.typ)
        Int.s

    (** Returns the number of times an element is in the array. *)
    let count =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_ARRAY "count"
        (Base.Int64.of_string "1481661226")
        (Variant.typ @-> Array.typ @-> returning Int.typ)
        Int.s

    (** Returns [code]true[/code] if the array contains the given value.
[codeblocks]
[gdscript]
print([""inside"", 7].has(""inside"")) # True
print([""inside"", 7].has(""outside"")) # False
print([""inside"", 7].has(7)) # True
print([""inside"", 7].has(""7"")) # False
[/gdscript]
[csharp]
var arr = new Godot.Collections.Array { ""inside"", 7 };
// has is renamed to Contains
GD.Print(arr.Contains(""inside"")); // True
GD.Print(arr.Contains(""outside"")); // False
GD.Print(arr.Contains(7)); // True
GD.Print(arr.Contains(""7"")); // False
[/csharp]
[/codeblocks]
[b]Note:[/b] This is equivalent to using the [code]in[/code] operator as follows:
[codeblocks]
[gdscript]
# Will evaluate to `true`.
if 2 in [2, 4, 6, 8]:
    print(""Contains!"")
[/gdscript]
[csharp]
// As there is no ""in"" keyword in C#, you have to use Contains
var array = new Godot.Collections.Array { 2, 4, 6, 8 };
if (array.Contains(2))
{
    GD.Print(""Contains!"");
}
[/csharp]
[/codeblocks] *)
    let has =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_ARRAY "has"
        (Base.Int64.of_string "3680194679")
        (Variant.typ @-> Array.typ @-> returning Bool.typ)
        Bool.s

    (** Removes and returns the last element of the array. Returns [code]null[/code] if the array is empty, without printing an error message. See also [method pop_front]. *)
    let pop_back =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_ARRAY "pop_back"
        (Base.Int64.of_string "1321915136")
        (Array.typ @-> returning Variant.typ)
        Variant.s

    (** Removes and returns the first element of the array. Returns [code]null[/code] if the array is empty, without printing an error message. See also [method pop_back].
[b]Note:[/b] On large arrays, this method is much slower than [method pop_back] as it will reindex all the array's elements every time it's called. The larger the array, the slower [method pop_front] will be. *)
    let pop_front =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_ARRAY "pop_front"
        (Base.Int64.of_string "1321915136")
        (Array.typ @-> returning Variant.typ)
        Variant.s

    (** Removes and returns the element of the array at index [param position]. If negative, [param position] is considered relative to the end of the array. Leaves the array unchanged and returns [code]null[/code] if the array is empty or if it's accessed out of bounds. An error message is printed when the array is accessed out of bounds, but not when the array is empty.
[b]Note:[/b] On large arrays, this method can be slower than [method pop_back] as it will reindex the array's elements that are located after the removed element. The larger the array and the lower the index of the removed element, the slower [method pop_at] will be. *)
    let pop_at =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_ARRAY "pop_at"
        (Base.Int64.of_string "3518259424")
        (Int.typ @-> Array.typ @-> returning Variant.typ)
        Variant.s

    (** Sorts the array.
[b]Note:[/b] The sorting algorithm used is not [url=https://en.wikipedia.org/wiki/Sorting_algorithm#Stability]stable[/url]. This means that values considered equal may have their order changed when using [method sort].
[b]Note:[/b] Strings are sorted in alphabetical order (as opposed to natural order). This may lead to unexpected behavior when sorting an array of strings ending with a sequence of numbers. Consider the following example:
[codeblocks]
[gdscript]
var strings = [""string1"", ""string2"", ""string10"", ""string11""]
strings.sort()
print(strings) # Prints [string1, string10, string11, string2]
[/gdscript]
[csharp]
var strings = new Godot.Collections.Array { ""string1"", ""string2"", ""string10"", ""string11"" };
strings.Sort();
GD.Print(strings); // Prints [string1, string10, string11, string2]
[/csharp]
[/codeblocks]
To perform natural order sorting, you can use [method sort_custom] with [method String.naturalnocasecmp_to] as follows:
[codeblock]
var strings = [""string1"", ""string2"", ""string10"", ""string11""]
strings.sort_custom(func(a, b): return a.naturalnocasecmp_to(b) < 0)
print(strings) # Prints [string1, string2, string10, string11]
[/codeblock] *)
    let sort =
      foreign_builtin_method0_void GlobalEnum.VariantType._TYPE_ARRAY "sort"
        (Base.Int64.of_string "3218959716")
        (Array.typ @-> returning Void.typ)
        Void.s

    (** Sorts the array using a custom method. The custom method receives two arguments (a pair of elements from the array) and must return either [code]true[/code] or [code]false[/code]. For two elements [code]a[/code] and [code]b[/code], if the given method returns [code]true[/code], element [code]b[/code] will be after element [code]a[/code] in the array.
[b]Note:[/b] The sorting algorithm used is not [url=https://en.wikipedia.org/wiki/Sorting_algorithm#Stability]stable[/url]. This means that values considered equal may have their order changed when using [method sort_custom].
[b]Note:[/b] You cannot randomize the return value as the heapsort algorithm expects a deterministic result. Randomizing the return value will result in unexpected behavior.
[codeblocks]
[gdscript]
func sort_ascending(a, b):
    if a[0] < b[0]:
        return true
    return false

func _ready():
    var my_items = [[5, ""Potato""], [9, ""Rice""], [4, ""Tomato""]]
    my_items.sort_custom(sort_ascending)
    print(my_items) # Prints [[4, Tomato], [5, Potato], [9, Rice]].

    # Descending, lambda version.
    my_items.sort_custom(func(a, b): return a[0] > b[0])
    print(my_items) # Prints [[9, Rice], [5, Potato], [4, Tomato]].
[/gdscript]
[csharp]
// There is no custom sort support for Godot.Collections.Array
[/csharp]
[/codeblocks] *)
    let sort_custom =
      foreign_builtin_method1_void GlobalEnum.VariantType._TYPE_ARRAY
        "sort_custom"
        (Base.Int64.of_string "3470848906")
        (Callable.typ @-> Array.typ @-> returning Void.typ)
        Void.s

    (** Shuffles the array such that the items will have a random order. This method uses the global random number generator common to methods such as [method @GlobalScope.randi]. Call [method @GlobalScope.randomize] to ensure that a new seed will be used each time if you want non-reproducible shuffling. *)
    let shuffle =
      foreign_builtin_method0_void GlobalEnum.VariantType._TYPE_ARRAY "shuffle"
        (Base.Int64.of_string "3218959716")
        (Array.typ @-> returning Void.typ)
        Void.s

    (** Finds the index of an existing value (or the insertion index that maintains sorting order, if the value is not yet present in the array) using binary search. Optionally, a [param before] specifier can be passed. If [code]false[/code], the returned index comes after all existing entries of the value in the array.
[codeblock]
var array = [""a"", ""b"", ""c"", ""c"", ""d"", ""e""]
print(array.bsearch(""c"", true))  # Prints 2, at the first matching element.
print(array.bsearch(""c"", false)) # Prints 4, after the last matching element, pointing to ""d"".
[/codeblock]
[b]Note:[/b] Calling [method bsearch] on an unsorted array results in unexpected behavior. *)
    let bsearch =
      foreign_builtin_method2 GlobalEnum.VariantType._TYPE_ARRAY "bsearch"
        (Base.Int64.of_string "3372222236")
        (Variant.typ @-> Bool.typ @-> Array.typ @-> returning Int.typ)
        Int.s

    (** Finds the index of an existing value (or the insertion index that maintains sorting order, if the value is not yet present in the array) using binary search and a custom comparison method. Optionally, a [param before] specifier can be passed. If [code]false[/code], the returned index comes after all existing entries of the value in the array. The custom method receives two arguments (an element from the array and the value searched for) and must return [code]true[/code] if the first argument is less than the second, and return [code]false[/code] otherwise.
[b]Note:[/b] The custom method must accept the two arguments in any order, you cannot rely on that the first argument will always be from the array.
[b]Note:[/b] Calling [method bsearch_custom] on an unsorted array results in unexpected behavior. *)
    let bsearch_custom =
      foreign_builtin_method3 GlobalEnum.VariantType._TYPE_ARRAY
        "bsearch_custom"
        (Base.Int64.of_string "161317131")
        (Variant.typ @-> Callable.typ @-> Bool.typ @-> Array.typ
       @-> returning Int.typ)
        Int.s

    (** Reverses the order of the elements in the array. *)
    let reverse =
      foreign_builtin_method0_void GlobalEnum.VariantType._TYPE_ARRAY "reverse"
        (Base.Int64.of_string "3218959716")
        (Array.typ @-> returning Void.typ)
        Void.s

    (** Returns a copy of the array.
If [param deep] is [code]true[/code], a deep copy is performed: all nested arrays and dictionaries are duplicated and will not be shared with the original array. If [code]false[/code], a shallow copy is made and references to the original nested arrays and dictionaries are kept, so that modifying a sub-array or dictionary in the copy will also impact those referenced in the source array. Note that any [Object]-derived elements will be shallow copied regardless of the [param deep] setting. *)
    let duplicate =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_ARRAY "duplicate"
        (Base.Int64.of_string "636440122")
        (Bool.typ @-> Array.typ @-> returning Array.typ)
        Array.s

    (** Returns the slice of the [Array], from [param begin] (inclusive) to [param end] (exclusive), as a new [Array].
The absolute value of [param begin] and [param end] will be clamped to the array size, so the default value for [param end] makes it slice to the size of the array by default (i.e. [code]arr.slice(1)[/code] is a shorthand for [code]arr.slice(1, arr.size())[/code]).
If either [param begin] or [param end] are negative, they will be relative to the end of the array (i.e. [code]arr.slice(0, -2)[/code] is a shorthand for [code]arr.slice(0, arr.size() - 2)[/code]).
If specified, [param step] is the relative index between source elements. It can be negative, then [param begin] must be higher than [param end]. For example, [code][0, 1, 2, 3, 4, 5].slice(5, 1, -2)[/code] returns [code][5, 3][/code].
If [param deep] is true, each element will be copied by value rather than by reference.
[b]Note:[/b] To include the first element when [param step] is negative, use [code]arr.slice(begin, -arr.size() - 1, step)[/code] (i.e. [code][0, 1, 2].slice(1, -4, -1)[/code] returns [code][1, 0][/code]). *)
    let slice =
      foreign_builtin_method4 GlobalEnum.VariantType._TYPE_ARRAY "slice"
        (Base.Int64.of_string "1393718243")
        (Int.typ @-> Int.typ @-> Int.typ @-> Bool.typ @-> Array.typ
       @-> returning Array.typ)
        Array.s

    (** Calls the provided [Callable] on each element in the array and returns a new array with the elements for which the method returned [code]true[/code].
The callable's method should take one [Variant] parameter (the current array element) and return a boolean value.
[codeblock]
func _ready():
    print([1, 2, 3].filter(remove_1)) # Prints [2, 3].
    print([1, 2, 3].filter(func(number): return number != 1)) # Same as above, but using lambda function.

func remove_1(number):
    return number != 1
[/codeblock]
See also [method any], [method all], [method map] and [method reduce]. *)
    let filter =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_ARRAY "filter"
        (Base.Int64.of_string "4075186556")
        (Callable.typ @-> Array.typ @-> returning Array.typ)
        Array.s

    (** Calls the provided [Callable] for each element in the array and returns a new array filled with values returned by the method.
The callable's method should take one [Variant] parameter (the current array element) and can return any [Variant].
[codeblock]
func _ready():
    print([1, 2, 3].map(negate)) # Prints [-1, -2, -3].
    print([1, 2, 3].map(func(number): return -number)) # Same as above, but using lambda function.

func negate(number):
    return -number
[/codeblock]
See also [method filter], [method reduce], [method any] and [method all]. *)
    let map =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_ARRAY "map"
        (Base.Int64.of_string "4075186556")
        (Callable.typ @-> Array.typ @-> returning Array.typ)
        Array.s

    (** Calls the provided [Callable] for each element in array and accumulates the result in [param accum].
The callable's method takes two arguments: the current value of [param accum] and the current array element. If [param accum] is [code]null[/code] (default value), the iteration will start from the second element, with the first one used as initial value of [param accum].
[codeblock]
func _ready():
    print([1, 2, 3].reduce(sum, 10)) # Prints 16.
    print([1, 2, 3].reduce(func(accum, number): return accum + number, 10)) # Same as above, but using lambda function.

func sum(accum, number):
    return accum + number
[/codeblock]
See also [method map], [method filter], [method any] and [method all]. *)
    let reduce =
      foreign_builtin_method2 GlobalEnum.VariantType._TYPE_ARRAY "reduce"
        (Base.Int64.of_string "4272450342")
        (Callable.typ @-> Variant.typ @-> Array.typ @-> returning Variant.typ)
        Variant.s

    (** Calls the provided [Callable] on each element in the array and returns [code]true[/code] if the [Callable] returns [code]true[/code] for [i]one or more[/i] elements in the array. If the [Callable] returns [code]false[/code] for all elements in the array, this method returns [code]false[/code].
The callable's method should take one [Variant] parameter (the current array element) and return a boolean value.
[codeblock]
func _ready():
    print([6, 10, 6].any(greater_than_5))  # Prints True (3 elements evaluate to `true`).
    print([4, 10, 4].any(greater_than_5))  # Prints True (1 elements evaluate to `true`).
    print([4, 4, 4].any(greater_than_5))  # Prints False (0 elements evaluate to `true`).
    print([].any(greater_than_5))  # Prints False (0 elements evaluate to `true`).

    print([6, 10, 6].any(func(number): return number > 5))  # Prints True. Same as the first line above, but using lambda function.

func greater_than_5(number):
    return number > 5
[/codeblock]
See also [method all], [method filter], [method map] and [method reduce].
[b]Note:[/b] Unlike relying on the size of an array returned by [method filter], this method will return as early as possible to improve performance (especially with large arrays).
[b]Note:[/b] For an empty array, this method always returns [code]false[/code]. *)
    let any =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_ARRAY "any"
        (Base.Int64.of_string "4129521963")
        (Callable.typ @-> Array.typ @-> returning Bool.typ)
        Bool.s

    (** Calls the provided [Callable] on each element in the array and returns [code]true[/code] if the [Callable] returns [code]true[/code] for [i]all[/i] elements in the array. If the [Callable] returns [code]false[/code] for one array element or more, this method returns [code]false[/code].
The callable's method should take one [Variant] parameter (the current array element) and return a boolean value.
[codeblock]
func _ready():
    print([6, 10, 6].all(greater_than_5))  # Prints True (3/3 elements evaluate to `true`).
    print([4, 10, 4].all(greater_than_5))  # Prints False (1/3 elements evaluate to `true`).
    print([4, 4, 4].all(greater_than_5))  # Prints False (0/3 elements evaluate to `true`).
    print([].all(greater_than_5))  # Prints True (0/0 elements evaluate to `true`).

    print([6, 10, 6].all(func(number): return number > 5))  # Prints True. Same as the first line above, but using lambda function.

func greater_than_5(number):
    return number > 5
[/codeblock]
See also [method any], [method filter], [method map] and [method reduce].
[b]Note:[/b] Unlike relying on the size of an array returned by [method filter], this method will return as early as possible to improve performance (especially with large arrays).
[b]Note:[/b] For an empty array, this method [url=https://en.wikipedia.org/wiki/Vacuous_truth]always[/url] returns [code]true[/code]. *)
    let all =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_ARRAY "all"
        (Base.Int64.of_string "4129521963")
        (Callable.typ @-> Array.typ @-> returning Bool.typ)
        Bool.s

    (** Returns the maximum value contained in the array if all elements are of comparable types. If the elements can't be compared, [code]null[/code] is returned.
To find the maximum value using a custom comparator, you can use [method reduce]. In this example every array element is checked and the first maximum value is returned:
[codeblock]
func _ready():
    var arr = [Vector2(0, 1), Vector2(2, 0), Vector2(1, 1), Vector2(1, 0), Vector2(0, 2)]
    # In this example we compare the lengths.
    print(arr.reduce(func(max, val): return val if is_length_greater(val, max) else max))

func is_length_greater(a, b):
    return a.length() > b.length()
[/codeblock] *)
    let max =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_ARRAY "max"
        (Base.Int64.of_string "1460142086")
        (Array.typ @-> returning Variant.typ)
        Variant.s

    (** Returns the minimum value contained in the array if all elements are of comparable types. If the elements can't be compared, [code]null[/code] is returned.
See also [method max] for an example of using a custom comparator. *)
    let min =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_ARRAY "min"
        (Base.Int64.of_string "1460142086")
        (Array.typ @-> returning Variant.typ)
        Variant.s

    (** Returns [code]true[/code] if the array is typed. Typed arrays can only store elements of their associated type and provide type safety for the [code][][/code] operator. Methods of typed array still return [Variant]. *)
    let is_typed =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_ARRAY "is_typed"
        (Base.Int64.of_string "3918633141")
        (Array.typ @-> returning Bool.typ)
        Bool.s

    (** Returns [code]true[/code] if the array is typed the same as [param array]. *)
    let is_same_typed =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_ARRAY "is_same_typed"
        (Base.Int64.of_string "2988181878")
        (Array.typ @-> Array.typ @-> returning Bool.typ)
        Bool.s

    (** Returns the built-in type of the typed array as a [enum Variant.Type] constant. If the array is not typed, returns [constant TYPE_NIL]. *)
    let get_typed_builtin =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_ARRAY
        "get_typed_builtin"
        (Base.Int64.of_string "3173160232")
        (Array.typ @-> returning Int.typ)
        Int.s

    (** Returns the [b]native[/b] class name of the typed array if the built-in type is [constant TYPE_OBJECT]. Otherwise, this method returns an empty string. *)
    let get_typed_class_name =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_ARRAY
        "get_typed_class_name"
        (Base.Int64.of_string "1825232092")
        (Array.typ @-> returning StringName.typ)
        StringName.s

    (** Returns the script associated with the typed array. This method returns a [Script] instance or [code]null[/code]. *)
    let get_typed_script =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_ARRAY
        "get_typed_script"
        (Base.Int64.of_string "1460142086")
        (Array.typ @-> returning Variant.typ)
        Variant.s

    (** Makes the array read-only, i.e. disabled modifying of the array's elements. Does not apply to nested content, e.g. content of nested arrays. *)
    let make_read_only =
      foreign_builtin_method0_void GlobalEnum.VariantType._TYPE_ARRAY
        "make_read_only"
        (Base.Int64.of_string "3218959716")
        (Array.typ @-> returning Void.typ)
        Void.s

    (** Returns [code]true[/code] if the array is read-only. See [method make_read_only]. Arrays are automatically read-only if declared with [code]const[/code] keyword. *)
    let is_read_only =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_ARRAY "is_read_only"
        (Base.Int64.of_string "3918633141")
        (Array.typ @-> returning Bool.typ)
        Bool.s

    let not =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_ARRAY None
        GlobalEnum.VariantOperator._OP_NOT
        (funptr (Array.typ @-> Array.typ @-> Bool.typ @-> returning void))

    let _Array_elem_Dictionary =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_ARRAY
        (Some GlobalEnum.VariantType._TYPE_DICTIONARY)
        GlobalEnum.VariantOperator._OP_IN
        (funptr (Array.typ @-> Dictionary.typ @-> Bool.typ @-> returning void))

    (** Compares the left operand [Array] against the [param right] [Array]. Returns [code]true[/code] if the sizes and contents of the arrays are equal, [code]false[/code] otherwise. *)
    let ( = ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_ARRAY
        (Some GlobalEnum.VariantType._TYPE_ARRAY)
        GlobalEnum.VariantOperator._OP_EQUAL
        (funptr (Array.typ @-> Array.typ @-> Bool.typ @-> returning void))

    (** Compares the left operand [Array] against the [param right] [Array]. Returns [code]true[/code] if the sizes or contents of the arrays are [i]not[/i] equal, [code]false[/code] otherwise. *)
    let ( <> ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_ARRAY
        (Some GlobalEnum.VariantType._TYPE_ARRAY)
        GlobalEnum.VariantOperator._OP_NOT_EQUAL
        (funptr (Array.typ @-> Array.typ @-> Bool.typ @-> returning void))

    (** Performs a comparison for each index between the left operand [Array] and the [param right] [Array], considering the highest common index of both arrays for this comparison: Returns [code]true[/code] on the first occurrence of an element that is less, or [code]false[/code] if the element is greater. Note that depending on the type of data stored, this function may be recursive. If all elements are equal, it compares the length of both arrays and returns [code]false[/code] if the left operand [Array] has fewer elements, otherwise it returns [code]true[/code]. *)
    let ( < ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_ARRAY
        (Some GlobalEnum.VariantType._TYPE_ARRAY)
        GlobalEnum.VariantOperator._OP_LESS
        (funptr (Array.typ @-> Array.typ @-> Bool.typ @-> returning void))

    (** Performs a comparison for each index between the left operand [Array] and the [param right] [Array], considering the highest common index of both arrays for this comparison: Returns [code]true[/code] on the first occurrence of an element that is less, or [code]false[/code] if the element is greater. Note that depending on the type of data stored, this function may be recursive. If all elements are equal, it compares the length of both arrays and returns [code]true[/code] if the left operand [Array] has the same number of elements or fewer, otherwise it returns [code]false[/code]. *)
    let ( <= ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_ARRAY
        (Some GlobalEnum.VariantType._TYPE_ARRAY)
        GlobalEnum.VariantOperator._OP_LESS_EQUAL
        (funptr (Array.typ @-> Array.typ @-> Bool.typ @-> returning void))

    (** Performs a comparison for each index between the left operand [Array] and the [param right] [Array], considering the highest common index of both arrays for this comparison: Returns [code]true[/code] on the first occurrence of an element that is greater, or [code]false[/code] if the element is less. Note that depending on the type of data stored, this function may be recursive. If all elements are equal, it compares the length of both arrays and returns [code]true[/code] if the [param right] [Array] has more elements, otherwise it returns [code]false[/code]. *)
    let ( > ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_ARRAY
        (Some GlobalEnum.VariantType._TYPE_ARRAY)
        GlobalEnum.VariantOperator._OP_GREATER
        (funptr (Array.typ @-> Array.typ @-> Bool.typ @-> returning void))

    (** Performs a comparison for each index between the left operand [Array] and the [param right] [Array], considering the highest common index of both arrays for this comparison: Returns [code]true[/code] on the first occurrence of an element that is greater, or [code]false[/code] if the element is less. Note that depending on the type of data stored, this function may be recursive. If all elements are equal, it compares the length of both arrays and returns [code]true[/code] if the [param right] [Array] has more or the same number of elements, otherwise it returns [code]false[/code]. *)
    let ( >= ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_ARRAY
        (Some GlobalEnum.VariantType._TYPE_ARRAY)
        GlobalEnum.VariantOperator._OP_GREATER_EQUAL
        (funptr (Array.typ @-> Array.typ @-> Bool.typ @-> returning void))

    (** Concatenates two [Array]s together, with the [param right] [Array] being added to the end of the [Array] specified in the left operand. For example, [code][1, 2] + [3, 4][/code] results in [code][1, 2, 3, 4][/code]. *)
    let ( + ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_ARRAY
        (Some GlobalEnum.VariantType._TYPE_ARRAY)
        GlobalEnum.VariantOperator._OP_ADD
        (funptr (Array.typ @-> Array.typ @-> Array.typ @-> returning void))

    let _Array_elem_Array =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_ARRAY
        (Some GlobalEnum.VariantType._TYPE_ARRAY)
        GlobalEnum.VariantOperator._OP_IN
        (funptr (Array.typ @-> Array.typ @-> Bool.typ @-> returning void))
  end

  module PackedByteArray = struct
    include M.PackedByteArray

    (** Returns the number of elements in the array. *)
    let size =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_PACKED_BYTE_ARRAY
        "size"
        (Base.Int64.of_string "3173160232")
        (PackedByteArray.typ @-> returning Int.typ)
        Int.s

    (** Returns [code]true[/code] if the array is empty. *)
    let is_empty =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_PACKED_BYTE_ARRAY
        "is_empty"
        (Base.Int64.of_string "3918633141")
        (PackedByteArray.typ @-> returning Bool.typ)
        Bool.s

    (** Changes the byte at the given index. *)
    let set =
      foreign_builtin_method2_void
        GlobalEnum.VariantType._TYPE_PACKED_BYTE_ARRAY "set"
        (Base.Int64.of_string "3638975848")
        (Int.typ @-> Int.typ @-> PackedByteArray.typ @-> returning Void.typ)
        Void.s

    (** Appends an element at the end of the array. *)
    let push_back =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_PACKED_BYTE_ARRAY
        "push_back"
        (Base.Int64.of_string "694024632")
        (Int.typ @-> PackedByteArray.typ @-> returning Bool.typ)
        Bool.s

    (** Appends an element at the end of the array (alias of [method push_back]). *)
    let append =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_PACKED_BYTE_ARRAY
        "append"
        (Base.Int64.of_string "694024632")
        (Int.typ @-> PackedByteArray.typ @-> returning Bool.typ)
        Bool.s

    (** Appends a [PackedByteArray] at the end of this array. *)
    let append_array =
      foreign_builtin_method1_void
        GlobalEnum.VariantType._TYPE_PACKED_BYTE_ARRAY "append_array"
        (Base.Int64.of_string "791097111")
        (PackedByteArray.typ @-> PackedByteArray.typ @-> returning Void.typ)
        Void.s

    (** Removes an element from the array by index. *)
    let remove_at =
      foreign_builtin_method1_void
        GlobalEnum.VariantType._TYPE_PACKED_BYTE_ARRAY "remove_at"
        (Base.Int64.of_string "2823966027")
        (Int.typ @-> PackedByteArray.typ @-> returning Void.typ)
        Void.s

    (** Inserts a new element at a given position in the array. The position must be valid, or at the end of the array ([code]idx == size()[/code]). *)
    let insert =
      foreign_builtin_method2 GlobalEnum.VariantType._TYPE_PACKED_BYTE_ARRAY
        "insert"
        (Base.Int64.of_string "1487112728")
        (Int.typ @-> Int.typ @-> PackedByteArray.typ @-> returning Int.typ)
        Int.s

    (** Assigns the given value to all elements in the array. This can typically be used together with [method resize] to create an array with a given size and initialized elements. *)
    let fill =
      foreign_builtin_method1_void
        GlobalEnum.VariantType._TYPE_PACKED_BYTE_ARRAY "fill"
        (Base.Int64.of_string "2823966027")
        (Int.typ @-> PackedByteArray.typ @-> returning Void.typ)
        Void.s

    (** Sets the size of the array. If the array is grown, reserves elements at the end of the array. If the array is shrunk, truncates the array to the new size. Calling [method resize] once and assigning the new values is faster than adding new elements one by one. *)
    let resize =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_PACKED_BYTE_ARRAY
        "resize"
        (Base.Int64.of_string "848867239")
        (Int.typ @-> PackedByteArray.typ @-> returning Int.typ)
        Int.s

    (** Clears the array. This is equivalent to using [method resize] with a size of [code]0[/code]. *)
    let clear =
      foreign_builtin_method0_void
        GlobalEnum.VariantType._TYPE_PACKED_BYTE_ARRAY "clear"
        (Base.Int64.of_string "3218959716")
        (PackedByteArray.typ @-> returning Void.typ)
        Void.s

    (** Returns [code]true[/code] if the array contains [param value]. *)
    let has =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_PACKED_BYTE_ARRAY
        "has"
        (Base.Int64.of_string "931488181")
        (Int.typ @-> PackedByteArray.typ @-> returning Bool.typ)
        Bool.s

    (** Reverses the order of the elements in the array. *)
    let reverse =
      foreign_builtin_method0_void
        GlobalEnum.VariantType._TYPE_PACKED_BYTE_ARRAY "reverse"
        (Base.Int64.of_string "3218959716")
        (PackedByteArray.typ @-> returning Void.typ)
        Void.s

    (** Returns the slice of the [PackedByteArray], from [param begin] (inclusive) to [param end] (exclusive), as a new [PackedByteArray].
The absolute value of [param begin] and [param end] will be clamped to the array size, so the default value for [param end] makes it slice to the size of the array by default (i.e. [code]arr.slice(1)[/code] is a shorthand for [code]arr.slice(1, arr.size())[/code]).
If either [param begin] or [param end] are negative, they will be relative to the end of the array (i.e. [code]arr.slice(0, -2)[/code] is a shorthand for [code]arr.slice(0, arr.size() - 2)[/code]). *)
    let slice =
      foreign_builtin_method2 GlobalEnum.VariantType._TYPE_PACKED_BYTE_ARRAY
        "slice"
        (Base.Int64.of_string "2278869132")
        (Int.typ @-> Int.typ @-> PackedByteArray.typ
        @-> returning PackedByteArray.typ)
        PackedByteArray.s

    (** Sorts the elements of the array in ascending order. *)
    let sort =
      foreign_builtin_method0_void
        GlobalEnum.VariantType._TYPE_PACKED_BYTE_ARRAY "sort"
        (Base.Int64.of_string "3218959716")
        (PackedByteArray.typ @-> returning Void.typ)
        Void.s

    (** Finds the index of an existing value (or the insertion index that maintains sorting order, if the value is not yet present in the array) using binary search. Optionally, a [param before] specifier can be passed. If [code]false[/code], the returned index comes after all existing entries of the value in the array.
[b]Note:[/b] Calling [method bsearch] on an unsorted array results in unexpected behavior. *)
    let bsearch =
      foreign_builtin_method2 GlobalEnum.VariantType._TYPE_PACKED_BYTE_ARRAY
        "bsearch"
        (Base.Int64.of_string "3380005890")
        (Int.typ @-> Bool.typ @-> PackedByteArray.typ @-> returning Int.typ)
        Int.s

    (** Creates a copy of the array, and returns it. *)
    let duplicate =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_PACKED_BYTE_ARRAY
        "duplicate"
        (Base.Int64.of_string "851781288")
        (PackedByteArray.typ @-> returning PackedByteArray.typ)
        PackedByteArray.s

    (** Searches the array for a value and returns its index or [code]-1[/code] if not found. Optionally, the initial search index can be passed. *)
    let find =
      foreign_builtin_method2 GlobalEnum.VariantType._TYPE_PACKED_BYTE_ARRAY
        "find"
        (Base.Int64.of_string "2984303840")
        (Int.typ @-> Int.typ @-> PackedByteArray.typ @-> returning Int.typ)
        Int.s

    (** Searches the array in reverse order. Optionally, a start search index can be passed. If negative, the start index is considered relative to the end of the array. *)
    let rfind =
      foreign_builtin_method2 GlobalEnum.VariantType._TYPE_PACKED_BYTE_ARRAY
        "rfind"
        (Base.Int64.of_string "2984303840")
        (Int.typ @-> Int.typ @-> PackedByteArray.typ @-> returning Int.typ)
        Int.s

    (** Returns the number of times an element is in the array. *)
    let count =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_PACKED_BYTE_ARRAY
        "count"
        (Base.Int64.of_string "4103005248")
        (Int.typ @-> PackedByteArray.typ @-> returning Int.typ)
        Int.s

    (** Converts ASCII/Latin-1 encoded array to [String]. Fast alternative to [method get_string_from_utf8] if the content is ASCII/Latin-1 only. Unlike the UTF-8 function this function maps every byte to a character in the array. Multibyte sequences will not be interpreted correctly. For parsing user input always use [method get_string_from_utf8]. This is the inverse of [method String.to_ascii_buffer]. *)
    let get_string_from_ascii =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_PACKED_BYTE_ARRAY
        "get_string_from_ascii"
        (Base.Int64.of_string "3942272618")
        (PackedByteArray.typ @-> returning String.typ)
        String.s

    (** Converts UTF-8 encoded array to [String]. Slower than [method get_string_from_ascii] but supports UTF-8 encoded data. Use this function if you are unsure about the source of the data. For user input this function should always be preferred. Returns empty string if source array is not valid UTF-8 string. This is the inverse of [method String.to_utf8_buffer]. *)
    let get_string_from_utf8 =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_PACKED_BYTE_ARRAY
        "get_string_from_utf8"
        (Base.Int64.of_string "3942272618")
        (PackedByteArray.typ @-> returning String.typ)
        String.s

    (** Converts UTF-16 encoded array to [String]. If the BOM is missing, system endianness is assumed. Returns empty string if source array is not valid UTF-16 string. This is the inverse of [method String.to_utf16_buffer]. *)
    let get_string_from_utf16 =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_PACKED_BYTE_ARRAY
        "get_string_from_utf16"
        (Base.Int64.of_string "3942272618")
        (PackedByteArray.typ @-> returning String.typ)
        String.s

    (** Converts UTF-32 encoded array to [String]. System endianness is assumed. Returns empty string if source array is not valid UTF-32 string. This is the inverse of [method String.to_utf32_buffer]. *)
    let get_string_from_utf32 =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_PACKED_BYTE_ARRAY
        "get_string_from_utf32"
        (Base.Int64.of_string "3942272618")
        (PackedByteArray.typ @-> returning String.typ)
        String.s

    (** Converts wide character ([code]wchar_t[/code], UTF-16 on Windows, UTF-32 on other platforms) encoded array to [String]. Returns empty string if source array is not valid wide string. This is the inverse of [method String.to_wchar_buffer]. *)
    let get_string_from_wchar =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_PACKED_BYTE_ARRAY
        "get_string_from_wchar"
        (Base.Int64.of_string "3942272618")
        (PackedByteArray.typ @-> returning String.typ)
        String.s

    (** Returns a hexadecimal representation of this array as a [String].
[codeblocks]
[gdscript]
var array = PackedByteArray([11, 46, 255])
print(array.hex_encode()) # Prints: 0b2eff
[/gdscript]
[csharp]
var array = new byte[] {11, 46, 255};
GD.Print(array.HexEncode()); // Prints: 0b2eff
[/csharp]
[/codeblocks] *)
    let hex_encode =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_PACKED_BYTE_ARRAY
        "hex_encode"
        (Base.Int64.of_string "3942272618")
        (PackedByteArray.typ @-> returning String.typ)
        String.s

    (** Returns a new [PackedByteArray] with the data compressed. Set the compression mode using one of [enum FileAccess.CompressionMode]'s constants. *)
    let compress =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_PACKED_BYTE_ARRAY
        "compress"
        (Base.Int64.of_string "1845905913")
        (Int.typ @-> PackedByteArray.typ @-> returning PackedByteArray.typ)
        PackedByteArray.s

    (** Returns a new [PackedByteArray] with the data decompressed. Set [param buffer_size] to the size of the uncompressed data. Set the compression mode using one of [enum FileAccess.CompressionMode]'s constants.
[b]Note:[/b] Decompression is not guaranteed to work with data not compressed by Godot, for example if data compressed with the deflate compression mode lacks a checksum or header. *)
    let decompress =
      foreign_builtin_method2 GlobalEnum.VariantType._TYPE_PACKED_BYTE_ARRAY
        "decompress"
        (Base.Int64.of_string "2278869132")
        (Int.typ @-> Int.typ @-> PackedByteArray.typ
        @-> returning PackedByteArray.typ)
        PackedByteArray.s

    (** Returns a new [PackedByteArray] with the data decompressed. Set the compression mode using one of [enum FileAccess.CompressionMode]'s constants. [b]This method only accepts brotli, gzip, and deflate compression modes.[/b]
This method is potentially slower than [method decompress], as it may have to re-allocate its output buffer multiple times while decompressing, whereas [method decompress] knows it's output buffer size from the beginning.
GZIP has a maximal compression ratio of 1032:1, meaning it's very possible for a small compressed payload to decompress to a potentially very large output. To guard against this, you may provide a maximum size this function is allowed to allocate in bytes via [param max_output_size]. Passing -1 will allow for unbounded output. If any positive value is passed, and the decompression exceeds that amount in bytes, then an error will be returned.
[b]Note:[/b] Decompression is not guaranteed to work with data not compressed by Godot, for example if data compressed with the deflate compression mode lacks a checksum or header. *)
    let decompress_dynamic =
      foreign_builtin_method2 GlobalEnum.VariantType._TYPE_PACKED_BYTE_ARRAY
        "decompress_dynamic"
        (Base.Int64.of_string "2278869132")
        (Int.typ @-> Int.typ @-> PackedByteArray.typ
        @-> returning PackedByteArray.typ)
        PackedByteArray.s

    (** Decodes a 8-bit unsigned integer number from the bytes starting at [param byte_offset]. Fails if the byte count is insufficient. Returns [code]0[/code] if a valid number can't be decoded. *)
    let decode_u8 =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_PACKED_BYTE_ARRAY
        "decode_u8"
        (Base.Int64.of_string "4103005248")
        (Int.typ @-> PackedByteArray.typ @-> returning Int.typ)
        Int.s

    (** Decodes a 8-bit signed integer number from the bytes starting at [param byte_offset]. Fails if the byte count is insufficient. Returns [code]0[/code] if a valid number can't be decoded. *)
    let decode_s8 =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_PACKED_BYTE_ARRAY
        "decode_s8"
        (Base.Int64.of_string "4103005248")
        (Int.typ @-> PackedByteArray.typ @-> returning Int.typ)
        Int.s

    (** Decodes a 16-bit unsigned integer number from the bytes starting at [param byte_offset]. Fails if the byte count is insufficient. Returns [code]0[/code] if a valid number can't be decoded. *)
    let decode_u16 =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_PACKED_BYTE_ARRAY
        "decode_u16"
        (Base.Int64.of_string "4103005248")
        (Int.typ @-> PackedByteArray.typ @-> returning Int.typ)
        Int.s

    (** Decodes a 16-bit signed integer number from the bytes starting at [param byte_offset]. Fails if the byte count is insufficient. Returns [code]0[/code] if a valid number can't be decoded. *)
    let decode_s16 =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_PACKED_BYTE_ARRAY
        "decode_s16"
        (Base.Int64.of_string "4103005248")
        (Int.typ @-> PackedByteArray.typ @-> returning Int.typ)
        Int.s

    (** Decodes a 32-bit unsigned integer number from the bytes starting at [param byte_offset]. Fails if the byte count is insufficient. Returns [code]0[/code] if a valid number can't be decoded. *)
    let decode_u32 =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_PACKED_BYTE_ARRAY
        "decode_u32"
        (Base.Int64.of_string "4103005248")
        (Int.typ @-> PackedByteArray.typ @-> returning Int.typ)
        Int.s

    (** Decodes a 32-bit signed integer number from the bytes starting at [param byte_offset]. Fails if the byte count is insufficient. Returns [code]0[/code] if a valid number can't be decoded. *)
    let decode_s32 =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_PACKED_BYTE_ARRAY
        "decode_s32"
        (Base.Int64.of_string "4103005248")
        (Int.typ @-> PackedByteArray.typ @-> returning Int.typ)
        Int.s

    (** Decodes a 64-bit unsigned integer number from the bytes starting at [param byte_offset]. Fails if the byte count is insufficient. Returns [code]0[/code] if a valid number can't be decoded. *)
    let decode_u64 =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_PACKED_BYTE_ARRAY
        "decode_u64"
        (Base.Int64.of_string "4103005248")
        (Int.typ @-> PackedByteArray.typ @-> returning Int.typ)
        Int.s

    (** Decodes a 64-bit signed integer number from the bytes starting at [param byte_offset]. Fails if the byte count is insufficient. Returns [code]0[/code] if a valid number can't be decoded. *)
    let decode_s64 =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_PACKED_BYTE_ARRAY
        "decode_s64"
        (Base.Int64.of_string "4103005248")
        (Int.typ @-> PackedByteArray.typ @-> returning Int.typ)
        Int.s

    (** Decodes a 16-bit floating point number from the bytes starting at [param byte_offset]. Fails if the byte count is insufficient. Returns [code]0.0[/code] if a valid number can't be decoded. *)
    let decode_half =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_PACKED_BYTE_ARRAY
        "decode_half"
        (Base.Int64.of_string "1401583798")
        (Int.typ @-> PackedByteArray.typ @-> returning Float.typ)
        Float.s

    (** Decodes a 32-bit floating point number from the bytes starting at [param byte_offset]. Fails if the byte count is insufficient. Returns [code]0.0[/code] if a valid number can't be decoded. *)
    let decode_float =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_PACKED_BYTE_ARRAY
        "decode_float"
        (Base.Int64.of_string "1401583798")
        (Int.typ @-> PackedByteArray.typ @-> returning Float.typ)
        Float.s

    (** Decodes a 64-bit floating point number from the bytes starting at [param byte_offset]. Fails if the byte count is insufficient. Returns [code]0.0[/code] if a valid number can't be decoded. *)
    let decode_double =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_PACKED_BYTE_ARRAY
        "decode_double"
        (Base.Int64.of_string "1401583798")
        (Int.typ @-> PackedByteArray.typ @-> returning Float.typ)
        Float.s

    (** Returns [code]true[/code] if a valid [Variant] value can be decoded at the [param byte_offset]. Returns [code]false[/code] otherwise or when the value is [Object]-derived and [param allow_objects] is [code]false[/code]. *)
    let has_encoded_var =
      foreign_builtin_method2 GlobalEnum.VariantType._TYPE_PACKED_BYTE_ARRAY
        "has_encoded_var"
        (Base.Int64.of_string "2914632957")
        (Int.typ @-> Bool.typ @-> PackedByteArray.typ @-> returning Bool.typ)
        Bool.s

    (** Decodes a [Variant] from the bytes starting at [param byte_offset]. Returns [code]null[/code] if a valid variant can't be decoded or the value is [Object]-derived and [param allow_objects] is [code]false[/code]. *)
    let decode_var =
      foreign_builtin_method2 GlobalEnum.VariantType._TYPE_PACKED_BYTE_ARRAY
        "decode_var"
        (Base.Int64.of_string "1740420038")
        (Int.typ @-> Bool.typ @-> PackedByteArray.typ @-> returning Variant.typ)
        Variant.s

    (** Decodes a size of a [Variant] from the bytes starting at [param byte_offset]. Requires at least 4 bytes of data starting at the offset, otherwise fails. *)
    let decode_var_size =
      foreign_builtin_method2 GlobalEnum.VariantType._TYPE_PACKED_BYTE_ARRAY
        "decode_var_size"
        (Base.Int64.of_string "954237325")
        (Int.typ @-> Bool.typ @-> PackedByteArray.typ @-> returning Int.typ)
        Int.s

    (** Returns a copy of the data converted to a [PackedInt32Array], where each block of 4 bytes has been converted to a signed 32-bit integer (C++ [code]int32_t[/code]).
The size of the input array must be a multiple of 4 (size of 32-bit integer). The size of the new array will be [code]byte_array.size() / 4[/code].
If the original data can't be converted to signed 32-bit integers, the resulting data is undefined. *)
    let to_int32_array =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_PACKED_BYTE_ARRAY
        "to_int32_array"
        (Base.Int64.of_string "3158844420")
        (PackedByteArray.typ @-> returning PackedInt32Array.typ)
        PackedInt32Array.s

    (** Returns a copy of the data converted to a [PackedInt64Array], where each block of 8 bytes has been converted to a signed 64-bit integer (C++ [code]int64_t[/code], Godot [int]).
The size of the input array must be a multiple of 8 (size of 64-bit integer). The size of the new array will be [code]byte_array.size() / 8[/code].
If the original data can't be converted to signed 64-bit integers, the resulting data is undefined. *)
    let to_int64_array =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_PACKED_BYTE_ARRAY
        "to_int64_array"
        (Base.Int64.of_string "1961294120")
        (PackedByteArray.typ @-> returning PackedInt64Array.typ)
        PackedInt64Array.s

    (** Returns a copy of the data converted to a [PackedFloat32Array], where each block of 4 bytes has been converted to a 32-bit float (C++ [code skip-lint]float[/code]).
The size of the input array must be a multiple of 4 (size of 32-bit float). The size of the new array will be [code]byte_array.size() / 4[/code].
If the original data can't be converted to 32-bit floats, the resulting data is undefined. *)
    let to_float32_array =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_PACKED_BYTE_ARRAY
        "to_float32_array"
        (Base.Int64.of_string "3575107827")
        (PackedByteArray.typ @-> returning PackedFloat32Array.typ)
        PackedFloat32Array.s

    (** Returns a copy of the data converted to a [PackedFloat64Array], where each block of 8 bytes has been converted to a 64-bit float (C++ [code]double[/code], Godot [float]).
The size of the input array must be a multiple of 8 (size of 64-bit double). The size of the new array will be [code]byte_array.size() / 8[/code].
If the original data can't be converted to 64-bit floats, the resulting data is undefined. *)
    let to_float64_array =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_PACKED_BYTE_ARRAY
        "to_float64_array"
        (Base.Int64.of_string "1627308337")
        (PackedByteArray.typ @-> returning PackedFloat64Array.typ)
        PackedFloat64Array.s

    (** Encodes a 8-bit unsigned integer number (byte) at the index of [param byte_offset] bytes. The array must have at least 1 byte of space, starting at the offset. *)
    let encode_u8 =
      foreign_builtin_method2_void
        GlobalEnum.VariantType._TYPE_PACKED_BYTE_ARRAY "encode_u8"
        (Base.Int64.of_string "3638975848")
        (Int.typ @-> Int.typ @-> PackedByteArray.typ @-> returning Void.typ)
        Void.s

    (** Encodes a 8-bit signed integer number (signed byte) at the index of [param byte_offset] bytes. The array must have at least 1 byte of space, starting at the offset. *)
    let encode_s8 =
      foreign_builtin_method2_void
        GlobalEnum.VariantType._TYPE_PACKED_BYTE_ARRAY "encode_s8"
        (Base.Int64.of_string "3638975848")
        (Int.typ @-> Int.typ @-> PackedByteArray.typ @-> returning Void.typ)
        Void.s

    (** Encodes a 16-bit unsigned integer number as bytes at the index of [param byte_offset] bytes. The array must have at least 2 bytes of space, starting at the offset. *)
    let encode_u16 =
      foreign_builtin_method2_void
        GlobalEnum.VariantType._TYPE_PACKED_BYTE_ARRAY "encode_u16"
        (Base.Int64.of_string "3638975848")
        (Int.typ @-> Int.typ @-> PackedByteArray.typ @-> returning Void.typ)
        Void.s

    (** Encodes a 16-bit signed integer number as bytes at the index of [param byte_offset] bytes. The array must have at least 2 bytes of space, starting at the offset. *)
    let encode_s16 =
      foreign_builtin_method2_void
        GlobalEnum.VariantType._TYPE_PACKED_BYTE_ARRAY "encode_s16"
        (Base.Int64.of_string "3638975848")
        (Int.typ @-> Int.typ @-> PackedByteArray.typ @-> returning Void.typ)
        Void.s

    (** Encodes a 32-bit unsigned integer number as bytes at the index of [param byte_offset] bytes. The array must have at least 4 bytes of space, starting at the offset. *)
    let encode_u32 =
      foreign_builtin_method2_void
        GlobalEnum.VariantType._TYPE_PACKED_BYTE_ARRAY "encode_u32"
        (Base.Int64.of_string "3638975848")
        (Int.typ @-> Int.typ @-> PackedByteArray.typ @-> returning Void.typ)
        Void.s

    (** Encodes a 32-bit signed integer number as bytes at the index of [param byte_offset] bytes. The array must have at least 4 bytes of space, starting at the offset. *)
    let encode_s32 =
      foreign_builtin_method2_void
        GlobalEnum.VariantType._TYPE_PACKED_BYTE_ARRAY "encode_s32"
        (Base.Int64.of_string "3638975848")
        (Int.typ @-> Int.typ @-> PackedByteArray.typ @-> returning Void.typ)
        Void.s

    (** Encodes a 64-bit unsigned integer number as bytes at the index of [param byte_offset] bytes. The array must have at least 8 bytes of space, starting at the offset. *)
    let encode_u64 =
      foreign_builtin_method2_void
        GlobalEnum.VariantType._TYPE_PACKED_BYTE_ARRAY "encode_u64"
        (Base.Int64.of_string "3638975848")
        (Int.typ @-> Int.typ @-> PackedByteArray.typ @-> returning Void.typ)
        Void.s

    (** Encodes a 64-bit signed integer number as bytes at the index of [param byte_offset] bytes. The array must have at least 8 bytes of space, starting at the offset. *)
    let encode_s64 =
      foreign_builtin_method2_void
        GlobalEnum.VariantType._TYPE_PACKED_BYTE_ARRAY "encode_s64"
        (Base.Int64.of_string "3638975848")
        (Int.typ @-> Int.typ @-> PackedByteArray.typ @-> returning Void.typ)
        Void.s

    (** Encodes a 16-bit floating point number as bytes at the index of [param byte_offset] bytes. The array must have at least 2 bytes of space, starting at the offset. *)
    let encode_half =
      foreign_builtin_method2_void
        GlobalEnum.VariantType._TYPE_PACKED_BYTE_ARRAY "encode_half"
        (Base.Int64.of_string "1113000516")
        (Int.typ @-> Float.typ @-> PackedByteArray.typ @-> returning Void.typ)
        Void.s

    (** Encodes a 32-bit floating point number as bytes at the index of [param byte_offset] bytes. The array must have at least 4 bytes of space, starting at the offset. *)
    let encode_float =
      foreign_builtin_method2_void
        GlobalEnum.VariantType._TYPE_PACKED_BYTE_ARRAY "encode_float"
        (Base.Int64.of_string "1113000516")
        (Int.typ @-> Float.typ @-> PackedByteArray.typ @-> returning Void.typ)
        Void.s

    (** Encodes a 64-bit floating point number as bytes at the index of [param byte_offset] bytes. The array must have at least 8 bytes of allocated space, starting at the offset. *)
    let encode_double =
      foreign_builtin_method2_void
        GlobalEnum.VariantType._TYPE_PACKED_BYTE_ARRAY "encode_double"
        (Base.Int64.of_string "1113000516")
        (Int.typ @-> Float.typ @-> PackedByteArray.typ @-> returning Void.typ)
        Void.s

    (** Encodes a [Variant] at the index of [param byte_offset] bytes. A sufficient space must be allocated, depending on the encoded variant's size. If [param allow_objects] is [code]false[/code], [Object]-derived values are not permitted and will instead be serialized as ID-only. *)
    let encode_var =
      foreign_builtin_method3 GlobalEnum.VariantType._TYPE_PACKED_BYTE_ARRAY
        "encode_var"
        (Base.Int64.of_string "2604460497")
        (Int.typ @-> Variant.typ @-> Bool.typ @-> PackedByteArray.typ
       @-> returning Int.typ)
        Int.s

    let not =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_PACKED_BYTE_ARRAY
        None GlobalEnum.VariantOperator._OP_NOT
        (funptr
           (PackedByteArray.typ @-> PackedByteArray.typ @-> Bool.typ
          @-> returning void))

    let _PackedByteArray_elem_Dictionary =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_PACKED_BYTE_ARRAY
        (Some GlobalEnum.VariantType._TYPE_DICTIONARY)
        GlobalEnum.VariantOperator._OP_IN
        (funptr
           (PackedByteArray.typ @-> Dictionary.typ @-> Bool.typ
          @-> returning void))

    let _PackedByteArray_elem_Array =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_PACKED_BYTE_ARRAY
        (Some GlobalEnum.VariantType._TYPE_ARRAY)
        GlobalEnum.VariantOperator._OP_IN
        (funptr
           (PackedByteArray.typ @-> Array.typ @-> Bool.typ @-> returning void))

    (** Returns [code]true[/code] if contents of both arrays are the same, i.e. they have all equal bytes at the corresponding indices. *)
    let ( = ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_PACKED_BYTE_ARRAY
        (Some GlobalEnum.VariantType._TYPE_PACKED_BYTE_ARRAY)
        GlobalEnum.VariantOperator._OP_EQUAL
        (funptr
           (PackedByteArray.typ @-> PackedByteArray.typ @-> Bool.typ
          @-> returning void))

    (** Returns [code]true[/code] if contents of the arrays differ. *)
    let ( <> ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_PACKED_BYTE_ARRAY
        (Some GlobalEnum.VariantType._TYPE_PACKED_BYTE_ARRAY)
        GlobalEnum.VariantOperator._OP_NOT_EQUAL
        (funptr
           (PackedByteArray.typ @-> PackedByteArray.typ @-> Bool.typ
          @-> returning void))

    (** Returns a new [PackedByteArray] with contents of [param right] added at the end of this array. For better performance, consider using [method append_array] instead. *)
    let ( + ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_PACKED_BYTE_ARRAY
        (Some GlobalEnum.VariantType._TYPE_PACKED_BYTE_ARRAY)
        GlobalEnum.VariantOperator._OP_ADD
        (funptr
           (PackedByteArray.typ @-> PackedByteArray.typ @-> PackedByteArray.typ
          @-> returning void))
  end

  module PackedInt32Array = struct
    include M.PackedInt32Array

    (** Returns the number of elements in the array. *)
    let size =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_PACKED_INT32_ARRAY
        "size"
        (Base.Int64.of_string "3173160232")
        (PackedInt32Array.typ @-> returning Int.typ)
        Int.s

    (** Returns [code]true[/code] if the array is empty. *)
    let is_empty =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_PACKED_INT32_ARRAY
        "is_empty"
        (Base.Int64.of_string "3918633141")
        (PackedInt32Array.typ @-> returning Bool.typ)
        Bool.s

    (** Changes the integer at the given index. *)
    let set =
      foreign_builtin_method2_void
        GlobalEnum.VariantType._TYPE_PACKED_INT32_ARRAY "set"
        (Base.Int64.of_string "3638975848")
        (Int.typ @-> Int.typ @-> PackedInt32Array.typ @-> returning Void.typ)
        Void.s

    (** Appends a value to the array. *)
    let push_back =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_PACKED_INT32_ARRAY
        "push_back"
        (Base.Int64.of_string "694024632")
        (Int.typ @-> PackedInt32Array.typ @-> returning Bool.typ)
        Bool.s

    (** Appends an element at the end of the array (alias of [method push_back]). *)
    let append =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_PACKED_INT32_ARRAY
        "append"
        (Base.Int64.of_string "694024632")
        (Int.typ @-> PackedInt32Array.typ @-> returning Bool.typ)
        Bool.s

    (** Appends a [PackedInt32Array] at the end of this array. *)
    let append_array =
      foreign_builtin_method1_void
        GlobalEnum.VariantType._TYPE_PACKED_INT32_ARRAY "append_array"
        (Base.Int64.of_string "1087733270")
        (PackedInt32Array.typ @-> PackedInt32Array.typ @-> returning Void.typ)
        Void.s

    (** Removes an element from the array by index. *)
    let remove_at =
      foreign_builtin_method1_void
        GlobalEnum.VariantType._TYPE_PACKED_INT32_ARRAY "remove_at"
        (Base.Int64.of_string "2823966027")
        (Int.typ @-> PackedInt32Array.typ @-> returning Void.typ)
        Void.s

    (** Inserts a new integer at a given position in the array. The position must be valid, or at the end of the array ([code]idx == size()[/code]). *)
    let insert =
      foreign_builtin_method2 GlobalEnum.VariantType._TYPE_PACKED_INT32_ARRAY
        "insert"
        (Base.Int64.of_string "1487112728")
        (Int.typ @-> Int.typ @-> PackedInt32Array.typ @-> returning Int.typ)
        Int.s

    (** Assigns the given value to all elements in the array. This can typically be used together with [method resize] to create an array with a given size and initialized elements. *)
    let fill =
      foreign_builtin_method1_void
        GlobalEnum.VariantType._TYPE_PACKED_INT32_ARRAY "fill"
        (Base.Int64.of_string "2823966027")
        (Int.typ @-> PackedInt32Array.typ @-> returning Void.typ)
        Void.s

    (** Sets the size of the array. If the array is grown, reserves elements at the end of the array. If the array is shrunk, truncates the array to the new size. Calling [method resize] once and assigning the new values is faster than adding new elements one by one. *)
    let resize =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_PACKED_INT32_ARRAY
        "resize"
        (Base.Int64.of_string "848867239")
        (Int.typ @-> PackedInt32Array.typ @-> returning Int.typ)
        Int.s

    (** Clears the array. This is equivalent to using [method resize] with a size of [code]0[/code]. *)
    let clear =
      foreign_builtin_method0_void
        GlobalEnum.VariantType._TYPE_PACKED_INT32_ARRAY "clear"
        (Base.Int64.of_string "3218959716")
        (PackedInt32Array.typ @-> returning Void.typ)
        Void.s

    (** Returns [code]true[/code] if the array contains [param value]. *)
    let has =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_PACKED_INT32_ARRAY
        "has"
        (Base.Int64.of_string "931488181")
        (Int.typ @-> PackedInt32Array.typ @-> returning Bool.typ)
        Bool.s

    (** Reverses the order of the elements in the array. *)
    let reverse =
      foreign_builtin_method0_void
        GlobalEnum.VariantType._TYPE_PACKED_INT32_ARRAY "reverse"
        (Base.Int64.of_string "3218959716")
        (PackedInt32Array.typ @-> returning Void.typ)
        Void.s

    (** Returns the slice of the [PackedInt32Array], from [param begin] (inclusive) to [param end] (exclusive), as a new [PackedInt32Array].
The absolute value of [param begin] and [param end] will be clamped to the array size, so the default value for [param end] makes it slice to the size of the array by default (i.e. [code]arr.slice(1)[/code] is a shorthand for [code]arr.slice(1, arr.size())[/code]).
If either [param begin] or [param end] are negative, they will be relative to the end of the array (i.e. [code]arr.slice(0, -2)[/code] is a shorthand for [code]arr.slice(0, arr.size() - 2)[/code]). *)
    let slice =
      foreign_builtin_method2 GlobalEnum.VariantType._TYPE_PACKED_INT32_ARRAY
        "slice"
        (Base.Int64.of_string "1216021098")
        (Int.typ @-> Int.typ @-> PackedInt32Array.typ
        @-> returning PackedInt32Array.typ)
        PackedInt32Array.s

    (** Returns a copy of the data converted to a [PackedByteArray], where each element have been encoded as 4 bytes.
The size of the new array will be [code]int32_array.size()  *  4[/code]. *)
    let to_byte_array =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_PACKED_INT32_ARRAY
        "to_byte_array"
        (Base.Int64.of_string "247621236")
        (PackedInt32Array.typ @-> returning PackedByteArray.typ)
        PackedByteArray.s

    (** Sorts the elements of the array in ascending order. *)
    let sort =
      foreign_builtin_method0_void
        GlobalEnum.VariantType._TYPE_PACKED_INT32_ARRAY "sort"
        (Base.Int64.of_string "3218959716")
        (PackedInt32Array.typ @-> returning Void.typ)
        Void.s

    (** Finds the index of an existing value (or the insertion index that maintains sorting order, if the value is not yet present in the array) using binary search. Optionally, a [param before] specifier can be passed. If [code]false[/code], the returned index comes after all existing entries of the value in the array.
[b]Note:[/b] Calling [method bsearch] on an unsorted array results in unexpected behavior. *)
    let bsearch =
      foreign_builtin_method2 GlobalEnum.VariantType._TYPE_PACKED_INT32_ARRAY
        "bsearch"
        (Base.Int64.of_string "3380005890")
        (Int.typ @-> Bool.typ @-> PackedInt32Array.typ @-> returning Int.typ)
        Int.s

    (** Creates a copy of the array, and returns it. *)
    let duplicate =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_PACKED_INT32_ARRAY
        "duplicate"
        (Base.Int64.of_string "1997843129")
        (PackedInt32Array.typ @-> returning PackedInt32Array.typ)
        PackedInt32Array.s

    (** Searches the array for a value and returns its index or [code]-1[/code] if not found. Optionally, the initial search index can be passed. *)
    let find =
      foreign_builtin_method2 GlobalEnum.VariantType._TYPE_PACKED_INT32_ARRAY
        "find"
        (Base.Int64.of_string "2984303840")
        (Int.typ @-> Int.typ @-> PackedInt32Array.typ @-> returning Int.typ)
        Int.s

    (** Searches the array in reverse order. Optionally, a start search index can be passed. If negative, the start index is considered relative to the end of the array. *)
    let rfind =
      foreign_builtin_method2 GlobalEnum.VariantType._TYPE_PACKED_INT32_ARRAY
        "rfind"
        (Base.Int64.of_string "2984303840")
        (Int.typ @-> Int.typ @-> PackedInt32Array.typ @-> returning Int.typ)
        Int.s

    (** Returns the number of times an element is in the array. *)
    let count =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_PACKED_INT32_ARRAY
        "count"
        (Base.Int64.of_string "4103005248")
        (Int.typ @-> PackedInt32Array.typ @-> returning Int.typ)
        Int.s

    let not =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_PACKED_INT32_ARRAY
        None GlobalEnum.VariantOperator._OP_NOT
        (funptr
           (PackedInt32Array.typ @-> PackedInt32Array.typ @-> Bool.typ
          @-> returning void))

    let _PackedInt32Array_elem_Dictionary =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_PACKED_INT32_ARRAY
        (Some GlobalEnum.VariantType._TYPE_DICTIONARY)
        GlobalEnum.VariantOperator._OP_IN
        (funptr
           (PackedInt32Array.typ @-> Dictionary.typ @-> Bool.typ
          @-> returning void))

    let _PackedInt32Array_elem_Array =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_PACKED_INT32_ARRAY
        (Some GlobalEnum.VariantType._TYPE_ARRAY)
        GlobalEnum.VariantOperator._OP_IN
        (funptr
           (PackedInt32Array.typ @-> Array.typ @-> Bool.typ @-> returning void))

    (** Returns [code]true[/code] if contents of both arrays are the same, i.e. they have all equal ints at the corresponding indices. *)
    let ( = ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_PACKED_INT32_ARRAY
        (Some GlobalEnum.VariantType._TYPE_PACKED_INT32_ARRAY)
        GlobalEnum.VariantOperator._OP_EQUAL
        (funptr
           (PackedInt32Array.typ @-> PackedInt32Array.typ @-> Bool.typ
          @-> returning void))

    (** Returns [code]true[/code] if contents of the arrays differ. *)
    let ( <> ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_PACKED_INT32_ARRAY
        (Some GlobalEnum.VariantType._TYPE_PACKED_INT32_ARRAY)
        GlobalEnum.VariantOperator._OP_NOT_EQUAL
        (funptr
           (PackedInt32Array.typ @-> PackedInt32Array.typ @-> Bool.typ
          @-> returning void))

    (** Returns a new [PackedInt32Array] with contents of [param right] added at the end of this array. For better performance, consider using [method append_array] instead. *)
    let ( + ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_PACKED_INT32_ARRAY
        (Some GlobalEnum.VariantType._TYPE_PACKED_INT32_ARRAY)
        GlobalEnum.VariantOperator._OP_ADD
        (funptr
           (PackedInt32Array.typ @-> PackedInt32Array.typ
          @-> PackedInt32Array.typ @-> returning void))
  end

  module PackedInt64Array = struct
    include M.PackedInt64Array

    (** Returns the number of elements in the array. *)
    let size =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_PACKED_INT64_ARRAY
        "size"
        (Base.Int64.of_string "3173160232")
        (PackedInt64Array.typ @-> returning Int.typ)
        Int.s

    (** Returns [code]true[/code] if the array is empty. *)
    let is_empty =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_PACKED_INT64_ARRAY
        "is_empty"
        (Base.Int64.of_string "3918633141")
        (PackedInt64Array.typ @-> returning Bool.typ)
        Bool.s

    (** Changes the integer at the given index. *)
    let set =
      foreign_builtin_method2_void
        GlobalEnum.VariantType._TYPE_PACKED_INT64_ARRAY "set"
        (Base.Int64.of_string "3638975848")
        (Int.typ @-> Int.typ @-> PackedInt64Array.typ @-> returning Void.typ)
        Void.s

    (** Appends a value to the array. *)
    let push_back =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_PACKED_INT64_ARRAY
        "push_back"
        (Base.Int64.of_string "694024632")
        (Int.typ @-> PackedInt64Array.typ @-> returning Bool.typ)
        Bool.s

    (** Appends an element at the end of the array (alias of [method push_back]). *)
    let append =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_PACKED_INT64_ARRAY
        "append"
        (Base.Int64.of_string "694024632")
        (Int.typ @-> PackedInt64Array.typ @-> returning Bool.typ)
        Bool.s

    (** Appends a [PackedInt64Array] at the end of this array. *)
    let append_array =
      foreign_builtin_method1_void
        GlobalEnum.VariantType._TYPE_PACKED_INT64_ARRAY "append_array"
        (Base.Int64.of_string "2090311302")
        (PackedInt64Array.typ @-> PackedInt64Array.typ @-> returning Void.typ)
        Void.s

    (** Removes an element from the array by index. *)
    let remove_at =
      foreign_builtin_method1_void
        GlobalEnum.VariantType._TYPE_PACKED_INT64_ARRAY "remove_at"
        (Base.Int64.of_string "2823966027")
        (Int.typ @-> PackedInt64Array.typ @-> returning Void.typ)
        Void.s

    (** Inserts a new integer at a given position in the array. The position must be valid, or at the end of the array ([code]idx == size()[/code]). *)
    let insert =
      foreign_builtin_method2 GlobalEnum.VariantType._TYPE_PACKED_INT64_ARRAY
        "insert"
        (Base.Int64.of_string "1487112728")
        (Int.typ @-> Int.typ @-> PackedInt64Array.typ @-> returning Int.typ)
        Int.s

    (** Assigns the given value to all elements in the array. This can typically be used together with [method resize] to create an array with a given size and initialized elements. *)
    let fill =
      foreign_builtin_method1_void
        GlobalEnum.VariantType._TYPE_PACKED_INT64_ARRAY "fill"
        (Base.Int64.of_string "2823966027")
        (Int.typ @-> PackedInt64Array.typ @-> returning Void.typ)
        Void.s

    (** Sets the size of the array. If the array is grown, reserves elements at the end of the array. If the array is shrunk, truncates the array to the new size. Calling [method resize] once and assigning the new values is faster than adding new elements one by one. *)
    let resize =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_PACKED_INT64_ARRAY
        "resize"
        (Base.Int64.of_string "848867239")
        (Int.typ @-> PackedInt64Array.typ @-> returning Int.typ)
        Int.s

    (** Clears the array. This is equivalent to using [method resize] with a size of [code]0[/code]. *)
    let clear =
      foreign_builtin_method0_void
        GlobalEnum.VariantType._TYPE_PACKED_INT64_ARRAY "clear"
        (Base.Int64.of_string "3218959716")
        (PackedInt64Array.typ @-> returning Void.typ)
        Void.s

    (** Returns [code]true[/code] if the array contains [param value]. *)
    let has =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_PACKED_INT64_ARRAY
        "has"
        (Base.Int64.of_string "931488181")
        (Int.typ @-> PackedInt64Array.typ @-> returning Bool.typ)
        Bool.s

    (** Reverses the order of the elements in the array. *)
    let reverse =
      foreign_builtin_method0_void
        GlobalEnum.VariantType._TYPE_PACKED_INT64_ARRAY "reverse"
        (Base.Int64.of_string "3218959716")
        (PackedInt64Array.typ @-> returning Void.typ)
        Void.s

    (** Returns the slice of the [PackedInt64Array], from [param begin] (inclusive) to [param end] (exclusive), as a new [PackedInt64Array].
The absolute value of [param begin] and [param end] will be clamped to the array size, so the default value for [param end] makes it slice to the size of the array by default (i.e. [code]arr.slice(1)[/code] is a shorthand for [code]arr.slice(1, arr.size())[/code]).
If either [param begin] or [param end] are negative, they will be relative to the end of the array (i.e. [code]arr.slice(0, -2)[/code] is a shorthand for [code]arr.slice(0, arr.size() - 2)[/code]). *)
    let slice =
      foreign_builtin_method2 GlobalEnum.VariantType._TYPE_PACKED_INT64_ARRAY
        "slice"
        (Base.Int64.of_string "1726550804")
        (Int.typ @-> Int.typ @-> PackedInt64Array.typ
        @-> returning PackedInt64Array.typ)
        PackedInt64Array.s

    (** Returns a copy of the data converted to a [PackedByteArray], where each element have been encoded as 8 bytes.
The size of the new array will be [code]int64_array.size()  *  8[/code]. *)
    let to_byte_array =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_PACKED_INT64_ARRAY
        "to_byte_array"
        (Base.Int64.of_string "247621236")
        (PackedInt64Array.typ @-> returning PackedByteArray.typ)
        PackedByteArray.s

    (** Sorts the elements of the array in ascending order. *)
    let sort =
      foreign_builtin_method0_void
        GlobalEnum.VariantType._TYPE_PACKED_INT64_ARRAY "sort"
        (Base.Int64.of_string "3218959716")
        (PackedInt64Array.typ @-> returning Void.typ)
        Void.s

    (** Finds the index of an existing value (or the insertion index that maintains sorting order, if the value is not yet present in the array) using binary search. Optionally, a [param before] specifier can be passed. If [code]false[/code], the returned index comes after all existing entries of the value in the array.
[b]Note:[/b] Calling [method bsearch] on an unsorted array results in unexpected behavior. *)
    let bsearch =
      foreign_builtin_method2 GlobalEnum.VariantType._TYPE_PACKED_INT64_ARRAY
        "bsearch"
        (Base.Int64.of_string "3380005890")
        (Int.typ @-> Bool.typ @-> PackedInt64Array.typ @-> returning Int.typ)
        Int.s

    (** Creates a copy of the array, and returns it. *)
    let duplicate =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_PACKED_INT64_ARRAY
        "duplicate"
        (Base.Int64.of_string "2376370016")
        (PackedInt64Array.typ @-> returning PackedInt64Array.typ)
        PackedInt64Array.s

    (** Searches the array for a value and returns its index or [code]-1[/code] if not found. Optionally, the initial search index can be passed. *)
    let find =
      foreign_builtin_method2 GlobalEnum.VariantType._TYPE_PACKED_INT64_ARRAY
        "find"
        (Base.Int64.of_string "2984303840")
        (Int.typ @-> Int.typ @-> PackedInt64Array.typ @-> returning Int.typ)
        Int.s

    (** Searches the array in reverse order. Optionally, a start search index can be passed. If negative, the start index is considered relative to the end of the array. *)
    let rfind =
      foreign_builtin_method2 GlobalEnum.VariantType._TYPE_PACKED_INT64_ARRAY
        "rfind"
        (Base.Int64.of_string "2984303840")
        (Int.typ @-> Int.typ @-> PackedInt64Array.typ @-> returning Int.typ)
        Int.s

    (** Returns the number of times an element is in the array. *)
    let count =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_PACKED_INT64_ARRAY
        "count"
        (Base.Int64.of_string "4103005248")
        (Int.typ @-> PackedInt64Array.typ @-> returning Int.typ)
        Int.s

    let not =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_PACKED_INT64_ARRAY
        None GlobalEnum.VariantOperator._OP_NOT
        (funptr
           (PackedInt64Array.typ @-> PackedInt64Array.typ @-> Bool.typ
          @-> returning void))

    let _PackedInt64Array_elem_Dictionary =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_PACKED_INT64_ARRAY
        (Some GlobalEnum.VariantType._TYPE_DICTIONARY)
        GlobalEnum.VariantOperator._OP_IN
        (funptr
           (PackedInt64Array.typ @-> Dictionary.typ @-> Bool.typ
          @-> returning void))

    let _PackedInt64Array_elem_Array =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_PACKED_INT64_ARRAY
        (Some GlobalEnum.VariantType._TYPE_ARRAY)
        GlobalEnum.VariantOperator._OP_IN
        (funptr
           (PackedInt64Array.typ @-> Array.typ @-> Bool.typ @-> returning void))

    (** Returns [code]true[/code] if contents of both arrays are the same, i.e. they have all equal ints at the corresponding indices. *)
    let ( = ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_PACKED_INT64_ARRAY
        (Some GlobalEnum.VariantType._TYPE_PACKED_INT64_ARRAY)
        GlobalEnum.VariantOperator._OP_EQUAL
        (funptr
           (PackedInt64Array.typ @-> PackedInt64Array.typ @-> Bool.typ
          @-> returning void))

    (** Returns [code]true[/code] if contents of the arrays differ. *)
    let ( <> ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_PACKED_INT64_ARRAY
        (Some GlobalEnum.VariantType._TYPE_PACKED_INT64_ARRAY)
        GlobalEnum.VariantOperator._OP_NOT_EQUAL
        (funptr
           (PackedInt64Array.typ @-> PackedInt64Array.typ @-> Bool.typ
          @-> returning void))

    (** Returns a new [PackedInt64Array] with contents of [param right] added at the end of this array. For better performance, consider using [method append_array] instead. *)
    let ( + ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_PACKED_INT64_ARRAY
        (Some GlobalEnum.VariantType._TYPE_PACKED_INT64_ARRAY)
        GlobalEnum.VariantOperator._OP_ADD
        (funptr
           (PackedInt64Array.typ @-> PackedInt64Array.typ
          @-> PackedInt64Array.typ @-> returning void))
  end

  module PackedFloat32Array = struct
    include M.PackedFloat32Array

    (** Returns the number of elements in the array. *)
    let size =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_PACKED_FLOAT32_ARRAY
        "size"
        (Base.Int64.of_string "3173160232")
        (PackedFloat32Array.typ @-> returning Int.typ)
        Int.s

    (** Returns [code]true[/code] if the array is empty. *)
    let is_empty =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_PACKED_FLOAT32_ARRAY
        "is_empty"
        (Base.Int64.of_string "3918633141")
        (PackedFloat32Array.typ @-> returning Bool.typ)
        Bool.s

    (** Changes the float at the given index. *)
    let set =
      foreign_builtin_method2_void
        GlobalEnum.VariantType._TYPE_PACKED_FLOAT32_ARRAY "set"
        (Base.Int64.of_string "1113000516")
        (Int.typ @-> Float.typ @-> PackedFloat32Array.typ @-> returning Void.typ)
        Void.s

    (** Appends an element at the end of the array. *)
    let push_back =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_PACKED_FLOAT32_ARRAY
        "push_back"
        (Base.Int64.of_string "4094791666")
        (Float.typ @-> PackedFloat32Array.typ @-> returning Bool.typ)
        Bool.s

    (** Appends an element at the end of the array (alias of [method push_back]). *)
    let append =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_PACKED_FLOAT32_ARRAY
        "append"
        (Base.Int64.of_string "4094791666")
        (Float.typ @-> PackedFloat32Array.typ @-> returning Bool.typ)
        Bool.s

    (** Appends a [PackedFloat32Array] at the end of this array. *)
    let append_array =
      foreign_builtin_method1_void
        GlobalEnum.VariantType._TYPE_PACKED_FLOAT32_ARRAY "append_array"
        (Base.Int64.of_string "2981316639")
        (PackedFloat32Array.typ @-> PackedFloat32Array.typ
       @-> returning Void.typ)
        Void.s

    (** Removes an element from the array by index. *)
    let remove_at =
      foreign_builtin_method1_void
        GlobalEnum.VariantType._TYPE_PACKED_FLOAT32_ARRAY "remove_at"
        (Base.Int64.of_string "2823966027")
        (Int.typ @-> PackedFloat32Array.typ @-> returning Void.typ)
        Void.s

    (** Inserts a new element at a given position in the array. The position must be valid, or at the end of the array ([code]idx == size()[/code]). *)
    let insert =
      foreign_builtin_method2 GlobalEnum.VariantType._TYPE_PACKED_FLOAT32_ARRAY
        "insert"
        (Base.Int64.of_string "1379903876")
        (Int.typ @-> Float.typ @-> PackedFloat32Array.typ @-> returning Int.typ)
        Int.s

    (** Assigns the given value to all elements in the array. This can typically be used together with [method resize] to create an array with a given size and initialized elements. *)
    let fill =
      foreign_builtin_method1_void
        GlobalEnum.VariantType._TYPE_PACKED_FLOAT32_ARRAY "fill"
        (Base.Int64.of_string "833936903")
        (Float.typ @-> PackedFloat32Array.typ @-> returning Void.typ)
        Void.s

    (** Sets the size of the array. If the array is grown, reserves elements at the end of the array. If the array is shrunk, truncates the array to the new size. Calling [method resize] once and assigning the new values is faster than adding new elements one by one. *)
    let resize =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_PACKED_FLOAT32_ARRAY
        "resize"
        (Base.Int64.of_string "848867239")
        (Int.typ @-> PackedFloat32Array.typ @-> returning Int.typ)
        Int.s

    (** Clears the array. This is equivalent to using [method resize] with a size of [code]0[/code]. *)
    let clear =
      foreign_builtin_method0_void
        GlobalEnum.VariantType._TYPE_PACKED_FLOAT32_ARRAY "clear"
        (Base.Int64.of_string "3218959716")
        (PackedFloat32Array.typ @-> returning Void.typ)
        Void.s

    (** Returns [code]true[/code] if the array contains [param value].
[b]Note:[/b] [constant @GDScript.NAN] doesn't behave the same as other numbers. Therefore, the results from this method may not be accurate if NaNs are included. *)
    let has =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_PACKED_FLOAT32_ARRAY
        "has"
        (Base.Int64.of_string "1296369134")
        (Float.typ @-> PackedFloat32Array.typ @-> returning Bool.typ)
        Bool.s

    (** Reverses the order of the elements in the array. *)
    let reverse =
      foreign_builtin_method0_void
        GlobalEnum.VariantType._TYPE_PACKED_FLOAT32_ARRAY "reverse"
        (Base.Int64.of_string "3218959716")
        (PackedFloat32Array.typ @-> returning Void.typ)
        Void.s

    (** Returns the slice of the [PackedFloat32Array], from [param begin] (inclusive) to [param end] (exclusive), as a new [PackedFloat32Array].
The absolute value of [param begin] and [param end] will be clamped to the array size, so the default value for [param end] makes it slice to the size of the array by default (i.e. [code]arr.slice(1)[/code] is a shorthand for [code]arr.slice(1, arr.size())[/code]).
If either [param begin] or [param end] are negative, they will be relative to the end of the array (i.e. [code]arr.slice(0, -2)[/code] is a shorthand for [code]arr.slice(0, arr.size() - 2)[/code]). *)
    let slice =
      foreign_builtin_method2 GlobalEnum.VariantType._TYPE_PACKED_FLOAT32_ARRAY
        "slice"
        (Base.Int64.of_string "1418229160")
        (Int.typ @-> Int.typ @-> PackedFloat32Array.typ
        @-> returning PackedFloat32Array.typ)
        PackedFloat32Array.s

    (** Returns a copy of the data converted to a [PackedByteArray], where each element have been encoded as 4 bytes.
The size of the new array will be [code]float32_array.size()  *  4[/code]. *)
    let to_byte_array =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_PACKED_FLOAT32_ARRAY
        "to_byte_array"
        (Base.Int64.of_string "247621236")
        (PackedFloat32Array.typ @-> returning PackedByteArray.typ)
        PackedByteArray.s

    (** Sorts the elements of the array in ascending order.
[b]Note:[/b] [constant @GDScript.NAN] doesn't behave the same as other numbers. Therefore, the results from this method may not be accurate if NaNs are included. *)
    let sort =
      foreign_builtin_method0_void
        GlobalEnum.VariantType._TYPE_PACKED_FLOAT32_ARRAY "sort"
        (Base.Int64.of_string "3218959716")
        (PackedFloat32Array.typ @-> returning Void.typ)
        Void.s

    (** Finds the index of an existing value (or the insertion index that maintains sorting order, if the value is not yet present in the array) using binary search. Optionally, a [param before] specifier can be passed. If [code]false[/code], the returned index comes after all existing entries of the value in the array.
[b]Note:[/b] Calling [method bsearch] on an unsorted array results in unexpected behavior.
[b]Note:[/b] [constant @GDScript.NAN] doesn't behave the same as other numbers. Therefore, the results from this method may not be accurate if NaNs are included. *)
    let bsearch =
      foreign_builtin_method2 GlobalEnum.VariantType._TYPE_PACKED_FLOAT32_ARRAY
        "bsearch"
        (Base.Int64.of_string "1188816338")
        (Float.typ @-> Bool.typ @-> PackedFloat32Array.typ @-> returning Int.typ)
        Int.s

    (** Creates a copy of the array, and returns it. *)
    let duplicate =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_PACKED_FLOAT32_ARRAY
        "duplicate"
        (Base.Int64.of_string "831114784")
        (PackedFloat32Array.typ @-> returning PackedFloat32Array.typ)
        PackedFloat32Array.s

    (** Searches the array for a value and returns its index or [code]-1[/code] if not found. Optionally, the initial search index can be passed.
[b]Note:[/b] [constant @GDScript.NAN] doesn't behave the same as other numbers. Therefore, the results from this method may not be accurate if NaNs are included. *)
    let find =
      foreign_builtin_method2 GlobalEnum.VariantType._TYPE_PACKED_FLOAT32_ARRAY
        "find"
        (Base.Int64.of_string "1343150241")
        (Float.typ @-> Int.typ @-> PackedFloat32Array.typ @-> returning Int.typ)
        Int.s

    (** Searches the array in reverse order. Optionally, a start search index can be passed. If negative, the start index is considered relative to the end of the array.
[b]Note:[/b] [constant @GDScript.NAN] doesn't behave the same as other numbers. Therefore, the results from this method may not be accurate if NaNs are included. *)
    let rfind =
      foreign_builtin_method2 GlobalEnum.VariantType._TYPE_PACKED_FLOAT32_ARRAY
        "rfind"
        (Base.Int64.of_string "1343150241")
        (Float.typ @-> Int.typ @-> PackedFloat32Array.typ @-> returning Int.typ)
        Int.s

    (** Returns the number of times an element is in the array.
[b]Note:[/b] [constant @GDScript.NAN] doesn't behave the same as other numbers. Therefore, the results from this method may not be accurate if NaNs are included. *)
    let count =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_PACKED_FLOAT32_ARRAY
        "count"
        (Base.Int64.of_string "2859915090")
        (Float.typ @-> PackedFloat32Array.typ @-> returning Int.typ)
        Int.s

    let not =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_PACKED_FLOAT32_ARRAY
        None GlobalEnum.VariantOperator._OP_NOT
        (funptr
           (PackedFloat32Array.typ @-> PackedFloat32Array.typ @-> Bool.typ
          @-> returning void))

    let _PackedFloat32Array_elem_Dictionary =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_PACKED_FLOAT32_ARRAY
        (Some GlobalEnum.VariantType._TYPE_DICTIONARY)
        GlobalEnum.VariantOperator._OP_IN
        (funptr
           (PackedFloat32Array.typ @-> Dictionary.typ @-> Bool.typ
          @-> returning void))

    let _PackedFloat32Array_elem_Array =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_PACKED_FLOAT32_ARRAY
        (Some GlobalEnum.VariantType._TYPE_ARRAY)
        GlobalEnum.VariantOperator._OP_IN
        (funptr
           (PackedFloat32Array.typ @-> Array.typ @-> Bool.typ @-> returning void))

    (** Returns [code]true[/code] if contents of both arrays are the same, i.e. they have all equal floats at the corresponding indices. *)
    let ( = ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_PACKED_FLOAT32_ARRAY
        (Some GlobalEnum.VariantType._TYPE_PACKED_FLOAT32_ARRAY)
        GlobalEnum.VariantOperator._OP_EQUAL
        (funptr
           (PackedFloat32Array.typ @-> PackedFloat32Array.typ @-> Bool.typ
          @-> returning void))

    (** Returns [code]true[/code] if contents of the arrays differ. *)
    let ( <> ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_PACKED_FLOAT32_ARRAY
        (Some GlobalEnum.VariantType._TYPE_PACKED_FLOAT32_ARRAY)
        GlobalEnum.VariantOperator._OP_NOT_EQUAL
        (funptr
           (PackedFloat32Array.typ @-> PackedFloat32Array.typ @-> Bool.typ
          @-> returning void))

    (** Returns a new [PackedFloat32Array] with contents of [param right] added at the end of this array. For better performance, consider using [method append_array] instead. *)
    let ( + ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_PACKED_FLOAT32_ARRAY
        (Some GlobalEnum.VariantType._TYPE_PACKED_FLOAT32_ARRAY)
        GlobalEnum.VariantOperator._OP_ADD
        (funptr
           (PackedFloat32Array.typ @-> PackedFloat32Array.typ
          @-> PackedFloat32Array.typ @-> returning void))
  end

  module PackedFloat64Array = struct
    include M.PackedFloat64Array

    (** Returns the number of elements in the array. *)
    let size =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_PACKED_FLOAT64_ARRAY
        "size"
        (Base.Int64.of_string "3173160232")
        (PackedFloat64Array.typ @-> returning Int.typ)
        Int.s

    (** Returns [code]true[/code] if the array is empty. *)
    let is_empty =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_PACKED_FLOAT64_ARRAY
        "is_empty"
        (Base.Int64.of_string "3918633141")
        (PackedFloat64Array.typ @-> returning Bool.typ)
        Bool.s

    (** Changes the float at the given index. *)
    let set =
      foreign_builtin_method2_void
        GlobalEnum.VariantType._TYPE_PACKED_FLOAT64_ARRAY "set"
        (Base.Int64.of_string "1113000516")
        (Int.typ @-> Float.typ @-> PackedFloat64Array.typ @-> returning Void.typ)
        Void.s

    (** Appends an element at the end of the array. *)
    let push_back =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_PACKED_FLOAT64_ARRAY
        "push_back"
        (Base.Int64.of_string "4094791666")
        (Float.typ @-> PackedFloat64Array.typ @-> returning Bool.typ)
        Bool.s

    (** Appends an element at the end of the array (alias of [method push_back]). *)
    let append =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_PACKED_FLOAT64_ARRAY
        "append"
        (Base.Int64.of_string "4094791666")
        (Float.typ @-> PackedFloat64Array.typ @-> returning Bool.typ)
        Bool.s

    (** Appends a [PackedFloat64Array] at the end of this array. *)
    let append_array =
      foreign_builtin_method1_void
        GlobalEnum.VariantType._TYPE_PACKED_FLOAT64_ARRAY "append_array"
        (Base.Int64.of_string "792078629")
        (PackedFloat64Array.typ @-> PackedFloat64Array.typ
       @-> returning Void.typ)
        Void.s

    (** Removes an element from the array by index. *)
    let remove_at =
      foreign_builtin_method1_void
        GlobalEnum.VariantType._TYPE_PACKED_FLOAT64_ARRAY "remove_at"
        (Base.Int64.of_string "2823966027")
        (Int.typ @-> PackedFloat64Array.typ @-> returning Void.typ)
        Void.s

    (** Inserts a new element at a given position in the array. The position must be valid, or at the end of the array ([code]idx == size()[/code]). *)
    let insert =
      foreign_builtin_method2 GlobalEnum.VariantType._TYPE_PACKED_FLOAT64_ARRAY
        "insert"
        (Base.Int64.of_string "1379903876")
        (Int.typ @-> Float.typ @-> PackedFloat64Array.typ @-> returning Int.typ)
        Int.s

    (** Assigns the given value to all elements in the array. This can typically be used together with [method resize] to create an array with a given size and initialized elements. *)
    let fill =
      foreign_builtin_method1_void
        GlobalEnum.VariantType._TYPE_PACKED_FLOAT64_ARRAY "fill"
        (Base.Int64.of_string "833936903")
        (Float.typ @-> PackedFloat64Array.typ @-> returning Void.typ)
        Void.s

    (** Sets the size of the array. If the array is grown, reserves elements at the end of the array. If the array is shrunk, truncates the array to the new size. Calling [method resize] once and assigning the new values is faster than adding new elements one by one. *)
    let resize =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_PACKED_FLOAT64_ARRAY
        "resize"
        (Base.Int64.of_string "848867239")
        (Int.typ @-> PackedFloat64Array.typ @-> returning Int.typ)
        Int.s

    (** Clears the array. This is equivalent to using [method resize] with a size of [code]0[/code]. *)
    let clear =
      foreign_builtin_method0_void
        GlobalEnum.VariantType._TYPE_PACKED_FLOAT64_ARRAY "clear"
        (Base.Int64.of_string "3218959716")
        (PackedFloat64Array.typ @-> returning Void.typ)
        Void.s

    (** Returns [code]true[/code] if the array contains [param value].
[b]Note:[/b] [constant @GDScript.NAN] doesn't behave the same as other numbers. Therefore, the results from this method may not be accurate if NaNs are included. *)
    let has =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_PACKED_FLOAT64_ARRAY
        "has"
        (Base.Int64.of_string "1296369134")
        (Float.typ @-> PackedFloat64Array.typ @-> returning Bool.typ)
        Bool.s

    (** Reverses the order of the elements in the array. *)
    let reverse =
      foreign_builtin_method0_void
        GlobalEnum.VariantType._TYPE_PACKED_FLOAT64_ARRAY "reverse"
        (Base.Int64.of_string "3218959716")
        (PackedFloat64Array.typ @-> returning Void.typ)
        Void.s

    (** Returns the slice of the [PackedFloat64Array], from [param begin] (inclusive) to [param end] (exclusive), as a new [PackedFloat64Array].
The absolute value of [param begin] and [param end] will be clamped to the array size, so the default value for [param end] makes it slice to the size of the array by default (i.e. [code]arr.slice(1)[/code] is a shorthand for [code]arr.slice(1, arr.size())[/code]).
If either [param begin] or [param end] are negative, they will be relative to the end of the array (i.e. [code]arr.slice(0, -2)[/code] is a shorthand for [code]arr.slice(0, arr.size() - 2)[/code]). *)
    let slice =
      foreign_builtin_method2 GlobalEnum.VariantType._TYPE_PACKED_FLOAT64_ARRAY
        "slice"
        (Base.Int64.of_string "2192974324")
        (Int.typ @-> Int.typ @-> PackedFloat64Array.typ
        @-> returning PackedFloat64Array.typ)
        PackedFloat64Array.s

    (** Returns a copy of the data converted to a [PackedByteArray], where each element have been encoded as 8 bytes.
The size of the new array will be [code]float64_array.size()  *  8[/code]. *)
    let to_byte_array =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_PACKED_FLOAT64_ARRAY
        "to_byte_array"
        (Base.Int64.of_string "247621236")
        (PackedFloat64Array.typ @-> returning PackedByteArray.typ)
        PackedByteArray.s

    (** Sorts the elements of the array in ascending order.
[b]Note:[/b] [constant @GDScript.NAN] doesn't behave the same as other numbers. Therefore, the results from this method may not be accurate if NaNs are included. *)
    let sort =
      foreign_builtin_method0_void
        GlobalEnum.VariantType._TYPE_PACKED_FLOAT64_ARRAY "sort"
        (Base.Int64.of_string "3218959716")
        (PackedFloat64Array.typ @-> returning Void.typ)
        Void.s

    (** Finds the index of an existing value (or the insertion index that maintains sorting order, if the value is not yet present in the array) using binary search. Optionally, a [param before] specifier can be passed. If [code]false[/code], the returned index comes after all existing entries of the value in the array.
[b]Note:[/b] Calling [method bsearch] on an unsorted array results in unexpected behavior.
[b]Note:[/b] [constant @GDScript.NAN] doesn't behave the same as other numbers. Therefore, the results from this method may not be accurate if NaNs are included. *)
    let bsearch =
      foreign_builtin_method2 GlobalEnum.VariantType._TYPE_PACKED_FLOAT64_ARRAY
        "bsearch"
        (Base.Int64.of_string "1188816338")
        (Float.typ @-> Bool.typ @-> PackedFloat64Array.typ @-> returning Int.typ)
        Int.s

    (** Creates a copy of the array, and returns it. *)
    let duplicate =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_PACKED_FLOAT64_ARRAY
        "duplicate"
        (Base.Int64.of_string "949266573")
        (PackedFloat64Array.typ @-> returning PackedFloat64Array.typ)
        PackedFloat64Array.s

    (** Searches the array for a value and returns its index or [code]-1[/code] if not found. Optionally, the initial search index can be passed.
[b]Note:[/b] [constant @GDScript.NAN] doesn't behave the same as other numbers. Therefore, the results from this method may not be accurate if NaNs are included. *)
    let find =
      foreign_builtin_method2 GlobalEnum.VariantType._TYPE_PACKED_FLOAT64_ARRAY
        "find"
        (Base.Int64.of_string "1343150241")
        (Float.typ @-> Int.typ @-> PackedFloat64Array.typ @-> returning Int.typ)
        Int.s

    (** Searches the array in reverse order. Optionally, a start search index can be passed. If negative, the start index is considered relative to the end of the array.
[b]Note:[/b] [constant @GDScript.NAN] doesn't behave the same as other numbers. Therefore, the results from this method may not be accurate if NaNs are included. *)
    let rfind =
      foreign_builtin_method2 GlobalEnum.VariantType._TYPE_PACKED_FLOAT64_ARRAY
        "rfind"
        (Base.Int64.of_string "1343150241")
        (Float.typ @-> Int.typ @-> PackedFloat64Array.typ @-> returning Int.typ)
        Int.s

    (** Returns the number of times an element is in the array.
[b]Note:[/b] [constant @GDScript.NAN] doesn't behave the same as other numbers. Therefore, the results from this method may not be accurate if NaNs are included. *)
    let count =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_PACKED_FLOAT64_ARRAY
        "count"
        (Base.Int64.of_string "2859915090")
        (Float.typ @-> PackedFloat64Array.typ @-> returning Int.typ)
        Int.s

    let not =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_PACKED_FLOAT64_ARRAY
        None GlobalEnum.VariantOperator._OP_NOT
        (funptr
           (PackedFloat64Array.typ @-> PackedFloat64Array.typ @-> Bool.typ
          @-> returning void))

    let _PackedFloat64Array_elem_Dictionary =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_PACKED_FLOAT64_ARRAY
        (Some GlobalEnum.VariantType._TYPE_DICTIONARY)
        GlobalEnum.VariantOperator._OP_IN
        (funptr
           (PackedFloat64Array.typ @-> Dictionary.typ @-> Bool.typ
          @-> returning void))

    let _PackedFloat64Array_elem_Array =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_PACKED_FLOAT64_ARRAY
        (Some GlobalEnum.VariantType._TYPE_ARRAY)
        GlobalEnum.VariantOperator._OP_IN
        (funptr
           (PackedFloat64Array.typ @-> Array.typ @-> Bool.typ @-> returning void))

    (** Returns [code]true[/code] if contents of both arrays are the same, i.e. they have all equal doubles at the corresponding indices. *)
    let ( = ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_PACKED_FLOAT64_ARRAY
        (Some GlobalEnum.VariantType._TYPE_PACKED_FLOAT64_ARRAY)
        GlobalEnum.VariantOperator._OP_EQUAL
        (funptr
           (PackedFloat64Array.typ @-> PackedFloat64Array.typ @-> Bool.typ
          @-> returning void))

    (** Returns [code]true[/code] if contents of the arrays differ. *)
    let ( <> ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_PACKED_FLOAT64_ARRAY
        (Some GlobalEnum.VariantType._TYPE_PACKED_FLOAT64_ARRAY)
        GlobalEnum.VariantOperator._OP_NOT_EQUAL
        (funptr
           (PackedFloat64Array.typ @-> PackedFloat64Array.typ @-> Bool.typ
          @-> returning void))

    (** Returns a new [PackedFloat64Array] with contents of [param right] added at the end of this array. For better performance, consider using [method append_array] instead. *)
    let ( + ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_PACKED_FLOAT64_ARRAY
        (Some GlobalEnum.VariantType._TYPE_PACKED_FLOAT64_ARRAY)
        GlobalEnum.VariantOperator._OP_ADD
        (funptr
           (PackedFloat64Array.typ @-> PackedFloat64Array.typ
          @-> PackedFloat64Array.typ @-> returning void))
  end

  module PackedStringArray = struct
    include M.PackedStringArray

    (** Returns the number of elements in the array. *)
    let size =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_PACKED_STRING_ARRAY
        "size"
        (Base.Int64.of_string "3173160232")
        (PackedStringArray.typ @-> returning Int.typ)
        Int.s

    (** Returns [code]true[/code] if the array is empty. *)
    let is_empty =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_PACKED_STRING_ARRAY
        "is_empty"
        (Base.Int64.of_string "3918633141")
        (PackedStringArray.typ @-> returning Bool.typ)
        Bool.s

    (** Changes the [String] at the given index. *)
    let set =
      foreign_builtin_method2_void
        GlobalEnum.VariantType._TYPE_PACKED_STRING_ARRAY "set"
        (Base.Int64.of_string "725585539")
        (Int.typ @-> String.typ @-> PackedStringArray.typ @-> returning Void.typ)
        Void.s

    (** Appends a string element at end of the array. *)
    let push_back =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_PACKED_STRING_ARRAY
        "push_back"
        (Base.Int64.of_string "816187996")
        (String.typ @-> PackedStringArray.typ @-> returning Bool.typ)
        Bool.s

    (** Appends an element at the end of the array (alias of [method push_back]). *)
    let append =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_PACKED_STRING_ARRAY
        "append"
        (Base.Int64.of_string "816187996")
        (String.typ @-> PackedStringArray.typ @-> returning Bool.typ)
        Bool.s

    (** Appends a [PackedStringArray] at the end of this array. *)
    let append_array =
      foreign_builtin_method1_void
        GlobalEnum.VariantType._TYPE_PACKED_STRING_ARRAY "append_array"
        (Base.Int64.of_string "1120103966")
        (PackedStringArray.typ @-> PackedStringArray.typ @-> returning Void.typ)
        Void.s

    (** Removes an element from the array by index. *)
    let remove_at =
      foreign_builtin_method1_void
        GlobalEnum.VariantType._TYPE_PACKED_STRING_ARRAY "remove_at"
        (Base.Int64.of_string "2823966027")
        (Int.typ @-> PackedStringArray.typ @-> returning Void.typ)
        Void.s

    (** Inserts a new element at a given position in the array. The position must be valid, or at the end of the array ([code]idx == size()[/code]). *)
    let insert =
      foreign_builtin_method2 GlobalEnum.VariantType._TYPE_PACKED_STRING_ARRAY
        "insert"
        (Base.Int64.of_string "2432393153")
        (Int.typ @-> String.typ @-> PackedStringArray.typ @-> returning Int.typ)
        Int.s

    (** Assigns the given value to all elements in the array. This can typically be used together with [method resize] to create an array with a given size and initialized elements. *)
    let fill =
      foreign_builtin_method1_void
        GlobalEnum.VariantType._TYPE_PACKED_STRING_ARRAY "fill"
        (Base.Int64.of_string "3174917410")
        (String.typ @-> PackedStringArray.typ @-> returning Void.typ)
        Void.s

    (** Sets the size of the array. If the array is grown, reserves elements at the end of the array. If the array is shrunk, truncates the array to the new size. Calling [method resize] once and assigning the new values is faster than adding new elements one by one. *)
    let resize =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_PACKED_STRING_ARRAY
        "resize"
        (Base.Int64.of_string "848867239")
        (Int.typ @-> PackedStringArray.typ @-> returning Int.typ)
        Int.s

    (** Clears the array. This is equivalent to using [method resize] with a size of [code]0[/code]. *)
    let clear =
      foreign_builtin_method0_void
        GlobalEnum.VariantType._TYPE_PACKED_STRING_ARRAY "clear"
        (Base.Int64.of_string "3218959716")
        (PackedStringArray.typ @-> returning Void.typ)
        Void.s

    (** Returns [code]true[/code] if the array contains [param value]. *)
    let has =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_PACKED_STRING_ARRAY
        "has"
        (Base.Int64.of_string "2566493496")
        (String.typ @-> PackedStringArray.typ @-> returning Bool.typ)
        Bool.s

    (** Reverses the order of the elements in the array. *)
    let reverse =
      foreign_builtin_method0_void
        GlobalEnum.VariantType._TYPE_PACKED_STRING_ARRAY "reverse"
        (Base.Int64.of_string "3218959716")
        (PackedStringArray.typ @-> returning Void.typ)
        Void.s

    (** Returns the slice of the [PackedStringArray], from [param begin] (inclusive) to [param end] (exclusive), as a new [PackedStringArray].
The absolute value of [param begin] and [param end] will be clamped to the array size, so the default value for [param end] makes it slice to the size of the array by default (i.e. [code]arr.slice(1)[/code] is a shorthand for [code]arr.slice(1, arr.size())[/code]).
If either [param begin] or [param end] are negative, they will be relative to the end of the array (i.e. [code]arr.slice(0, -2)[/code] is a shorthand for [code]arr.slice(0, arr.size() - 2)[/code]). *)
    let slice =
      foreign_builtin_method2 GlobalEnum.VariantType._TYPE_PACKED_STRING_ARRAY
        "slice"
        (Base.Int64.of_string "2094601407")
        (Int.typ @-> Int.typ @-> PackedStringArray.typ
        @-> returning PackedStringArray.typ)
        PackedStringArray.s

    (** Returns a [PackedByteArray] with each string encoded as bytes. *)
    let to_byte_array =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_PACKED_STRING_ARRAY
        "to_byte_array"
        (Base.Int64.of_string "247621236")
        (PackedStringArray.typ @-> returning PackedByteArray.typ)
        PackedByteArray.s

    (** Sorts the elements of the array in ascending order. *)
    let sort =
      foreign_builtin_method0_void
        GlobalEnum.VariantType._TYPE_PACKED_STRING_ARRAY "sort"
        (Base.Int64.of_string "3218959716")
        (PackedStringArray.typ @-> returning Void.typ)
        Void.s

    (** Finds the index of an existing value (or the insertion index that maintains sorting order, if the value is not yet present in the array) using binary search. Optionally, a [param before] specifier can be passed. If [code]false[/code], the returned index comes after all existing entries of the value in the array.
[b]Note:[/b] Calling [method bsearch] on an unsorted array results in unexpected behavior. *)
    let bsearch =
      foreign_builtin_method2 GlobalEnum.VariantType._TYPE_PACKED_STRING_ARRAY
        "bsearch"
        (Base.Int64.of_string "328976671")
        (String.typ @-> Bool.typ @-> PackedStringArray.typ @-> returning Int.typ)
        Int.s

    (** Creates a copy of the array, and returns it. *)
    let duplicate =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_PACKED_STRING_ARRAY
        "duplicate"
        (Base.Int64.of_string "2991231410")
        (PackedStringArray.typ @-> returning PackedStringArray.typ)
        PackedStringArray.s

    (** Searches the array for a value and returns its index or [code]-1[/code] if not found. Optionally, the initial search index can be passed. *)
    let find =
      foreign_builtin_method2 GlobalEnum.VariantType._TYPE_PACKED_STRING_ARRAY
        "find"
        (Base.Int64.of_string "1760645412")
        (String.typ @-> Int.typ @-> PackedStringArray.typ @-> returning Int.typ)
        Int.s

    (** Searches the array in reverse order. Optionally, a start search index can be passed. If negative, the start index is considered relative to the end of the array. *)
    let rfind =
      foreign_builtin_method2 GlobalEnum.VariantType._TYPE_PACKED_STRING_ARRAY
        "rfind"
        (Base.Int64.of_string "1760645412")
        (String.typ @-> Int.typ @-> PackedStringArray.typ @-> returning Int.typ)
        Int.s

    (** Returns the number of times an element is in the array. *)
    let count =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_PACKED_STRING_ARRAY
        "count"
        (Base.Int64.of_string "2920860731")
        (String.typ @-> PackedStringArray.typ @-> returning Int.typ)
        Int.s

    let not =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_PACKED_STRING_ARRAY
        None GlobalEnum.VariantOperator._OP_NOT
        (funptr
           (PackedStringArray.typ @-> PackedStringArray.typ @-> Bool.typ
          @-> returning void))

    let _PackedStringArray_elem_Dictionary =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_PACKED_STRING_ARRAY
        (Some GlobalEnum.VariantType._TYPE_DICTIONARY)
        GlobalEnum.VariantOperator._OP_IN
        (funptr
           (PackedStringArray.typ @-> Dictionary.typ @-> Bool.typ
          @-> returning void))

    let _PackedStringArray_elem_Array =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_PACKED_STRING_ARRAY
        (Some GlobalEnum.VariantType._TYPE_ARRAY)
        GlobalEnum.VariantOperator._OP_IN
        (funptr
           (PackedStringArray.typ @-> Array.typ @-> Bool.typ @-> returning void))

    (** Returns [code]true[/code] if contents of both arrays are the same, i.e. they have all equal [String]s at the corresponding indices. *)
    let ( = ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_PACKED_STRING_ARRAY
        (Some GlobalEnum.VariantType._TYPE_PACKED_STRING_ARRAY)
        GlobalEnum.VariantOperator._OP_EQUAL
        (funptr
           (PackedStringArray.typ @-> PackedStringArray.typ @-> Bool.typ
          @-> returning void))

    (** Returns [code]true[/code] if contents of the arrays differ. *)
    let ( <> ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_PACKED_STRING_ARRAY
        (Some GlobalEnum.VariantType._TYPE_PACKED_STRING_ARRAY)
        GlobalEnum.VariantOperator._OP_NOT_EQUAL
        (funptr
           (PackedStringArray.typ @-> PackedStringArray.typ @-> Bool.typ
          @-> returning void))

    (** Returns a new [PackedStringArray] with contents of [param right] added at the end of this array. For better performance, consider using [method append_array] instead. *)
    let ( + ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_PACKED_STRING_ARRAY
        (Some GlobalEnum.VariantType._TYPE_PACKED_STRING_ARRAY)
        GlobalEnum.VariantOperator._OP_ADD
        (funptr
           (PackedStringArray.typ @-> PackedStringArray.typ
          @-> PackedStringArray.typ @-> returning void))
  end

  module PackedVector2Array = struct
    include M.PackedVector2Array

    (** Returns the number of elements in the array. *)
    let size =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_PACKED_VECTOR2_ARRAY
        "size"
        (Base.Int64.of_string "3173160232")
        (PackedVector2Array.typ @-> returning Int.typ)
        Int.s

    (** Returns [code]true[/code] if the array is empty. *)
    let is_empty =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_PACKED_VECTOR2_ARRAY
        "is_empty"
        (Base.Int64.of_string "3918633141")
        (PackedVector2Array.typ @-> returning Bool.typ)
        Bool.s

    (** Changes the [Vector2] at the given index. *)
    let set =
      foreign_builtin_method2_void
        GlobalEnum.VariantType._TYPE_PACKED_VECTOR2_ARRAY "set"
        (Base.Int64.of_string "635767250")
        (Int.typ @-> Vector2.typ @-> PackedVector2Array.typ
       @-> returning Void.typ)
        Void.s

    (** Inserts a [Vector2] at the end. *)
    let push_back =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_PACKED_VECTOR2_ARRAY
        "push_back"
        (Base.Int64.of_string "4188891560")
        (Vector2.typ @-> PackedVector2Array.typ @-> returning Bool.typ)
        Bool.s

    (** Appends an element at the end of the array (alias of [method push_back]). *)
    let append =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_PACKED_VECTOR2_ARRAY
        "append"
        (Base.Int64.of_string "4188891560")
        (Vector2.typ @-> PackedVector2Array.typ @-> returning Bool.typ)
        Bool.s

    (** Appends a [PackedVector2Array] at the end of this array. *)
    let append_array =
      foreign_builtin_method1_void
        GlobalEnum.VariantType._TYPE_PACKED_VECTOR2_ARRAY "append_array"
        (Base.Int64.of_string "3887534835")
        (PackedVector2Array.typ @-> PackedVector2Array.typ
       @-> returning Void.typ)
        Void.s

    (** Removes an element from the array by index. *)
    let remove_at =
      foreign_builtin_method1_void
        GlobalEnum.VariantType._TYPE_PACKED_VECTOR2_ARRAY "remove_at"
        (Base.Int64.of_string "2823966027")
        (Int.typ @-> PackedVector2Array.typ @-> returning Void.typ)
        Void.s

    (** Inserts a new element at a given position in the array. The position must be valid, or at the end of the array ([code]idx == size()[/code]). *)
    let insert =
      foreign_builtin_method2 GlobalEnum.VariantType._TYPE_PACKED_VECTOR2_ARRAY
        "insert"
        (Base.Int64.of_string "2225629369")
        (Int.typ @-> Vector2.typ @-> PackedVector2Array.typ
       @-> returning Int.typ)
        Int.s

    (** Assigns the given value to all elements in the array. This can typically be used together with [method resize] to create an array with a given size and initialized elements. *)
    let fill =
      foreign_builtin_method1_void
        GlobalEnum.VariantType._TYPE_PACKED_VECTOR2_ARRAY "fill"
        (Base.Int64.of_string "3790411178")
        (Vector2.typ @-> PackedVector2Array.typ @-> returning Void.typ)
        Void.s

    (** Sets the size of the array. If the array is grown, reserves elements at the end of the array. If the array is shrunk, truncates the array to the new size. Calling [method resize] once and assigning the new values is faster than adding new elements one by one. *)
    let resize =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_PACKED_VECTOR2_ARRAY
        "resize"
        (Base.Int64.of_string "848867239")
        (Int.typ @-> PackedVector2Array.typ @-> returning Int.typ)
        Int.s

    (** Clears the array. This is equivalent to using [method resize] with a size of [code]0[/code]. *)
    let clear =
      foreign_builtin_method0_void
        GlobalEnum.VariantType._TYPE_PACKED_VECTOR2_ARRAY "clear"
        (Base.Int64.of_string "3218959716")
        (PackedVector2Array.typ @-> returning Void.typ)
        Void.s

    (** Returns [code]true[/code] if the array contains [param value].
[b]Note:[/b] Vectors with [constant @GDScript.NAN] elements don't behave the same as other vectors. Therefore, the results from this method may not be accurate if NaNs are included. *)
    let has =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_PACKED_VECTOR2_ARRAY
        "has"
        (Base.Int64.of_string "3190634762")
        (Vector2.typ @-> PackedVector2Array.typ @-> returning Bool.typ)
        Bool.s

    (** Reverses the order of the elements in the array. *)
    let reverse =
      foreign_builtin_method0_void
        GlobalEnum.VariantType._TYPE_PACKED_VECTOR2_ARRAY "reverse"
        (Base.Int64.of_string "3218959716")
        (PackedVector2Array.typ @-> returning Void.typ)
        Void.s

    (** Returns the slice of the [PackedVector2Array], from [param begin] (inclusive) to [param end] (exclusive), as a new [PackedVector2Array].
The absolute value of [param begin] and [param end] will be clamped to the array size, so the default value for [param end] makes it slice to the size of the array by default (i.e. [code]arr.slice(1)[/code] is a shorthand for [code]arr.slice(1, arr.size())[/code]).
If either [param begin] or [param end] are negative, they will be relative to the end of the array (i.e. [code]arr.slice(0, -2)[/code] is a shorthand for [code]arr.slice(0, arr.size() - 2)[/code]). *)
    let slice =
      foreign_builtin_method2 GlobalEnum.VariantType._TYPE_PACKED_VECTOR2_ARRAY
        "slice"
        (Base.Int64.of_string "3864005350")
        (Int.typ @-> Int.typ @-> PackedVector2Array.typ
        @-> returning PackedVector2Array.typ)
        PackedVector2Array.s

    (** Returns a [PackedByteArray] with each vector encoded as bytes. *)
    let to_byte_array =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_PACKED_VECTOR2_ARRAY
        "to_byte_array"
        (Base.Int64.of_string "247621236")
        (PackedVector2Array.typ @-> returning PackedByteArray.typ)
        PackedByteArray.s

    (** Sorts the elements of the array in ascending order.
[b]Note:[/b] Vectors with [constant @GDScript.NAN] elements don't behave the same as other vectors. Therefore, the results from this method may not be accurate if NaNs are included. *)
    let sort =
      foreign_builtin_method0_void
        GlobalEnum.VariantType._TYPE_PACKED_VECTOR2_ARRAY "sort"
        (Base.Int64.of_string "3218959716")
        (PackedVector2Array.typ @-> returning Void.typ)
        Void.s

    (** Finds the index of an existing value (or the insertion index that maintains sorting order, if the value is not yet present in the array) using binary search. Optionally, a [param before] specifier can be passed. If [code]false[/code], the returned index comes after all existing entries of the value in the array.
[b]Note:[/b] Calling [method bsearch] on an unsorted array results in unexpected behavior.
[b]Note:[/b] Vectors with [constant @GDScript.NAN] elements don't behave the same as other vectors. Therefore, the results from this method may not be accurate if NaNs are included. *)
    let bsearch =
      foreign_builtin_method2 GlobalEnum.VariantType._TYPE_PACKED_VECTOR2_ARRAY
        "bsearch"
        (Base.Int64.of_string "3778035805")
        (Vector2.typ @-> Bool.typ @-> PackedVector2Array.typ
       @-> returning Int.typ)
        Int.s

    (** Creates a copy of the array, and returns it. *)
    let duplicate =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_PACKED_VECTOR2_ARRAY
        "duplicate"
        (Base.Int64.of_string "3763646812")
        (PackedVector2Array.typ @-> returning PackedVector2Array.typ)
        PackedVector2Array.s

    (** Searches the array for a value and returns its index or [code]-1[/code] if not found. Optionally, the initial search index can be passed.
[b]Note:[/b] Vectors with [constant @GDScript.NAN] elements don't behave the same as other vectors. Therefore, the results from this method may not be accurate if NaNs are included. *)
    let find =
      foreign_builtin_method2 GlobalEnum.VariantType._TYPE_PACKED_VECTOR2_ARRAY
        "find"
        (Base.Int64.of_string "1469606149")
        (Vector2.typ @-> Int.typ @-> PackedVector2Array.typ
       @-> returning Int.typ)
        Int.s

    (** Searches the array in reverse order. Optionally, a start search index can be passed. If negative, the start index is considered relative to the end of the array.
[b]Note:[/b] Vectors with [constant @GDScript.NAN] elements don't behave the same as other vectors. Therefore, the results from this method may not be accurate if NaNs are included. *)
    let rfind =
      foreign_builtin_method2 GlobalEnum.VariantType._TYPE_PACKED_VECTOR2_ARRAY
        "rfind"
        (Base.Int64.of_string "1469606149")
        (Vector2.typ @-> Int.typ @-> PackedVector2Array.typ
       @-> returning Int.typ)
        Int.s

    (** Returns the number of times an element is in the array.
[b]Note:[/b] Vectors with [constant @GDScript.NAN] elements don't behave the same as other vectors. Therefore, the results from this method may not be accurate if NaNs are included. *)
    let count =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_PACKED_VECTOR2_ARRAY
        "count"
        (Base.Int64.of_string "2798848307")
        (Vector2.typ @-> PackedVector2Array.typ @-> returning Int.typ)
        Int.s

    let not =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_PACKED_VECTOR2_ARRAY
        None GlobalEnum.VariantOperator._OP_NOT
        (funptr
           (PackedVector2Array.typ @-> PackedVector2Array.typ @-> Bool.typ
          @-> returning void))

    let _PackedVector2Array_elem_Dictionary =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_PACKED_VECTOR2_ARRAY
        (Some GlobalEnum.VariantType._TYPE_DICTIONARY)
        GlobalEnum.VariantOperator._OP_IN
        (funptr
           (PackedVector2Array.typ @-> Dictionary.typ @-> Bool.typ
          @-> returning void))

    let _PackedVector2Array_elem_Array =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_PACKED_VECTOR2_ARRAY
        (Some GlobalEnum.VariantType._TYPE_ARRAY)
        GlobalEnum.VariantOperator._OP_IN
        (funptr
           (PackedVector2Array.typ @-> Array.typ @-> Bool.typ @-> returning void))

    (** Returns [code]true[/code] if contents of both arrays are the same, i.e. they have all equal [Vector2]s at the corresponding indices. *)
    let ( = ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_PACKED_VECTOR2_ARRAY
        (Some GlobalEnum.VariantType._TYPE_PACKED_VECTOR2_ARRAY)
        GlobalEnum.VariantOperator._OP_EQUAL
        (funptr
           (PackedVector2Array.typ @-> PackedVector2Array.typ @-> Bool.typ
          @-> returning void))

    (** Returns [code]true[/code] if contents of the arrays differ. *)
    let ( <> ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_PACKED_VECTOR2_ARRAY
        (Some GlobalEnum.VariantType._TYPE_PACKED_VECTOR2_ARRAY)
        GlobalEnum.VariantOperator._OP_NOT_EQUAL
        (funptr
           (PackedVector2Array.typ @-> PackedVector2Array.typ @-> Bool.typ
          @-> returning void))

    (** Returns a new [PackedVector2Array] with contents of [param right] added at the end of this array. For better performance, consider using [method append_array] instead. *)
    let ( + ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_PACKED_VECTOR2_ARRAY
        (Some GlobalEnum.VariantType._TYPE_PACKED_VECTOR2_ARRAY)
        GlobalEnum.VariantOperator._OP_ADD
        (funptr
           (PackedVector2Array.typ @-> PackedVector2Array.typ
          @-> PackedVector2Array.typ @-> returning void))
  end

  module PackedVector3Array = struct
    include M.PackedVector3Array

    (** Returns the number of elements in the array. *)
    let size =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_PACKED_VECTOR3_ARRAY
        "size"
        (Base.Int64.of_string "3173160232")
        (PackedVector3Array.typ @-> returning Int.typ)
        Int.s

    (** Returns [code]true[/code] if the array is empty. *)
    let is_empty =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_PACKED_VECTOR3_ARRAY
        "is_empty"
        (Base.Int64.of_string "3918633141")
        (PackedVector3Array.typ @-> returning Bool.typ)
        Bool.s

    (** Changes the [Vector3] at the given index. *)
    let set =
      foreign_builtin_method2_void
        GlobalEnum.VariantType._TYPE_PACKED_VECTOR3_ARRAY "set"
        (Base.Int64.of_string "3975343409")
        (Int.typ @-> Vector3.typ @-> PackedVector3Array.typ
       @-> returning Void.typ)
        Void.s

    (** Inserts a [Vector3] at the end. *)
    let push_back =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_PACKED_VECTOR3_ARRAY
        "push_back"
        (Base.Int64.of_string "3295363524")
        (Vector3.typ @-> PackedVector3Array.typ @-> returning Bool.typ)
        Bool.s

    (** Appends an element at the end of the array (alias of [method push_back]). *)
    let append =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_PACKED_VECTOR3_ARRAY
        "append"
        (Base.Int64.of_string "3295363524")
        (Vector3.typ @-> PackedVector3Array.typ @-> returning Bool.typ)
        Bool.s

    (** Appends a [PackedVector3Array] at the end of this array. *)
    let append_array =
      foreign_builtin_method1_void
        GlobalEnum.VariantType._TYPE_PACKED_VECTOR3_ARRAY "append_array"
        (Base.Int64.of_string "203538016")
        (PackedVector3Array.typ @-> PackedVector3Array.typ
       @-> returning Void.typ)
        Void.s

    (** Removes an element from the array by index. *)
    let remove_at =
      foreign_builtin_method1_void
        GlobalEnum.VariantType._TYPE_PACKED_VECTOR3_ARRAY "remove_at"
        (Base.Int64.of_string "2823966027")
        (Int.typ @-> PackedVector3Array.typ @-> returning Void.typ)
        Void.s

    (** Inserts a new element at a given position in the array. The position must be valid, or at the end of the array ([code]idx == size()[/code]). *)
    let insert =
      foreign_builtin_method2 GlobalEnum.VariantType._TYPE_PACKED_VECTOR3_ARRAY
        "insert"
        (Base.Int64.of_string "3892262309")
        (Int.typ @-> Vector3.typ @-> PackedVector3Array.typ
       @-> returning Int.typ)
        Int.s

    (** Assigns the given value to all elements in the array. This can typically be used together with [method resize] to create an array with a given size and initialized elements. *)
    let fill =
      foreign_builtin_method1_void
        GlobalEnum.VariantType._TYPE_PACKED_VECTOR3_ARRAY "fill"
        (Base.Int64.of_string "3726392409")
        (Vector3.typ @-> PackedVector3Array.typ @-> returning Void.typ)
        Void.s

    (** Sets the size of the array. If the array is grown, reserves elements at the end of the array. If the array is shrunk, truncates the array to the new size. Calling [method resize] once and assigning the new values is faster than adding new elements one by one. *)
    let resize =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_PACKED_VECTOR3_ARRAY
        "resize"
        (Base.Int64.of_string "848867239")
        (Int.typ @-> PackedVector3Array.typ @-> returning Int.typ)
        Int.s

    (** Clears the array. This is equivalent to using [method resize] with a size of [code]0[/code]. *)
    let clear =
      foreign_builtin_method0_void
        GlobalEnum.VariantType._TYPE_PACKED_VECTOR3_ARRAY "clear"
        (Base.Int64.of_string "3218959716")
        (PackedVector3Array.typ @-> returning Void.typ)
        Void.s

    (** Returns [code]true[/code] if the array contains [param value].
[b]Note:[/b] Vectors with [constant @GDScript.NAN] elements don't behave the same as other vectors. Therefore, the results from this method may not be accurate if NaNs are included. *)
    let has =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_PACKED_VECTOR3_ARRAY
        "has"
        (Base.Int64.of_string "1749054343")
        (Vector3.typ @-> PackedVector3Array.typ @-> returning Bool.typ)
        Bool.s

    (** Reverses the order of the elements in the array. *)
    let reverse =
      foreign_builtin_method0_void
        GlobalEnum.VariantType._TYPE_PACKED_VECTOR3_ARRAY "reverse"
        (Base.Int64.of_string "3218959716")
        (PackedVector3Array.typ @-> returning Void.typ)
        Void.s

    (** Returns the slice of the [PackedVector3Array], from [param begin] (inclusive) to [param end] (exclusive), as a new [PackedVector3Array].
The absolute value of [param begin] and [param end] will be clamped to the array size, so the default value for [param end] makes it slice to the size of the array by default (i.e. [code]arr.slice(1)[/code] is a shorthand for [code]arr.slice(1, arr.size())[/code]).
If either [param begin] or [param end] are negative, they will be relative to the end of the array (i.e. [code]arr.slice(0, -2)[/code] is a shorthand for [code]arr.slice(0, arr.size() - 2)[/code]). *)
    let slice =
      foreign_builtin_method2 GlobalEnum.VariantType._TYPE_PACKED_VECTOR3_ARRAY
        "slice"
        (Base.Int64.of_string "2086131305")
        (Int.typ @-> Int.typ @-> PackedVector3Array.typ
        @-> returning PackedVector3Array.typ)
        PackedVector3Array.s

    (** Returns a [PackedByteArray] with each vector encoded as bytes. *)
    let to_byte_array =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_PACKED_VECTOR3_ARRAY
        "to_byte_array"
        (Base.Int64.of_string "247621236")
        (PackedVector3Array.typ @-> returning PackedByteArray.typ)
        PackedByteArray.s

    (** Sorts the elements of the array in ascending order.
[b]Note:[/b] Vectors with [constant @GDScript.NAN] elements don't behave the same as other vectors. Therefore, the results from this method may not be accurate if NaNs are included. *)
    let sort =
      foreign_builtin_method0_void
        GlobalEnum.VariantType._TYPE_PACKED_VECTOR3_ARRAY "sort"
        (Base.Int64.of_string "3218959716")
        (PackedVector3Array.typ @-> returning Void.typ)
        Void.s

    (** Finds the index of an existing value (or the insertion index that maintains sorting order, if the value is not yet present in the array) using binary search. Optionally, a [param before] specifier can be passed. If [code]false[/code], the returned index comes after all existing entries of the value in the array.
[b]Note:[/b] Calling [method bsearch] on an unsorted array results in unexpected behavior.
[b]Note:[/b] Vectors with [constant @GDScript.NAN] elements don't behave the same as other vectors. Therefore, the results from this method may not be accurate if NaNs are included. *)
    let bsearch =
      foreign_builtin_method2 GlobalEnum.VariantType._TYPE_PACKED_VECTOR3_ARRAY
        "bsearch"
        (Base.Int64.of_string "219263630")
        (Vector3.typ @-> Bool.typ @-> PackedVector3Array.typ
       @-> returning Int.typ)
        Int.s

    (** Creates a copy of the array, and returns it. *)
    let duplicate =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_PACKED_VECTOR3_ARRAY
        "duplicate"
        (Base.Int64.of_string "2754175465")
        (PackedVector3Array.typ @-> returning PackedVector3Array.typ)
        PackedVector3Array.s

    (** Searches the array for a value and returns its index or [code]-1[/code] if not found. Optionally, the initial search index can be passed.
[b]Note:[/b] Vectors with [constant @GDScript.NAN] elements don't behave the same as other vectors. Therefore, the results from this method may not be accurate if NaNs are included. *)
    let find =
      foreign_builtin_method2 GlobalEnum.VariantType._TYPE_PACKED_VECTOR3_ARRAY
        "find"
        (Base.Int64.of_string "3718155780")
        (Vector3.typ @-> Int.typ @-> PackedVector3Array.typ
       @-> returning Int.typ)
        Int.s

    (** Searches the array in reverse order. Optionally, a start search index can be passed. If negative, the start index is considered relative to the end of the array.
[b]Note:[/b] Vectors with [constant @GDScript.NAN] elements don't behave the same as other vectors. Therefore, the results from this method may not be accurate if NaNs are included. *)
    let rfind =
      foreign_builtin_method2 GlobalEnum.VariantType._TYPE_PACKED_VECTOR3_ARRAY
        "rfind"
        (Base.Int64.of_string "3718155780")
        (Vector3.typ @-> Int.typ @-> PackedVector3Array.typ
       @-> returning Int.typ)
        Int.s

    (** Returns the number of times an element is in the array.
[b]Note:[/b] Vectors with [constant @GDScript.NAN] elements don't behave the same as other vectors. Therefore, the results from this method may not be accurate if NaNs are included. *)
    let count =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_PACKED_VECTOR3_ARRAY
        "count"
        (Base.Int64.of_string "194580386")
        (Vector3.typ @-> PackedVector3Array.typ @-> returning Int.typ)
        Int.s

    let not =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_PACKED_VECTOR3_ARRAY
        None GlobalEnum.VariantOperator._OP_NOT
        (funptr
           (PackedVector3Array.typ @-> PackedVector3Array.typ @-> Bool.typ
          @-> returning void))

    let _PackedVector3Array_elem_Dictionary =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_PACKED_VECTOR3_ARRAY
        (Some GlobalEnum.VariantType._TYPE_DICTIONARY)
        GlobalEnum.VariantOperator._OP_IN
        (funptr
           (PackedVector3Array.typ @-> Dictionary.typ @-> Bool.typ
          @-> returning void))

    let _PackedVector3Array_elem_Array =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_PACKED_VECTOR3_ARRAY
        (Some GlobalEnum.VariantType._TYPE_ARRAY)
        GlobalEnum.VariantOperator._OP_IN
        (funptr
           (PackedVector3Array.typ @-> Array.typ @-> Bool.typ @-> returning void))

    (** Returns [code]true[/code] if contents of both arrays are the same, i.e. they have all equal [Vector3]s at the corresponding indices. *)
    let ( = ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_PACKED_VECTOR3_ARRAY
        (Some GlobalEnum.VariantType._TYPE_PACKED_VECTOR3_ARRAY)
        GlobalEnum.VariantOperator._OP_EQUAL
        (funptr
           (PackedVector3Array.typ @-> PackedVector3Array.typ @-> Bool.typ
          @-> returning void))

    (** Returns [code]true[/code] if contents of the arrays differ. *)
    let ( <> ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_PACKED_VECTOR3_ARRAY
        (Some GlobalEnum.VariantType._TYPE_PACKED_VECTOR3_ARRAY)
        GlobalEnum.VariantOperator._OP_NOT_EQUAL
        (funptr
           (PackedVector3Array.typ @-> PackedVector3Array.typ @-> Bool.typ
          @-> returning void))

    (** Returns a new [PackedVector3Array] with contents of [param right] added at the end of this array. For better performance, consider using [method append_array] instead. *)
    let ( + ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_PACKED_VECTOR3_ARRAY
        (Some GlobalEnum.VariantType._TYPE_PACKED_VECTOR3_ARRAY)
        GlobalEnum.VariantOperator._OP_ADD
        (funptr
           (PackedVector3Array.typ @-> PackedVector3Array.typ
          @-> PackedVector3Array.typ @-> returning void))
  end

  module PackedColorArray = struct
    include M.PackedColorArray

    (** Returns the number of elements in the array. *)
    let size =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_PACKED_COLOR_ARRAY
        "size"
        (Base.Int64.of_string "3173160232")
        (PackedColorArray.typ @-> returning Int.typ)
        Int.s

    (** Returns [code]true[/code] if the array is empty. *)
    let is_empty =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_PACKED_COLOR_ARRAY
        "is_empty"
        (Base.Int64.of_string "3918633141")
        (PackedColorArray.typ @-> returning Bool.typ)
        Bool.s

    (** Changes the [Color] at the given index. *)
    let set =
      foreign_builtin_method2_void
        GlobalEnum.VariantType._TYPE_PACKED_COLOR_ARRAY "set"
        (Base.Int64.of_string "1444096570")
        (Int.typ @-> Color.typ @-> PackedColorArray.typ @-> returning Void.typ)
        Void.s

    (** Appends a value to the array. *)
    let push_back =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_PACKED_COLOR_ARRAY
        "push_back"
        (Base.Int64.of_string "1007858200")
        (Color.typ @-> PackedColorArray.typ @-> returning Bool.typ)
        Bool.s

    (** Appends an element at the end of the array (alias of [method push_back]). *)
    let append =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_PACKED_COLOR_ARRAY
        "append"
        (Base.Int64.of_string "1007858200")
        (Color.typ @-> PackedColorArray.typ @-> returning Bool.typ)
        Bool.s

    (** Appends a [PackedColorArray] at the end of this array. *)
    let append_array =
      foreign_builtin_method1_void
        GlobalEnum.VariantType._TYPE_PACKED_COLOR_ARRAY "append_array"
        (Base.Int64.of_string "798822497")
        (PackedColorArray.typ @-> PackedColorArray.typ @-> returning Void.typ)
        Void.s

    (** Removes an element from the array by index. *)
    let remove_at =
      foreign_builtin_method1_void
        GlobalEnum.VariantType._TYPE_PACKED_COLOR_ARRAY "remove_at"
        (Base.Int64.of_string "2823966027")
        (Int.typ @-> PackedColorArray.typ @-> returning Void.typ)
        Void.s

    (** Inserts a new element at a given position in the array. The position must be valid, or at the end of the array ([code]idx == size()[/code]). *)
    let insert =
      foreign_builtin_method2 GlobalEnum.VariantType._TYPE_PACKED_COLOR_ARRAY
        "insert"
        (Base.Int64.of_string "785289703")
        (Int.typ @-> Color.typ @-> PackedColorArray.typ @-> returning Int.typ)
        Int.s

    (** Assigns the given value to all elements in the array. This can typically be used together with [method resize] to create an array with a given size and initialized elements. *)
    let fill =
      foreign_builtin_method1_void
        GlobalEnum.VariantType._TYPE_PACKED_COLOR_ARRAY "fill"
        (Base.Int64.of_string "3730314301")
        (Color.typ @-> PackedColorArray.typ @-> returning Void.typ)
        Void.s

    (** Sets the size of the array. If the array is grown, reserves elements at the end of the array. If the array is shrunk, truncates the array to the new size. Calling [method resize] once and assigning the new values is faster than adding new elements one by one. *)
    let resize =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_PACKED_COLOR_ARRAY
        "resize"
        (Base.Int64.of_string "848867239")
        (Int.typ @-> PackedColorArray.typ @-> returning Int.typ)
        Int.s

    (** Clears the array. This is equivalent to using [method resize] with a size of [code]0[/code]. *)
    let clear =
      foreign_builtin_method0_void
        GlobalEnum.VariantType._TYPE_PACKED_COLOR_ARRAY "clear"
        (Base.Int64.of_string "3218959716")
        (PackedColorArray.typ @-> returning Void.typ)
        Void.s

    (** Returns [code]true[/code] if the array contains [param value]. *)
    let has =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_PACKED_COLOR_ARRAY
        "has"
        (Base.Int64.of_string "3167426256")
        (Color.typ @-> PackedColorArray.typ @-> returning Bool.typ)
        Bool.s

    (** Reverses the order of the elements in the array. *)
    let reverse =
      foreign_builtin_method0_void
        GlobalEnum.VariantType._TYPE_PACKED_COLOR_ARRAY "reverse"
        (Base.Int64.of_string "3218959716")
        (PackedColorArray.typ @-> returning Void.typ)
        Void.s

    (** Returns the slice of the [PackedColorArray], from [param begin] (inclusive) to [param end] (exclusive), as a new [PackedColorArray].
The absolute value of [param begin] and [param end] will be clamped to the array size, so the default value for [param end] makes it slice to the size of the array by default (i.e. [code]arr.slice(1)[/code] is a shorthand for [code]arr.slice(1, arr.size())[/code]).
If either [param begin] or [param end] are negative, they will be relative to the end of the array (i.e. [code]arr.slice(0, -2)[/code] is a shorthand for [code]arr.slice(0, arr.size() - 2)[/code]). *)
    let slice =
      foreign_builtin_method2 GlobalEnum.VariantType._TYPE_PACKED_COLOR_ARRAY
        "slice"
        (Base.Int64.of_string "2451797139")
        (Int.typ @-> Int.typ @-> PackedColorArray.typ
        @-> returning PackedColorArray.typ)
        PackedColorArray.s

    (** Returns a [PackedByteArray] with each color encoded as bytes. *)
    let to_byte_array =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_PACKED_COLOR_ARRAY
        "to_byte_array"
        (Base.Int64.of_string "247621236")
        (PackedColorArray.typ @-> returning PackedByteArray.typ)
        PackedByteArray.s

    (** Sorts the elements of the array in ascending order. *)
    let sort =
      foreign_builtin_method0_void
        GlobalEnum.VariantType._TYPE_PACKED_COLOR_ARRAY "sort"
        (Base.Int64.of_string "3218959716")
        (PackedColorArray.typ @-> returning Void.typ)
        Void.s

    (** Finds the index of an existing value (or the insertion index that maintains sorting order, if the value is not yet present in the array) using binary search. Optionally, a [param before] specifier can be passed. If [code]false[/code], the returned index comes after all existing entries of the value in the array.
[b]Note:[/b] Calling [method bsearch] on an unsorted array results in unexpected behavior. *)
    let bsearch =
      foreign_builtin_method2 GlobalEnum.VariantType._TYPE_PACKED_COLOR_ARRAY
        "bsearch"
        (Base.Int64.of_string "314143821")
        (Color.typ @-> Bool.typ @-> PackedColorArray.typ @-> returning Int.typ)
        Int.s

    (** Creates a copy of the array, and returns it. *)
    let duplicate =
      foreign_builtin_method0 GlobalEnum.VariantType._TYPE_PACKED_COLOR_ARRAY
        "duplicate"
        (Base.Int64.of_string "1011903421")
        (PackedColorArray.typ @-> returning PackedColorArray.typ)
        PackedColorArray.s

    (** Searches the array for a value and returns its index or [code]-1[/code] if not found. Optionally, the initial search index can be passed. *)
    let find =
      foreign_builtin_method2 GlobalEnum.VariantType._TYPE_PACKED_COLOR_ARRAY
        "find"
        (Base.Int64.of_string "3156095363")
        (Color.typ @-> Int.typ @-> PackedColorArray.typ @-> returning Int.typ)
        Int.s

    (** Searches the array in reverse order. Optionally, a start search index can be passed. If negative, the start index is considered relative to the end of the array. *)
    let rfind =
      foreign_builtin_method2 GlobalEnum.VariantType._TYPE_PACKED_COLOR_ARRAY
        "rfind"
        (Base.Int64.of_string "3156095363")
        (Color.typ @-> Int.typ @-> PackedColorArray.typ @-> returning Int.typ)
        Int.s

    (** Returns the number of times an element is in the array. *)
    let count =
      foreign_builtin_method1 GlobalEnum.VariantType._TYPE_PACKED_COLOR_ARRAY
        "count"
        (Base.Int64.of_string "1682108616")
        (Color.typ @-> PackedColorArray.typ @-> returning Int.typ)
        Int.s

    let not =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_PACKED_COLOR_ARRAY
        None GlobalEnum.VariantOperator._OP_NOT
        (funptr
           (PackedColorArray.typ @-> PackedColorArray.typ @-> Bool.typ
          @-> returning void))

    let _PackedColorArray_elem_Dictionary =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_PACKED_COLOR_ARRAY
        (Some GlobalEnum.VariantType._TYPE_DICTIONARY)
        GlobalEnum.VariantOperator._OP_IN
        (funptr
           (PackedColorArray.typ @-> Dictionary.typ @-> Bool.typ
          @-> returning void))

    let _PackedColorArray_elem_Array =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_PACKED_COLOR_ARRAY
        (Some GlobalEnum.VariantType._TYPE_ARRAY)
        GlobalEnum.VariantOperator._OP_IN
        (funptr
           (PackedColorArray.typ @-> Array.typ @-> Bool.typ @-> returning void))

    (** Returns [code]true[/code] if contents of both arrays are the same, i.e. they have all equal [Color]s at the corresponding indices. *)
    let ( = ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_PACKED_COLOR_ARRAY
        (Some GlobalEnum.VariantType._TYPE_PACKED_COLOR_ARRAY)
        GlobalEnum.VariantOperator._OP_EQUAL
        (funptr
           (PackedColorArray.typ @-> PackedColorArray.typ @-> Bool.typ
          @-> returning void))

    (** Returns [code]true[/code] if contents of the arrays differ. *)
    let ( <> ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_PACKED_COLOR_ARRAY
        (Some GlobalEnum.VariantType._TYPE_PACKED_COLOR_ARRAY)
        GlobalEnum.VariantOperator._OP_NOT_EQUAL
        (funptr
           (PackedColorArray.typ @-> PackedColorArray.typ @-> Bool.typ
          @-> returning void))

    (** Returns a new [PackedColorArray] with contents of [param right] added at the end of this array. For better performance, consider using [method append_array] instead. *)
    let ( + ) =
      foreign_builtin_operator GlobalEnum.VariantType._TYPE_PACKED_COLOR_ARRAY
        (Some GlobalEnum.VariantType._TYPE_PACKED_COLOR_ARRAY)
        GlobalEnum.VariantOperator._OP_ADD
        (funptr
           (PackedColorArray.typ @-> PackedColorArray.typ
          @-> PackedColorArray.typ @-> returning void))
  end
end
